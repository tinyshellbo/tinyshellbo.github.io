<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>青年大学习自助脚本</title>
      <link href="./2021/09/26/other/%E5%A4%A7%E5%AD%A6%E4%B9%A0%E8%84%9A%E6%9C%AC/"/>
      <url>./2021/09/26/other/%E5%A4%A7%E5%AD%A6%E4%B9%A0%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="assets\css\APlayer.min.css"><script src="assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id><a href="#" class="headerlink" title></a></h2><blockquote><p>此处是脚本存放的地方</p></blockquote><h3 id="获取token的脚本"><a href="#获取token的脚本" class="headerlink" title="获取token的脚本"></a>获取token的脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlencode</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> faker <span class="keyword">import</span> Faker</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_rand_str</span>(<span class="params"><span class="built_in">len</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(random.sample(string.ascii_letters + string.digits, <span class="built_in">len</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_token</span>():</span></span><br><span class="line">    url = <span class="string">&quot;https://jxtw.h5yunban.cn/jxtw-qndxx/cgi-bin/login/we-chat/callback?callback=https%3A%2F%2Fjxtw.h5yunban.cn%2Fjxtw-qndxx%2FsignUp.php&amp;scope=snsapi_userinfo&amp;appid=wxe9a08de52d2723ba&amp;openid=&#123;&#125;&amp;&#123;&#125;&amp;headimg=https://thirdwx.qlogo.cn/mmopen/vi_32/I7gbHHRj903RFibtlB4jrz1T1jTJ3eCWsCJwibQIT5hLRXO25ib9AHeqUjsPGmwhtiaBuzhQfhEZ6ibBdGbyZuM72LA/132&amp;time=&#123;&#125;&amp;source=common&amp;t=&#123;&#125;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        faker = Faker(<span class="string">&#x27;zh_CN&#x27;</span>)  <span class="comment"># 此处用到了 faker  执行pip install faker安装faker</span></span><br><span class="line">        openid = gen_rand_str(<span class="number">28</span>)  <span class="comment"># openid 是一个 28 长度字符串，我这里随机生成的</span></span><br><span class="line">        nickname = urlencode(&#123;<span class="string">&#x27;j&#x27;</span>: faker.name()&#125;)  <span class="comment"># 随机名称字</span></span><br><span class="line">        newurl = url.<span class="built_in">format</span>(openid, nickname, <span class="string">&quot;%d&quot;</span> % time.time(), <span class="string">&quot;%d&quot;</span> % time.time())  <span class="comment"># 生成 一个新的url</span></span><br><span class="line">        <span class="built_in">print</span>(newurl)</span><br><span class="line">        res = requests.get(newurl) <span class="comment"># 返回的这个内容包含 access_token</span></span><br><span class="line">        text = res.text</span><br><span class="line">        <span class="built_in">print</span>(text)</span><br><span class="line"></span><br><span class="line">        token = re.findall(<span class="string">&quot;&lt;script&gt;localStorage.setItem\(&#x27;accessToken&#x27;, &#x27;(.*?)&#x27;\)&quot;</span>, text)</span><br><span class="line">        <span class="keyword">if</span> token:</span><br><span class="line">            token = token[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        traceback.print_exception()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;获取token出错&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> token</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(get_token())</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="发起一次请求的脚本"><a href="#发起一次请求的脚本" class="headerlink" title="发起一次请求的脚本"></a>发起一次请求的脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlencode</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> faker <span class="keyword">import</span> Faker</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_rand_str</span>(<span class="params"><span class="built_in">len</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(random.sample(string.ascii_letters + string.digits, <span class="built_in">len</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_token</span>():</span></span><br><span class="line">    url = <span class="string">&quot;https://jxtw.h5yunban.cn/jxtw-qndxx/cgi-bin/login/we-chat/callback?callback=https%3A%2F%2Fjxtw.h5yunban.cn%2Fjxtw-qndxx%2FsignUp.php&amp;scope=snsapi_userinfo&amp;appid=wxe9a08de52d2723ba&amp;openid=&#123;&#125;&amp;&#123;&#125;&amp;headimg=https://thirdwx.qlogo.cn/mmopen/vi_32/I7gbHHRj903RFibtlB4jrz1T1jTJ3eCWsCJwibQIT5hLRXO25ib9AHeqUjsPGmwhtiaBuzhQfhEZ6ibBdGbyZuM72LA/132&amp;time=&#123;&#125;&amp;source=common&amp;t=&#123;&#125;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        faker = Faker(<span class="string">&#x27;zh_CN&#x27;</span>)  <span class="comment"># 此处用到了 faker  执行pip install faker安装faker</span></span><br><span class="line">        openid = gen_rand_str(<span class="number">28</span>)  <span class="comment"># openid 是一个 28 长度字符串，我这里随机生成的</span></span><br><span class="line">        nickname = urlencode(&#123;<span class="string">&#x27;j&#x27;</span>: faker.name()&#125;)  <span class="comment"># 随机名称字</span></span><br><span class="line">        newurl = url.<span class="built_in">format</span>(openid, nickname, <span class="string">&quot;%d&quot;</span> % time.time(), <span class="string">&quot;%d&quot;</span> % time.time())  <span class="comment"># 生成 一个新的url</span></span><br><span class="line"></span><br><span class="line">        res = requests.get(newurl)  <span class="comment"># 返回的这个内容包含 access_token</span></span><br><span class="line">        text = res.text</span><br><span class="line"></span><br><span class="line">        token = re.findall(<span class="string">&quot;&lt;script&gt;localStorage.setItem\(&#x27;accessToken&#x27;, &#x27;(.*?)&#x27;\)&quot;</span>, text)</span><br><span class="line">        <span class="keyword">if</span> token:</span><br><span class="line">            token = token[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        traceback.print_exception()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;获取token出错&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> token</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">onepost</span>(<span class="params">access_token, course_id, nid, class_name, username</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    发起一次请求</span></span><br><span class="line"><span class="string">    :param access_token:</span></span><br><span class="line"><span class="string">    :param course_id: 课程id</span></span><br><span class="line"><span class="string">    :param nid: 团委id</span></span><br><span class="line"><span class="string">    :param class_name: 班级</span></span><br><span class="line"><span class="string">    :param username: 学生姓名</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    post_data = &#123;</span><br><span class="line">        <span class="string">&quot;course&quot;</span>: course_id,</span><br><span class="line">        <span class="string">&quot;nid&quot;</span>: nid,</span><br><span class="line">        <span class="string">&quot;subOrg&quot;</span>: class_name,</span><br><span class="line">        <span class="string">&quot;cardNo&quot;</span>: username</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 发送请求url post</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        post_url = <span class="string">&quot;https://jxtw.h5yunban.cn/jxtw-qndxx/cgi-bin/user-api/course/join?accessToken=&quot;</span></span><br><span class="line">        res = requests.post(url=post_url + access_token, data=json.dumps(post_data))</span><br><span class="line">        <span class="keyword">if</span> res.status_code == <span class="number">200</span>:</span><br><span class="line">            <span class="built_in">print</span>(res.json())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;发送请求出错！&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_current_course_id</span>(<span class="params">token</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> token:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="comment"># 获取当前课程的url地址</span></span><br><span class="line">    current_url = <span class="string">&quot;https://jxtw.h5yunban.cn/jxtw-qndxx/cgi-bin/common-api/course/current?accessToken=&quot;</span></span><br><span class="line">    new_current_url = current_url + token</span><br><span class="line">    course_id = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        res = requests.get(new_current_url)</span><br><span class="line">        <span class="keyword">if</span> res.status_code == <span class="number">200</span>:</span><br><span class="line">            res_json = res.json()</span><br><span class="line">            <span class="keyword">if</span> res_json.get(<span class="string">&#x27;status&#x27;</span>) != <span class="number">200</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            result = res_json[<span class="string">&#x27;result&#x27;</span>]</span><br><span class="line">            course_id = result.get(<span class="string">&#x27;id&#x27;</span>)</span><br><span class="line">            title = result.get(<span class="string">&#x27;title&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;获取课程id出错&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> (course_id, title)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    faker = Faker(<span class="string">&#x27;zh_CN&#x27;</span>)</span><br><span class="line"><span class="comment"># 获取当前课程的 course_id</span></span><br><span class="line">    course_res = get_current_course_id(get_token())</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> course_res:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;获取course_id出错&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    course_id = course_res[<span class="number">0</span>]</span><br><span class="line">    course_title = course_res[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    nid = <span class="string">&quot;&quot;</span>  <span class="comment"># 团委id 自行修改</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    班级 注意： 如果有的团委组织是第四级组织,那么这个class_name就为空值就行，</span></span><br><span class="line"><span class="string">    否则会出现以下响应 </span></span><br><span class="line"><span class="string">    &#123;&#x27;status&#x27;: 400, &#x27;message&#x27;: &#x27;已选择四级组织，无需输入&#x27;, &#x27;result&#x27;: None, &#x27;debug&#x27;: None&#125;</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    class_name = <span class="string">&#x27;班级&#x27;</span>  <span class="comment">#</span></span><br><span class="line">    username = faker.name()  <span class="comment"># 你的姓名</span></span><br><span class="line">    token = get_token()  <span class="comment"># 获取token</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> token:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 发起一次请求 ，可以自行改造成批量</span></span><br><span class="line">    res = onepost(token, course_id, nid, class_name, username)</span><br><span class="line">    <span class="keyword">if</span> res:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;成功&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="团委id获取"><a href="#团委id获取" class="headerlink" title="团委id获取"></a>团委id获取</h3><p>有的同学可能不知道如何去获取自己的团委所属的id</p><p>在这里我贴一下获取团委id的脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_org</span>(<span class="params">item=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line">    url = <span class="string">&quot;https://jxtw.h5yunban.cn/jxtw-qndxx/cgi-bin/common-api/organization/children?pid=&quot;</span></span><br><span class="line">    <span class="keyword">if</span> item == <span class="literal">None</span>:</span><br><span class="line">        url = url+<span class="string">&#x27;N&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        url = url+item.get(<span class="string">&#x27;id&#x27;</span>)</span><br><span class="line">    res = requests.get(url)</span><br><span class="line">    <span class="keyword">if</span> res.status_code != <span class="number">200</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;请求失败&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 获取返回的 json数据</span></span><br><span class="line">    res_json = res.json()</span><br><span class="line">    <span class="comment"># 获取团委列表</span></span><br><span class="line">    result_list = res_json.get(<span class="string">&#x27;result&#x27;</span>)</span><br><span class="line">    <span class="comment"># 如果团委列表为空，则 return</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> result_list:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;该团委没有下级团委了&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;您的最终团委id: &#x27;</span>+item.get(<span class="string">&#x27;id&#x27;</span>)+<span class="string">&#x27;    您的团委是第%s级&#x27;</span>%item.get(<span class="string">&#x27;level&#x27;</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;找到以下团委列表:&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> index,item <span class="keyword">in</span> <span class="built_in">enumerate</span>(result_list):</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">str</span>(index+<span class="number">1</span>)+<span class="string">&#x27;、团委id:  &#x27;</span>+item.get(<span class="string">&#x27;id&#x27;</span>)+<span class="string">&#x27;团委名字: &#x27;</span>+item.get(<span class="string">&#x27;title&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    index = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请选择以下第几个团委(输入 1、2、3 等数字):&#x27;</span>))</span><br><span class="line">    <span class="keyword">if</span> index &gt; <span class="built_in">len</span>(result_list) <span class="keyword">or</span> index &lt;<span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;你所选的下标越界! 退出！&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 递归查找</span></span><br><span class="line">    <span class="keyword">return</span> print_org(result_list[index-<span class="number">1</span>])</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    print_org()</span><br></pre></td></tr></table></figure><p>运行后最终会根据你的选择一步一步的直到获取到你的团委，并且显示你的团委等级，这个团委等级有一定的用处</p><blockquote><p>再说一下这几个参数如何传递</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     <span class="string">&quot;course&quot;</span>: course_id,</span><br><span class="line">     <span class="string">&quot;nid&quot;</span>: nid,</span><br><span class="line">     <span class="string">&quot;subOrg&quot;</span>: class_name,</span><br><span class="line">     <span class="string">&quot;cardNo&quot;</span>: username</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>course_id： 就是当前课程的id(可以理解为代号)</p><p>nid: 团委id</p><p>subOrg： 这个值是根据nid的值来变的，重点: 如果你的团委是四级团委，那么这个subOrg就填None，也就是函数传参时，class_name=None,如果时三级团委，那么就需要填写班级，</p><p>cardNo: 你的名字</p><p>以上脚本保证有效，可以自行根据一次请求的脚本编写批量脚本，部署服务器定时运行，帮全校乃至全省弄青年大学习</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>青年大学习自助提交</title>
      <link href="./2021/09/26/other/%E9%9D%92%E5%B9%B4%E5%A4%A7%E5%AD%A6%E4%B9%A0%E6%8A%93%E5%8C%85/"/>
      <url>./2021/09/26/other/%E9%9D%92%E5%B9%B4%E5%A4%A7%E5%AD%A6%E4%B9%A0%E6%8A%93%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="assets\css\APlayer.min.css"><script src="assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><blockquote><p>由于每周都要被辅导员吹青年大学习，以前是伪造截图就好了，现在还有个后台什么的可以查看到哪些人看了没看。一般人肯定就老老实实去看了，但是作为学习了计算机的人，肯定不能向势力屈服…</p></blockquote><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>首先，每次辅导员催交的时候都会发一个已经观看了青年大学习的截图，没在名单上的就视为没看过。如下图</p><p><img src="image-20210926125828420.png" alt="image-20210926125828420"></p><p>里面由我们的名字学号和所在团委，那么，这些记录怎么来的呢？有过web相关开发的都知道，这肯定是客户端发了一个请求到服务器里头，服务器存储到了数据库中，然后便有了记录可查。那么这个请求是什么时候发起的呢？是在我们看完青年大学习的时候就发了一个请求过去吗？还记得我们进入青年大学习时有一个选择团委和填写姓名的页面么？问题揭晓了，就是那个界面我们提交了我们的”学习记录”，如下图</p><p><img src="image-20210926130400631.png" alt="image-20210926130400631" style="zoom: 25%;"><img src="image-20210926130800904.png" alt="image-20210926130800904" style="zoom: 25%;"></p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul><li><p>那么知道是这个界面提交了我们的”学习记录“,此时此刻我们就需要获取这个页面的url，然后找到他的请求地址，用编程语言去模拟发起请求就可以了</p></li><li><p>我们用手机本来可以点击右上角选择用浏览器打开获取这个地址的url，但是呢，没有这个选项，那么该如何获取这个请求地址呢？</p></li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>既然浏览器无法打开，那么我们可以使用http抓包工具，抓包工具可以获取我们手机电脑上的http请求，我使用的 <strong>Fiddler Everywhere</strong>  这个抓包工具</p><p>下载地址: <a href="https://www.telerik.com/fiddler">Fiddler | Web Debugging Proxy and Troubleshooting Solutions (telerik.com)</a></p><img src="image-20210926131835605.png" alt="image-20210926131835605" style="zoom:50%;"><p>里面蛮多版本 ，Fiddler Everywhere是需要登录并且只有三十天的试用期，他的界面的是比较美观的，而且一些请求分析看起来蛮好的。Fiddler Classic界面有点年代感，但是他是免费的。但是作为颜狗，我坚定的选择了前者。</p><p>给出两者的图片对比</p><p>Fiddler Everywhere</p><p><img src="image-20210926132742311.png" alt="image-20210926132742311"></p><p>Fiddler Classic</p><p><img src="image-20210926132841218.png" alt="image-20210926132841218"></p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>fiddler everywhere下载好了，在的网站基本都是https协议的，所以我先配置了一下fiddler的https证书</p><p><img src="image-20210926133158540.png" alt="image-20210926133158540"></p><p>点击设置的图标，选择右侧的HTTPS,勾选Capture HTTPS traffic 并 Trust root Certificate ,安装好证书后就可以捕获https包了</p><p>我这里就不用手机去抓包了，因为电脑微信也是可以访问那个页面的，懒得去弄手机的了</p><p>如果要弄用手机抓包，就开启一下Fiddler的允许远程连接，手机上再配置一下代理和安装好https证书就好了</p><p><img src="image-20210926133703437.png" alt="image-20210926133703437"></p><h3 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h3><p>打开 Fiddler EveryWhere 并访问公众号江西共青团，点击网上团课，然后会弹出这个“熟悉”的界面（之前没登录过的可能会显示授权窗口）</p><p><img src="image-20210926133942333.png" alt="image-20210926133942333"></p><p>与此同时，我们观察到 Fiddler 中有相关的请求</p><p><img src="image-20210926134311726.png" alt="image-20210926134311726"></p><p>我们可以看到其中有很多个个<a href="https://jstw.h5yunban.cn开始请求,八九不离十,就是这个了,查看他们这些url的请求与响应/">https://jstw.h5yunban.cn开始请求，八九不离十，就是这个了，查看他们这些url的请求与响应</a></p><ul><li> <a href="https://jxtw.h5yunban.cn/jxtw-qndxx/signUp.php">https://jxtw.h5yunban.cn/jxtw-qndxx/signUp.php</a></li></ul><p>  这个url从名字（signUp）上看就是一个登录或注册页面的地址，就是我们上面那个页面的地址，看它的返回的html就明白了</p><p>  <img src="image-20210926135040272.png" alt="image-20210926135040272"></p><ul><li><p><a href="https://jxtw.h5yunban.cn/jxtw-qndxx/cgi-bin/user-api/info?accessToken=token%E5%80%BC">https://jxtw.h5yunban.cn/jxtw-qndxx/cgi-bin/user-api/info?accessToken=token值</a></p><p>这个地址后面带了个参数accessToken，并且看它的相应，这个地址返回的是我个人的一些信息，我直接拿着这个地址在浏览器访问，也获取到了同样的信息,由于涉及信息相关，我就没把这个token放出来了</p></li></ul><p><img src="image-20210926135319991.png" alt="image-20210926135319991"></p><p><img src="image-20210926135750196.png" alt="image-20210926135750196"></p><p>我修改了这个accessToken的值，浏览器访问一下，结果如下</p><p><img src="image-20210926140004743.png" alt="image-20210926140004743"></p><p>这也证明了这个accessToken是标识用户身份信息的一个东西，每个人都有对应的accessToken</p><ul><li><a href="https://jxtw.h5yunban.cn/jxtw-qndxx/wx-share.php?url=https://jxtw.h5yunban.cn/jxtw-qndxx/signUp.php">https://jxtw.h5yunban.cn/jxtw-qndxx/wx-share.php?url=https%3A%2F%2Fjxtw.h5yunban.cn%2Fjxtw-qndxx%2FsignUp.php</a></li></ul><p><img src="image-20210926140405797.png" alt="image-20210926140405797"></p><p>这个url返回的信息也是无关紧要，无需带token，说明是一个通用的url</p><ul><li><p><a href="https://jxtw.h5yunban.cn/jxtw-qndxx/cgi-bin/common-api/course/current?accessToken=">https://jxtw.h5yunban.cn/jxtw-qndxx/cgi-bin/common-api/course/current?accessToken=</a></p><p>这个地址携带了token</p><p><img src="image-20210926140626153.png" alt="image-20210926140626153"></p></li></ul><p>从返回值来看，以及url地址上的current判断，这个地址返回的是当前期的青年大学习课程</p><p>json格式如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;status&quot;</span>: <span class="number">200</span>,</span><br><span class="line">  <span class="attr">&quot;message&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">&quot;result&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;id&quot;</span>: <span class="string">&quot;C0038&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;pid&quot;</span>: <span class="string">&quot;C&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;网上主题团课&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;startTime&quot;</span>: <span class="string">&quot;2021-09-20 12:00:00&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;endTime&quot;</span>: <span class="string">&quot;2021-09-26 18:00:00&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;第十二季第一期&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;cover&quot;</span>: <span class="string">&quot;https://st-file.yunbanos.cn/uploadsoss/jxtw-qndxx/2021-09-20/c3a3b4da48ab63041d81f39e38ba8e21.png&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;uriType&quot;</span>: <span class="string">&quot;超链接&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;uri&quot;</span>: <span class="string">&quot;https://h5.cyol.com/special/daxuexi/bq9we1g5wq/m.html&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;content&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">&quot;s&quot;</span>: <span class="string">&quot;正常&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;creator&quot;</span>: <span class="string">&quot;0e10adc3949ba59abbe56e057f20f883e&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;createTime&quot;</span>: <span class="string">&quot;2021-09-20 10:44:46&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;users&quot;</span>: <span class="string">&quot;0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;clickTimes&quot;</span>: <span class="string">&quot;0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;isTop&quot;</span>: <span class="literal">null</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;debug&quot;</span>: <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记住这里面的result中的id，这个是课程id,表示着这是哪一期的课程，后面会用到</p><ul><li><p><a href="https://jxtw.h5yunban.cn/jxtw-qndxx/cgi-bin/common-api/organization/children?pid=N">https://jxtw.h5yunban.cn/jxtw-qndxx/cgi-bin/common-api/organization/children?pid=N</a></p><p>无需token,也是一个通用的</p><img src="image-20210926141003566.png" alt="image-20210926141003566" style="zoom:150%;"></li></ul><p>返回格式如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;status&quot;</span>: <span class="number">200</span>,</span><br><span class="line">  <span class="attr">&quot;message&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">&quot;result&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;id&quot;</span>: <span class="string">&quot;N0002&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;南昌市&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;pid&quot;</span>: <span class="string">&quot;N&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;image&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">      <span class="attr">&quot;level&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;memberCnt&quot;</span>: <span class="string">&quot;132736&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;aid&quot;</span>: <span class="string">&quot;529891B3-D535-40E3-A003-ABF53EC37C9C&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;account&quot;</span>: <span class="string">&quot;nctsw&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;password&quot;</span>: <span class="string">&quot;83885819&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;id&quot;</span>: <span class="string">&quot;N0003&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;九江市&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;pid&quot;</span>: <span class="string">&quot;N&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;image&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">      <span class="attr">&quot;level&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;memberCnt&quot;</span>: <span class="string">&quot;111526&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;aid&quot;</span>: <span class="string">&quot;5FEB3AFD-271D-4A40-B04C-D5675F3DBB28&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;account&quot;</span>: <span class="string">&quot;jjtsw&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;password&quot;</span>: <span class="string">&quot;371650&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">....</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;id&quot;</span>: <span class="string">&quot;N0016&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;省直属单位团委&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;pid&quot;</span>: <span class="string">&quot;N&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;image&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">      <span class="attr">&quot;level&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;memberCnt&quot;</span>: <span class="string">&quot;0&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;aid&quot;</span>: <span class="string">&quot;6246F567-F09E-4BD9-8C57-B55D1E4EC465&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;account&quot;</span>: <span class="string">&quot;szsdwtw&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;password&quot;</span>: <span class="string">&quot;661268&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;debug&quot;</span>: <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>地址上的按个pid其实就是一个团委的标识符，通过pid获取其下级团委，江西省这边的第一的pid是N，所以通过pid=N 获取到了各个市级的团委列表。返回的参数里头又有一个id,然后通过这个id，也可以获取其下面的团委</p><p>比如从中知道了南昌市的id： N0002</p><p>访问: <a href="https://jxtw.h5yunban.cn/jxtw-qndxx/cgi-bin/common-api/organization/children?pid=N0002">https://jxtw.h5yunban.cn/jxtw-qndxx/cgi-bin/common-api/organization/children?pid=N0002</a></p><p>返回结果如下:</p><p><img src="image-20210926141710801.png" alt="image-20210926141710801"></p><p>结果是南昌市下级团委列表</p><p>这个url是关键，这就是为啥辅导员截图中有详细的团委的名称了，就是这个接口，好了，继续分析余下的url</p><ul><li><a href="https://jxtw.h5yunban.cn/jxtw-qndxx/cgi-bin/user-api/course/records/v2?accessToken=">https://jxtw.h5yunban.cn/jxtw-qndxx/cgi-bin/user-api/course/records/v2?accessToken=</a></li></ul><p><img src="image-20210926142034332.png" alt="image-20210926142034332"></p><p>这个地址是返回了用户的学习记录,需要带token</p><h4 id="继续"><a href="#继续" class="headerlink" title="继续"></a>继续</h4><p>好了，目前为止，我们之前那次点击发起的请求发现的 urls 就已经分析完了</p><p>为了避免请求过多，我把分析过的请求给 remove </p><p><img src="image-20210926142442281.png" alt="image-20210926142442281"></p><p>点击开始学习,继续抓余下的请求地址</p><img src="image-20210926142538507.png" alt="image-20210926142538507" style="zoom:50%;"><p><img src="image-20210926142701069.png" alt="image-20210926142701069"></p><p>弹出了以下界面，而且我一进去，他就自动帮我填好了团委和名字信息，为啥呢？我继续观察Fiddler，发现了多了以下几个请求</p><p><img src="image-20210926142845004.png" alt="image-20210926142845004"></p><p>接着继续分析每个 url 的请求和响应</p><ul><li><a href="https://jxtw.h5yunban.cn/jxtw-qndxx/cgi-bin/user-api/course/last-info?accessToken=">https://jxtw.h5yunban.cn/jxtw-qndxx/cgi-bin/user-api/course/last-info?accessToken=</a></li></ul><p><img src="image-20210926143126426.png" alt="image-20210926143126426"></p><p>这个请求是获取我上一次的“学习记录”，这也就是为什么一进去那个界面就自动帮我们填好了信息</p><p>剩下的几个请求都是根据团委 id 获取该团委下的团委列表</p><h3 id="继续点击去学习"><a href="#继续点击去学习" class="headerlink" title="继续点击去学习"></a>继续点击去学习</h3><p><img src="image-20210926143547769.png" alt="image-20210926143547769"></p><p>这次这个应该是关键了，因为我们信息已经填好了，点击这个估计就是把信息提交到服务器了</p><p><img src="image-20210926143729555.png" alt="image-20210926143729555"></p><p>在点击这个进去了那个视频学习页面，同时也多了几个h5.cyol.com的域名开始请求，这个就是青年大学习服务器所用的相关域名了，不用管，我们继续分析jxtw.h5yunban.cn这个域名下的请求</p><h4 id="重要请求"><a href="#重要请求" class="headerlink" title="重要请求"></a>重要请求</h4><ul><li><a href="https://jxtw.h5yunban.cn/jxtw-qndxx/cgi-bin/user-api/course/join?accessToken=">https://jxtw.h5yunban.cn/jxtw-qndxx/cgi-bin/user-api/course/join?accessToken=</a></li></ul><p>这个请求便是将我们的信息发送到服务器的请求了</p><img src="image-20210926144203445.png" alt="image-20210926144203445" style="zoom:50%;"><p>注意这个请求和之前的请求有点不大一样，这个请求有请求体，之前的就是单纯的一个url访问，这次因为是提交，我们的信息是包含在请求体中被发送服务器被记录的</p><p>返回的结果是表示我们成功了<br>请求体json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"> <span class="attr">&quot;course&quot;</span>: <span class="string">&quot;C0038&quot;</span>, <span class="comment">// 课程id</span></span><br><span class="line"></span><br><span class="line"> <span class="attr">&quot;nid&quot;</span>: <span class="string">&quot;&quot;</span>, <span class="comment">// 所在团委id</span></span><br><span class="line"></span><br><span class="line"> <span class="attr">&quot;subOrg&quot;</span>: <span class="string">&quot;&quot;</span>, <span class="comment">// 所在班级</span></span><br><span class="line"></span><br><span class="line"> <span class="attr">&quot;cardNo&quot;</span>: <span class="string">&quot;汤小波&quot;</span> <span class="comment">// 姓名</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回结果json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;status&quot;</span>: <span class="number">200</span>,</span><br><span class="line">  <span class="attr">&quot;message&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">&quot;result&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;id&quot;</span>: <span class="string">&quot;1428316&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;openid&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;nid&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;subOrg&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;cardNo&quot;</span>: <span class="string">&quot;汤小波&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;userIp&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;createTime&quot;</span>: <span class="string">&quot;2021-09-26 14:36:53&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;lastUpdTime&quot;</span>: <span class="string">&quot;2021-09-26 14:36:53&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;debug&quot;</span>: <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此得知，辅导员那里的表格记录，就是这个请求造成的，这个请求包含了我们所在的团委，班级信息等</p><p>那问题好办了，只要我们用编程语言每周往这个接口发起请求，那么也就意味着我们每周都“学习了”</p><p>现在的关键是拿到那个标识我们身份的 accessToken 的值，但是呢，这个accessToken只有一定时间段的有效性，过了就会失效</p><h3 id="接下来的问题"><a href="#接下来的问题" class="headerlink" title="接下来的问题"></a>接下来的问题</h3><p>我们总不可能每次等请求过期都去抓包获取一次它的请求吧？那也太麻烦了，还不如老老实实手动去点击。</p><p>同样的道理，找到获取token的接口不就得了，每次自动去获取新的token就好了</p><p>接下来的我就展示抓包分析过程了，我直接把我的最终结果展示出来</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://jxtw.h5yunban.cn/jxtw-qndxx/cgi-bin/login/we-chat/callback?callback=https%3A%2F%2Fjxtw.h5yunban.cn%2Fjxtw-qndxx%2FsignUp.php&amp;scope=snsapi_userinfo&amp;appid=wxe9a08de52d2723ba&amp;openid=一个openid&amp;nickname=名称&amp;headimg=头像地址&amp;time=时间戳&amp;source=common&amp;t=时间戳&quot;</span><br></pre></td></tr></table></figure><p>这个 url 里面我用中文标识出来的参数就是获取信息的关键，appid貌似是固定的（我只用了我自己和我一个同学的测试），随机改变  openid 是可以获取到token的，只是获取到的token不再是你，而是一个新同学（这个新同学是没有在服务器有过记录的），所以每次通过这个请求获取到一个token，这个新同学提交的是你的信息，假如你是张三，团委是XX,那么新同学提交的时候就填张三的名字，那么辅导员那里的记录就有了一个张三，那么也就认为你学习了青年大学习。</p><p><strong>其实上面只有 openid 需要改变 openid改变代表不同的账号，如果是同一个openid，那就代表是同一个账号，反复发请求过去，还是记录在同一个账号上，最后只有最后一次请求才有效果滴，所以openid至关重要随即变</strong>  </p><p>好了，说了这么多，上代码，这里我用我熟悉python配合requests库发起请求</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlencode</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> faker <span class="keyword">import</span> Faker</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_rand_str</span>(<span class="params"><span class="built_in">len</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(random.sample(string.ascii_letters + string.digits, <span class="built_in">len</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_token</span>():</span></span><br><span class="line">    url = <span class="string">&quot;https://jxtw.h5yunban.cn/jxtw-qndxx/cgi-bin/login/we-chat/callback?callback=https%3A%2F%2Fjxtw.h5yunban.cn%2Fjxtw-qndxx%2FsignUp.php&amp;scope=snsapi_userinfo&amp;appid=wxe9a08de52d2723ba&amp;openid=&#123;&#125;&amp;&#123;&#125;&amp;headimg=https://thirdwx.qlogo.cn/mmopen/vi_32/I7gbHHRj903RFibtlB4jrz1T1jTJ3eCWsCJwibQIT5hLRXO25ib9AHeqUjsPGmwhtiaBuzhQfhEZ6ibBdGbyZuM72LA/132&amp;time=&#123;&#125;&amp;source=common&amp;t=&#123;&#125;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        faker = Faker(<span class="string">&#x27;zh_CN&#x27;</span>)  <span class="comment"># 此处用到了 faker  执行pip install faker安装faker</span></span><br><span class="line">        openid = gen_rand_str(<span class="number">28</span>)  <span class="comment"># openid 是一个 28 长度字符串，我这里随机生成的</span></span><br><span class="line">        nickname = urlencode(&#123;<span class="string">&#x27;j&#x27;</span>: faker.name()&#125;)  <span class="comment"># 随机名称字</span></span><br><span class="line">        newurl = url.<span class="built_in">format</span>(openid, nickname, <span class="string">&quot;%d&quot;</span> % time.time(), <span class="string">&quot;%d&quot;</span> % time.time())  <span class="comment"># 生成 一个新的url</span></span><br><span class="line">        <span class="built_in">print</span>(newurl)</span><br><span class="line">        res = requests.get(newurl) <span class="comment"># 返回的这个内容包含 access_token</span></span><br><span class="line">        text = res.text</span><br><span class="line">        <span class="built_in">print</span>(text)</span><br><span class="line"></span><br><span class="line">        token = re.findall(<span class="string">&quot;&lt;script&gt;localStorage.setItem\(&#x27;accessToken&#x27;, &#x27;(.*?)&#x27;\)&quot;</span>, text)</span><br><span class="line">        <span class="keyword">if</span> token:</span><br><span class="line">            token = token[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        traceback.print_exception()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;获取token出错&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> token</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(get_token())</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>稍作解释： 获取那个newurl获得的内容如下，其实可以直接在浏览器打开那个newurl，然后浏览器会执行下面返回的脚本，然后就可以用你的电脑浏览器访问那个界面了，因为本地已经存储好了那个token</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="built_in">localStorage</span>.setItem(<span class="string">&#x27;accessToken&#x27;</span>, <span class="string">&#x27;53FD1B6B-06E0-4758-A4C2-8F80DDE3CEF9&#x27;</span>);<span class="built_in">window</span>.location.replace(<span class="string">&#x27;https://jxtw.h5yunban.cn/jxtw-qndxx/signUp.php&#x27;</span>);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>看调用了localstorage将accessToken存在本地，然后重定向到那个登录页面</p><p>我们通过正则表达式解析出来就好</p><p>好了，动态的token获取到了，不要纠结，这个token是不代表任何人，因为那个 openid 是随机的，我也不知道这个系统后端是怎么写的，随机一个数组也能拿到token,只不过这个token是一个全新的人，这个获取到的token是可以通过后端验证的，用这个新的token去发起请求，将你的信息携带过去，只要那边后台记录了一个我所在的团委一个和你同名的人，辅导员就认为你已经学习了</p><p>伪造一次请求的完整代码，直接复制可用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlencode</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> faker <span class="keyword">import</span> Faker</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_rand_str</span>(<span class="params"><span class="built_in">len</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(random.sample(string.ascii_letters + string.digits, <span class="built_in">len</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_token</span>():</span></span><br><span class="line">    url = <span class="string">&quot;https://jxtw.h5yunban.cn/jxtw-qndxx/cgi-bin/login/we-chat/callback?callback=https%3A%2F%2Fjxtw.h5yunban.cn%2Fjxtw-qndxx%2FsignUp.php&amp;scope=snsapi_userinfo&amp;appid=wxe9a08de52d2723ba&amp;openid=&#123;&#125;&amp;&#123;&#125;&amp;headimg=https://thirdwx.qlogo.cn/mmopen/vi_32/I7gbHHRj903RFibtlB4jrz1T1jTJ3eCWsCJwibQIT5hLRXO25ib9AHeqUjsPGmwhtiaBuzhQfhEZ6ibBdGbyZuM72LA/132&amp;time=&#123;&#125;&amp;source=common&amp;t=&#123;&#125;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        faker = Faker(<span class="string">&#x27;zh_CN&#x27;</span>)  <span class="comment"># 此处用到了 faker  执行pip install faker安装faker</span></span><br><span class="line">        openid = gen_rand_str(<span class="number">28</span>)  <span class="comment"># openid 是一个 28 长度字符串，我这里随机生成的</span></span><br><span class="line">        nickname = urlencode(&#123;<span class="string">&#x27;j&#x27;</span>: faker.name()&#125;)  <span class="comment"># 随机名称字</span></span><br><span class="line">        newurl = url.<span class="built_in">format</span>(openid, nickname, <span class="string">&quot;%d&quot;</span> % time.time(), <span class="string">&quot;%d&quot;</span> % time.time())  <span class="comment"># 生成 一个新的url</span></span><br><span class="line"></span><br><span class="line">        res = requests.get(newurl)  <span class="comment"># 返回的这个内容包含 access_token</span></span><br><span class="line">        text = res.text</span><br><span class="line"></span><br><span class="line">        token = re.findall(<span class="string">&quot;&lt;script&gt;localStorage.setItem\(&#x27;accessToken&#x27;, &#x27;(.*?)&#x27;\)&quot;</span>, text)</span><br><span class="line">        <span class="keyword">if</span> token:</span><br><span class="line">            token = token[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        traceback.print_exception()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;获取token出错&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> token</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">onepost</span>(<span class="params">access_token, course_id, nid, class_name, username</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    发起一次请求</span></span><br><span class="line"><span class="string">    :param access_token:</span></span><br><span class="line"><span class="string">    :param course_id: 课程id</span></span><br><span class="line"><span class="string">    :param nid: 团委id</span></span><br><span class="line"><span class="string">    :param class_name: 班级</span></span><br><span class="line"><span class="string">    :param username: 学生姓名</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    post_data = &#123;</span><br><span class="line">        <span class="string">&quot;course&quot;</span>: course_id,</span><br><span class="line">        <span class="string">&quot;nid&quot;</span>: nid,</span><br><span class="line">        <span class="string">&quot;subOrg&quot;</span>: class_name,</span><br><span class="line">        <span class="string">&quot;cardNo&quot;</span>: username</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 发送请求url post</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        post_url = <span class="string">&quot;https://jxtw.h5yunban.cn/jxtw-qndxx/cgi-bin/user-api/course/join?accessToken=&quot;</span></span><br><span class="line">        res = requests.post(url=post_url + access_token, data=json.dumps(post_data))</span><br><span class="line">        <span class="keyword">if</span> res.status_code == <span class="number">200</span>:</span><br><span class="line">            <span class="built_in">print</span>(res.json())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;发送请求出错！&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_current_course_id</span>(<span class="params">token</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> token:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="comment"># 获取当前课程的url地址</span></span><br><span class="line">    current_url = <span class="string">&quot;https://jxtw.h5yunban.cn/jxtw-qndxx/cgi-bin/common-api/course/current?accessToken=&quot;</span></span><br><span class="line">    new_current_url = current_url + token</span><br><span class="line">    course_id = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        res = requests.get(new_current_url)</span><br><span class="line">        <span class="keyword">if</span> res.status_code == <span class="number">200</span>:</span><br><span class="line">            res_json = res.json()</span><br><span class="line">            <span class="keyword">if</span> res_json.get(<span class="string">&#x27;status&#x27;</span>) != <span class="number">200</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            result = res_json[<span class="string">&#x27;result&#x27;</span>]</span><br><span class="line">            course_id = result.get(<span class="string">&#x27;id&#x27;</span>)</span><br><span class="line">            title = result.get(<span class="string">&#x27;title&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;获取课程id出错&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> (course_id, title)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    faker = Faker(<span class="string">&#x27;zh_CN&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    course_res = get_current_course_id(get_token())</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> course_res:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;获取course_id出错&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    course_id = course_res[<span class="number">0</span>]</span><br><span class="line">    course_title = course_res[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    nid = <span class="string">&quot;&quot;</span>  <span class="comment"># 团委id 自行修改</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    班级 注意： 如果有的团委组织是第四级组织,那么这个class_name就为空值就行，</span></span><br><span class="line"><span class="string">    否则会出现以下响应 </span></span><br><span class="line"><span class="string">    &#123;&#x27;status&#x27;: 400, &#x27;message&#x27;: &#x27;已选择四级组织，无需输入&#x27;, &#x27;result&#x27;: None, &#x27;debug&#x27;: None&#125;</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    class_name = <span class="string">&#x27;班级&#x27;</span>  <span class="comment">#</span></span><br><span class="line">    username = faker.name()  <span class="comment"># 你的姓名</span></span><br><span class="line">    token = get_token()  <span class="comment"># 获取token</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> token:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 发起一次请求 ，可以自行改造成批量</span></span><br><span class="line">    res = onepost(token, course_id, nid, class_name, username)</span><br><span class="line">    <span class="keyword">if</span> res:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;成功&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="请求接口汇总"><a href="#请求接口汇总" class="headerlink" title="请求接口汇总"></a>请求接口汇总</h2><table><thead><tr><th>接口地址</th><th>描述</th></tr></thead><tbody><tr><td><a href="https://jxtw.h5yunban.cn/jxtw-qndxx/signUp.php">https://jxtw.h5yunban.cn/jxtw-qndxx/signUp.php</a></td><td>入口地址</td></tr><tr><td><a href="https://jxtw.h5yunban.cn/jxtw-qndxx/cgi-bin/user-api/info?accessToken=">https://jxtw.h5yunban.cn/jxtw-qndxx/cgi-bin/user-api/info?accessToken=</a></td><td>个人信息</td></tr><tr><td><a href="https://jxtw.h5yunban.cn/jxtw-qndxx/cgi-bin/common-api/course/current?accessToken=">https://jxtw.h5yunban.cn/jxtw-qndxx/cgi-bin/common-api/course/current?accessToken=</a></td><td>当前一期的青年大学习课程</td></tr><tr><td><a href="https://jxtw.h5yunban.cn/jxtw-qndxx/cgi-bin/common-api/organization/children?pid=N">https://jxtw.h5yunban.cn/jxtw-qndxx/cgi-bin/common-api/organization/children?pid=N</a></td><td>根据 pid 获取下级团委列表</td></tr><tr><td><a href="https://jxtw.h5yunban.cn/jxtw-qndxx/cgi-bin/user-api/course/last-info?accessToken=">https://jxtw.h5yunban.cn/jxtw-qndxx/cgi-bin/user-api/course/last-info?accessToken=</a></td><td>上一次的学习记录</td></tr><tr><td><a href="https://jxtw.h5yunban.cn/jxtw-qndxx/cgi-bin/user-api/course/join?accessToken=">https://jxtw.h5yunban.cn/jxtw-qndxx/cgi-bin/user-api/course/join?accessToken=</a></td><td>发送求情地址，post请求</td></tr><tr><td></td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 闲杂 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -fiddler -python爬虫案例 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack学习记录</title>
      <link href="./2021/09/19/web/webpack/"/>
      <url>./2021/09/19/web/webpack/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="assets\css\APlayer.min.css"><script src="assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="什么是webpack？"><a href="#什么是webpack？" class="headerlink" title="什么是webpack？"></a>什么是webpack？</h1><blockquote><p>webpack是前端工程化的具体解决方案，用于打包的，webpack分析项目结构,找到javascript模块以及其他的一些浏览器不能直接运行的拓展语言(如Scss，typescript等)，并将其打包为合适的格式以供浏览器使用</p></blockquote><h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><blockquote><p>它提供了有好的前端模块化支持，以及代码压缩混淆、出力浏览器端javascript的兼容性、性能优化等强大的功能.</p></blockquote><h2 id="webpack基本使用"><a href="#webpack基本使用" class="headerlink" title="webpack基本使用"></a>webpack基本使用</h2><ol><li>新建项目空白目录、并运行npm init -y，初始化包管理配置文件package.json</li><li>新建src源代码目录</li><li>新建src-&gt;index.html首页和src-&gt;index.js脚本文件</li><li>初始化首页基本的结构</li><li>运行npm install jquery -S 命令安装jquery</li><li>通过es6模块化的方式导入jquery，实现列表隔行变色效果</li></ol><p><strong>index.hml</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>这是第 1 个 li<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>这是第 2 个 li<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>这是第 3 个 li<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>这是第 4 个 li<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>这是第 5 个 li<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>这是第 6 个 li<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>这是第 7 个 li<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>这是第 8 个 li<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>这是第 9 个 li<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>index.js</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">&#x27;jquery&#x27;</span>  <span class="comment">//用 es6 默认语法导入 Jquery</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 jquery 入口函数</span></span><br><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 实现奇偶数行变色</span></span><br><span class="line">    $(<span class="string">&#x27;li:odd&#x27;</span>).css(<span class="string">&#x27;background-color&#x27;</span>, <span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">    $(<span class="string">&#x27;li:even&#x27;</span>).css(<span class="string">&#x27;background-color&#x27;</span>, <span class="string">&#x27;pink&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p>报错如图</p><p><img src="image-20210919200748471.png" alt="image-20210919200748471"></p><p>思路: 使用webpack打包</p><h3 id="安装webpack"><a href="#安装webpack" class="headerlink" title="安装webpack"></a>安装webpack</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack@5.42.1 webpack-cli@4.7.2 -D</span><br></pre></td></tr></table></figure><p><em><strong>-D  –save-dev 简写 参数解释: 将包记录到devDependencies里面，只在开发时候使用</strong></em></p><h3 id="在项目中配置webpack"><a href="#在项目中配置webpack" class="headerlink" title="在项目中配置webpack"></a>在项目中配置webpack</h3><ul><li><p>在项目根目录中，创建名为webpack.config.js的webpack配置文件，并初始化如下的基本配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">module.exports=&#123;</span><br><span class="line">    </span><br><span class="line">    mode: &#x27;development&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在package.json的scripts节点下，新增dev脚本如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;dev&quot;: &quot;webpack&quot; </span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li><li><p>在终端运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> D:\codingprojects\vue\learn\webpack\example1&gt; npm run dev</span><br><span class="line"></span><br><span class="line">&gt; example1@<span class="number">1.0</span>.<span class="number">0</span> dev</span><br><span class="line">&gt; webpack</span><br><span class="line"></span><br><span class="line">asset main.js <span class="number">323</span> KiB [<span class="type">emitted</span>] (name: main)</span><br><span class="line">runtime modules <span class="number">937</span> bytes <span class="number">4</span> modules</span><br><span class="line">cacheable modules <span class="number">282</span> KiB</span><br><span class="line">  ./src/index.js <span class="number">244</span> bytes [<span class="type">built</span>] [<span class="type">code</span> <span class="type">generated</span>]</span><br><span class="line">  ./node_modules/jquery/dist/jquery.js <span class="number">282</span> KiB [<span class="type">built</span>] [<span class="type">code</span> <span class="type">generated</span>]</span><br><span class="line">webpack <span class="number">5.42</span>.<span class="number">1</span> compiled successfully <span class="keyword">in</span> <span class="number">2111</span> ms</span><br></pre></td></tr></table></figure></li></ul><p><strong>结果:</strong>  <em>在根目录生成了dist目录 包含main.js</em></p><p>在index.html中修改script的src为../dist/main.js</p><h4 id="最终结果"><a href="#最终结果" class="headerlink" title="最终结果"></a>最终结果</h4><p><img src="image-20210919214335621.png" alt="image-20210919214335621"></p><h3 id="webpack继续探索"><a href="#webpack继续探索" class="headerlink" title="webpack继续探索"></a>webpack继续探索</h3><p>上面的例子是打包的main.js包含了注释 大小为323KB</p><h4 id="mode为production"><a href="#mode为production" class="headerlink" title="mode为production"></a>mode为production</h4><p>将mode改为production再次打包</p><p>再次运行 npm run dev</p><p><strong>运行结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PS D:\codingprojects\vue\learn\webpack\example1&gt; npm run dev</span><br><span class="line"></span><br><span class="line">&gt; example1@1.0.0 dev</span><br><span class="line">&gt; webpack</span><br><span class="line"></span><br><span class="line">asset main.js 88.3 KiB [emitted] [minimized] (name: main) 1 related asset</span><br><span class="line">runtime modules 663 bytes 3 modules</span><br><span class="line">cacheable modules 282 KiB</span><br><span class="line">  ./src/index.js 244 bytes [built] [code generated]</span><br><span class="line">  ./node_modules/jquery/dist/jquery.js 282 KiB [built] [code generated]  </span><br><span class="line">webpack 5.42.1 compiled successfully in 4687 ms</span><br></pre></td></tr></table></figure><p>查看文件，注释没有了! 大小变成了282KB</p><p><strong>缺点：</strong>打包时间长,production用于生产,开发时使用development，速度快</p><p><strong>原理：</strong>在运行 npm run dev 时会去先读取根目录下的webpack.config.js</p><p><strong>思考：</strong> 为何执行命令就可以把jquery.js和自己编写的index.js打包到dist/main.js中呢？</p><h3 id="webpack-中的默认约定"><a href="#webpack-中的默认约定" class="headerlink" title="webpack 中的默认约定"></a>webpack 中的默认约定</h3><p>在webpack 4.x 和 5.x的版本中，有如下的默认约定</p><ol><li>默认的打包入口文件 src -&gt; index.js</li><li>默认的输出文件路径为 dist -&gt; main.js</li></ol><p>但是可以在webpack.config.js可以修改默认配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports=&#123;</span><br><span class="line"></span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;production&#x27;</span>,</span><br><span class="line">    <span class="attr">entry</span>: path.join(__dirname,<span class="string">&#x27;./src/index.js&#x27;</span>), <span class="comment">// 入口文件</span></span><br><span class="line">    <span class="comment">// 指定生成的文件放到哪里</span></span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">path</span>: path.join(__dirname,<span class="string">&#x27;./dist&#x27;</span>), <span class="comment">// 存放的文件夹</span></span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;bundle.js&#x27;</span> <span class="comment">// 生成的文件名</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>当前问题：</strong> 每次修改了源文件都要执行打包命令，非常耗时</p><h3 id="webpack-dev-server-插件-热更新"><a href="#webpack-dev-server-插件-热更新" class="headerlink" title="webpack-dev-server 插件 热更新"></a>webpack-dev-server 插件 热更新</h3><p><strong>问题解决：</strong> 安装插件 webpack-dev-server </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack-dev-server@3.11.2 -D</span><br><span class="line">yarn add webpack-dev-server@3.11.2 -D</span><br></pre></td></tr></table></figure><p>修改package.json中的scripts</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;dev&quot;</span>: <span class="string">&quot;webpack server&quot;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>执行 npm run dev 并访问 localhost:8080</p><p><strong>此处注意版本问题：</strong> 如版本过高导致访问的时候出错</p><p>出现类似的错误</p><p><img src="image-20210919225815714.png" alt="image-20210919225815714"></p><p><img src="image-20210919225905764.png" alt="image-20210919225905764"></p><p>正确显示：</p><p><img src="image-20210919230054740.png" alt="image-20210919230054740"></p><p>现在修改了能动态编译，但是修改了相关的元素访问依旧是无效</p><p><strong>原因：</strong>因为是生成的bundle.js是存放在内存中，script中的src要引用内存当中的bundle.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;/bundle.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>当前问题:</strong>  打开localhost:8080后还要点击src才能访问网页</p><p><strong>需求：</strong> 一访问则直接进入</p><p><strong>解决：</strong> 安装html-webpack-plugin</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install html-webpack-plugin@5.3.2 -D</span><br></pre></td></tr></table></figure><p><strong>配置插件：</strong> </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> HtmlPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> htmlPlugin = <span class="keyword">new</span> HtmlPlugin(</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">template</span>: <span class="string">&#x27;./src/index.html&#x27;</span>,</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;./index.html&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"><span class="built_in">module</span>.exports=&#123;</span><br><span class="line"></span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">    <span class="attr">entry</span>: path.join(__dirname,<span class="string">&#x27;./src/index.js&#x27;</span>), <span class="comment">// 入口文件</span></span><br><span class="line">    <span class="comment">// 指定生成的文件放到哪里</span></span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">path</span>: path.join(__dirname,<span class="string">&#x27;./dist&#x27;</span>), <span class="comment">// 存放的文件夹</span></span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;bundle.js&#x27;</span> <span class="comment">// 生成的文件名</span></span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">plugins</span>:[htmlPlugin]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如图:</p><p><img src="image-20210919231623903.png" alt="image-20210919231623903"></p><h4 id="devServer-配置"><a href="#devServer-配置" class="headerlink" title="devServer 配置"></a>devServer 配置</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">devServer:&#123;</span><br><span class="line">    <span class="attr">open</span>: <span class="literal">true</span> ,<span class="comment">// 运行后自动打开浏览器</span></span><br><span class="line">    <span class="attr">port</span>: <span class="number">8888</span>, <span class="comment">// 运行的端口号</span></span><br><span class="line">    <span class="attr">host</span>: <span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="comment">// host地址</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="loader-配置"><a href="#loader-配置" class="headerlink" title="loader 配置"></a>loader 配置</h3><h4 id="打包处理-CSS-文件"><a href="#打包处理-CSS-文件" class="headerlink" title="打包处理 CSS 文件"></a>打包处理 CSS 文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import $ from &#x27;jquery&#x27;  // 用 es6 默认语法导入 Jquery</span><br><span class="line">import &#x27;./css/index.css&#x27; // 在 webpack 中，一切皆模块，都可以通过 ES6 导入语法进行导入</span><br><span class="line"></span><br><span class="line">// 定义 jquery 入口函数</span><br><span class="line">$(function()&#123;</span><br><span class="line">    // 实现奇偶数行变色</span><br><span class="line">    $(&#x27;li:odd&#x27;).css(&#x27;background-color&#x27;, &#x27;white&#x27;)</span><br><span class="line">    $(&#x27;li:even&#x27;).css(&#x27;background-color&#x27;, &#x27;red&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>:&#123;</span><br><span class="line">    <span class="attr">rules</span>:[<span class="comment">// 文件后缀名的匹配规则</span></span><br><span class="line">        &#123;<span class="attr">test</span>:<span class="regexp">/\.css$/</span>,use:[<span class="string">&#x27;style-loader&#x27;</span>,<span class="string">&#x27;css-loader&#x27;</span>]&#125;</span><br><span class="line"></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>webpack只能处理js结尾的文件，其他的文件无法处理，要借助相应的loader</p><p>处理css文件要安装对应的loader</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i style-loader@3.0.0 css-loader@5.2.6 -D</span><br></pre></td></tr></table></figure><ol><li><p>当 webpack 发现某个文件处理不了的时候，会查找 webpack.config.js 这个配置文件，看 module.rules 数组中，是否配置了对应的 loader 加载器</p></li><li><p>当webpack 把index.css 这个文件，先转交给最后一个 loader 进行处理 （ 先转交给 css-loader） css-loader再转交给上一个…</p></li></ol><h4 id="打包处理-less-文件"><a href="#打包处理-less-文件" class="headerlink" title="打包处理 less 文件"></a>打包处理 less 文件</h4><ul><li>安装less的loader  </li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install less-loader@10.0.1 less@4.1.1 -D</span><br></pre></td></tr></table></figure><ul><li>配置rules</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module:&#123;</span><br><span class="line">    rules:[// 文件后缀名的匹配规则</span><br><span class="line">        &#123;test:/\.css$/,use:[&#x27;style-loader&#x27;,&#x27;css-loader&#x27;]&#125;,</span><br><span class="line">        &#123;test:/\.less$/,use:[&#x27;style-loader&#x27;,&#x27;css-loader&#x27;,&#x27;less-loader&#x27;]&#125;,</span><br><span class="line"></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="处理图片文件"><a href="#处理图片文件" class="headerlink" title="处理图片文件"></a>处理图片文件</h4><p>安装相应的loader</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install url-loader@4.1.1 file-loader@6.2.0 -D</span><br></pre></td></tr></table></figure><p>配置rules</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>:&#123;</span><br><span class="line">    <span class="attr">rules</span>:[<span class="comment">// 文件后缀名的匹配规则</span></span><br><span class="line">        &#123;<span class="attr">test</span>:<span class="regexp">/\.css$/</span>,use:[<span class="string">&#x27;style-loader&#x27;</span>,<span class="string">&#x27;css-loader&#x27;</span>]&#125;,</span><br><span class="line">        &#123;<span class="attr">test</span>:<span class="regexp">/\.less$/</span>,use:[<span class="string">&#x27;style-loader&#x27;</span>,<span class="string">&#x27;css-loader&#x27;</span>,<span class="string">&#x27;less-loader&#x27;</span>]&#125;,</span><br><span class="line">        &#123;<span class="attr">test</span>:<span class="regexp">/\.png|jpg|gif$/</span>,use:<span class="string">&#x27;url-loader?limit=888&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**limit参数解释: ** 当文件大小小于limit(byte)时，图片会转成base64，以减小网络请求，当图片大小大于limit时则不会转成base64</p><h4 id="处理js文件中的高级语法"><a href="#处理js文件中的高级语法" class="headerlink" title="处理js文件中的高级语法"></a>处理js文件中的高级语法</h4><p>webpack 只能打包处理一部分高级的 JavaScript 语法。对于那些 webpack 无法处理的高级 js 语法，需要借</p><p>助于 babel-loader 进行打包处理。 例如以下的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">info</span>(<span class="params">target</span>)</span>&#123;</span><br><span class="line">    target.info = <span class="string">&#x27;测试&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@info</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Person.info)</span><br></pre></td></tr></table></figure><h5 id="安装babel-loader"><a href="#安装babel-loader" class="headerlink" title="安装babel-loader"></a>安装babel-loader</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i babel-loader@8.2.2 @babel/core@7.14.6 @babel/plugin-proposal-decorators@7.14.5 -D</span><br></pre></td></tr></table></figure><h5 id="配置rules"><a href="#配置rules" class="headerlink" title="配置rules"></a>配置rules</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rules:[<span class="comment">// 文件后缀名的匹配规则</span></span><br><span class="line">    &#123;<span class="attr">test</span>:<span class="regexp">/\.css$/</span>,use:[<span class="string">&#x27;style-loader&#x27;</span>,<span class="string">&#x27;css-loader&#x27;</span>]&#125;,</span><br><span class="line">    &#123;<span class="attr">test</span>:<span class="regexp">/\.less$/</span>,use:[<span class="string">&#x27;style-loader&#x27;</span>,<span class="string">&#x27;css-loader&#x27;</span>,<span class="string">&#x27;less-loader&#x27;</span>]&#125;,</span><br><span class="line">    &#123;<span class="attr">test</span>:<span class="regexp">/\.png|jpg|gif$/</span>,use:<span class="string">&#x27;url-loader&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">test</span>:<span class="regexp">/\.js$/</span>,use: <span class="string">&#x27;babel-loader&#x27;</span>,<span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>&#125;</span><br><span class="line">    </span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>另在项目根目录中创建名为 babel.config.js 的配置文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">plugins</span>:[[<span class="string">&#x27;@babel/plugin-proposal-decorators&#x27;</span>,&#123;<span class="attr">legacy</span>:<span class="literal">true</span>&#125;]]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="打包发布"><a href="#打包发布" class="headerlink" title="打包发布"></a>打包发布</h3><p>配置webpack的打包发布</p><p>package.json中配置scripts</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;dev&quot;</span>: <span class="string">&quot;webpack server&quot;</span>,  </span><br><span class="line">  <span class="string">&quot;build&quot;</span>: <span class="string">&quot;webpack --mode production&quot;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="source-Map"><a href="#source-Map" class="headerlink" title="source Map"></a>source Map</h3><p><em><strong>Source Map 就是一个信息文件，里面储存着位置信息。也就是说，Source Map 文件中存储着压缩混淆后的代码，所对应的转换前的位置。有了它，出错的时候，除错工具将直接显示原始代码，而不是转换后的代码，能够极大的方便后期的调试</strong></em></p><p><strong>配置：</strong> webpack.config.js文件中的modules添加devtool</p><p>调试时配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">module.exports=&#123;</span><br><span class="line">    devtool: &#x27;eval-source-map&#x27;,</span><br><span class="line">    devServer:&#123;</span><br><span class="line">        open: true ,// 运行后自动打开浏览器</span><br><span class="line">        port: 8888, // 运行的端口号</span><br><span class="line">        host: &#x27;127.0.0.1&#x27;, // host地址</span><br><span class="line">    &#125;,</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在发布时配置:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">module.exports=&#123;</span><br><span class="line">    devtool: &#x27;nosources-source-map&#x27;,</span><br><span class="line">    devServer:&#123;</span><br><span class="line">        open: true ,// 运行后自动打开浏览器</span><br><span class="line">        port: 8888, // 运行的端口号</span><br><span class="line">        host: &#x27;127.0.0.1&#x27;, // host地址</span><br><span class="line">    &#125;,</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="符号"><a href="#符号" class="headerlink" title="@ 符号"></a>@ 符号</h3><p>配置webpack.config.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">    <span class="attr">alias</span>: &#123;</span><br><span class="line">        <span class="comment">// 告诉webpack @ 符号表示 ‘./src’</span></span><br><span class="line">        <span class="string">&#x27;@&#x27;</span>: path.join(__dirname,<span class="string">&#x27;./src/&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 默认 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 默认 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础笔记6-NET</title>
      <link href="./2021/09/16/java/java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B06-NET/"/>
      <url>./2021/09/16/java/java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B06-NET/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="assets\css\APlayer.min.css"><script src="assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="NET"><a href="#NET" class="headerlink" title="NET"></a>NET</h1><h2 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h2><h3 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h3><p>网络编程，就是在一定的协议下，实现两台计算机的通信的技术</p><p>通信一定是基于软件结构实现的:</p><ul><li>C/S 结构 ：全称为 Client/Server 结构，是指客户端和服务器结构，常见程序有 QQ、IDEA等软件。</li><li>B/S 结构 ：全称为 Browser/Server 结构，是指浏览器和服务器结构。</li></ul><p>两种架构各有优势，但是无论哪种架构，都离不开网络的支持。</p><p>网络通信的三要素：</p><ol><li><p>协议：计算机网络客户端与服务端通信必须约定和彼此遵守的通信规则，HTTP、FTP、TCP、UDP、SMTP</p></li><li><p>IP地址：互联网协议地址（Internet Protocol Address），用来给一个网络中的计算机设备做唯一的编号</p><ul><li><p>IPv4 ：4个字节，32位组成，192.168.1.1</p></li><li><p>Pv6：可以实现为所有设备分配 IP  128 位</p></li><li><p>ipconfig：查看本机的 IP</p><ul><li>ping 检查本机与某个 IP 指定的机器是否联通，或者说是检测对方是否在线。</li><li>ping 空格 IP地址 ：ping 220.181.57.216，ping <a href="http://www.baidu.com/">www.baidu.com</a></li></ul></li></ul><p>特殊的IP地址： 本机IP地址，<strong>127.0.0.1 == localhost</strong>，回环测试</p></li><li><p>端口：端口号就可以唯一标识设备中的进程（应用程序）<br>端口号：用两个字节表示的整数，的取值范围是 0-65535，0-1023 之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用 1024 以上的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败，报出端口被占用异常</p></li></ol><p>利用<strong>协议+IP 地址+端口号</strong> 三元组合，就可以标识网络中的进程了，那么进程间的通信就可以利用这个标识与其它进程进行交互。</p><p>参考视频：<a href="https://www.bilibili.com/video/BV1kT4y1M7vt">https://www.bilibili.com/video/BV1kT4y1M7vt</a></p><hr><h3 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h3><p>网络通信协议：对计算机必须遵守的规则，只有遵守这些规则，计算机之间才能进行通信</p><blockquote><p>应用层：应用程序（QQ、微信、浏览器），可能用到的协议（HTTP、FTP、SMTP）</p><p>传输层：TCP/IP 协议 - UDP 协议</p><p>网络层  ：IP 协议，封装自己的 IP 和对方的 IP 和端口</p><p>数据链路层 ： 进入到硬件（网）</p></blockquote><p>通信<strong>是进程与进程之间的通信</strong>，不是主机与主机之间的通信</p><p>TCP/IP协议：传输控制协议 (Transmission Control Protocol)</p><p>传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流，每一条 TCP 连接只能是点对点的（一对一）</p><ul><li>在通信之前必须确定对方在线并且连接成功才可以通信</li><li>例如下载文件、浏览网页等（要求可靠传输）</li></ul><p>用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，不可靠，没有拥塞控制，面向报文，支持一对一、一对多、多对一和多对多的交互通信</p><ul><li>直接发消息给对方，不管对方是否在线，发消息后也不需要确认</li><li>无线（视频会议，通话），性能好，可能丢失一些数据</li></ul><hr><h3 id="Java模型"><a href="#Java模型" class="headerlink" title="Java模型"></a>Java模型</h3><p>相关概念：</p><ul><li>同步：当前线程要自己进行数据的读写操作（自己去银行取钱）</li><li>异步：当前线程可以去做其他事情（委托别人拿银行卡到银行取钱，然后给你）</li><li>阻塞：在数据没有的情况下，还是要继续等待着读（排队等待）</li><li>非阻塞：在数据没有的情况下，会去做其他事情，一旦有了数据再来获取（柜台取款，取个号，然后坐在椅子上做其它事，等号广播会通知你办理） </li></ul><p>Java 中的通信模型:</p><ol><li><p>BIO 表示同步阻塞式通信，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，可以通过线程池机制改善。</p><p>同步阻塞式性能极差：大量线程，大量阻塞</p></li><li><p>伪异步通信：引入线程池，不需要一个客户端一个线程，实现线程复用来处理很多个客户端，线程可控。 </p><p>高并发下性能还是很差：线程数量少，数据依然是阻塞的，数据没有来线程还是要等待</p></li><li><p>NIO 表示<strong>同步非阻塞 IO</strong>，服务器实现模式为请求对应一个线程，客户端发送的连接会注册到多路复用器上，多路复用器轮询到连接有 I/O 请求时才启动一个线程进行处理</p><p>工作原理：1 个主线程专门负责接收客户端，1 个线程轮询所有的客户端，发来了数据才会开启线程处理</p><p>同步：线程还要不断的接收客户端连接，以及处理数据</p><p>非阻塞：如果一个管道没有数据，不需要等待，可以轮询下一个管道是否有数据</p></li><li><p>AIO 表示异步非阻塞 IO，AIO 引入异步通道的概念，采用了 Proactor 模式，有效的请求才启动线程，特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用</p><p>异步：服务端线程接收到了客户端管道以后就交给底层处理 IO 通信，线程可以做其他事情</p><p>非阻塞：底层也是客户端有数据才会处理，有了数据以后处理好通知服务器应用来启动线程进行处理</p></li></ol><p>各种模型应用场景：</p><ul><li>BIO 适用于连接数目比较小且固定的架构，该方式对服务器资源要求比较高，并发局限于应用中，程序简单</li><li>NIO 适用于连接数目多且连接比较短（轻操作）的架构，如聊天服务器，并发局限于应用中，编程复杂，JDK 1.4 开始支持</li><li>AIO 适用于连接数目多且连接比较长（重操作）的架构，如相册服务器，充分调用操作系统参与并发操作，JDK 1.7 开始支持</li></ul><hr><h2 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h2><h3 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h3><h4 id="五种模型"><a href="#五种模型" class="headerlink" title="五种模型"></a>五种模型</h4><p>对于一个套接字上的输入操作，第一步是等待数据从网络中到达，当数据到达时被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区</p><p>Linux 有五种 I/O 模型：</p><ul><li>阻塞式 I/O</li><li>非阻塞式 I/O</li><li>I/O 复用（select 和 poll）</li><li>信号驱动式 I/O（SIGIO）</li><li>异步 I/O（AIO）</li></ul><p>五种模型对比：</p><ul><li>同步 I/O 包括阻塞式 I/O、非阻塞式 I/O、I/O 复用和信号驱动 I/O ，它们的主要区别在第一个阶段，非阻塞式 I/O 、信号驱动 I/O 和异步 I/O 在第一阶段不会阻塞</li></ul><ul><li>同步 I/O：将数据从内核缓冲区复制到应用进程缓冲区的阶段（第二阶段），应用进程会阻塞</li><li>异步 I/O：第二阶段应用进程不会阻塞</li></ul><hr><h4 id="阻塞式IO"><a href="#阻塞式IO" class="headerlink" title="阻塞式IO"></a>阻塞式IO</h4><p>应用进程通过系统调用 recvfrom 接收数据，会被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回。阻塞不意味着整个操作系统都被阻塞，其它应用进程还可以执行，只是当前阻塞进程不消耗 CPU 时间，这种模型的 CPU 利用率会比较高</p><p>recvfrom() 用于<strong>接收 Socket 传来的数据，并复制到应用进程的缓冲区 buf 中</strong>，把 recvfrom() 当成系统调用</p><p><img src="https://gitee.com/seazean/images/raw/master/Java/IO%E6%A8%A1%E5%9E%8B-%E9%98%BB%E5%A1%9E%E5%BC%8FIO.png"></p><hr><h4 id="非阻塞式"><a href="#非阻塞式" class="headerlink" title="非阻塞式"></a>非阻塞式</h4><p>应用进程通过 recvfrom 调用不停的去和内核交互，直到内核准备好数据。如果没有准备好数据，内核返回一个错误码，过一段时间应用进程再执行 recvfrom 系统调用，在两次发送请求的时间段，进程可以进行其他任务，这种方式称为轮询（polling）</p><p>由于 CPU 要处理更多的系统调用，因此这种模型的 CPU 利用率比较低</p><p><img src="https://gitee.com/seazean/images/raw/master/Java/IO%E6%A8%A1%E5%9E%8B-%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%BC%8FIO.png"></p><hr><h4 id="信号驱动"><a href="#信号驱动" class="headerlink" title="信号驱动"></a>信号驱动</h4><p>应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，等待数据阶段应用进程是非阻塞的。当内核数据准备就绪时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中</p><p>相比于非阻塞式 I/O 的轮询方式，信号驱动 I/O 的 CPU 利用率更高</p><p><img src="https://gitee.com/seazean/images/raw/master/Java/IO%E6%A8%A1%E5%9E%8B-%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8IO.png"></p><hr><h4 id="IO复用"><a href="#IO复用" class="headerlink" title="IO复用"></a>IO复用</h4><p>IO 复用模型使用 select 或者 poll 函数等待数据，select 会监听所有注册好的 IO，<strong>等待多个套接字中的任何一个变为可读</strong>，等待过程会被阻塞，当某个套接字准备好数据变为可读时 select 调用就返回，然后调用 recvfrom 把数据从内核复制到进程中</p><p>IO 复用让单个进程具有处理多个 I/O 事件的能力，又被称为 Event Driven I/O，即事件驱动 I/O</p><p>如果一个 Web 服务器没有 I/O 复用，那么每一个 Socket 连接都要创建一个线程去处理，如果同时有几万个连接，就需要创建相同数量的线程。相比于多进程和多线程技术，I/O 复用不需要进程线程创建和切换的开销，系统开销更小</p><p><img src="https://gitee.com/seazean/images/raw/master/Java/IO%E6%A8%A1%E5%9E%8B-IO%E5%A4%8D%E7%94%A8%E6%A8%A1%E5%9E%8B.png"></p><hr><h4 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h4><p>应用进程执行 aio_read 系统调用会立即返回，给内核传递描述符、缓冲区指针、缓冲区大小等。应用进程可以继续执行不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。</p><p>异步 I/O 与信号驱动 I/O 的区别在于，异步 I/O 的信号是通知应用进程 I/O 完成，而信号驱动 I/O 的信号是通知应用进程可以开始 I/O</p><p><img src="https://gitee.com/seazean/images/raw/master/Java/IO%E6%A8%A1%E5%9E%8B-%E5%BC%82%E6%AD%A5IO%E6%A8%A1%E5%9E%8B.png"></p><hr><h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><h5 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h5><p>Socket 不是文件，只是一个标识符，但是 Unix 操作系统把所有东西都<strong>看作</strong>是文件，所以 socket 说成 file descriptor，也就是 fd</p><p>select 允许应用程序监视一组文件描述符，等待一个或者多个描述符成为就绪状态，从而完成 I/O 操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>fd_set 使用 <strong>bitmap 数组</strong>实现，数组大小用 FD_SETSIZE 定义，只能监听少于 FD_SETSIZE 数量的描述符，32 位机默认是 1024 个，64 位机默认是 2048，可以对进行修改，然后重新编译内核</p></li><li><p>fd_set 有三种类型的描述符：readset、writeset、exceptset，对应读、写、异常条件的描述符集合</p></li><li><p>n 是监测的 socket 的最大数量</p></li><li><p>timeout 为超时参数，调用 select 会一直阻塞直到有描述符的事件到达或者等待的时间超过 timeout</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span>&#123;</span>    <span class="keyword">long</span> tv_sec; <span class="comment">//秒    long tv_usec;//微秒&#125;</span></span><br></pre></td></tr></table></figure><p>timeout == null：等待无限长的时间<br>tv_sec == 0 &amp;&amp; tv_usec == 0：获取后直接返回，不阻塞等待<br>tv_sec != 0 || tv_usec != 0：等待指定时间</p></li><li><p>方法成功调用返回结果为<strong>就绪的文件描述符个数</strong>，出错返回结果为 -1，超时返回结果为 0</p></li></ul><p>Linux 提供了一组宏为 fd_set 进行赋值操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *fdset)</span></span>;<span class="comment">// 将一个 fd_set 类型变量的所有值都置为 0int FD_CLR(int fd, fd_set *fdset);// 将一个 fd_set 类型变量的 fd 位置为 0int FD_SET(int fd, fd_set *fdset);// 将一个 fd_set 类型变量的 fd 位置为 1int FD_ISSET(int fd, fd_set *fdset);// 判断 fd 位是否被置为 1</span></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);<span class="built_in">memset</span>(&amp;addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr)));addr.sin_family = AF_INET;addr.sin_port = htons(<span class="number">2000</span>);addr.sin_addr.s_addr = INADDR_ANY;bind(sockfd, (struct sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));<span class="comment">//绑定连接listen(sockfd, 5);//监听5个端口for(i = 0; i &lt; 5; i++) &#123;memset(&amp;client, e, sizeof(client));    addrlen = sizeof(client);fds[i] = accept(sockfd, (struct sockaddr*)&amp;client, &amp;addrlen);    //将监听的对应的文件描述符fd存入fds：[3,4,5,6,7]    if(fds[i] &gt; max)max = fds[i];&#125;while(1) &#123;    FD_ZERO(&amp;rset);//置为0    for(i = 0; i &lt; 5; i++) &#123;    FD_SET(fds[i], &amp;rset);//对应位置1 [0001 1111 00.....]&#125;print(&quot;round again&quot;);select(max + 1, &amp;rset, NULL, NULL, NULL);//监听    for(i = 0; i &lt;5; i++) &#123;        if(FD_ISSET(fds[i], &amp;rset)) &#123;//判断监听哪一个端口            memset(buffer, 0, MAXBUF);            read(fds[i], buffer, MAXBUF);//进入内核态读数据            print(buffer);        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>参考视频：<a href="https://www.bilibili.com/video/BV19D4y1o797">https://www.bilibili.com/video/BV19D4y1o797</a></p><hr><h5 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h5><p>select 调用流程图：</p><p><img src="https://gitee.com/seazean/images/raw/master/Java/IO-select%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B.png"></p><ol><li>使用 copy_from_user 从用户空间拷贝 fd_set 到内核空间，进程阻塞</li><li>注册回调函数 _pollwait</li><li>遍历所有 fd，调用其对应的 poll 方法判断当前请求是否准备就绪，对于 socket，这个 poll 方法是 sock_poll，sock_poll 根据情况会调用到 tcp_poll、udp_poll 或者 datagram_poll，以 tcp_poll 为例，其核心实现就是 _pollwait</li><li>_pollwait 把 <strong>current（调用 select 的进程）</strong>挂到设备的等待队列，不同设备有不同的等待队列，对于 tcp_poll ，其等待队列是 sk → sk_sleep（把进程挂到等待队列中并不代表进程已经睡眠），在设备收到消息（网络设备）或填写完文件数据（磁盘设备）后，会唤醒设备等待队列上睡眠的进程，这时 current 便被唤醒，进入就绪队列</li><li>poll 方法返回时会返回一个描述读写操作是否就绪的 mask 掩码，根据这个 mask 掩码给 fd_set 赋值</li><li>如果遍历完所有的 fd，还没有返回一个可读写的 mask 掩码，则会调用 schedule_timeout 让 current 进程进入睡眠。当设备驱动发生自身资源可读写后，会唤醒其等待队列上睡眠的进程，如果超过一定的超时时间（schedule_timeout）没有其他线程唤醒，则调用 select 的进程会重新被唤醒获得 CPU，进而重新遍历 fd，判断有没有就绪的 fd</li><li>把 fd_set 从内核空间拷贝到用户空间，阻塞进程继续执行</li></ol><p>参考文章：<a href="https://www.cnblogs.com/anker/p/3265058.html">https://www.cnblogs.com/anker/p/3265058.html</a></p><p>其他流程图：<a href="https://www.processon.com/view/link/5f62b9a6e401fd2ad7e5d6d1">https://www.processon.com/view/link/5f62b9a6e401fd2ad7e5d6d1</a></p><hr><h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p>poll 的功能与 select 类似，也是等待一组描述符中的一个成为就绪状态</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">unsigned</span> <span class="keyword">int</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>poll 中的描述符是 pollfd 类型的数组，pollfd 的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span>    <span class="keyword">int</span>   fd;         <span class="comment">/* file descriptor */</span>    <span class="keyword">short</span> events;     <span class="comment">/* requested events */</span>    <span class="keyword">short</span> revents;    <span class="comment">/* returned events */</span>&#125;;</span><br></pre></td></tr></table></figure><p>select 和 poll 对比：</p><ul><li>select 会修改描述符，而 poll 不会</li><li>select 的描述符类型使用数组实现，有描述符的限制；而 poll 使用<strong>链表</strong>实现，没有描述符数量的限制</li><li>poll 提供了更多的事件类型，并且对描述符的重复利用上比 select 高</li></ul><ul><li>select 和 poll 速度都比较慢，<strong>每次调用</strong>都需要将全部描述符数组 fd 从应用进程缓冲区复制到内核缓冲区，同时每次都需要在内核遍历传递进来的所有 fd ，这个开销在 fd 很多时会很大</li><li>几乎所有的系统都支持 select，但是只有比较新的系统支持 poll</li><li>select 和 poll 的时间复杂度 O(n)，对 socket 进行扫描时是线性扫描，即采用轮询的方法，效率较低，因为并不知道具体是哪个 socket 具有事件，所以随着 FD 数量的增加会造成遍历速度慢的<strong>线性下降</strong>性能问题</li><li>poll 还有一个特点是水平触发，如果报告了 fd 后，没有被处理，那么下次 poll 时会再次报告该 fd</li><li>如果一个线程对某个描述符调用了 select 或者 poll，另一个线程关闭了该描述符，会导致调用结果不确定</li></ul><p>参考文章：<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Socket.md">https://github.com/CyC2018/CS-Notes/blob/master/notes/Socket.md</a></p><hr><h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><h5 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h5><p>epoll 使用事件的就绪通知方式，通过 epoll_ctl() 向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵<strong>红黑树</strong>上，一旦该 fd 就绪，<strong>内核通过 callback 回调函数将 I/O 准备好的描述符加入到一个链表中</strong>管理，进程调用 epoll_wait() 便可以得到事件就绪的描述符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;<span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span>；<span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>epall_create：一个系统函数，函数将在内核空间内创建一个 epoll 数据结构，可以理解为 epoll 结构空间，返回值为 epoll 的文件描述符编号，以后有 client 连接时，向该 epoll 结构中添加监听，所以 epoll 使用一个文件描述符管理多个描述符</p></li><li><p>epall_ctl：epoll 的事件注册函数，select 函数是调用时指定需要监听的描述符和事件，epoll 先将用户感兴趣的描述符事件注册到 epoll 空间。此函数是非阻塞函数，用来增删改 epoll 空间内的描述符，参数解释：</p><ul><li><p>epfd：epoll 结构的进程 fd 编号，函数将依靠该编号找到对应的 epoll 结构</p></li><li><p>op：表示当前请求类型，有三个宏定义：</p><ul><li>EPOLL_CTL_ADD：注册新的 fd 到 epfd 中</li><li>EPOLL_CTL_MOD：修改已经注册的 fd 的监听事件</li><li>EPOLL_CTI_DEL：从 epfd 中删除一个 fd</li></ul></li><li><p>fd：需要监听的文件描述符，一般指 socket_fd</p></li><li><p>event：告诉内核对该 fd 资源感兴趣的事件，epoll_event 的结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span>    <span class="keyword">_uint32_t</span> events;<span class="comment">/*epoll events*/</span>    <span class="keyword">epoll_data_t</span> data;<span class="comment">/*user data variable*/</span>&#125;</span><br></pre></td></tr></table></figure><p>events 可以是以下几个宏集合：EPOLLIN、EPOLOUT、EPOLLPRI、EPOLLERR、EPOLLHUP（挂断）、EPOLET（边缘触发）、EPOLLONESHOT（只监听一次，事件触发后自动清除该 fd，从 epoll 列表）</p></li></ul></li><li><p>epoll_wait：等待事件的产生，类似于 select() 调用，返回值为本次就绪的 fd 个数，直接从就绪链表获取，时间复杂度 O(1)</p><ul><li>epfd：<strong>指定感兴趣的 epoll 事件列表</strong></li><li>events：指向一个 epoll_event 结构数组，当函数返回时，内核会把就绪状态的数据拷贝到该数组</li><li>maxevents：标明 epoll_event 数组最多能接收的数据量，即本次操作最多能获取多少就绪数据</li><li>timeout：单位为毫秒<ul><li>0：表示立即返回，非阻塞调用</li><li>-1：阻塞调用，直到有用户感兴趣的事件就绪为止</li><li>大于 0：阻塞调用，阻塞指定时间内如果有事件就绪则提前返回，否则等待指定时间后返回</li></ul></li></ul></li></ul><p>epoll 的描述符事件有两种触发模式：LT（level trigger）和 ET（edge trigger）：</p><ul><li>LT 模式：当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait() 会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking</li><li>ET 模式：通知之后进程必须立即处理事件，下次再调用 epoll_wait() 时不会再得到事件到达的通知。减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高；只支持 No-Blocking，以避免由于一个 fd 的阻塞读/阻塞写操作把处理多个文件描述符的任务饥饿</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 epoll 描述符，每个应用程序只需要一个，用于监控所有套接字int pollingfd = epoll_create(0xCAFE);if ( pollingfd &lt; 0 )// report error// 初始化 epoll 结构struct epoll_event ev = &#123; 0 &#125;;// 将连接类实例与事件相关联，可以关联任何想要的东西ev.data.ptr = pConnection1;// 监视输入，并且在事件发生后不自动重新准备描述符ev.events = EPOLLIN | EPOLLONESHOT;// 将描述符添加到监控列表中，即使另一个线程在epoll_wait中等待，描述符将被正确添加if ( epoll_ctl( epollfd, EPOLL_CTL_ADD, pConnection1-&gt;getSocket(), &amp;ev) != 0 )    // report error// 最多等待 20 个事件struct epoll_event pevents[20];// 等待10秒，检索20个并存入epoll_event数组int ready = epoll_wait(pollingfd, pevents, 20, 10000);// 检查epoll是否成功if ( ret == -1)// report error and abortelse if ( ret == 0)// timeout; no event detectedelse&#123;    for (int i = 0; i &lt; ready; i+ )    &#123;        if ( pevents[i].events &amp; EPOLLIN )        &#123;            // 获取连接指针            Connection * c = (Connection*) pevents[i].data.ptr;            c-&gt;handleReadEvent();         &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>流程图：<a href="https://gitee.com/seazean/images/blob/master/Java/IO-epoll%E5%8E%9F%E7%90%86%E5%9B%BE.jpg">https://gitee.com/seazean/images/blob/master/Java/IO-epoll%E5%8E%9F%E7%90%86%E5%9B%BE.jpg</a></p><p>参考视频：<a href="https://www.bilibili.com/video/BV19D4y1o797">https://www.bilibili.com/video/BV19D4y1o797</a></p><hr><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><p>epoll 的特点：</p><ul><li><p>epoll 仅适用于 Linux 系统</p></li><li><p>epoll 使用<strong>一个文件描述符管理多个描述符</strong>，将用户关系的文件描述符的事件存放到内核的一个事件表（个人理解成哑元节点）</p></li><li><p>没有最大描述符数量（并发连接）的限制，打开 fd 的上限远大于1024（1G 内存能监听约10万个端口）</p></li><li><p>epoll 的时间复杂度 O(1)，epoll 理解为 event poll，不同于忙轮询和无差别轮询，调用 epoll_wait <strong>只是轮询就绪链表</strong>。当监听列表有设备就绪时调用回调函数，把就绪 fd 放入就绪链表中，并唤醒在 epoll_wait 中阻塞的进程，所以 epoll 实际上是<strong>事件驱动</strong>（每个事件关联上fd）的，降低了 system call 的时间复杂度</p></li><li><p>epoll 内核中根据每个 fd 上的 callback 函数来实现，只有活跃的 socket 才会主动调用 callback，所以使用 epoll 没有前面两者的线性下降的性能问题，效率提高</p></li><li><p>epoll 注册新的事件都是注册到到内核中 epoll 句柄中，不需要每次调用 epoll_wait 时重复拷贝，对比前面两种，epoll 只需要将描述符从进程缓冲区向内核缓冲区拷贝一次。 epoll 也可以利用 <strong>mmap() 文件映射内存</strong>加速与内核空间的消息传递，减少复制开销</p></li><li><p>前面两者要把 current 往设备等待队列中挂一次，epoll 也只把 current 往等待队列上挂一次，但是这里的等待队列并不是设备等待队列，只是一个 epoll 内部定义的等待队列，这样可以节省开销</p></li><li><p>epoll 对多线程编程更有友好，一个线程调用了 epoll_wait() 另一个线程关闭了同一个描述符，也不会产生像 select 和 poll 的不确定情况</p></li></ul><p>参考文章：<a href="https://www.jianshu.com/p/dfd940e7fca2">https://www.jianshu.com/p/dfd940e7fca2</a></p><p>参考文章：<a href="https://www.cnblogs.com/anker/p/3265058.html">https://www.cnblogs.com/anker/p/3265058.html</a></p><hr><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>应用场景： </p><ul><li><p>select 应用场景：</p><ul><li>select 的 timeout 参数精度为微秒，poll 和 epoll 为毫秒，因此 select 适用<strong>实时性要求比较高</strong>的场景，比如核反应堆的控制</li><li>select 可移植性更好，几乎被所有主流平台所支持</li></ul></li><li><p>poll 应用场景：poll 没有最大描述符数量的限制，适用于平台支持并且对实时性要求不高的情况</p></li><li><p>epoll 应用场景：</p><ul><li>运行在 Linux 平台上，有大量的描述符需要同时轮询，并且这些连接最好是<strong>长连接</strong></li><li>需要同时监控小于 1000 个描述符，没必要使用 epoll，因为这个应用场景下并不能体现 epoll 的优势</li><li>需要监控的描述符状态变化多，而且是非常短暂的，就没有必要使用 epoll。因为 epoll 中的所有描述符都存储在内核中，每次对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用，频繁系统调用降低效率，并且 epoll 的描述符存储在内核，不容易调试</li></ul></li></ul><p>参考文章：<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Socket.md">https://github.com/CyC2018/CS-Notes/blob/master/notes/Socket.md</a></p><hr><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><h4 id="内核态"><a href="#内核态" class="headerlink" title="内核态"></a>内核态</h4><p>用户空间：用户代码、用户堆栈</p><p>内核空间：内核代码、内核调度程序、进程描述符（内核堆栈、thread_info 进程描述符）</p><ul><li>进程描述符和用户的进程是一一对应的</li><li>SYS_API 系统调用：如 read、write，系统调用就是 0X80 中断</li><li>进程描述符 pd：进程从用户态切换到内核态时，需要保存用户态时的上下文信息在 PCB 中</li><li>线程上下文：用户程序基地址，程序计数器、cpu cache、寄存器等，方便程序切回用户态时恢复现场</li><li>内核堆栈：<strong>系统调用函数也是要创建变量的，</strong>这些变量在内核堆栈上分配</li></ul><p><img src="https://gitee.com/seazean/images/raw/master/Java/IO-%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81.png"></p><hr><h4 id="80中断"><a href="#80中断" class="headerlink" title="80中断"></a>80中断</h4><p>在用户程序中调用操作系统提供的核心态级别的子功能，为了系统安全需要进行用户态和内核态转换，状态的转换需要进行 CPU 中断，中断分为硬中断和软中断：</p><ul><li>硬中断：如网络传输中，数据到达网卡后，网卡经过一系列操作后发起硬件中断</li><li>软中断：如程序运行过程中本身产生的一些中断<ul><li>发起 <code>0X80</code> 中断</li><li>程序执行碰到除 0 异常</li></ul></li></ul><p>系统调用 system_call 函数所对应的中断指令编号是 0X80（十进制是 8×16=128），而该指令编号对应的就是系统调用程序的入口，所以称系统调用为 80 中断</p><p>系统调用的流程：</p><ul><li>在 CPU 寄存器里存一个系统调用号，表示哪个系统函数，比如 read</li><li>将 CPU 的临时数据都保存到 thread_info 中</li><li>执行 80 中断处理程序，找到刚刚存的系统调用号（read），先检查缓存中有没有对应的数据，没有就去磁盘中加载到内核缓冲区，然后从内核缓冲区拷贝到用户空间</li><li>最后恢复到用户态，通过 thread_info 恢复现场，用户态继续执行</li></ul><p><img src="https://gitee.com/seazean/images/raw/master/Java/IO-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E8%BF%87%E7%A8%8B.jpg"></p><p>参考视频：<a href="https://www.bilibili.com/video/BV19D4y1o797">https://www.bilibili.com/video/BV19D4y1o797</a></p><hr><h3 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h3><h4 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h4><p>DMA (Direct Memory Access) ：直接存储器访问，让外部设备不通过 CPU 直接与系统内存交换数据的接口技术</p><p>作用：可以解决批量数据的输入/输出问题，使数据的传送速度取决于存储器和外设的工作速度</p><p>把内存数据传输到网卡然后发送：</p><ul><li>没有 DMA：CPU 读内存数据到 CPU 高速缓存，再写到网卡，这样就把 CPU 的速度拉低到和网卡一个速度</li><li>使用 DMA：把数据读到 Socket 内核缓存区（CPU 复制），CPU 分配给 DMA 开始<strong>异步</strong>操作，DMA 读取 Socket 缓冲区到 DMA 缓冲区，然后写到网卡。DMA 执行完后中断（就是通知） CPU，这时 Socket 内核缓冲区为空，CPU 从用户态切换到内核态，执行中断处理程序，将需要使用 Socket 缓冲区的阻塞进程移到就绪队列</li></ul><p>一个完整的 DMA 传输过程必须经历 DMA 请求、DMA 响应、DMA 传输、DMA 结束四个步骤：</p><img src="https://gitee.com/seazean/images/raw/master/Java/IO-DMA.png" style="zoom: 50%;"><p>DMA 方式是一种完全由硬件进行信息传送的控制方式，通常系统总线由 CPU 管理，在 DMA 方式中，CPU 的主存控制信号被禁止使用，CPU 把总线（地址总线、数据总线、控制总线）让出来由 DMA 控制器接管，用来控制传送的字节数、判断 DMA 是否结束、以及发出 DMA 结束信号，所以 DMA 控制器必须有以下功能：</p><ul><li>接受外设发出的 DMA 请求，并向 CPU 发出总线接管请求</li><li>当 CPU 发出允许接管信号后，进入 DMA 操作周期</li><li>确定传送数据的主存单元地址及长度，并自动修改主存地址计数和传送长度计数</li><li>规定数据在主存和外设间的传送方向，发出读写等控制信号，执行数据传送操作</li><li>判断 DMA 传送是否结束，发出 DMA 结束信号，使 CPU 恢复正常工作状态（中断）</li></ul><hr><h4 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h4><p>传统的 I/O 操作进行了 4 次用户空间与内核空间的上下文切换，以及 4 次数据拷贝：</p><ul><li>JVM 发出 read 系统调用，OS 上下文切换到内核模式（切换 1）并将数据从网卡或硬盘等设备通过 DMA 读取到内核空间缓冲区（拷贝 1）</li><li>OS 内核将数据复制到用户空间缓冲区（拷贝 2），然后 read 系统调用返回，又会导致一次内核空间到用户空间的上下文切换（切换 2）</li><li>JVM 处理代码逻辑并发送 write() 系统调用，OS 上下文切换到内核模式（切换3）并从用户空间缓冲区复制数据到内核空间缓冲区（拷贝3）</li><li>将内核空间缓冲区中的数据写到 hardware（拷贝4），write 系统调用返回，导致内核空间到用户空间的再次上下文切换（切换4）</li></ul><p>流程图中的箭头反过来也成立，可以从网卡获取数据</p><p><img src="https://gitee.com/seazean/images/raw/master/Java/IO-BIO%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png"></p><p>read 调用图示：read、write 都是系统调用指令</p><img src="https://gitee.com/seazean/images/raw/master/Java/IO-缓冲区读写.png" style="zoom: 67%;"><hr><h4 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h4><p>mmap（Memory Mapped Files）加 write 实现零拷贝，<strong>零拷贝就是没有数据从内核空间复制到用户空间</strong></p><p>用户空间和内核空间都使用内存，所以可以共享同一块物理内存地址，省去用户态和内核态之间的拷贝。写网卡时，共享空间的内容拷贝到 Socket 缓冲区，然后交给 DMA 发送到网卡，只需要 3 次复制</p><p>进行了 4 次用户空间与内核空间的上下文切换，以及 3 次数据拷贝（2 次 DMA，一次 CPU 复制）：</p><ul><li>发出 mmap 系统调用，DMA 拷贝到内核缓冲区，映射到共享缓冲区；mmap 系统调用返回，无需拷贝</li><li>发出 write 系统调用，将数据从内核缓冲区拷贝到内核 Socket 缓冲区；write系统调用返回，DMA 将内核空间 Socket 缓冲区中的数据传递到协议引擎</li></ul><p><img src="https://gitee.com/seazean/images/raw/master/Java/IO-mmap%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png"></p><p>原理：利用操作系统的 Page 来实现文件到物理内存的直接映射，完成映射后对物理内存的操作会<strong>被同步</strong>到硬盘上</p><p>缺点：不可靠，写到 mmap 中的数据并没有被真正的写到硬盘，操作系统会在程序主动调用 flush 的时候才把数据真正的写到硬盘</p><p>Java NIO 提供了 <strong>MappedByteBuffer</strong> 类可以用来实现 mmap 内存映射，MappedByteBuffer 类对象<strong>只能通过调用 <code>FileChannel.map()</code> 获取</strong></p><hr><h4 id="sendfile"><a href="#sendfile" class="headerlink" title="sendfile"></a>sendfile</h4><p>sendfile 实现零拷贝，打开文件的文件描述符 fd 和 socket 的 fd 传递给 sendfile，然后经过 3 次复制和 2 次用户态和内核态的切换</p><p>原理：数据根本不经过用户态，直接从内核缓冲区进入到 Socket Buffer，由于和用户态完全无关，就减少了两次上下文切换</p><p><img src="https://gitee.com/seazean/images/raw/master/Java/IO-sendfile%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png"></p><p>sendfile2.4 之后，sendfile 实现了更简单的方式，文件到达内核缓冲区后，不必再将数据全部复制到 socket buffer 缓冲区，而是只<strong>将记录数据位置和长度相关等描述符信息</strong>保存到 socket buffer，DMA 根据 Socket 缓冲区中描述符提供的位置和偏移量信息直接将内核空间缓冲区中的数据拷贝到协议引擎上（2 次复制 2 次切换）</p><p>Java NIO 对 sendfile 的支持是 <code>FileChannel.transferTo()/transferFrom()</code>，把磁盘文件读取 OS 内核缓冲区后的 fileChannel，直接转给 socketChannel 发送，底层就是 sendfile</p><p>参考文章：<a href="https://blog.csdn.net/hancoder/article/details/112149121">https://blog.csdn.net/hancoder/article/details/112149121</a></p><hr><h2 id="BIO-1"><a href="#BIO-1" class="headerlink" title="BIO"></a>BIO</h2><h3 id="Inet"><a href="#Inet" class="headerlink" title="Inet"></a>Inet</h3><p>一个 InetAddress 类的对象就代表一个 IP 地址对象</p><p>成员方法：</p><ul><li><code>static InetAddress getLocalHost()</code>：获得本地主机 IP 地址对象</li><li><code>static InetAddress getByName(String host)</code>：根据 IP 地址字符串或主机名获得对应的IP地址对象</li><li><code>String getHostName()</code>：获取主机名</li><li><code>String getHostAddress()</code>：获得 IP 地址字符串</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InetAddressDemo</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;        <span class="comment">// 1.获取本机地址对象        InetAddress ip = InetAddress.getLocalHost();        System.out.println(ip.getHostName());//DESKTOP-NNMBHQR        System.out.println(ip.getHostAddress());//192.168.11.1        // 2.获取域名ip对象        InetAddress ip2 = InetAddress.getByName(&quot;www.baidu.com&quot;);        System.out.println(ip2.getHostName());//www.baidu.com        System.out.println(ip2.getHostAddress());//14.215.177.38        // 3.获取公网IP对象。        InetAddress ip3 = InetAddress.getByName(&quot;182.61.200.6&quot;);        System.out.println(ip3.getHostName());//182.61.200.6        System.out.println(ip3.getHostAddress());//182.61.200.6                // 4.判断是否能通： ping  5s之前测试是否可通        System.out.println(ip2.isReachable(5000)); // ping百度    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>UDP（User Datagram Protocol）协议的特点：</p><ul><li>面向无连接的协议</li><li>发送端只管发送，不确认对方是否能收到</li><li>基于数据包进行数据传输</li><li>发送数据的包的大小限制 <strong>64KB</strong> 以内</li><li>因为面向无连接，速度快，但是不可靠，会丢失数据</li></ul><p>UDP 协议的使用场景：在线视频、网络语音、电话</p><hr><h4 id="实现UDP"><a href="#实现UDP" class="headerlink" title="实现UDP"></a>实现UDP</h4><p>UDP 协议相关的两个类：</p><ul><li>DatagramPacket（数据包对象）：用来封装要发送或要接收的数据，比如：集装箱</li><li>DatagramSocket（发送对象）：用来发送或接收数据包，比如：码头</li></ul><p><strong>DatagramPacket</strong>：</p><ul><li><p>DatagramPacket 类：</p><p><code>public new DatagramPacket(byte[] buf, int length, InetAddress address, int port)</code>：创建发送端数据包对象 </p><ul><li>buf：要发送的内容，字节数组</li><li>length：要发送内容的长度，单位是字节</li><li>address：接收端的IP地址对象</li><li>port：接收端的端口号</li></ul><p><code>public new DatagramPacket(byte[] buf, int length)</code>：创建接收端的数据包对象</p><ul><li>buf：用来存储接收到内容        </li><li>length：能够接收内容的长度</li></ul></li><li><p>DatagramPacket 类常用方法：</p><ul><li><code>public int getLength()</code>：获得实际接收到的字节个数</li><li><code>public byte[] getData()</code>：返回数据缓冲区</li></ul></li></ul><p><strong>DatagramSocket</strong>：</p><ul><li>DatagramSocket 类构造方法：<ul><li><code>protected DatagramSocket()</code>：创建发送端的 Socket 对象，系统会随机分配一个端口号</li><li><code>protected DatagramSocket(int port)</code>：创建接收端的 Socket 对象并指定端口号</li></ul></li><li>DatagramSocket 类成员方法：<ul><li><code>public void send(DatagramPacket dp)</code>：发送数据包</li><li><code>public void receive(DatagramPacket p)</code>：接收数据包</li><li><code>public void close()</code>：关闭数据报套接字</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDPClientDemo</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;        System.out.println(<span class="string">&quot;===启动客户端===&quot;</span>);        <span class="comment">// 1.创建一个集装箱对象，用于封装需要发送的数据包!        byte[] buffer = &quot;我学Java&quot;.getBytes();        DatagramPacket packet = new DatagramPacket(buffer,bubffer.length,InetAddress.getLoclHost,8000);        // 2.创建一个码头对象        DatagramSocket socket = new DatagramSocket();        // 3.开始发送数据包对象        socket.send(packet);        socket.close();    &#125;&#125;public class UDPServerDemo&#123;    public static void main(String[] args) throws Exception &#123;        System.out.println(&quot;==启动服务端程序==&quot;);        // 1.创建一个接收客户都端的数据包对象（集装箱）        byte[] buffer = new byte[1024*64];        DatagramPacket packet = new DatagramPacket(buffer, bubffer.length);        // 2.创建一个接收端的码头对象        DatagramSocket socket = new DatagramSocket(8000);        // 3.开始接收        socket.receive(packet);        // 4.从集装箱中获取本次读取的数据量        int len = packet.getLength();        // 5.输出数据        // String rs = new String(socket.getData(), 0, len)        String rs = new String(buffer , 0 , len);        System.out.println(rs);        // 6.服务端还可以获取发来信息的客户端的IP和端口。        String ip = packet.getAddress().getHostAdress();        int port = packet.getPort();        socket.close();    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="通讯方式"><a href="#通讯方式" class="headerlink" title="通讯方式"></a>通讯方式</h4><p>UDP 通信方式：</p><ul><li><p>单播：用于两个主机之间的端对端通信</p></li><li><p>组播：用于对一组特定的主机进行通信</p><p>IP : 224.0.1.0</p><p>Socket 对象 : MulticastSocket</p></li><li><p>广播：用于一个主机对整个局域网上所有主机上的数据通信</p><p>IP : 255.255.255.255</p><p>Socket 对象 : DatagramSocket</p></li></ul><hr><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><h4 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>TCP/IP (Transfer Control Protocol) 协议，传输控制协议</p><p>TCP/IP 协议的特点：</p><ul><li>面向连接的协议</li><li>只能由客户端主动发送数据给服务器端，服务器端接收到数据之后，可以给客户端响应数据</li><li>通过<strong>三次握手</strong>建立连接，连接成功形成数据传输通道；通过<strong>四次挥手</strong>断开连接</li><li>基于字节流进行数据传输</li><li>传输数据大小没有限制</li><li>因为面向连接的协议，速度慢，但是是可靠的协议。</li></ul><p>TCP 协议的使用场景：文件上传和下载、邮件发送和接收、远程登录</p><p>注意：<strong>TCP 不会为没有数据的 ACK 超时重传</strong></p><img src="https://gitee.com/seazean/images/raw/master/Java/三次握手.png" alt="三次握手" style="zoom: 50%;"><img src="https://gitee.com/seazean/images/raw/master/Java/四次挥手.png" alt="四次挥手" style="zoom: 67%;"><p>推荐阅读：<a href="https://yuanrengu.com/2020/77eef79f.html">https://yuanrengu.com/2020/77eef79f.html</a></p><hr><h4 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h4><p>TCP 通信也叫 <strong>Socket 网络编程</strong>，只要代码基于 Socket 开发，底层就是基于了可靠传输的 TCP 通信</p><p>TCP 协议相关的类：</p><ul><li>Socket：一个该类的对象就代表一个客户端程序。</li><li>ServerSocket：一个该类的对象就代表一个服务器端程序。</li></ul><p>Socket 类：</p><ul><li><p>构造方法：</p><ul><li><p><code>Socket(InetAddress address,int port)</code>：创建流套接字并将其连接到指定 IP 指定端口号</p></li><li><p><code>Socket(String host, int port)</code>：根据ip地址字符串和端口号创建客户端 Socket 对象</p><p>注意事项：执行该方法，就会立即连接指定的服务器，连接成功，则表示三次握手通过，反之抛出异常</p></li></ul></li><li><p>常用 API：</p><ul><li><code>OutputStream getOutputStream()</code>：获得字节输出流对象</li><li><code>InputStream getInputStream()</code>：获得字节输入流对象</li><li><code>void shutdownInput()</code>：停止接受</li><li><code>void shutdownOutput()</code>：停止发送数据，终止通信</li><li><code>SocketAddress getRemoteSocketAddress() </code>：返回套接字连接到的端点的地址，未连接返回 null</li></ul></li></ul><p>ServerSocket 类：</p><ul><li><p>构造方法：<code>public ServerSocket(int port)</code></p></li><li><p>常用API：<code>public Socket accept()</code>，<strong>阻塞等待</strong>接收一个客户端的 Socket 管道连接请求，连接成功返回一个 Socket 对象</p><p>三次握手后 TCP 连接建立成功，服务器内核会把连接从 SYN 半连接队列中移出，移入 accept （全连接）队列，等待进程调用 accept 函数时把连接取出。如果进程不能及时调用 accept 函数，就会造成 accept 队列溢出，最终导致建立好的 TCP 连接被丢弃</p></li></ul><p>相当于客户端和服务器建立一个数据管道，管道一般不用 close</p><hr><h4 id="实现TCP"><a href="#实现TCP" class="headerlink" title="实现TCP"></a>实现TCP</h4><h5 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h5><p>客户端的开发流程：</p><ol><li>客户端要请求于服务端的 Socket 管道连接</li><li>从 Socket 通信管道中得到一个字节输出流</li><li>通过字节输出流给服务端写出数据</li></ol><p>服务端的开发流程：</p><ol><li>用 ServerSocket 注册端口</li><li>接收客户端的 Socket 管道连接</li><li>从 Socket 通信管道中得到一个字节输入流</li><li>从字节输入流中读取客户端发来的数据</li></ol><p><img src="https://gitee.com/seazean/images/raw/master/Java/BIO%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6.png"></p><p><img src="https://gitee.com/seazean/images/raw/master/Java/TCP-%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%9E%8B.png"></p><ul><li>如果输出缓冲区空间不够存放主机发送的数据，则会被阻塞，输入缓冲区同理</li><li>缓冲区不属于应用程序，属于内核</li><li>TCP 从输出缓冲区读取数据会加锁阻塞线程</li></ul><hr><h5 id="实现通信"><a href="#实现通信" class="headerlink" title="实现通信"></a>实现通信</h5><p>需求一：客户端发送一行数据，服务端接收一行数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientDemo</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;        <span class="comment">// 1.客户端要请求于服务端的socket管道连接。        Socket socket = new Socket(&quot;127.0.0.1&quot;, 8080);        // 2.从socket通信管道中得到一个字节输出流        OutputStream os = new socket.getOutputStream();        // 3.把低级的字节输出流包装成高级的打印流。        PrintStream ps = new PrintStream(os);        // 4.开始发消息出去        ps.println(&quot;我是客户端&quot;);        ps.flush();//一般不关闭IO流        System.out.println(&quot;客户端发送完毕~~~~&quot;);    &#125;&#125;public class ServerDemo&#123;    public static void main(String[] args) throws Exception &#123;        System.out.println(&quot;----服务端启动----&quot;);        // 1.注册端口: public ServerSocket(int port)        ServerSocket serverSocket = new ServerSocket(8080);        // 2.开始等待接收客户端的Socket管道连接。        Socket socket = serverSocket.accept();        // 3.从socket通信管道中得到一个字节输入流。        InputStream is = socket.getInputStream();        // 4.把字节输入流转换成字符输入流        BufferedReader br = new BufferedReader(new InputStreamReader(is));        // 6.按照行读取消息 。        String line;        if((line = br.readLine()) != null)&#123;            System.out.println(line);        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>需求二：客户端可以反复发送数据，服务端可以反复数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientDemo</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;        <span class="comment">// 1.客户端要请求于服务端的socket管道连接。        Socket socket = new Socket(&quot;127.0.0.1&quot;,8080);        // 2.从socket通信管道中得到一个字节输出流        OutputStream os = socket.getOutputStream();        // 3.把低级的字节输出流包装成高级的打印流。        PrintStream ps = new PrintStream(os);        // 4.开始发消息出去         while(true)&#123;            Scanner sc = new Scanner(System.in);            System.out.print(&quot;请说：&quot;);            ps.println(sc.nextLine());            ps.flush();        &#125;    &#125;&#125;public class ServerDemo&#123;    public static void main(String[] args) throws Exception &#123;        System.out.println(&quot;----服务端启动----&quot;);        // 1.注册端口: public ServerSocket(int port)        ServerSocket serverSocket = new ServerSocket(8080);        // 2.开始等待接收客户端的Socket管道连接。        Socket socket = serverSocket.accept();        // 3.从socket通信管道中得到一个字节输入流。        InputStream is = socket.getInputStream();        // 4.把字节输入流转换成字符输入流        BufferedReader br = new BufferedReader(new InputStreamReader(is));        // 6.按照行读取消息 。        String line;        while((line = br.readLine()) != null)&#123;            System.out.println(line);        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>需求三：实现一个服务端可以同时接收多个客户端的消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientDemo</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;        Socket socket = <span class="keyword">new</span> Socket(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">8080</span>);        OutputStream os = <span class="keyword">new</span> socket.getOutputStream();        PrintStream ps = <span class="keyword">new</span> PrintStream(os);<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;            Scanner sc = <span class="keyword">new</span> Scanner(System.in);            System.out.print(<span class="string">&quot;请说：&quot;</span>);            ps.println(sc.nextLine());            ps.flush();        &#125;    &#125;&#125;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerDemo</span></span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;        System.out.println(<span class="string">&quot;----服务端启动----&quot;</span>);        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8080</span>);        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;            <span class="comment">// 开始等待接收客户端的Socket管道连接。             Socket socket = serverSocket.accept();            // 每接收到一个客户端必须为这个客户端管道分配一个独立的线程来处理与之通信。            new ServerReaderThread(socket).start();        &#125;    &#125;&#125;class ServerReaderThread extends Thread&#123;    privat Socket socket;    public ServerReaderThread(Socket socket)&#123;this.socket = socket;&#125;    @Override    public void run() &#123;        try(InputStream is = socket.getInputStream();           BufferedReader br = new BufferedReader(new InputStreamReader(is))           )&#123;            String line;            while((line = br.readLine()) != null)&#123;                sout(socket.getRemoteSocketAddress() + &quot;:&quot; + line);            &#125;        &#125;catch(Exception e)&#123;            sout(socket.getRemoteSocketAddress() + &quot;下线了~~~~~~&quot;);        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h5 id="伪异步"><a href="#伪异步" class="headerlink" title="伪异步"></a>伪异步</h5><p>一个客户端要一个线程，并发越高系统瘫痪的越快，可以在服务端引入线程池，使用线程池来处理与客户端的消息通信</p><ul><li><p>优势：不会引起系统的死机，可以控制并发线程的数量</p></li><li><p>劣势：同时可以并发的线程将受到限制</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BIOServer</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;        <span class="comment">//线程池机制        //创建一个线程池，如果有客户端连接，就创建一个线程，与之通讯(单独写一个方法)        ExecutorService newCachedThreadPool = Executors.newCachedThreadPool();        //创建ServerSocket        ServerSocket serverSocket = new ServerSocket(6666);        System.out.println(&quot;服务器启动了&quot;);        while (true) &#123;            System.out.println(&quot;线程名字 = &quot; + Thread.currentThread().getName());            //监听，等待客户端连接            System.out.println(&quot;等待连接....&quot;);            final Socket socket = serverSocket.accept();            System.out.println(&quot;连接到一个客户端&quot;);            //创建一个线程，与之通讯            newCachedThreadPool.execute(new Runnable() &#123;                public void run() &#123;                    //可以和客户端通讯                    handler(socket);                &#125;            &#125;);        &#125;    &#125;    //编写一个handler方法，和客户端通讯    public static void handler(Socket socket) &#123;        try &#123;            System.out.println(&quot;线程名字 = &quot; + Thread.currentThread().getName());            byte[] bytes = new byte[1024];            //通过socket获取输入流            InputStream inputStream = socket.getInputStream();            int len;            //循环的读取客户端发送的数据            while ((len = inputStream.read(bytes)) != -1) &#123;                System.out.println(&quot;线程名字 = &quot; + Thread.currentThread().getName());                //输出客户端发送的数据                System.out.println(new String(bytes, 0, read));            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            System.out.println(&quot;关闭和client的连接&quot;);            try &#123;                socket.close();            &#125; catch (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="文件传输"><a href="#文件传输" class="headerlink" title="文件传输"></a>文件传输</h4><h5 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h5><p>客户端：本地图片:  ‪E:\seazean\图片资源\beautiful.jpg<br>服务端：服务器路径：E:\seazean\图片服务器</p><p>UUID. randomUUID() : 方法生成随机的文件名</p><p>**socket.shutdownOutput()**：这个必须执行，不然服务器会一直循环等待数据，最后文件损坏，程序报错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常量包public class Constants &#123;    public static final String SRC_IMAGE = &quot;D:\\seazean\\图片资源\\beautiful.jpg&quot;;    public static final String SERVER_DIR = &quot;D:\\seazean\\图片服务器\\&quot;;    public static final String SERVER_IP = &quot;127.0.0.1&quot;;    public static final int SERVER_PORT = 8888;&#125;public class ClientDemo &#123;    public static void main(String[] args) throws Exception &#123;        Socket socket = new Socket(Constants.ERVER_IP,Constants.SERVER_PORT);        BufferedOutputStream bos=new BufferedOutputStream(socket.getOutputStream());        //提取本机的图片上传给服务端。Constants.SRC_IMAGE        BufferedInputStream bis = new BufferedInputStream(new FileInputStream());        byte[] buffer = new byte[1024];        int len ;        while((len = bis.read(buffer)) != -1) &#123;            bos.write(buffer, 0 ,len);        &#125;        bos.flush();// 刷新图片数据到服务端！！        socket.shutdownOutput();// 告诉服务端我的数据已经发送完毕，不要在等我了！        bis.close();                //等待着服务端的响应数据！！        BufferedReader br = new BufferedReader(            new InputStreamReader(socket.getInputStream()));        System.out.println(&quot;收到服务端响应：&quot;+br.readLine());    &#125;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerDemo</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;        System.out.println(<span class="string">&quot;----服务端启动----&quot;</span>);        <span class="comment">// 1.注册端口:         ServerSocket serverSocket = new ServerSocket(Constants.SERVER_PORT);        // 2.定义一个循环不断的接收客户端的连接请求        while(true)&#123;            // 3.开始等待接收客户端的Socket管道连接。            Socket socket = serverSocket.accept();            // 4.每接收到一个客户端必须为这个客户端管道分配一个独立的线程来处理与之通信。            new ServerReaderThread(socket).start();        &#125;    &#125;&#125;class ServerReaderThread extends Thread&#123;    private Socket socket ;    public ServerReaderThread(Socket socket)&#123;this.socket = socket;&#125;    @Override    public void run() &#123;        try&#123;            InputStream is = socket.getInputStream();           BufferedInputStream bis = new BufferedInputStream(is);            BufferedOutputStream bos = new BufferedOutputStream(                new FileOutputStream                (Constants.SERVER_DIR+UUID.randomUUID().toString()+&quot;.jpg&quot;));            byte[] buffer = new byte[1024];            int len;            while((len = bis.read(buffer)) != -1)&#123;                bos.write(buffer,0,len);            &#125;            bos.close();            System.out.println(&quot;服务端接收完毕了！&quot;);                        // 4.响应数据给客户端            PrintStream ps = new PrintStream(socket.getOutputStream());            ps.println(&quot;您好，已成功接收您上传的图片！&quot;);            ps.flush();            Thread.sleep(10000);        &#125;catch (Exception e)&#123;            sout(socket.getRemoteSocketAddress() + &quot;下线了&quot;);        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h5 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h5><p>构造方法：</p><ul><li><code>DataOutputStream(OutputStream out)</code> : 创建一个新的数据输出流，以将数据写入指定的底层输出流</li><li><code>DataInputStream(InputStream in) </code> : 创建使用指定的底层 InputStream 的 DataInputStream</li></ul><p>常用API：</p><ul><li><code>final void writeUTF(String str)</code> : 使用机器无关的方式使用 UTF-8 编码将字符串写入底层输出流</li><li><code>final String readUTF()</code> : 读取以 modified UTF-8 格式编码的 Unicode 字符串，返回 String 类型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;InputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;path&quot;</span>);            <span class="comment">//  1、请求与服务端的Socket链接            Socket socket = new Socket(&quot;127.0.0.1&quot; , 8888);            //  2、把字节输出流包装成一个数据输出流            DataOutputStream dos = new DataOutputStream(socket.getOutputStream());            //  3、先发送上传文件的后缀给服务端            dos.writeUTF(&quot;.png&quot;);            //  4、把文件数据发送给服务端进行接收            byte[] buffer = new byte[1024];            int len;            while((len = is.read(buffer)) &gt; 0 )&#123;                dos.write(buffer , 0 , len);            &#125;            dos.flush();            Thread.sleep(10000);    &#125;&#125;public class Server &#123;    public static void main(String[] args) &#123;        ServerSocket ss = new ServerSocket(8888);        Socket socket = ss.accept(); // 1、得到一个数据输入流读取客户端发送过来的数据DataInputStream dis = new DataInputStream(socket.getInputStream());// 2、读取客户端发送过来的文件类型String suffix = dis.readUTF();// 3、定义一个字节输出管道负责把客户端发来的文件数据写出去OutputStream os = new FileOutputStream(&quot;path&quot;+                    UUID.randomUUID().toString()+suffix);// 4、从数据输入流中读取文件数据，写出到字节输出流中去byte[] buffer = new byte[1024];int len;while((len = dis.read(buffer)) &gt; 0)&#123; os.write(buffer,0, len);&#125;os.close();System.out.println(&quot;服务端接收文件保存成功！&quot;);    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><h3 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h3><p><strong>NIO的介绍</strong>：</p><p>Java NIO（New IO、Java non-blocking IO），从 Java 1.4 版本开始引入的一个新的 IO API，可以替代标准的  Java IO API，NIO 支持面向缓冲区的、基于通道的 IO 操作，以更加高效的方式进行文件的读写操作。</p><ul><li>NIO 有三大核心部分：<strong>Channel( 通道) ，Buffer( 缓冲区)，Selector( 选择器)</strong></li><li>NIO 是非阻塞IO，传统 IO 的 read 和 write 只能阻塞执行，线程在读写 IO 期间不能干其他事情，比如调用 socket.accept()，如果服务器没有数据传输过来，线程就一直阻塞，而 NIO 中可以配置 Socket 为非阻塞模式</li><li>NIO 可以做到用一个线程来处理多个操作的。假设有 1000 个请求过来，根据实际情况可以分配20 或者 80个线程来处理，不像之前的阻塞 IO 那样分配 1000 个</li></ul><p>NIO 和 BIO 的比较：</p><ul><li><p>BIO 以流的方式处理数据，而 NIO 以块的方式处理数据，块 I/O 的效率比流 I/O 高很多</p></li><li><p>BIO 是阻塞的，NIO 则是非阻塞的</p></li><li><p>BIO 基于字节流和字符流进行操作，而 NIO 基于 Channel 和 Buffer 进行操作，数据从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector 用于监听多个通道的事件（比如：连接请求，数据到达等），因此使用单个线程就可以监听多个客户端通道</p><table><thead><tr><th>NIO</th><th>BIO</th></tr></thead><tbody><tr><td>面向缓冲区（Buffer）</td><td>面向流（Stream）</td></tr><tr><td>非阻塞（Non Blocking IO）</td><td>阻塞IO(Blocking IO)</td></tr><tr><td>选择器（Selectors）</td><td></td></tr></tbody></table></li></ul><hr><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>NIO 三大核心部分：Channel( 通道) ，Buffer( 缓冲区), Selector( 选择器)</p><ul><li><p>Buffer 缓冲区</p><p>缓冲区本质是一块可以写入数据、读取数据的内存，<strong>底层是一个数组</strong>，这块内存被包装成NIO Buffer对象，并且提供了方法用来操作这块内存，相比较直接对数组的操作，Buffer 的 API 更加容易操作和管理</p></li><li><p>Channel 通道</p><p>Java NIO 的通道类似流，不同的是既可以从通道中读取数据，又可以写数据到通道，流的读写通常是单向的，通道可以非阻塞读取和写入通道，支持读取或写入缓冲区，也支持异步地读写。</p></li><li><p>Selector 选择器</p><p>Selector 是一个 Java NIO 组件，能够检查一个或多个 NIO 通道，并确定哪些通道已经准备好进行读取或写入，这样一个单独的线程可以管理多个channel，从而管理多个网络连接，提高效率</p></li></ul><p>NIO 的实现框架：</p><p><img src="https://gitee.com/seazean/images/raw/master/Java/NIO%E6%A1%86%E6%9E%B6.png"></p><ul><li>每个 Channel 对应一个 Buffer</li><li>一个线程对应 Selector ， 一个 Selector 对应多个 Channel（连接）</li><li>程序切换到哪个 Channel 是由事件决定的，Event 是一个重要的概念</li><li>Selector 会根据不同的事件，在各个通道上切换</li><li>Buffer 是一个内存块 ， 底层是一个数组</li><li>数据的读取写入是通过 Buffer 完成的 , BIO 中要么是输入流，或者是输出流，不能双向，NIO 的 Buffer 是可以读也可以写， flip() 切换 Buffer 的工作模式</li></ul><p>Java NIO 系统的核心在于：通道和缓冲区，通道表示打开的 IO 设备（例如：文件、 套接字）的连接。若要使用 NIO 系统，获取用于连接 IO 设备的通道以及用于容纳数据的缓冲区，然后操作缓冲区，对数据进行处理。简而言之，Channel 负责传输， Buffer 负责存取数据</p><hr><h3 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h3><h4 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>缓冲区（Buffer）：缓冲区本质上是一个<strong>可以读写数据的内存块</strong>，用于特定基本数据类型的容器，用于与 NIO 通道进行交互，数据是从通道读入缓冲区，从缓冲区写入通道中的</p><p><img src="https://gitee.com/seazean/images/raw/master/Java/NIO-Buffer.png"></p><p><strong>Buffer 底层是一个数组</strong>，可以保存多个相同类型的数据，根据数据类型不同 ，有以下 Buffer 常用子类：ByteBuffer、CharBuffer、ShortBuffer、IntBuffer、LongBuffer、FloatBuffer、DoubleBuffer </p><hr><h4 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h4><ul><li><p>容量（capacity）：作为一个内存块，Buffer 具有固定大小，缓冲区容量不能为负，并且创建后不能更改</p></li><li><p>限制 （limit）：表示缓冲区中可以操作数据的大小（limit 后数据不能进行读写），缓冲区的限制不能为负，并且不能大于其容量。写入模式，limit 等于 buffer 的容量；读取模式下，limit 等于写入的数据量</p></li><li><p>位置（position）：<strong>下一个要读取或写入的数据的索引</strong>，缓冲区的位置不能为负，并且不能大于其限制</p></li><li><p>标记（mark）与重置（reset）：标记是一个索引，通过 Buffer 中的 mark() 方法指定 Buffer 中一个特定的位置，可以通过调用 reset() 方法恢复到这个 position</p></li><li><p>位置、限制、容量遵守以下不变式： <strong>0 &lt;= position &lt;= limit &lt;= capacity</strong></p><img src="https://gitee.com/seazean/images/raw/master/Java/NIO-Buffer操作.png" style="zoom:67%;"></li></ul><hr><h4 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h4><p><code>static XxxBuffer allocate(int capacity)</code>：创建一个容量为 capacity 的 XxxBuffer 对象</p><p>Buffer 基本操作：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public Buffer clear()</td><td>清空缓冲区，不清空内容，将位置设置为零，限制设置为容量</td></tr><tr><td>public Buffer flip()</td><td>翻转缓冲区，将缓冲区的界限设置为当前位置，position 置 0</td></tr><tr><td>public int capacity()</td><td>返回 Buffer的 capacity 大小</td></tr><tr><td>public final int limit()</td><td>返回 Buffer 的界限 limit 的位置</td></tr><tr><td>public Buffer limit(int n)</td><td>设置缓冲区界限为 n</td></tr><tr><td>public Buffer mark()</td><td>在此位置对缓冲区设置标记</td></tr><tr><td>public final int position()</td><td>返回缓冲区的当前位置 position</td></tr><tr><td>public Buffer position(int n)</td><td>设置缓冲区的当前位置为n</td></tr><tr><td>public Buffer reset()</td><td>将位置 position 重置为先前 mark 标记的位置</td></tr><tr><td>public Buffer rewind()</td><td>将位置设为为0，取消设置的 mark</td></tr><tr><td>public final int remaining()</td><td>返回当前位置 position 和 limit 之间的元素个数</td></tr><tr><td>public final boolean hasRemaining()</td><td>判断缓冲区中是否还有元素</td></tr><tr><td>public static ByteBuffer wrap(byte[] array)</td><td>将一个字节数组包装到缓冲区中</td></tr><tr><td>abstract ByteBuffer asReadOnlyBuffer()</td><td>创建一个新的只读字节缓冲区</td></tr></tbody></table><p>Buffer 数据操作：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public abstract byte get()</td><td>读取该缓冲区当前位置的单个字节，然后增加位置</td></tr><tr><td>public ByteBuffer get(byte[] dst)</td><td>读取多个字节到字节数组dst中</td></tr><tr><td>public abstract byte get(int index)</td><td>读取指定索引位置的字节，不移动 position</td></tr><tr><td>public abstract ByteBuffer put(byte b)</td><td>将给定单个字节写入缓冲区的当前位置，position+1</td></tr><tr><td>public final ByteBuffer put(byte[] src)</td><td>将 src 字节数组写入缓冲区的当前位置</td></tr><tr><td>public abstract ByteBuffer put(int index, byte b)</td><td>将指定字节写入缓冲区的索引位置，不移动 position</td></tr></tbody></table><p>提示：”\n”，占用两个字节</p><hr><h4 id="读写数据"><a href="#读写数据" class="headerlink" title="读写数据"></a>读写数据</h4><p>使用 Buffer 读写数据一般遵循以下四个步骤：</p><ul><li>写入数据到 Buffer</li><li>调用 flip()方法，转换为读取模式</li><li>从 Buffer 中读取数据</li><li>调用 buffer.clear() 方法清除缓冲区（不是清空了数据，只是重置指针）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBuffer</span> </span>&#123;<span class="meta">@Test</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;String str = <span class="string">&quot;seazean&quot;</span>;<span class="comment">//1. 分配一个指定大小的缓冲区ByteBuffer buffer = ByteBuffer.allocate(1024);System.out.println(&quot;-----------------allocate()----------------&quot;);System.out.println(bufferf.position());//0System.out.println(buffer.limit());//1024System.out.println(buffer.capacity());//1024                //2. 利用 put() 存入数据到缓冲区中      buffer.put(str.getBytes());     System.out.println(&quot;-----------------put()----------------&quot;);System.out.println(bufferf.position());//7System.out.println(buffer.limit());//1024System.out.println(buffer.capacity());//1024                //3. 切换读取数据模式        buffer.flip();        System.out.println(&quot;-----------------flip()----------------&quot;);        System.out.println(buffer.position());//0        System.out.println(buffer.limit());//7        System.out.println(buffer.capacity());//1024                //4. 利用 get() 读取缓冲区中的数据        byte[] dst = new byte[buffer.limit()];        buffer.get(dst);        System.out.println(dst.length);        System.out.println(new String(dst, 0, dst.length));        System.out.println(buffer.position());//7        System.out.println(buffer.limit());//7               //5. clear() : 清空缓冲区. 但是缓冲区中的数据依然存在，但是处于“被遗忘”状态        System.out.println(buffer.hasRemaining());//true        buffer.clear();        System.out.println(buffer.hasRemaining());//true      System.out.println(&quot;-----------------clear()----------------&quot;);      System.out.println(buffer.position());//0      System.out.println(buffer.limit());//1024      System.out.println(buffer.capacity());//1024    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><h4 id="基本介绍-4"><a href="#基本介绍-4" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>Byte Buffer 有两种类型，一种是基于直接内存（也就是非堆内存），另一种是非直接内存（也就是堆内存）</p><p>Direct Memory 优点：</p><ul><li>Java 的 NIO 库允许 Java 程序使用直接内存，用于数据缓冲区，使用 native 函数直接分配堆外内存</li><li><strong>读写性能高</strong>，读写频繁的场合可能会考虑使用直接内存</li><li>大大提高 IO 性能，避免了在 Java 堆和 native 堆来回复制数据</li></ul><p>直接内存缺点：</p><ul><li>分配回收成本较高，不受 JVM 内存回收管理</li><li>可能导致 OutOfMemoryError 异常：OutOfMemoryError: Direct buffer memory</li><li>回收依赖 System.gc() 的调用，但这个调用 JVM 不保证执行、也不保证何时执行，行为是不可控的。程序一般需要自行管理，成对去调用 malloc、free</li></ul><p>应用场景：</p><ul><li>有很大的数据需要存储，数据的生命周期很长</li><li>适合频繁的 IO 操作，比如网络并发场景</li></ul><p>数据流的角度：</p><ul><li>非直接内存的作用链：本地IO → 内核缓冲区→ 用户（JVM）缓冲区 →内核缓冲区 → 本地IO</li><li>直接内存是：本地IO → 直接内存 → 本地IO</li></ul><p>JVM 直接内存图解：</p><img src="https://gitee.com/seazean/images/raw/master/Java/JVM-直接内存直接缓冲区.png" style="zoom: 50%;"><img src="https://gitee.com/seazean/images/raw/master/Java/JVM-直接内存非直接缓冲区.png" style="zoom:50%;"><hr><h4 id="通信原理"><a href="#通信原理" class="headerlink" title="通信原理"></a>通信原理</h4><p>堆外内存不受 JVM GC 控制，可以使用堆外内存进行通信，防止 GC 后缓冲区位置发生变化的情况</p><p>NIO 使用的 SocketChannel 也是使用的堆外内存，源码解析：</p><ul><li><p>SocketChannel#write(java.nio.ByteBuffer) → SocketChannelImpl#write(java.nio.ByteBuffer)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">write</span><span class="params">(ByteBuffer var1)</span> <span class="keyword">throws</span> IOException </span>&#123;     <span class="keyword">do</span> &#123;         var3 = IOUtil.write(<span class="keyword">this</span>.fd, var1, -<span class="number">1L</span>, nd);     &#125; <span class="keyword">while</span>(var3 == -<span class="number">3</span> &amp;&amp; <span class="keyword">this</span>.isOpen());&#125;</span><br></pre></td></tr></table></figure></li><li><p>IOUtil#write(java.io.FileDescriptor, java.nio.ByteBuffer, long, sun.nio.ch.NativeDispatcher)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">write</span><span class="params">(FileDescriptor var0, ByteBuffer var1, <span class="keyword">long</span> var2, NativeDispatcher var4)</span> </span>&#123;    <span class="comment">// 【判断是否是直接内存，是则直接写出，不是则封装到直接内存】    if (var1 instanceof DirectBuffer) &#123;        return writeFromNativeBuffer(var0, var1, var2, var4);    &#125; else &#123;        //....        // 从堆内buffer拷贝到堆外buffer        ByteBuffer var8 = Util.getTemporaryDirectBuffer(var7);        var8.put(var1);        //...        // 从堆外写到内核缓冲区int var9 = writeFromNativeBuffer(var0, var8, var2, var4);&#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>读操作相同</p></li></ul><hr><h4 id="分配回收"><a href="#分配回收" class="headerlink" title="分配回收"></a>分配回收</h4><p>直接内存创建 Buffer 对象：<code>static XxxBuffer allocateDirect(int capacity)</code></p><p>DirectByteBuffer 源码分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DirectByteBuffer(<span class="keyword">int</span> cap) &#123;     <span class="comment">//....    long base = 0;    try &#123;        // 分配直接内存        base = unsafe.allocateMemory(size);    &#125;    // 内存赋值    unsafe.setMemory(base, size, (byte) 0);    if (pa &amp;&amp; (base % ps != 0)) &#123;        address = base + ps - (base &amp; (ps - 1));    &#125; else &#123;        address = base;    &#125;    // 创建回收函数    cleaner = Cleaner.create(this, new Deallocator(base, size, cap));&#125;private static class Deallocator implements Runnable &#123;    public void run() &#123;        unsafe.freeMemory(address);//...    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p><strong>分配和回收原理</strong>：</p><ul><li>使用了 Unsafe 对象的 allocateMemory 方法完成直接内存的分配，setMemory 方法完成赋值</li><li>ByteBuffer 的实现类内部，使用了 Cleaner （虚引用）来监测 ByteBuffer 对象，一旦 ByteBuffer 对象被垃圾回收，那么 ReferenceHandler 线程通过 Cleaner 的 clean 方法调用 Deallocator 的 run方法，最后通过 freeMemory 来释放直接内存</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** * 直接内存分配的底层原理：Unsafe */</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1_27</span> </span>&#123;    <span class="keyword">static</span> <span class="keyword">int</span> _1Gb = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;        Unsafe unsafe = getUnsafe();        <span class="comment">// 分配内存        long base = unsafe.allocateMemory(_1Gb);        unsafe.setMemory(base, _1Gb, (byte) 0);        System.in.read();        // 释放内存        unsafe.freeMemory(base);        System.in.read();    &#125;    public static Unsafe getUnsafe() &#123;        try &#123;            Field f = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);            f.setAccessible(true);            Unsafe unsafe = (Unsafe) f.get(null);            return unsafe;        &#125; catch (NoSuchFieldException | IllegalAccessException e) &#123;            throw new RuntimeException(e);        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h4><p>FileChannel 提供 map 方法返回 MappedByteBuffer 对象，把文件映射到内存，通常情况可以映射整个文件，如果文件比较大，可以进行分段映射，完成映射后对物理内存的操作会被<strong>同步</strong>到硬盘上</p><p>FileChannel 中的成员属性：</p><ul><li><p>MapMode.mode：内存映像文件访问的方式，共三种：</p><ul><li><code>MapMode.READ_ONLY</code>：只读，试图修改得到的缓冲区将导致抛出异常。</li><li><code>MapMode.READ_WRITE</code>：读/写，对得到的缓冲区的更改最终将写入文件；但该更改对映射到同一文件的其他程序不一定是可见的</li><li><code>MapMode.PRIVATE</code>：私用，可读可写，但是修改的内容不会写入文件，只是 buffer 自身的改变，称之为写时复制</li></ul></li><li><p><code>public final FileLock lock()</code>：获取此文件通道的排他锁</p></li></ul><p>MappedByteBuffer，可以让文件在直接内存（堆外内存）中进行修改，这种方式叫做<strong>内存映射</strong>，可以直接调用系统底层的缓存，没有 JVM 和 OS 之间的复制操作，提高了传输效率，作用：</p><ul><li><strong>用在进程间的通信，能达到共享内存页的作用</strong>，但在高并发下要对文件内存进行加锁，防止出现读写内容混乱和不一致性，Java 提供了文件锁 FileLock，但在父/子进程中锁定后另一进程会一直等待，效率不高</li><li>读写那些太大而不能放进内存中的文件，分段映射</li></ul><p>MappedByteBuffer 较之 ByteBuffer新增的三个方法</p><ul><li><code>final MappedByteBuffer force()</code>：缓冲区是 READ_WRITE 模式下，对缓冲区内容的修改强行写入文件</li><li><code>final MappedByteBuffer load()</code>：将缓冲区的内容载入物理内存，并返回该缓冲区的引用</li><li><code>final boolean isLoaded()</code>：如果缓冲区的内容在物理内存中，则返回真，否则返回假</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MappedByteBufferTest</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;        <span class="comment">// 读写模式        RandomAccessFile ra = new RandomAccessFile(&quot;1.txt&quot;, &quot;rw&quot;);        //获取对应的通道        FileChannel channel = ra.getChannel();        /**         * 参数1FileChannel.MapMode.READ_WRITE 使用的读写模式         * 参数20: 文件映射时的起始位置         * 参数35: 是映射到内存的大小（不是索引位置），即将 1.txt 的多少个字节映射到内存         * 可以直接修改的范围就是 0-5         * 实际类型 DirectByteBuffer         */        MappedByteBuffer buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, 5);        buffer.put(0, (byte) &#x27;H&#x27;);        buffer.put(3, (byte) &#x27;9&#x27;);        buffer.put(5, (byte) &#x27;Y&#x27;);//IndexOutOfBoundsException        ra.close();        System.out.println(&quot;修改成功~~&quot;);    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>从硬盘上将文件读入内存，要经过文件系统进行数据拷贝，拷贝操作是由文件系统和硬件驱动实现。通过内存映射的方法访问硬盘上的文件，拷贝数据的效率要比 read 和 write 系统调用高：</p><ul><li>read() 是系统调用，首先将文件从硬盘拷贝到内核空间的一个缓冲区，再将这些数据拷贝到用户空间，实际上进行了两次数据拷贝</li><li>mmap() 也是系统调用，但没有进行数据拷贝，当缺页中断发生时，直接将文件从硬盘拷贝到共享内存，只进行了一次数据拷贝</li></ul><p>注意：mmap 的文件映射，在 Full GC 时才会进行释放，如果需要手动清除内存映射文件，可以反射调用 sun.misc.Cleaner 方法</p><p>参考文章：<a href="https://www.jianshu.com/p/f90866dcbffc">https://www.jianshu.com/p/f90866dcbffc</a></p><hr><h3 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h3><h4 id="基本介绍-5"><a href="#基本介绍-5" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>通道（Channel）：表示 IO 源与目标打开的连接，Channel 类似于传统的流，只不过 Channel 本身不能直接访问数据，Channel 只能与 Buffer <strong>进行交互</strong></p><ol><li><p>NIO 的通道类似于流，但有些区别如下：</p><ul><li>通道可以同时进行读写，而流只能读或者只能写</li><li>通道可以实现异步读写数据</li><li>通道可以从缓冲读数据，也可以写数据到缓冲</li></ul></li><li><p>BIO 中的 stream 是单向的，NIO中的 Channel 是双向的，可以读操作，也可以写操作</p></li><li><p>Channel 在 NIO 中是一个接口：<code>public interface Channel extends Closeable&#123;&#125;</code></p></li></ol><p>Channel 实现类：</p><ul><li>FileChannel：用于读取、写入、映射和操作文件的通道</li><li>DatagramChannel：通过 UDP 读写网络中的数据通道</li><li>SocketChannel：通过 TCP 读写网络中的数据</li><li>ServerSocketChannel：可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个SocketChannel。<br>提示：ServerSocketChanne 类似 ServerSocket , SocketChannel 类似 Socket</li></ul><hr><h4 id="常用API-1"><a href="#常用API-1" class="headerlink" title="常用API"></a>常用API</h4><p>获取 Channel 方式：</p><ul><li>对支持通道的对象调用 <code>getChannel()</code> 方法</li><li>通过通道的静态方法 <code>open()</code> 打开并返回指定通道</li><li>使用 Files 类的静态方法 <code>newByteChannel()</code> 获取字节通道</li></ul><p>Channel 基本操作：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public abstract int read(ByteBuffer dst)</td><td>从 Channel 中读取数据到 ByteBuffer，从 position 开始储存</td></tr><tr><td>public final long read(ByteBuffer[] dsts)</td><td>将Channel中的数据“分散”到ByteBuffer[]</td></tr><tr><td>public abstract int write(ByteBuffer src)</td><td>将 ByteBuffer 中的数据写入 Channel，从 position 开始写出</td></tr><tr><td>public final long write(ByteBuffer[] srcs)</td><td>将ByteBuffer[]到中的数据“聚集”到Channel</td></tr><tr><td>public abstract long position()</td><td>返回此通道的文件位置</td></tr><tr><td>FileChannel position(long newPosition)</td><td>设置此通道的文件位置</td></tr><tr><td>public abstract long size()</td><td>返回此通道的文件的当前大小</td></tr></tbody></table><p><strong>读写都是相对于内存来看，也就是缓冲区</strong></p><hr><h4 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelTest</span> </span>&#123;    <span class="meta">@Test</span><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123; <span class="comment">// 1、字节输出流通向目标文件        FileOutputStream fos = new FileOutputStream(&quot;data01.txt&quot;);        // 2、得到字节输出流对应的通道  【FileChannel】        FileChannel channel = fos.getChannel();        // 3、分配缓冲区        ByteBuffer buffer = ByteBuffer.allocate(1024);        buffer.put(&quot;hello,黑马Java程序员！&quot;.getBytes());        // 4、把缓冲区切换成写出模式        buffer.flip();        channel.write(buffer);        channel.close();        System.out.println(&quot;写数据到文件中！&quot;);    &#125;    @Test    public void read() throws Exception &#123;        // 1、定义一个文件字节输入流与源文件接通        FileInputStream fis = new FileInputStream(&quot;data01.txt&quot;);        // 2、需要得到文件字节输入流的文件通道        FileChannel channel = fis.getChannel();        // 3、定义一个缓冲区        ByteBuffer buffer = ByteBuffer.allocate(1024);        // 4、读取数据到缓冲区        channel.read(buffer);        buffer.flip();        // 5、读取出缓冲区中的数据并输出即可        String rs = new String(buffer.array(),0,buffer.remaining());        System.out.println(rs);    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="文件复制"><a href="#文件复制" class="headerlink" title="文件复制"></a>文件复制</h4><p>Channel 的方法：sendfile 实现零拷贝</p><ul><li><p><code>abstract long transferFrom(ReadableByteChannel src, long position, long count)</code>：从给定的可读字节通道将字节传输到该通道的文件中</p><ul><li>src：源通道</li><li>position：文件中要进行传输的位置，必须是非负的 </li><li>count：要传输的最大字节数，必须是非负的 </li></ul></li><li><p><code>abstract long transferTo(long position, long count, WritableByteChannel target)</code>：将该通道文件的字节传输到给定的可写字节通道。</p><ul><li>position：传输开始的文件中的位置; 必须是非负的 </li><li>count：要传输的最大字节数; 必须是非负的 </li><li>target：目标通道 </li></ul></li></ul><p>文件复制的两种方式：</p><ol><li>Buffer</li><li>使用上述两种方法</li></ol><p><img src="https://gitee.com/seazean/images/raw/master/Java/NIO-%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelTest</span> </span>&#123;    <span class="meta">@Test</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copy1</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;        File srcFile = <span class="keyword">new</span> File(<span class="string">&quot;C:\\壁纸.jpg&quot;</span>);        File destFile = <span class="keyword">new</span> File(<span class="string">&quot;C:\\Users\\壁纸new.jpg&quot;</span>);        <span class="comment">// 得到一个字节字节输入流        FileInputStream fis = new FileInputStream(srcFile);        // 得到一个字节输出流        FileOutputStream fos = new FileOutputStream(destFile);        // 得到的是文件通道        FileChannel isChannel = fis.getChannel();        FileChannel osChannel = fos.getChannel();        // 分配缓冲区        ByteBuffer buffer = ByteBuffer.allocate(1024);        while(true)&#123;            // 必须先清空缓冲然后再写入数据到缓冲区            buffer.clear();            // 开始读取一次数据            int flag = isChannel.read(buffer);            if(flag == -1)&#123;                break;            &#125;            // 已经读取了数据 ，把缓冲区的模式切换成可读模式            buffer.flip();            // 把数据写出到            osChannel.write(buffer);        &#125;        isChannel.close();        osChannel.close();        System.out.println(&quot;复制完成！&quot;);    &#125;    @Testpublic void copy02() throws Exception &#123;    // 1、字节输入管道    FileInputStream fis = new FileInputStream(&quot;data01.txt&quot;);    FileChannel isChannel = fis.getChannel();    // 2、字节输出流管道    FileOutputStream fos = new FileOutputStream(&quot;data03.txt&quot;);    FileChannel osChannel = fos.getChannel();    // 3、复制    osChannel.transferFrom(isChannel,isChannel.position(),isChannel.size());    isChannel.close();    osChannel.close();&#125;    @Testpublic void copy03() throws Exception &#123;    // 1、字节输入管道    FileInputStream fis = new FileInputStream(&quot;data01.txt&quot;);    FileChannel isChannel = fis.getChannel();    // 2、字节输出流管道    FileOutputStream fos = new FileOutputStream(&quot;data04.txt&quot;);    FileChannel osChannel = fos.getChannel();    // 3、复制    isChannel.transferTo(isChannel.position() , isChannel.size() , osChannel);    isChannel.close();    osChannel.close();&#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="分散聚集"><a href="#分散聚集" class="headerlink" title="分散聚集"></a>分散聚集</h4><p>分散读取（Scatter ）：是指把 Channel 通道的数据读入到多个缓冲区中去</p><p>聚集写入（Gathering ）：是指将多个 Buffer 中的数据聚集到 Channel</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelTest</span> </span>&#123;    <span class="meta">@Test</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;    <span class="comment">// 1、字节输入管道        FileInputStream is = new FileInputStream(&quot;data01.txt&quot;);        FileChannel isChannel = is.getChannel();        // 2、字节输出流管道        FileOutputStream fos = new FileOutputStream(&quot;data02.txt&quot;);        FileChannel osChannel = fos.getChannel();        // 3、定义多个缓冲区做数据分散        ByteBuffer buffer1 = ByteBuffer.allocate(4);        ByteBuffer buffer2 = ByteBuffer.allocate(1024);        ByteBuffer[] buffers = &#123;buffer1 , buffer2&#125;;        // 4、从通道中读取数据分散到各个缓冲区        isChannel.read(buffers);        // 5、从每个缓冲区中查询是否有数据读取到了        for(ByteBuffer buffer : buffers)&#123;            buffer.flip();// 切换到读数据模式            System.out.println(new String(buffer.array() , 0 , buffer.remaining()));        &#125;        // 6、聚集写入到通道        osChannel.write(buffers);        isChannel.close();        osChannel.close();        System.out.println(&quot;文件复制~~&quot;);    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><h4 id="基本介绍-6"><a href="#基本介绍-6" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>选择器（Selector） 是 SelectableChannle 对象的<strong>多路复用器</strong>，Selector 可以同时监控多个通道的状况，利用 Selector 可使一个单独的线程管理多个 Channel，<strong>Selector 是非阻塞 IO 的核心</strong>。</p><p><img src="https://gitee.com/seazean/images/raw/master/Java/NIO-Selector.png"></p><ul><li>Selector 能够检测多个注册的通道上是否有事件发生（多个 Channel 以事件的方式可以注册到同一个 Selector)，如果有事件发生，便获取事件然后针对每个事件进行相应的处理，就可以只用一个单线程去管理多个通道，也就是管理多个连接和请求</li><li>只有在连接/通道真正有读写事件发生时，才会进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程</li><li>避免了多线程之间的上下文切换导致的开销</li></ul><hr><h4 id="常用API-2"><a href="#常用API-2" class="headerlink" title="常用API"></a>常用API</h4><p>创建 Selector：<code>Selector selector = Selector.open();</code></p><p>向选择器注册通道：<code>SelectableChannel.register(Selector sel, int ops)</code></p><p>选择器对通道的监听事件，需要通过第二个参数 ops 指定。监听的事件类型用四个常量表示：</p><ul><li>读 : SelectionKey.OP_READ （1）</li><li>写 : SelectionKey.OP_WRITE （4）</li><li>连接 : SelectionKey.OP_CONNECT （8）</li><li>接收 : SelectionKey.OP_ACCEPT （16）</li><li>若不止监听一个事件，可以使用位或操作符连接：<code>int interest = SelectionKey.OP_READ | SelectionKey.OP_WRITE</code></li></ul><p><strong>Selector API</strong>：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public static Selector open()</td><td>打开选择器</td></tr><tr><td>public abstract void close()</td><td>关闭此选择器</td></tr><tr><td>public abstract int select()</td><td><strong>阻塞</strong>选择一组通道准备好进行 I/O 操作的键</td></tr><tr><td>public abstract int select(long timeout)</td><td><strong>阻塞</strong>等待 timeout 毫秒</td></tr><tr><td>public abstract int selectNow()</td><td>获取一下，<strong>不阻塞</strong>，立刻返回</td></tr><tr><td>public abstract Selector wakeup()</td><td>唤醒正在阻塞的 selector</td></tr><tr><td>public abstract Set<SelectionKey> selectedKeys()</SelectionKey></td><td>返回此选择器的选择键集</td></tr></tbody></table><p>SelectionKey API:</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public abstract void cancel()</td><td>取消该键的通道与其选择器的注册</td></tr><tr><td>public abstract SelectableChannel channel()</td><td>返回创建此键的通道，该方法在取消键之后仍将返回通道</td></tr><tr><td>public final boolean isAcceptable()</td><td>检测此密钥的通道是否已准备好接受新的套接字连接</td></tr><tr><td>public final boolean isConnectable()</td><td>检测此密钥的通道是否已完成或未完成其套接字连接操作</td></tr><tr><td>public final boolean isReadable()</td><td>检测此密钥的频道是否可以阅读</td></tr><tr><td>public final boolean isWritable()</td><td>检测此密钥的通道是否准备好进行写入</td></tr></tbody></table><p>基本步骤：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.获取通道ServerSocketChannel ssChannel = ServerSocketChannel.open();//2.切换非阻塞模式ssChannel.configureBlocking(false);//3.绑定连接ssChannel.bin(new InetSocketAddress(9999));//4.获取选择器Selector selector = Selector.open();//5.将通道注册到选择器上，并且指定“监听接收事件”ssChannel.register(selector, SelectionKey.OP_ACCEPT);</span></span><br></pre></td></tr></table></figure><hr><h3 id="NIO实现"><a href="#NIO实现" class="headerlink" title="NIO实现"></a>NIO实现</h3><h4 id="常用API-3"><a href="#常用API-3" class="headerlink" title="常用API"></a>常用API</h4><ul><li><p>SelectableChannel_API</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public final SelectableChannel configureBlocking(boolean block)</td><td>设置此通道的阻塞模式</td></tr><tr><td>public final SelectionKey register(Selector sel, int ops)</td><td>向给定的选择器注册此通道，并选择关注的的事件</td></tr></tbody></table></li><li><p>SocketChannel_API：</p><table><thead><tr><th align="left">方法</th><th>说明</th></tr></thead><tbody><tr><td align="left">public static SocketChannel open()</td><td>打开套接字通道</td></tr><tr><td align="left">public static SocketChannel open(SocketAddress remote)</td><td>打开套接字通道并连接到远程地址</td></tr><tr><td align="left">public abstract boolean connect(SocketAddress remote)</td><td>连接此通道的到远程地址</td></tr><tr><td align="left">public abstract SocketChannel bind(SocketAddress local)</td><td>将通道的套接字绑定到本地地址</td></tr><tr><td align="left">public abstract SocketAddress getLocalAddress()</td><td>返回套接字绑定的本地套接字地址</td></tr><tr><td align="left">public abstract SocketAddress getRemoteAddress()</td><td>返回套接字连接的远程套接字地址</td></tr></tbody></table></li><li><p>ServerSocketChannel_API：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public static ServerSocketChannel open()</td><td>打开服务器套接字通道</td></tr><tr><td>public final ServerSocketChannel bind(SocketAddress local)</td><td>将通道的套接字绑定到本地地址，并配置套接字以监听连接</td></tr><tr><td>public abstract SocketChannel accept()</td><td>接受与此通道套接字的连接，通过此方法返回的套接字通道将处于阻塞模式</td></tr></tbody></table><ul><li>如果 ServerSocketChannel 处于非阻塞模式，如果没有挂起连接，则此方法将立即返回 null</li><li>如果通道处于阻塞模式，如果没有挂起连接将无限期地阻塞，直到有新的连接或发生 I/O 错误</li></ul></li></ul><hr><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>服务端 ：</p><ol><li><p>获取通道，当客户端连接服务端时，服务端会通过 <code>ServerSocketChannel.accept</code> 得到 SocketChannel </p></li><li><p>切换非阻塞模式</p></li><li><p>绑定连接</p></li><li><p>获取选择器</p></li><li><p>将通道注册到选择器上，并且指定监听接收事件</p></li><li><p><strong>轮询式</strong>的获取选择器上已经准备就绪的事件</p></li></ol><p>客户端：</p><ol><li>获取通道：<code>SocketChannel sc = SocketChannel.open(new InetSocketAddress(HOST, PORT))</code></li><li>切换非阻塞模式</li><li>分配指定大小的缓冲区：<code>ByteBuffer buffer = ByteBuffer.allocate(1024)</code></li><li>发送数据给服务端</li></ol><p>37 行代码，如果判断条件改为 !=-1，需要客户端 shutdown 一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;        <span class="comment">// 1、获取通道        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();        // 2、切换为非阻塞模式        serverSocketChannel.configureBlocking(false);        // 3、绑定连接的端口        serverSocketChannel.bind(new InetSocketAddress(9999));        // 4、获取选择器Selector        Selector selector = Selector.open();        // 5、将通道都注册到选择器上去，并且开始指定监听接收事件        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);// 6、使用Selector选择器轮询已经就绪好的事件        while (selector.select() &gt; 0) &#123;            System.out.println(&quot;----开始新一轮的时间处理----&quot;);            // 7、获取选择器中的所有注册的通道中已经就绪好的事件            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();            Iterator&lt;SelectionKey&gt; it = selectionKeys.iterator();            // 8、开始遍历这些准备好的事件            while (it.hasNext()) &#123;                SelectionKey key = it.next();// 提取当前这个事件                // 9、判断这个事件具体是什么                if (key.isAcceptable()) &#123;                    // 10、直接获取当前接入的客户端通道                    SocketChannel socketChannel = serverSocketChannel.accept();                    // 11 、切换成非阻塞模式                    socketChannel.configureBlocking(false);                    // 12、将本客户端通道注册到选择器                    socketChannel.register(selector, SelectionKey.OP_READ);                &#125; else if (key.isReadable()) &#123;                    // 13、获取当前选择器上的读就绪事件                    SelectableChannel channel = key.channel();                    SocketChannel socketChannel = (SocketChannel) channel;                    // 14、读取数据                    ByteBuffer buffer = ByteBuffer.allocate(1024);                    int len;                    while ((len = socketChannel.read(buffer)) &gt; 0) &#123;                        buffer.flip();                        System.out.println(socketChannel.getRemoteAddress() + &quot;:&quot; + new String(buffer.array(), 0, len));                        buffer.clear();// 清除之前的数据                    &#125;                &#125;                // 删除当前的 selectionKey，防止重复操作                it.remove();            &#125;        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;        <span class="comment">// 1、获取通道        SocketChannel socketChannel = SocketChannel.open(new InetSocketAddress(&quot;127.0.0.1&quot;, 9999));        // 2、切换成非阻塞模式        socketChannel.configureBlocking(false);        // 3、分配指定缓冲区大小        ByteBuffer buffer = ByteBuffer.allocate(1024);        // 4、发送数据给服务端        Scanner sc = new Scanner(System.in);        while (true)&#123;            System.out.print(&quot;请说：&quot;);            String msg = sc.nextLine();            buffer.put((&quot;波妞：&quot; + msg).getBytes());            buffer.flip();            socketChannel.write(buffer);            buffer.clear();        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h2 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h2><p>Java AIO(NIO.2) ： AsynchronousI/O，异步非阻塞，采用了 Proactor 模式。服务器实现模式为一个有效请求一个线程，客户端的 I/O 请求都是由 OS 先完成了再通知服务器应用去启动线程进行处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AIO异步非阻塞，基于NIO的，可以称之为NIO2<span class="number">.0</span>  BIO                     NIO                                AIO        Socket                SocketChannel                    AsynchronousSocketChannelServerSocket          ServerSocketChannel       AsynchronousServerSocketChannel</span><br></pre></td></tr></table></figure><p>当进行读写操作时，调用 API 的 read 或 write 方法，这两种方法均为异步的，完成后会主动调用回调函数：</p><ul><li>对于读操作，当有流可读取时，操作系统会将可读的流传入 read 方法的缓冲区</li><li>对于写操作，当操作系统将 write 方法传递的流写入完毕时，操作系统主动通知应用程序</li></ul><p>在 JDK1.7 中，这部分内容被称作 NIO.2，主要在 Java.nio.channels 包下增加了下面四个异步通道：<br>AsynchronousSocketChannel、AsynchronousServerSocketChannel、AsynchronousFileChannel、AsynchronousDatagramChannel</p><hr>]]></content>
      
      
      <categories>
          
          <category> 计网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> TCP </tag>
            
            <tag> HTTP </tag>
            
            <tag> UDP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础笔记5-JUC</title>
      <link href="./2021/09/16/java/java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B05-JUC/"/>
      <url>./2021/09/16/java/java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B05-JUC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="assets\css\APlayer.min.css"><script src="assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>进程：程序是静止的，进程实体的运行过程就是进程，是系统进行<strong>资源分配的基本单位</strong></p><p>进程的特征：并发性、异步性、动态性、独立性、结构性</p><p><strong>线程</strong>：线程是属于进程的，是一个基本的 CPU 执行单元，是程序执行流的最小单元。线程是进程中的一个实体，是系统<strong>独立调度的基本单位</strong>，线程本身不拥有系统资源，只拥有一点在运行中必不可少的资源，但它可与同属一个进程的其他线程共享进程所拥有的全部资源</p><p>关系：一个进程可以包含多个线程，这就是多线程，比如看视频是进程，图画、声音、广告等就是多个线程</p><p>线程的作用：使多道程序更好的并发执行，提高资源利用率和系统吞吐量，增强操作系统的并发性能</p><p>并发并行：</p><ul><li>并行：在同一时刻，有多个指令在多个 CPU 上同时执行</li><li>并发：在同一时刻，有多个指令在单个 CPU 上交替执行</li></ul><p>同步异步：</p><ul><li>需要等待结果返回，才能继续运行就是同步</li><li>不需要等待结果返回，就能继续运行就是异步</li></ul><p>参考视频：<a href="https://www.bilibili.com/video/BV16J411h7Rd">https://www.bilibili.com/video/BV16J411h7Rd</a></p><p>笔记的整体结构依据视频编写，并随着学习的深入补充了很多知识</p><hr><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>线程进程对比：</p><ul><li><p>进程基本上相互独立的，而线程存在于进程内，是进程的一个子集</p></li><li><p>进程拥有共享的资源，如内存空间等，供其<strong>内部的线程共享</strong></p></li><li><p>进程间通信较为复杂</p><p>同一台计算机的进程通信称为 IPC（Inter-process communication）</p><ul><li>信号量：信号量是一个计数器，用于多进程对共享数据的访问，解决同步相关的问题并避免竞争条件</li><li>共享存储：多个进程可以访问同一块内存空间，需要使用信号量用来同步对共享存储的访问</li><li>管道通信：管道是用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件，pipe 文件<ul><li>匿名管道（Pipes）：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信，只支持<strong>半双工通信</strong></li><li>命名管道（Names Pipes）：以磁盘文件的方式存在，可以实现本机任意两个进程通信，遵循 FIFO</li></ul></li><li>消息队列：内核中存储消息的链表，由消息队列标识符标识，能在不同进程之间提供<strong>全双工通信</strong>，对比管道：<ul><li>匿名管道存在于内存中的文件；命名管道存在于实际的磁盘介质或者文件系统；消息队列存放在内核中，只有在内核重启（操作系统重启）或者显示地删除一个消息队列时，该消息队列才被真正删除</li><li>读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收</li></ul></li></ul><p>不同计算机之间的<strong>进程通信</strong>，需要通过网络，并遵守共同的协议，例如 HTTP</p><ul><li>套接字：与其它通信机制不同的是，它可用于不同机器间的互相通信</li></ul></li><li><p>线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量</p><p><strong>Java 中的通信机制</strong>：volatile、等待/通知机制、join 方式、InheritableThreadLocal、MappedByteBuffer</p></li><li><p>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低</p></li></ul><hr><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><h4 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h4><p>Thread 创建线程方式：创建线程类，匿名内部类方式</p><ul><li><strong>start() 方法底层其实是给 CPU 注册当前线程，并且触发 run() 方法执行</strong></li><li>线程的启动必须调用 start() 方法，如果线程直接调用 run() 方法，相当于变成了普通类的执行，此时主线程将只有执行该线程</li><li>建议线程先创建子线程，主线程的任务放在之后，否则主线程（main）永远是先执行完</li></ul><p>Thread 构造器：</p><ul><li><code>public Thread()</code></li><li><code>public Thread(String name)</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span></span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        Thread t = <span class="keyword">new</span> MyThread();        t.start();       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">100</span> ; i++ )&#123;            System.out.println(<span class="string">&quot;main线程&quot;</span> + i)        &#125;        <span class="comment">// main线程输出放在上面 就变成有先后顺序了，因为是 main 线程驱动的子线程运行    &#125;&#125;class MyThread extends Thread&#123;    @Override    public void run() &#123;        for(int i = 0 ; i &lt; 100 ; i++ )&#123;            System.out.println(&quot;子线程输出：&quot;+i)        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>继承 Thread 类的优缺点：</p><ul><li>优点：编码简单</li><li>缺点：线程类已经继承了 Thread 类无法继承其他类了，功能不能通过继承拓展（单继承的局限性）</li></ul><hr><h4 id="Runnable"><a href="#Runnable" class="headerlink" title="Runnable"></a>Runnable</h4><p>Runnable 创建线程方式：创建线程类，匿名内部类方式</p><p>Thread 的构造器：</p><ul><li><code>public Thread(Runnable target)</code></li><li><code>public Thread(Runnable target, String name)</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        Runnable target = <span class="keyword">new</span> MyRunnable();        Thread t1 = <span class="keyword">new</span> Thread(target,<span class="string">&quot;1号线程&quot;</span>);t1.start();        Thread t2 = <span class="keyword">new</span> Thread(target);<span class="comment">//Thread-0    &#125;&#125;public class MyRunnable implements Runnable&#123;    @Override    public void run() &#123;        for(int i = 0 ; i &lt; 10 ; i++ )&#123;            System.out.println(Thread.currentThread().getName() + &quot;-&gt;&quot; + i);        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p><strong>Thread 类本身也是实现了 Runnable 接口</strong>，Thread 类中持有 Runnable 的属性，执行线程 run 方法底层是调用 Runnable#run：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;    <span class="keyword">private</span> Runnable target;        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;        <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;          <span class="comment">// 底层调用的是 Runnable 的 run 方法            target.run();        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>Runnable 方式的优缺点：</p><ul><li><p>缺点：代码复杂一点。</p></li><li><p>优点：</p><ol><li><p>线程任务类只是实现了 Runnable 接口，可以继续继承其他类，避免了单继承的局限性</p></li><li><p>同一个线程任务对象可以被包装成多个线程对象</p></li><li><p>适合多个多个线程去共享同一个资源</p></li><li><p>实现解耦操作，线程任务代码可以被多个线程共享，线程任务代码和线程独立</p></li><li><p>线程池可以放入实现 Runnable 或 Callable 线程任务对象</p></li></ol></li></ul><p>​     </p><hr><h4 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h4><p>实现 Callable 接口：</p><ol><li>定义一个线程任务类实现 Callable 接口，申明线程执行的结果类型</li><li>重写线程任务类的 call 方法，这个方法可以直接返回执行的结果</li><li>创建一个 Callable 的线程任务对象</li><li>把 Callable 的线程任务对象<strong>包装成一个未来任务对象</strong></li><li>把未来任务对象包装成线程对象</li><li>调用线程的 start() 方法启动线程</li></ol><p><code>public FutureTask(Callable&lt;V&gt; callable)</code>：未来任务对象，在线程执行完后得到线程的执行结果</p><ul><li>FutureTask 就是 Runnable 对象，因为 <strong>Thread 类只能执行 Runnable 实例的任务对象</strong>，所以把 Callable 包装成未来任务对象</li><li>线程池部分详解了 FutureTask 的源码</li></ul><p><code>public V get()</code>：同步等待 task 执行完毕的结果，如果在线程中获取另一个线程执行结果，会阻塞等待，用于线程同步</p><ul><li>get() 线程会阻塞等待任务执行完成</li><li>run() 执行完后会把结果设置到 FutureTask  的一个成员变量，get() 线程可以获取到该变量的值</li></ul><p>优缺点：</p><ul><li>优点：同 Runnable，并且能得到线程执行的结果</li><li>缺点：编码复杂</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        Callable call = <span class="keyword">new</span> MyCallable();        FutureTask&lt;String&gt; task = <span class="keyword">new</span> FutureTask&lt;&gt;(call);        Thread t = <span class="keyword">new</span> Thread(task);        t.start();        <span class="keyword">try</span> &#123;            String s = task.get(); <span class="comment">// 获取call方法返回的结果（正常/异常结果）            System.out.println(s);        &#125;  catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;public class MyCallable implements Callable&lt;String&gt; &#123;    @Override//重写线程任务类方法    public String call() throws Exception &#123;        return Thread.currentThread().getName() + &quot;-&gt;&quot; + &quot;Hello World&quot;;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h3 id="运行原理"><a href="#运行原理" class="headerlink" title="运行原理"></a>运行原理</h3><p>JVM 中由堆、栈、方法区所组成</p><p>Java Virtual Machine Stacks（Java 虚拟机栈）：每个线程启动后，虚拟机就会为其分配一块栈内存</p><ul><li>每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存</li><li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</li></ul><p>线程上下文切换（Thread Context Switch）：一些原因导致 CPU 不再执行当前线程，转而执行另一个线程</p><ul><li>线程的 CPU 时间片用完</li><li>垃圾回收</li><li>有更高优先级的线程需要运行</li><li>线程自己调用了 sleep、yield、wait、join、park 等方法</li></ul><p>程序计数器（Program Counter Register）：记住下一条 JVM 指令的执行地址，是线程私有的</p><p>当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等</p><p>Java 创建的线程是内核级线程，<strong>线程的调度是在内核态运行的，而线程中的代码是在用户态运行</strong>，所以线程切换（状态改变）会导致用户与内核态转换，这是非常消耗性能</p><p>Java 中 main 方法启动的是一个进程也是一个主线程，main 方法里面的其他线程均为子线程，main 线程是这些线程的父线程</p><hr><h3 id="线程方法"><a href="#线程方法" class="headerlink" title="线程方法"></a>线程方法</h3><h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><p>Thread 类 API：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public void start()</td><td>启动一个新线程；Java虚拟机调用此线程的run方法</td></tr><tr><td>public void run()</td><td>线程启动后调用该方法</td></tr><tr><td>public void setName(String name)</td><td>给当前线程取名字</td></tr><tr><td>public void getName()</td><td>获取当前线程的名字<br>线程存在默认名称：子线程是Thread-索引，主线程是main</td></tr><tr><td>public static Thread currentThread()</td><td>获取当前线程对象，代码在哪个线程中执行</td></tr><tr><td>public static void sleep(long time)</td><td>让当前线程休眠多少毫秒再继续执行<br><strong>Thread.sleep(0)</strong> : 让操作系统立刻重新进行一次cpu竞争</td></tr><tr><td>public static native void yield()</td><td>提示线程调度器让出当前线程对CPU的使用</td></tr><tr><td>public final int getPriority()</td><td>返回此线程的优先级</td></tr><tr><td>public final void setPriority(int priority)</td><td>更改此线程的优先级，常用1 5 10</td></tr><tr><td>public void interrupt()</td><td>中断这个线程，异常处理机制</td></tr><tr><td>public static boolean interrupted()</td><td>判断当前线程是否被打断，清除打断标记</td></tr><tr><td>public boolean isInterrupted()</td><td>判断当前线程是否被打断，不清除打断标记</td></tr><tr><td>public final void join()</td><td>等待这个线程结束</td></tr><tr><td>public final void join(long millis)</td><td>等待这个线程死亡millis毫秒，0意味着永远等待</td></tr><tr><td>public final native boolean isAlive()</td><td>线程是否存活（还没有运行完毕）</td></tr><tr><td>public final void setDaemon(boolean on)</td><td>将此线程标记为守护线程或用户线程</td></tr></tbody></table><hr><h4 id="run-start"><a href="#run-start" class="headerlink" title="run start"></a>run start</h4><p>run：称为线程体，包含了要执行的这个线程的内容，方法运行结束，此线程随即终止。直接调用 run 是在主线程中执行了 run，没有启动新的线程，需要顺序执行</p><p>start：使用 start 是启动新的线程，此线程处于就绪（可运行）状态，通过新的线程间接执行 run 中的代码</p><p>说明：<strong>线程控制资源类</strong></p><p><strong>面试问题</strong>：run() 方法中的异常不能抛出，只能 try/catch</p><ul><li>因为父类中没有抛出任何异常，子类不能比父类抛出更多的异常</li><li><strong>异常不能跨线程传播回 main() 中</strong>，因此必须在本地进行处理</li></ul><hr><h4 id="sleep-yield"><a href="#sleep-yield" class="headerlink" title="sleep yield"></a>sleep yield</h4><p>sleep：</p><ul><li>调用 sleep 会让当前线程从 <code>Running</code> 进入 <code>Timed Waiting</code> 状态（阻塞）</li><li>sleep() 方法的过程中，线程不会释放对象锁</li><li>其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException</li><li>睡眠结束后的线程未必会立刻得到执行，需要抢占 CPU</li><li>建议用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性</li></ul><p>yield：</p><ul><li>调用 yield 会让提示线程调度器让出当前线程对 CPU 的使用</li><li>具体的实现依赖于操作系统的任务调度器</li><li><strong>会放弃 CPU 资源，锁资源不会释放</strong></li></ul><hr><h4 id="priority"><a href="#priority" class="headerlink" title="priority"></a>priority</h4><p>线程优先级会提示（hint）调度器优先调度该线程，但这仅仅是一个提示，调度器可以忽略它</p><p>如果 CPU 比较忙，那么优先级高的线程会获得更多的时间片，但 CPU 闲时，优先级几乎没作用</p><hr><h4 id="join"><a href="#join" class="headerlink" title="join"></a>join</h4><p>public final void join()：等待这个线程结束</p><p>原理：调用者轮询检查线程 alive 状态，t1.join() 等价于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;    <span class="comment">// 调用者线程进入 thread 的 waitSet 等待, 直到当前线程运行结束    while (isAlive()) &#123;        wait(0);    &#125;&#125;</span></span><br></pre></td></tr></table></figure><ul><li><p>join 方法是被 synchronized 修饰的，本质上是一个对象锁，其内部的 wait 方法调用也是释放锁的，但是<strong>释放的是当前的线程对象锁，而不是外面的锁</strong></p></li><li><p>当调用某个线程（t1）的 join 方法后，该线程（t1）抢占到 CPU 资源，就不再释放，直到线程执行完毕</p></li></ul><p>线程同步：</p><ul><li>join 实现线程同步，因为会阻塞等待另一个线程的结束，才能继续向下运行<ul><li>需要外部共享变量，不符合面向对象封装的思想</li><li>必须等待线程结束，不能配合线程池使用</li></ul></li><li>Future 实现（同步）：get() 方法阻塞等待执行结果<ul><li>main 线程接收结果</li><li>get 方法是让调用线程同步等待</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;    <span class="keyword">static</span> <span class="keyword">int</span> r = <span class="number">0</span>;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;        test1();    &#125;    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;            <span class="keyword">try</span> &#123;                Thread.sleep(<span class="number">1000</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            r = <span class="number">10</span>;        &#125;);        t1.start();        t1.join();<span class="comment">//不等待线程执行结束，输出的10        System.out.println(r);    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h4><h5 id="打断线程"><a href="#打断线程" class="headerlink" title="打断线程"></a>打断线程</h5><p><code>public void interrupt()</code>：打断这个线程，异常处理机制</p><p><code>public static boolean interrupted()</code>：判断当前线程是否被打断，打断返回 true，清除打断标记，连续调用两次一定返回 false</p><p><code>public boolean isInterrupted()</code>：判断当前线程是否被打断，不清除打断标记</p><p>打断的线程会发生上下文切换，操作系统会保存线程信息，抢占到 CPU 后会从中断的地方接着运行（打断不是停止）</p><ul><li><p>sleep、wait、join 方法都会让线程进入阻塞状态，打断进程<strong>会清空打断状态</strong>（false）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;    Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;        <span class="keyword">try</span> &#123;            Thread.sleep(<span class="number">1000</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;, <span class="string">&quot;t1&quot;</span>);    t1.start();    Thread.sleep(<span class="number">500</span>);    t1.interrupt();    System.out.println(<span class="string">&quot; 打断状态: &#123;&#125;&quot;</span> + t1.isInterrupted());<span class="comment">// 打断状态: &#123;&#125;false&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>打断正常运行的线程：不会清空打断状态（true）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;    Thread t2 = <span class="keyword">new</span> Thread(()-&gt;&#123;        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;            Thread current = Thread.currentThread();            <span class="keyword">boolean</span> interrupted = current.isInterrupted();            <span class="keyword">if</span>(interrupted) &#123;                System.out.println(<span class="string">&quot; 打断状态: &#123;&#125;&quot;</span> + interrupted);<span class="comment">//打断状态: &#123;&#125;true                break;            &#125;        &#125;    &#125;, &quot;t2&quot;);    t2.start();    Thread.sleep(500);    t2.interrupt();&#125;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="打断park"><a href="#打断park" class="headerlink" title="打断park"></a>打断park</h5><p>park 作用类似 sleep，打断 park 线程，不会清空打断状态（true）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;    Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;        System.out.println(<span class="string">&quot;park...&quot;</span>);        LockSupport.park();        System.out.println(<span class="string">&quot;unpark...&quot;</span>);        System.out.println(<span class="string">&quot;打断状态：&quot;</span> + Thread.currentThread().isInterrupted());<span class="comment">//打断状态：true    &#125;, &quot;t1&quot;);    t1.start();    Thread.sleep(2000);    t1.interrupt();&#125;</span></span><br></pre></td></tr></table></figure><p>如果打断标记已经是 true, 则 park 会失效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LockSupport.park();System.out.println(<span class="string">&quot;unpark...&quot;</span>);LockSupport.park();<span class="comment">//失效，不会阻塞System.out.println(&quot;unpark...&quot;);//和上一个unpark同时执行</span></span><br></pre></td></tr></table></figure><p>可以修改获取打断状态方法，使用 <code>Thread.interrupted()</code>，清除打断标记</p><p>LockSupport 类在 同步 → park-un 详解</p><hr><h5 id="终止模式"><a href="#终止模式" class="headerlink" title="终止模式"></a>终止模式</h5><p>终止模式之两阶段终止模式：Two Phase Termination</p><p>目标：在一个线程 T1 中如何优雅终止线程 T2？优雅指的是给 T2 一个后置处理器</p><p>错误思想：</p><ul><li>使用线程对象的 stop() 方法停止线程：stop 方法会真正杀死线程，如果这时线程锁住了共享资源，当它被杀死后就再也没有机会释放锁，其它线程将永远无法获取锁</li><li>使用 System.exit(int) 方法停止线程：目的仅是停止一个线程，但这种做法会让整个程序都停止</li></ul><p>两阶段终止模式图示：</p><img src="https://gitee.com/seazean/images/raw/master/Java/JUC-两阶段终止模式.png" style="zoom: 67%;"><p>打断线程可能在任何时间，所以需要考虑在任何时刻被打断的处理方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;        TwoPhaseTermination tpt = <span class="keyword">new</span> TwoPhaseTermination();        tpt.start();        Thread.sleep(<span class="number">3500</span>);        tpt.stop();    &#125;&#125;<span class="class"><span class="keyword">class</span> <span class="title">TwoPhaseTermination</span> </span>&#123;    <span class="keyword">private</span> Thread monitor;    <span class="comment">// 启动监控线程    public void start() &#123;        monitor = new Thread(new Runnable() &#123;            @Override            public void run() &#123;                while (true) &#123;                    Thread thread = Thread.currentThread();                    if (thread.isInterrupted()) &#123;                        System.out.println(&quot;后置处理&quot;);                        break;                    &#125;                    try &#123;                        Thread.sleep(1000);// 睡眠                        System.out.println(&quot;执行监控记录&quot;);// 在此被打断不会异常                    &#125; catch (InterruptedException e) &#123;// 在睡眠期间被打断，进入异常处理的逻辑                        e.printStackTrace();                        // 重新设置打断标记                        thread.interrupt();                    &#125;                &#125;            &#125;        &#125;);        monitor.start();    &#125;    // 停止监控线程    public void stop() &#123;        monitor.interrupt();    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="daemon"><a href="#daemon" class="headerlink" title="daemon"></a>daemon</h4><p><code>public final void setDaemon(boolean on)</code>：如果是 true ，将此线程标记为守护线程 </p><p>线程<strong>启动前</strong>调用此方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread t = <span class="keyword">new</span> Thread() &#123;    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;        System.out.println(<span class="string">&quot;running&quot;</span>);    &#125;&#125;;<span class="comment">// 设置该线程为守护线程t.setDaemon(true);t.start();</span></span><br></pre></td></tr></table></figure><p>用户线程：平常创建的普通线程</p><p>守护线程：服务于用户线程，只要其它非守护线程运行结束了，即使守护线程代码没有执行完，也会强制结束。守护进程是脱离于终端并且在后台运行的进程，脱离终端是为了避免在执行的过程中的信息在终端上显示</p><p>说明：当运行的线程都是守护线程，Java 虚拟机将退出，因为普通线程执行完后，JVM 是守护线程，不会继续运行下去</p><p>常见的守护线程：</p><ul><li>垃圾回收器线程就是一种守护线程</li><li>Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等待它们处理完当前请求</li></ul><hr><h4 id="不推荐"><a href="#不推荐" class="headerlink" title="不推荐"></a>不推荐</h4><p>不推荐使用的方法，这些方法已过时，容易破坏同步代码块，造成线程死锁：</p><table><thead><tr><th>方法</th><th>功能</th></tr></thead><tbody><tr><td>public final void stop()</td><td>停止线程运行</td></tr><tr><td>public final void suspend()</td><td><strong>挂起（暂停）线程运行</strong></td></tr><tr><td>public final void resume()</td><td>恢复线程运行</td></tr></tbody></table><p>所以 Java 中线程的状态是阻塞，很少使用挂起</p><hr><h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><p>进程的状态参考操作系统：创建态、就绪态、运行态、阻塞态、终止态</p><p>线程由生到死的完整过程（生命周期）：当线程被创建并启动以后，既不是一启动就进入了执行状态，也不是一直处于执行状态，在 API 中 <code>java.lang.Thread.State</code> 这个枚举中给出了六种线程状态：</p><table><thead><tr><th>线程状态</th><th>导致状态发生条件</th></tr></thead><tbody><tr><td>NEW（新建）</td><td>线程刚被创建，但是并未启动，还没调用 start 方法，只有线程对象，没有线程特征</td></tr><tr><td>Runnable（可运行）</td><td>线程可以在 Java 虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操作系统处理器，调用了 t.start() 方法：就绪（经典叫法）</td></tr><tr><td>Blocked（锁阻塞）</td><td>当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入 Blocked 状态；当该线程持有锁时，该线程将变成 Runnable 状态</td></tr><tr><td>Waiting（无限等待）</td><td>一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入 Waiting 状态，进入这个状态后不能自动唤醒，必须等待另一个线程调用 notify 或者 notifyAll 方法才能唤醒</td></tr><tr><td>Timed Waiting （计时等待）</td><td>有几个方法有超时参数，调用将进入 Timed Waiting 状态，这一状态将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有 Thread.sleep 、Object.wait</td></tr><tr><td>Teminated（被终止）</td><td>run 方法正常退出而死亡，或者因为没有捕获的异常终止了 run 方法而死亡</td></tr></tbody></table><p><img src="https://gitee.com/seazean/images/raw/master/Java/JUC-%E7%BA%BF%E7%A8%8B6%E7%A7%8D%E7%8A%B6%E6%80%81.png"></p><ul><li><p>NEW → RUNNABLE：当调用 t.start() 方法时，由 NEW → RUNNABLE</p></li><li><p>RUNNABLE &lt;–&gt; WAITING：</p><ul><li><p>调用 obj.wait() 方法时</p><p>调用 obj.notify()、obj.notifyAll()、t.interrupt()：</p><ul><li>竞争锁成功，t 线程从 WAITING → RUNNABLE</li><li>竞争锁失败，t 线程从 WAITING → BLOCKED</li></ul></li><li><p>当前线程调用 t.join() 方法，注意是当前线程在 t 线程对象的监视器上等待</p></li><li><p>当前线程调用 LockSupport.park() 方法</p></li></ul></li><li><p>RUNNABLE &lt;–&gt; TIMED_WAITING：调用 obj.wait(long n) 方法、当前线程调用 t.join(long n) 方法、当前线程调用 Thread.sleep(long n)</p></li><li><p>RUNNABLE &lt;–&gt; BLOCKED：t 线程用 synchronized(obj) 获取了对象锁时竞争失败</p></li></ul><hr><h3 id="查看线程"><a href="#查看线程" class="headerlink" title="查看线程"></a>查看线程</h3><p>windows：</p><ul><li>任务管理器可以查看进程和线程数，也可以用来杀死进程</li><li>tasklist 查看进程</li><li>taskkill 杀死进程</li></ul><p>linux：</p><ul><li>ps -ef 查看所有进程</li><li>ps -fT -p <PID> 查看某个进程（PID）的所有线程</PID></li><li>kill 杀死进程</li><li>top 按大写 H 切换是否显示线程</li><li>top -H -p <PID> 查看某个进程（PID）的所有线程</PID></li></ul><p>Java：</p><ul><li>jps 命令查看所有 Java 进程</li><li>jstack <PID> 查看某个 Java 进程（PID）的所有线程状态</PID></li><li>jconsole 来查看某个 Java 进程中线程的运行情况（图形界面）</li></ul><hr><h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><p>临界资源：一次仅允许一个进程使用的资源成为临界资源</p><p>临界区：访问临界资源的代码块</p><p>竞态条件：多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了竞态条件</p><p>一个程序运行多个线程本身是没有问题的，多个线程访问共享资源会出现问题。多个线程读共享资源也没有问题，在多个线程对共享资源读写操作时发生指令交错，就会出现问题</p><p>为了避免临界区的竞态条件发生（解决线程安全问题）：</p><ul><li>阻塞式的解决方案：synchronized，lock</li><li>非阻塞式的解决方案：原子变量</li></ul><p>管程（monitor）：由局部于自己的若干公共变量和所有访问这些公共变量的过程所组成的软件模块，保证同一时刻只有一个进程在管程内活动，即管程内定义的操作在同一时刻只被一个进程调用（由编译器实现）</p><p><strong>synchronized：对象锁，保证了临界区内代码的原子性</strong>，采用互斥的方式让同一时刻至多只有一个线程能持有对象锁，其它线程获取这个对象锁时会阻塞，保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换</p><p>互斥和同步都可以采用 synchronized 关键字来完成，区别：</p><ul><li>互斥是保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区代码</li><li>同步是由于线程执行的先后、顺序不同、需要一个线程等待其它线程运行到某个点</li></ul><p>性能：</p><ul><li>线程安全，性能差</li><li>线程不安全性能好，假如开发中不会存在多线程安全问题，建议使用线程不安全的设计类</li></ul><hr><h3 id="syn-ed"><a href="#syn-ed" class="headerlink" title="syn-ed"></a>syn-ed</h3><h4 id="使用锁"><a href="#使用锁" class="headerlink" title="使用锁"></a>使用锁</h4><h5 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h5><p>锁对象：理论上可以是<strong>任意的唯一对象</strong></p><p>synchronized 是可重入、不公平的重量级锁</p><p>原则上：</p><ul><li>锁对象建议使用共享资源</li><li>在实例方法中使用 this 作为锁对象，锁住的 this 正好是共享资源</li><li>在静态方法中使用类名 .class 字节码作为锁对象，因为静态成员属于类，被所有实例对象共享，所以需要锁住类</li></ul><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(锁对象)&#123;<span class="comment">// 访问共享资源的核心代码&#125;</span></span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo</span> </span>&#123;    <span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;    <span class="comment">//static修饰，则元素是属于类本身的，不属于对象  ，与类一起加载一次，只有一个    static final Object room = new Object();    public static void main(String[] args) throws InterruptedException &#123;        Thread t1 = new Thread(() -&gt; &#123;            for (int i = 0; i &lt; 5000; i++) &#123;                synchronized (room) &#123;                    counter++;                &#125;            &#125;        &#125;, &quot;t1&quot;);        Thread t2 = new Thread(() -&gt; &#123;            for (int i = 0; i &lt; 5000; i++) &#123;                synchronized (room) &#123;                    counter--;                &#125;            &#125;        &#125;, &quot;t2&quot;);        t1.start();        t2.start();        t1.join();        t2.join();        System.out.println(counter);    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h5 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h5><p>把出现线程安全问题的核心方法锁起来，每次只能一个线程进入访问</p><p>synchronized 修饰的方法的不具备继承性，所以子类是线程不安全的，如果子类的方法也被 synchronized 修饰，两个锁对象其实是一把锁，而且是<strong>子类对象作为锁</strong></p><p>用法：直接给方法加上一个修饰符 synchronized</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同步方法修饰符 synchronized 返回值类型 方法名(方法参数) &#123; 方法体；&#125;//同步静态方法修饰符 static synchronized 返回值类型 方法名(方法参数) &#123; 方法体；&#125;</span></span><br></pre></td></tr></table></figure><p>同步方法底层也是有锁对象的：</p><ul><li><p>如果方法是实例方法：同步方法默认用 this 作为的锁对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">//等价于public void test() &#123;    synchronized(this) &#123;&#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>如果方法是静态方法：同步方法默认用类名 .class 作为的锁对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;&#125;&#125;<span class="comment">//等价于class Test&#123;    public void test() &#123;        synchronized(Test.class) &#123;&#125;&#125;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><p>面向对象实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;        Room room = <span class="keyword">new</span> Room();        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5000</span>; j++) &#123;                room.increment();            &#125;        &#125;, <span class="string">&quot;t1&quot;</span>);        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5000</span>; j++) &#123;                room.decrement();            &#125;        &#125;, <span class="string">&quot;t2&quot;</span>);        t1.start();        t2.start();        t1.join();        t2.join();        System.out.println(room.get());    &#125;&#125;<span class="class"><span class="keyword">class</span> <span class="title">Room</span> </span>&#123;    <span class="keyword">int</span> value = <span class="number">0</span>;    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;        value++;    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> </span>&#123;        value--;    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> value;    &#125;&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="线程八锁"><a href="#线程八锁" class="headerlink" title="线程八锁"></a>线程八锁</h5><p>线程八锁就是考察 synchronized 锁住的是哪个对象，直接百度搜索相关的实例</p><p>说明：主要关注锁住的对象是不是同一个</p><ul><li>锁住类对象，所有类的实例的方法都是安全的，类的所有实例都相当于同一把锁</li><li>锁住 this 对象，只有在当前实例对象的线程内是安全的，如果有多个实例就不安全</li></ul><p>线程不安全：因为锁住的不是同一个对象，线程 1 调用 a 方法锁住的类对象，线程 2 调用 b 方法锁住的 n2 对象，不是同一个对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Number</span></span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;Thread.sleep(<span class="number">1000</span>);        System.out.println(<span class="string">&quot;1&quot;</span>);    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;        System.out.println(<span class="string">&quot;2&quot;</span>);    &#125;&#125;<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    Number n1 = <span class="keyword">new</span> Number();    Number n2 = <span class="keyword">new</span> Number();    <span class="keyword">new</span> Thread(()-&gt;&#123; n1.a(); &#125;).start();    <span class="keyword">new</span> Thread(()-&gt;&#123; n2.b(); &#125;).start();&#125;</span><br></pre></td></tr></table></figure><p>线程安全：因为 n1 调用 a() 方法，锁住的是类对象，n2 调用 b() 方法，锁住的也是类对象，所以线程安全</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Number</span></span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;Thread.sleep(<span class="number">1000</span>);        System.out.println(<span class="string">&quot;1&quot;</span>);    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;        System.out.println(<span class="string">&quot;2&quot;</span>);    &#125;&#125;<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    Number n1 = <span class="keyword">new</span> Number();    Number n2 = <span class="keyword">new</span> Number();    <span class="keyword">new</span> Thread(()-&gt;&#123; n1.a(); &#125;).start();    <span class="keyword">new</span> Thread(()-&gt;&#123; n2.b(); &#125;).start();&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="锁原理"><a href="#锁原理" class="headerlink" title="锁原理"></a>锁原理</h4><h5 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h5><p>Monitor 被翻译为监视器或管程</p><p>每个 Java 对象都可以关联一个 Monitor 对象，Monitor 也是 class，其<strong>实例存储在堆中</strong>，如果使用 synchronized 给对象上锁（重量级）之后，该对象头的 Mark Word 中就被设置指向 Monitor 对象的指针，这就是重量级锁</p><ul><li><p>Mark Word 结构：</p><p><img src="https://gitee.com/seazean/images/raw/master/Java/JUC-Monitor-MarkWord%E7%BB%93%E6%9E%8432%E4%BD%8D.png"></p></li><li><p>64位虚拟机 Mark Word：</p><p><img src="https://gitee.com/seazean/images/raw/master/Java/JUC-Monitor-MarkWord%E7%BB%93%E6%9E%8464%E4%BD%8D.png"></p></li></ul><p>工作流程：</p><ul><li>开始时 Monitor 中 Owner 为 null</li><li>当 Thread-2 执行 synchronized(obj) 就会将 Monitor 的所有者 Owner 置为 Thread-2，Monitor 中只能有一个 Owner，<strong>obj 对象的 Mark Word 指向 Monitor</strong>，把对象原有的 MarkWord 存入线程栈中的锁记录中（轻量级锁部分详解）<img src="https://gitee.com/seazean/images/raw/master/Java/JUC-Monitor工作原理1.png" style="zoom:67%;"></li><li>在 Thread-2 上锁的过程，Thread-3、Thread-4、Thread-5 也执行 synchronized(obj)，就会进入 EntryList BLOCKED（双向链表）</li><li>Thread-2 执行完同步代码块的内容，根据 obj 对象头中 Monitor 地址寻找，设置 Owner 为空，把线程栈的锁记录中的对象头的值设置到 MarkWord</li><li>唤醒 EntryList 中等待的线程来竞争锁，竞争是<strong>非公平的</strong>，如果这时有新的线程想要获取锁，可能直接就抢占到了，阻塞队列的线程就会继续阻塞</li><li>WaitSet 中的 Thread-0，是以前获得过锁，但条件不满足进入 WAITING 状态的线程（wait-notify 机制）</li></ul><p><img src="https://gitee.com/seazean/images/raw/master/Java/JUC-Monitor%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%862.png"></p><p>注意：</p><ul><li>synchronized 必须是进入同一个对象的 Monitor 才有上述的效果</li><li>不加 synchronized 的对象不会关联监视器，不遵从以上规则</li></ul><hr><h5 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h5><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    Object lock = <span class="keyword">new</span> Object();    <span class="keyword">synchronized</span> (lock) &#123;        System.out.println(<span class="string">&quot;ok&quot;</span>);    &#125;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: <span class="keyword">new</span>#<span class="number">2</span><span class="comment">// new Object3: dup4: invokespecial #1 // invokespecial &lt;init&gt;:()V，非虚方法7: astore_1 // lock引用 -&gt; lock8: aload_1// lock （synchronized开始）9: dup// 一份用来初始化，一份用来引用10: astore_2 // lock引用 -&gt; slot 211: monitorenter // 【将 lock对象 MarkWord 置为 Monitor 指针】12: getstatic #3// System.out15: ldc #4// &quot;ok&quot;17: invokevirtual #5 // invokevirtual println:(Ljava/lang/String;)V20: aload_2 // slot 2(lock引用)21: monitorexit // 【将 lock对象 MarkWord 重置, 唤醒 EntryList】22: goto 3025: astore_3 // any -&gt; slot 326: aload_2 // slot 2(lock引用)27: monitorexit // 【将 lock对象 MarkWord 重置, 唤醒 EntryList】28: aload_329: athrow30: returnException table:    from to target type      12 22 25 any      25 28 25 anyLineNumberTable: ...LocalVariableTable:    Start Length Slot Name Signature    0 31 0 args [Ljava/lang/String;    8 23 1 lock Ljava/lang/Object;</span></span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>通过异常 <strong>try-catch 机制</strong>，确保一定会被解锁</li><li>方法级别的 synchronized 不会在字节码指令中有所体现</li></ul><hr><h4 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h4><h5 id="升级过程"><a href="#升级过程" class="headerlink" title="升级过程"></a>升级过程</h5><p><strong>synchronized 是可重入、不公平的重量级锁</strong>，所以可以对其进行优化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁<span class="comment">// 随着竞争的增加，只能锁升级，不能降级</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/seazean/images/raw/master/Java/JUC-%E9%94%81%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B.png"></p><hr><h5 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h5><p>偏向锁的思想是偏向于让第一个获取锁对象的线程，这个线程之后重新获取该锁不再需要同步操作：</p><ul><li><p>当锁对象第一次被线程获得的时候进入偏向状态，标记为 101，同时使用 CAS 操作将线程 ID 记录到 Mark Word。如果 CAS 操作成功，这个线程以后进入这个锁相关的同步块，查看这个线程 ID 是自己的就表示没有竞争，就不需要再进行任何同步操作</p></li><li><p>当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时撤销偏向（Revoke Bias）后恢复到未锁定或轻量级锁状态</p></li></ul><img src="https://gitee.com/seazean/images/raw/master/Java/JUC-Monitor-MarkWord结构64位.png" style="zoom: 67%;"><p>一个对象创建时：</p><ul><li><p>如果开启了偏向锁（默认开启），那么对象创建后，markword 值为 0x05 即最后 3 位为 101，thread、epoch、age 都为 0</p></li><li><p>偏向锁是默认是延迟的，不会在程序启动时立即生效，如果想避免延迟，可以加 VM 参数 <code>-XX:BiasedLockingStartupDelay=0</code> 来禁用延迟</p><p>JDK 8 延迟 4s 开启偏向锁原因：在刚开始执行代码时，会有好多线程来抢锁，如果开偏向锁效率反而降低</p></li><li><p>如果禁用了偏向锁，那么对象创建后，markword 值为 0x01 即最后 3 位为 001，这时它的 hashcode、age 都为 0，<strong>第一次用到 hashcode 时才会赋值</strong>，添加 VM 参数 <code>-XX:-UseBiasedLocking</code> 禁用偏向锁</p></li></ul><p>撤销偏向锁的状态：</p><ul><li>调用对象的 hashCode：偏向锁的对象 MarkWord 中存储的是线程 id，调用 hashCode 导致偏向锁被撤销<ul><li>轻量级锁会在锁记录中记录 hashCode</li><li>重量级锁会在 Monitor 中记录 hashCode</li></ul></li><li>当有其它线程使用偏向锁对象时，会将偏向锁升级为轻量级锁</li><li>调用 wait/notify，需要申请 Monitor，进入 WaitSet</li></ul><p><strong>批量撤销</strong>：如果对象被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2，重偏向会重置对象的 Thread ID</p><ul><li><p>批量重偏向：当撤销偏向锁阈值超过 20 次后，JVM 会觉得是不是偏向错了，于是在给这些对象加锁时重新偏向至加锁线程</p></li><li><p>批量撤销：当撤销偏向锁阈值超过 40 次后，JVM 会觉得自己确实偏向错了，根本就不该偏向，于是整个类的所有对象都会变为不可偏向的，新建的对象也是不可偏向的</p></li></ul><hr><h5 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h5><p>一个对象有多个线程要加锁，但加锁的时间是错开的（没有竞争），可以使用轻量级锁来优化，轻量级锁对使用者是透明的（不可见）</p><p>可重入锁：线程可以进入任何一个它已经拥有的锁所同步着的代码块，可重入锁最大的作用是<strong>避免死锁</strong></p><p>轻量级锁在没有竞争时（锁重入时），每次重入仍然需要执行 CAS 操作，Java 6 才引入的偏向锁来优化</p><p>锁重入实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Object obj = <span class="keyword">new</span> Object();<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;    <span class="keyword">synchronized</span>( obj ) &#123;        <span class="comment">// 同步块 A        method2();    &#125;&#125;public static void method2() &#123;    synchronized( obj ) &#123;    // 同步块 B    &#125;&#125;</span></span><br></pre></td></tr></table></figure><ul><li><p>创建锁记录（Lock Record）对象，每个线程的<strong>栈帧</strong>都会包含一个锁记录的结构，存储锁定对象的 Mark Word</p><p><img src="https://gitee.com/seazean/images/raw/master/Java/JUC-%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E5%8E%9F%E7%90%861.png"></p></li><li><p>让锁记录中 Object reference 指向锁住的对象，并尝试用 CAS 替换 Object 的 Mark Word，将 Mark Word 的值存入锁记录</p></li><li><p>如果 CAS 替换成功，对象头中存储了锁记录地址和状态 00（轻量级锁） ，表示由该线程给对象加锁<br><img src="https://gitee.com/seazean/images/raw/master/Java/JUC-%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E5%8E%9F%E7%90%862.png"></p></li><li><p>如果 CAS 失败，有两种情况：</p><ul><li>如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入锁膨胀过程</li><li>如果是线程自己执行了 synchronized 锁重入，就添加一条 Lock Record 作为重入的计数</li></ul><p><img src="https://gitee.com/seazean/images/raw/master/Java/JUC-%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E5%8E%9F%E7%90%863.png"></p></li><li><p>当退出 synchronized 代码块（解锁时）</p><ul><li>如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减 1</li><li>如果锁记录的值不为 null，这时使用 CAS 将 Mark Word 的值恢复给对象头<ul><li>成功，则解锁成功</li><li>失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</li></ul></li></ul></li></ul><hr><h5 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h5><p>在尝试加轻量级锁的过程中，CAS 操作无法成功，可能是其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为<strong>重量级锁</strong></p><ul><li><p>当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁</p><p><img src="https://gitee.com/seazean/images/raw/master/Java/JUC-%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%E5%8E%9F%E7%90%861.png"></p></li><li><p>Thread-1 加轻量级锁失败，进入锁膨胀流程：为 Object 对象申请 Monitor 锁，让Object 对象头指向重量级锁地址，Monitor 的 Owner 置为 Thread-0，然后自己进入 Monitor 的 EntryList BLOCKED</p><p><img src="https://gitee.com/seazean/images/raw/master/Java/JUC-%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%E5%8E%9F%E7%90%862.png"></p></li><li><p>当 Thread-0 退出同步块解锁时，使用 CAS 将 Mark Word 的值恢复给对象头失败，这时进入重量级解锁流程，即按照 Monitor 地址找到 Monitor 对象，设置 Owner 为 null，唤醒 EntryList 中 BLOCKED 线程</p></li></ul><hr><h4 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h4><h5 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h5><p>重量级锁竞争时，尝试获取锁的线程不会立即阻塞，可以使用<strong>自旋</strong>（默认 10 次）来进行优化，采用循环的方式去尝试获取锁</p><p>注意：</p><ul><li>自旋占用 CPU 时间，单核 CPU 自旋就是浪费时间，因为同一时刻只能运行一个线程，多核 CPU 自旋才能发挥优势</li><li>自旋失败的线程会进入阻塞状态</li></ul><p>优点：不会进入阻塞状态，<strong>减少线程上下文切换的消耗</strong></p><p>缺点：当自旋的线程越来越多时，会不断的消耗 CPU 资源</p><p>自旋锁情况：</p><ul><li><p>自旋成功的情况：</p><pre><code>&lt;img src=&quot;https://gitee.com/seazean/images/raw/master/Java/JUC-自旋成功.png&quot; style=&quot;zoom: 80%;&quot; /&gt;</code></pre></li><li><p>自旋失败的情况：</p><img src="https://gitee.com/seazean/images/raw/master/Java/JUC-自旋失败.png" style="zoom:80%;"></li></ul><p>自旋锁说明：</p><ul><li>在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，比较智能</li><li>Java 7 之后不能控制是否开启自旋功能，由 JVM 控制</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//手写自旋锁public class SpinLock &#123;    // 泛型装的是Thread，原子引用线程    AtomicReference&lt;Thread&gt; atomicReference = new AtomicReference&lt;&gt;();    public void lock() &#123;        Thread thread = Thread.currentThread();        System.out.println(thread.getName() + &quot; come in&quot;);        //开始自旋，期望值为null，更新值是当前线程        while (!atomicReference.compareAndSet(null, thread)) &#123;            Thread.sleep(1000);            System.out.println(thread.getName() + &quot; 正在自旋&quot;);        &#125;        System.out.println(thread.getName() + &quot; 自旋成功&quot;);    &#125;    public void unlock() &#123;        Thread thread = Thread.currentThread();        //线程使用完锁把引用变为nullatomicReference.compareAndSet(thread, null);        System.out.println(thread.getName() + &quot; invoke unlock&quot;);    &#125;    public static void main(String[] args) throws InterruptedException &#123;        SpinLock lock = new SpinLock();        new Thread(() -&gt; &#123;            //占有锁            lock.lock();            Thread.sleep(10000);             //释放锁            lock.unlock();        &#125;,&quot;t1&quot;).start();        // 让main线程暂停1秒，使得t1线程，先执行        Thread.sleep(1000);        new Thread(() -&gt; &#123;            lock.lock();            lock.unlock();        &#125;,&quot;t2&quot;).start();    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h5 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h5><p>锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除，这是 JVM <strong>即时编译器的优化</strong></p><p>锁消除主要是通过<strong>逃逸分析</strong>来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除（同步消除：JVM 内存分配）</p><hr><h5 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h5><p>对相同对象多次加锁，导致线程发生多次重入，频繁的加锁操作就会导致性能损耗，可以使用锁粗化方式优化</p><p>如果虚拟机探测到一串的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部</p><ul><li><p>一些看起来没有加锁的代码，其实隐式的加了很多锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">concatString</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;    <span class="keyword">return</span> s1 + s2 + s3;&#125;</span><br></pre></td></tr></table></figure></li><li><p>String 是一个不可变的类，编译器会对 String 的拼接自动优化。在 JDK 1.5 之前，转化为StringBuffer对象的连续 append() 操作，每个append() 方法中都有一个同步块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">concatString</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;    StringBuffer sb = <span class="keyword">new</span> StringBuffer();    sb.append(s1);    sb.append(s2);    sb.append(s3);    <span class="keyword">return</span> sb.toString();&#125;</span><br></pre></td></tr></table></figure></li></ul><p>扩展到第一个 append() 操作之前直至最后一个 append() 操作之后，只需要加锁一次就可以</p><hr><h4 id="多把锁"><a href="#多把锁" class="headerlink" title="多把锁"></a>多把锁</h4><p>多把不相干的锁：一间大屋子有两个功能：睡觉、学习，互不相干。现在一人要学习，一人要睡觉，如果只用一间屋子（一个对象锁）的话，那么并发度很低</p><p>将锁的粒度细分：</p><ul><li>好处，是可以增强并发度</li><li>坏处，如果一个线程需要同时获得多把锁，就容易发生死锁 </li></ul><p>解决方法：准备多个对象锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    BigRoom bigRoom = <span class="keyword">new</span> BigRoom();    <span class="keyword">new</span> Thread(() -&gt; &#123; bigRoom.study(); &#125;).start();    <span class="keyword">new</span> Thread(() -&gt; &#123; bigRoom.sleep(); &#125;).start();&#125;<span class="class"><span class="keyword">class</span> <span class="title">BigRoom</span> </span>&#123;    <span class="keyword">private</span> <span class="keyword">final</span> Object studyRoom = <span class="keyword">new</span> Object();    <span class="keyword">private</span> <span class="keyword">final</span> Object sleepRoom = <span class="keyword">new</span> Object();    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;        <span class="keyword">synchronized</span> (sleepRoom) &#123;            System.out.println(<span class="string">&quot;sleeping 2 小时&quot;</span>);            Thread.sleep(<span class="number">2000</span>);        &#125;    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;        <span class="keyword">synchronized</span> (studyRoom) &#123;            System.out.println(<span class="string">&quot;study 1 小时&quot;</span>);            Thread.sleep(<span class="number">1000</span>);        &#125;    &#125;&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="活跃性"><a href="#活跃性" class="headerlink" title="活跃性"></a>活跃性</h4><h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><h6 id="形成"><a href="#形成" class="headerlink" title="形成"></a>形成</h6><p>死锁：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放，由于线程被无限期地阻塞，因此程序不可能正常终止</p><p>java 死锁产生的四个必要条件：</p><ol><li>互斥条件，即当资源被一个线程使用（占有）时，别的线程不能使用</li><li>不可剥夺条件，资源请求者不能强制从资源占有者手中夺取资源，资源只能由资源占有者主动释放</li><li>请求和保持条件，即当资源请求者在请求其他的资源的同时保持对原有资源的占有</li><li>循环等待条件，即存在一个等待循环队列：p1 要 p2 的资源，p2 要 p1 的资源，形成了一个等待环路</li></ol><p>四个条件都成立的时候，便形成死锁。死锁情况下打破上述任何一个条件，便可让死锁消失</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dead</span> </span>&#123;    <span class="keyword">public</span> <span class="keyword">static</span> Object resources1 = <span class="keyword">new</span> Object();    <span class="keyword">public</span> <span class="keyword">static</span> Object resources2 = <span class="keyword">new</span> Object();    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        <span class="keyword">new</span> Thread(() -&gt; &#123;            <span class="comment">// 线程1：占用资源1 ，请求资源2            synchronized(resources1)&#123;                System.out.println(&quot;线程1已经占用了资源1，开始请求资源2&quot;);                Thread.sleep(2000);//休息两秒，防止线程1直接运行完成。                //2秒内线程2肯定可以锁住资源2                synchronized (resources2)&#123;                    System.out.println(&quot;线程1已经占用了资源2&quot;);                &#125;        &#125;).start();        new Thread(() -&gt; &#123;            // 线程2：占用资源2 ，请求资源1            synchronized(resources2)&#123;                System.out.println(&quot;线程2已经占用了资源2，开始请求资源1&quot;);                Thread.sleep(2000);                synchronized (resources1)&#123;                    System.out.println(&quot;线程2已经占用了资源1&quot;);                &#125;            &#125;&#125;        &#125;).start();    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>面向对象写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> </span>&#123;    <span class="keyword">static</span> String lockA = <span class="string">&quot;lockA&quot;</span>;    <span class="keyword">static</span> String lockB = <span class="string">&quot;lockB&quot;</span>;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        <span class="keyword">new</span> Thread(<span class="keyword">new</span> HoldLockThread(lockA, lockB)).start();        <span class="keyword">new</span> Thread(<span class="keyword">new</span> HoldLockThread(lockB, lockA)).start();    &#125;&#125;<span class="class"><span class="keyword">class</span> <span class="title">HoldLockThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;    <span class="keyword">private</span> String lockA;    <span class="keyword">private</span> String lockB;    <span class="function"><span class="keyword">public</span> <span class="title">HoldLockThread</span><span class="params">(String lockA, String lockB)</span> </span>&#123;        <span class="keyword">this</span>.lockA = lockA;        <span class="keyword">this</span>.lockB = lockB;    &#125;    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;        <span class="keyword">synchronized</span> (lockA) &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 持有&quot;</span> + lockA + <span class="string">&quot;，尝试获得&quot;</span> + lockB);            <span class="keyword">try</span> &#123;                Thread.sleep(<span class="number">2000</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            <span class="keyword">synchronized</span> (lockB) &#123;                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 持有&quot;</span> + lockB + <span class="string">&quot;，尝试获得&quot;</span> + lockA);            &#125;        &#125;    &#125;&#125;</span><br></pre></td></tr></table></figure><hr><h6 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h6><p>定位死锁的方法：</p><ul><li><p>使用 jps 定位进程 id，再用 <code>jstack id</code> 定位死锁，找到死锁的线程去查看源码，解决优化</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Thread-1&quot;</span> <span class="comment">#12 prio=5 os_prio=0 tid=0x000000001eb69000 nid=0xd40 waiting formonitor entry [0x000000001f54f000]java.lang.Thread.State: BLOCKED (on object monitor)#省略    &quot;Thread-1&quot; #12 prio=5 os_prio=0 tid=0x000000001eb69000 nid=0xd40 waiting for monitor entry [0x000000001f54f000]java.lang.Thread.State: BLOCKED (on object monitor)#省略Found one Java-level deadlock:===================================================&quot;Thread-1&quot;:    waiting to lock monitor 0x000000000361d378 (object 0x000000076b5bf1c0, a java.lang.Object),    which is held by &quot;Thread-0&quot;&quot;Thread-0&quot;:    waiting to lock monitor 0x000000000361e768 (object 0x000000076b5bf1d0, a java.lang.Object),    which is held by &quot;Thread-1&quot;    Java stack information for the threads listed above:===================================================&quot;Thread-1&quot;:    at thread.TestDeadLock.lambda$main$1(TestDeadLock.java:28)    - waiting to lock &lt;0x000000076b5bf1c0&gt; (a java.lang.Object)    - locked &lt;0x000000076b5bf1d0&gt; (a java.lang.Object)    at thread.TestDeadLock$$Lambda$2/883049899.run(Unknown Source)    at java.lang.Thread.run(Thread.java:745)&quot;Thread-0&quot;:    at thread.TestDeadLock.lambda$main$0(TestDeadLock.java:15)    - waiting to lock &lt;0x000000076b5bf1d0&gt; (a java.lang.Object)    - locked &lt;0x000000076b5bf1c0&gt; (a java.lang.Object)    at thread.TestDeadLock$$Lambda$1/495053715</span></span><br></pre></td></tr></table></figure></li><li><p>linux 下可以通过 top 先定位到 CPU 占用高的 Java 进程，再利用 <code>top -Hp 进程id</code> 来定位是哪个线程，最后再用 jstack <pid>的输出来看各个线程栈</pid></p></li><li><p>避免死锁：避免死锁要注意加锁顺序</p></li><li><p>可以使用 jconsole 工具，在 <code>jdk\bin</code> 目录下</p></li></ul><hr><h5 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h5><p>活锁：指的是任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试—失败—尝试—失败的过程</p><p>两个线程互相改变对方的结束条件，最后谁也无法结束：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestLiveLock</span> </span>&#123;    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">10</span>;    <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        <span class="keyword">new</span> Thread(() -&gt; &#123;            <span class="comment">// 期望减到 0 退出循环            while (count &gt; 0) &#123;                Thread.sleep(200);                count--;                System.out.println(&quot;线程一count:&quot; + count);            &#125;        &#125;, &quot;t1&quot;).start();        new Thread(() -&gt; &#123;            // 期望超过 20 退出循环            while (count &lt; 20) &#123;                Thread.sleep(200);                count++;                System.out.println(&quot;线程二count:&quot;+ count);            &#125;        &#125;, &quot;t2&quot;).start();    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h5 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h5><p>饥饿：一个线程由于优先级太低，始终得不到 CPU 调度执行，也不能够结束</p><hr><h3 id="wait-ify"><a href="#wait-ify" class="headerlink" title="wait-ify"></a>wait-ify</h3><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>需要获取对象锁后才可以调用 <code>锁对象.wait()</code>，notify 随机唤醒一个线程，notifyAll 唤醒所有线程去竞争 CPU</p><p>Object 类 API：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span>:唤醒正在等待对象监视器的单个线程。<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span>:唤醒正在等待对象监视器的所有线程。<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span>:导致当前线程等待，直到另一个线程调用该对象的<span class="title">notify</span><span class="params">()</span>方法或 <span class="title">notifyAll</span><span class="params">()</span>方法。<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span>:有时限的等待, 到n毫秒后结束等待，或是被唤醒</span></span><br></pre></td></tr></table></figure><p>说明：<strong>wait 是挂起线程，需要唤醒的都是挂起操作</strong>，阻塞线程可以自己去争抢锁，挂起的线程需要唤醒后去争抢锁</p><p>对比 sleep()：</p><ul><li>原理不同：sleep() 方法是属于 Thread 类，是线程用来控制自身流程的，使此线程暂停执行一段时间而把执行机会让给其他线程；wait() 方法属于 Object 类，用于线程间通信</li><li>对锁的处理机制不同：调用 sleep() 方法的过程中，线程不会释放对象锁，当调用 wait() 方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池（不释放锁其他线程怎么抢占到锁执行唤醒操作），但是都会释放 CPU</li><li>使用区域不同：wait() 方法必须放在<strong>同步控制方法和同步代码块（先获取锁）</strong>中使用，sleep() 方法则可以放在任何地方使用</li></ul><p>底层原理：</p><ul><li>Owner 线程发现条件不满足，调用 wait 方法，即可进入 WaitSet 变为 WAITING 状态</li><li>BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片</li><li>BLOCKED 线程会在 Owner 线程释放锁时唤醒</li><li>WAITING 线程会在 Owner 线程调用 notify 或 notifyAll 时唤醒，唤醒后并不意味者立刻获得锁，<strong>需要进入 EntryList 重新竞争</strong></li></ul><p><img src="https://gitee.com/seazean/images/raw/master/Java/JUC-Monitor%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%862.png"></p><hr><h4 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h4><p>虚假唤醒：notify 只能随机唤醒一个 WaitSet 中的线程，这时如果有其它线程也在等待，那么就可能唤醒不了正确的线程</p><p>解决方法：采用 notifyAll</p><p>notifyAll 仅解决某个线程的唤醒问题，使用 if + wait 判断仅有一次机会，一旦条件不成立，无法重新判断</p><p>解决方法：用 while + wait，当条件不成立，再次 wait</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.demo&quot;)</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo</span> </span>&#123;    <span class="keyword">static</span> <span class="keyword">final</span> Object room = <span class="keyword">new</span> Object();    <span class="keyword">static</span> <span class="keyword">boolean</span> hasCigarette = <span class="keyword">false</span>;    <span class="comment">//有没有烟    static boolean hasTakeout = false;    public static void main(String[] args) throws InterruptedException &#123;        new Thread(() -&gt; &#123;            synchronized (room) &#123;                log.debug(&quot;有烟没？[&#123;&#125;]&quot;, hasCigarette);                while (!hasCigarette) &#123;//while防止虚假唤醒                    log.debug(&quot;没烟，先歇会！&quot;);                    try &#123;                        room.wait();                    &#125; catch (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                &#125;                log.debug(&quot;有烟没？[&#123;&#125;]&quot;, hasCigarette);                if (hasCigarette) &#123;                    log.debug(&quot;可以开始干活了&quot;);                &#125; else &#123;                    log.debug(&quot;没干成活...&quot;);                &#125;            &#125;        &#125;, &quot;小南&quot;).start();        new Thread(() -&gt; &#123;            synchronized (room) &#123;                Thread thread = Thread.currentThread();                log.debug(&quot;外卖送到没？[&#123;&#125;]&quot;, hasTakeout);                if (!hasTakeout) &#123;                    log.debug(&quot;没外卖，先歇会！&quot;);                    try &#123;                        room.wait();                    &#125; catch (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                &#125;                log.debug(&quot;外卖送到没？[&#123;&#125;]&quot;, hasTakeout);                if (hasTakeout) &#123;                    log.debug(&quot;可以开始干活了&quot;);                &#125; else &#123;                    log.debug(&quot;没干成活...&quot;);                &#125;            &#125;        &#125;, &quot;小女&quot;).start();        Thread.sleep(1000);        new Thread(() -&gt; &#123;        // 这里能不能加 synchronized (room)？            synchronized (room) &#123;                hasTakeout = true;//log.debug(&quot;烟到了噢！&quot;);                log.debug(&quot;外卖到了噢！&quot;);                room.notifyAll();            &#125;        &#125;, &quot;送外卖的&quot;).start();    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h3 id="park-un"><a href="#park-un" class="headerlink" title="park-un"></a>park-un</h3><p>LockSupport 是用来创建锁和其他同步类的<strong>线程原语</strong></p><p>LockSupport 类方法：</p><ul><li><code>LockSupport.park()</code>：暂停当前线程，挂起原语</li><li><code>LockSupport.unpark(暂停的线程对象)</code>：恢复某个线程的运行</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;        System.out.println(<span class="string">&quot;start...&quot;</span>);<span class="comment">//1Thread.sleep(1000);// Thread.sleep(3000)        // 先 park 再 unpark 和先 unpark 再 park 效果一样，都会直接恢复线程的运行        System.out.println(&quot;park...&quot;);//2        LockSupport.park();        System.out.println(&quot;resume...&quot;);//4    &#125;,&quot;t1&quot;);    t1.start();   Thread.sleep(2000);    System.out.println(&quot;unpark...&quot;);//3    LockSupport.unpark(t1);&#125;</span></span><br></pre></td></tr></table></figure><p>LockSupport 出现就是为了增强 wait &amp; notify 的功能：</p><ul><li>wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park、unpark 不需要</li><li>park &amp; unpark <strong>以线程为单位</strong>来阻塞和唤醒线程，而 notify 只能随机唤醒一个等待线程，notifyAll 是唤醒所有等待线程</li><li>park &amp; unpark 可以先 unpark，而 wait &amp; notify 不能先 notify。类比生产消费，先消费发现有产品就消费，没有就等待；先生产就直接产生商品，然后线程直接消费</li><li>wait 会释放锁资源进入等待队列，<strong>park 不会释放锁资源</strong>，只负责阻塞当前线程，会释放 CPU</li></ul><p>原理：类似生产者消费者</p><ul><li>先 park：<ol><li>当前线程调用 Unsafe.park() 方法</li><li>检查 _counter ，本情况为 0，这时获得 _mutex 互斥锁</li><li>线程进入 _cond 条件变量挂起</li><li>调用 Unsafe.unpark(Thread_0) 方法，设置 _counter 为 1</li><li>唤醒 _cond 条件变量中的 Thread_0，Thread_0 恢复运行，设置 _counter 为 0</li></ol></li></ul><p><img src="https://gitee.com/seazean/images/raw/master/Java/JUC-park%E5%8E%9F%E7%90%861.png"></p><ul><li><p>先 unpark：</p><ol><li>调用 Unsafe.unpark(Thread_0) 方法，设置 _counter 为 1</li><li>当前线程调用 Unsafe.park() 方法</li><li>检查 _counter ，本情况为 1，这时线程无需挂起，继续运行，设置 _counter 为 0</li></ol><p><img src="https://gitee.com/seazean/images/raw/master/Java/JUC-park%E5%8E%9F%E7%90%862.png"></p></li></ul><hr><h3 id="安全分析"><a href="#安全分析" class="headerlink" title="安全分析"></a>安全分析</h3><p>成员变量和静态变量：</p><ul><li>如果它们没有共享，则线程安全</li><li>如果它们被共享了，根据它们的状态是否能够改变，分两种情况：<ul><li>如果只有读操作，则线程安全</li><li>如果有读写操作，则这段代码是临界区，需要考虑线程安全问题</li></ul></li></ul><p>局部变量：</p><ul><li>局部变量是线程安全的</li><li>局部变量引用的对象不一定线程安全（逃逸分析）：<ul><li>如果该对象没有逃离方法的作用访问，它是线程安全的（每一个方法有一个栈帧）</li><li>如果该对象逃离方法的作用范围，需要考虑线程安全问题（暴露引用）</li></ul></li></ul><p>常见线程安全类：String、Integer、StringBuffer、Random、Vector、Hashtable、java.util.concurrent 包</p><ul><li><p>线程安全的是指，多个线程调用它们同一个实例的某个方法时，是线程安全的</p></li><li><p><strong>每个方法是原子的，但多个方法的组合不是原子的</strong>，只能保证调用的方法内部安全：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hashtable table = <span class="keyword">new</span> Hashtable();<span class="comment">// 线程1，线程2if( table.get(&quot;key&quot;) == null) &#123;table.put(&quot;key&quot;, value);&#125;</span></span><br></pre></td></tr></table></figure></li></ul><p>无状态类线程安全，就是没有成员变量的类</p><p>不可变类线程安全：String、Integer 等都是不可变类，<strong>内部的状态不可以改变</strong>，所以方法是线程安全</p><ul><li><p>replace 等方法底层是新建一个对象，复制过去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">// 线程不安全String S1 = &quot;...&quot;;// 线程安全final String S2 = &quot;...&quot;;// 线程安全Date D1 = new Date();// 线程不安全final Date D2 = new Date();// 线程不安全，final让D2引用的对象不能变，但对象的内容可以变</span></span><br></pre></td></tr></table></figure></li></ul><p>抽象方法如果有参数，被重写后行为不确定可能造成线程不安全，被称之为外星方法：<code>public abstract foo(Student s);</code></p><hr><h3 id="同步模式"><a href="#同步模式" class="headerlink" title="同步模式"></a>同步模式</h3><h4 id="保护性暂停"><a href="#保护性暂停" class="headerlink" title="保护性暂停"></a>保护性暂停</h4><h5 id="单任务版"><a href="#单任务版" class="headerlink" title="单任务版"></a>单任务版</h5><p>Guarded Suspension，用在一个线程等待另一个线程的执行结果</p><ul><li>有一个结果需要从一个线程传递到另一个线程，让它们关联同一个 GuardedObject</li><li>如果有结果不断从一个线程到另一个线程那么可以使用消息队列（见生产者/消费者）</li><li>JDK 中，join 的实现、Future 的实现，采用的就是此模式</li></ul><p><img src="https://gitee.com/seazean/images/raw/master/Java/JUC-%E4%BF%9D%E6%8A%A4%E6%80%A7%E6%9A%82%E5%81%9C.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    GuardedObject object = <span class="keyword">new</span> GuardedObjectV2();    <span class="keyword">new</span> Thread(() -&gt; &#123;        sleep(<span class="number">1</span>);        object.complete(Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>));    &#125;).start();        Object response = object.get(<span class="number">2500</span>);    <span class="keyword">if</span> (response != <span class="keyword">null</span>) &#123;        log.debug(<span class="string">&quot;get response: [&#123;&#125;] lines&quot;</span>, ((List&lt;String&gt;) response).size());    &#125; <span class="keyword">else</span> &#123;        log.debug(<span class="string">&quot;can&#x27;t get response&quot;</span>);    &#125;&#125;<span class="class"><span class="keyword">class</span> <span class="title">GuardedObject</span> </span>&#123;    <span class="keyword">private</span> Object response;    <span class="keyword">private</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();    <span class="comment">//获取结果    //timeout :最大等待时间    public Object get(long millis) &#123;        synchronized (lock) &#123;            // 1) 记录最初时间            long begin = System.currentTimeMillis();            // 2) 已经经历的时间            long timePassed = 0;            while (response == null) &#123;                // 4) 假设 millis 是 1000，结果在 400 时唤醒了，那么还有 600 要等                long waitTime = millis - timePassed;                log.debug(&quot;waitTime: &#123;&#125;&quot;, waitTime);                //经历时间超过最大等待时间退出循环                if (waitTime &lt;= 0) &#123;                    log.debug(&quot;break...&quot;);                    break;                &#125;                try &#123;                    lock.wait(waitTime);                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                // 3) 如果提前被唤醒，这时已经经历的时间假设为 400                timePassed = System.currentTimeMillis() - begin;                log.debug(&quot;timePassed: &#123;&#125;, object is null &#123;&#125;&quot;,                        timePassed, response == null);            &#125;            return response;        &#125;    &#125;    //产生结果    public void complete(Object response) &#123;        synchronized (lock) &#123;            // 条件满足，通知等待线程            this.response = response;            log.debug(&quot;notify...&quot;);            lock.notifyAll();        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><h5 id="多任务版"><a href="#多任务版" class="headerlink" title="多任务版"></a>多任务版</h5><p>多任务版保护性暂停：</p><p><img src="https://gitee.com/seazean/images/raw/master/Java/JUC-%E4%BF%9D%E6%8A%A4%E6%80%A7%E6%9A%82%E5%81%9C%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%89%88.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;        <span class="keyword">new</span> People().start();    &#125;    Thread.sleep(<span class="number">1000</span>);    <span class="keyword">for</span> (Integer id : Mailboxes.getIds()) &#123;        <span class="keyword">new</span> Postman(id, id + <span class="string">&quot;号快递到了&quot;</span>).start();    &#125;&#125;<span class="meta">@Slf4j(topic = &quot;c.People&quot;)</span><span class="class"><span class="keyword">class</span> <span class="title">People</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;        <span class="comment">// 收信        GuardedObject guardedObject = Mailboxes.createGuardedObject();        log.debug(&quot;开始收信i d:&#123;&#125;&quot;, guardedObject.getId());        Object mail = guardedObject.get(5000);        log.debug(&quot;收到信id:&#123;&#125;，内容:&#123;&#125;&quot;, guardedObject.getId(),mail);    &#125;&#125;class Postman extends Thread&#123;    private int id;    private String mail;    //构造方法    @Override    public void run() &#123;        GuardedObject guardedObject = Mailboxes.getGuardedObject(id);        log.debug(&quot;开始送信i d:&#123;&#125;，内容:&#123;&#125;&quot;, guardedObject.getId(),mail);        guardedObject.complete(mail);    &#125;&#125;class  Mailboxes &#123;    private static Map&lt;Integer, GuardedObject&gt; boxes = new Hashtable&lt;&gt;();    private static int id = 1;    //产生唯一的id    private static synchronized int generateId() &#123;        return id++;    &#125;    public static GuardedObject getGuardedObject(int id) &#123;        return boxes.remove(id);    &#125;    public static GuardedObject createGuardedObject() &#123;        GuardedObject go = new GuardedObject(generateId());        boxes.put(go.getId(), go);        return go;    &#125;    public static Set&lt;Integer&gt; getIds() &#123;        return boxes.keySet();    &#125;&#125;class GuardedObject &#123;    //标识，Guarded Object    private int id;//添加get set方法&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="顺序输出"><a href="#顺序输出" class="headerlink" title="顺序输出"></a>顺序输出</h4><p>顺序输出 2  1 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;    Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;            <span class="comment">//try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; &#125;            // 当没有许可时，当前线程暂停运行；有许可时，用掉这个许可，当前线程恢复运行            LockSupport.park();            System.out.println(&quot;1&quot;);        &#125;    &#125;);    Thread t2 = new Thread(() -&gt; &#123;        while (true) &#123;            System.out.println(&quot;2&quot;);            // 给线程 t1 发放『许可』（多次连续调用 unpark 只会发放一个『许可』）            LockSupport.unpark(t1);            try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; &#125;        &#125;    &#125;);    t1.start();    t2.start();&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="交替输出"><a href="#交替输出" class="headerlink" title="交替输出"></a>交替输出</h4><p>连续输出 5 次 abc</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">day2_14</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;        AwaitSignal awaitSignal = <span class="keyword">new</span> AwaitSignal(<span class="number">5</span>);        Condition a = awaitSignal.newCondition();        Condition b = awaitSignal.newCondition();        Condition c = awaitSignal.newCondition();        <span class="keyword">new</span> Thread(() -&gt; &#123;            awaitSignal.print(<span class="string">&quot;a&quot;</span>, a, b);        &#125;).start();        <span class="keyword">new</span> Thread(() -&gt; &#123;            awaitSignal.print(<span class="string">&quot;b&quot;</span>, b, c);        &#125;).start();        <span class="keyword">new</span> Thread(() -&gt; &#123;            awaitSignal.print(<span class="string">&quot;c&quot;</span>, c, a);        &#125;).start();        Thread.sleep(<span class="number">1000</span>);        awaitSignal.lock();        <span class="keyword">try</span> &#123;            a.signal();        &#125; <span class="keyword">finally</span> &#123;            awaitSignal.unlock();        &#125;    &#125;&#125;<span class="class"><span class="keyword">class</span> <span class="title">AwaitSignal</span> <span class="keyword">extends</span> <span class="title">ReentrantLock</span> </span>&#123;    <span class="keyword">private</span> <span class="keyword">int</span> loopNumber;    <span class="function"><span class="keyword">public</span> <span class="title">AwaitSignal</span><span class="params">(<span class="keyword">int</span> loopNumber)</span> </span>&#123;        <span class="keyword">this</span>.loopNumber = loopNumber;    &#125;    <span class="comment">//参数1：打印内容  参数二：条件变量  参数二：唤醒下一个    public void print(String str, Condition condition, Condition next) &#123;        for (int i = 0; i &lt; loopNumber; i++) &#123;            lock();            try &#123;                condition.await();                System.out.print(str);                next.signal();            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125; finally &#123;                unlock();            &#125;        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h3 id="异步模式"><a href="#异步模式" class="headerlink" title="异步模式"></a>异步模式</h3><h4 id="传统版"><a href="#传统版" class="headerlink" title="传统版"></a>传统版</h4><p>异步模式之生产者/消费者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShareData</span> </span>&#123;    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">0</span>;    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();    <span class="keyword">private</span> Condition condition = lock.newCondition();    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;        <span class="comment">// 同步代码块，加锁        lock.lock();        try &#123;            // 判断  防止虚假唤醒            while(number != 0) &#123;                // 等待不能生产                condition.await();            &#125;            // 干活            number++;            System.out.println(Thread.currentThread().getName() + &quot;\t &quot; + number);            // 通知 唤醒            condition.signalAll();        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            lock.unlock();        &#125;    &#125;    public void decrement() throws Exception&#123;        // 同步代码块，加锁        lock.lock();        try &#123;            // 判断 防止虚假唤醒            while(number == 0) &#123;                // 等待不能消费                condition.await();            &#125;            // 干活            number--;            System.out.println(Thread.currentThread().getName() + &quot;\t &quot; + number);            // 通知 唤醒            condition.signalAll();        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            lock.unlock();        &#125;    &#125;&#125;public class TraditionalProducerConsumer &#123;public static void main(String[] args) &#123;        ShareData shareData = new ShareData();        // t1线程，生产        new Thread(() -&gt; &#123;            for (int i = 0; i &lt; 5; i++) &#123;            shareData.increment();            &#125;        &#125;, &quot;t1&quot;).start();        // t2线程，消费        new Thread(() -&gt; &#123;            for (int i = 0; i &lt; 5; i++) &#123;shareData.decrement();            &#125;        &#125;, &quot;t2&quot;).start();     &#125;&#125;</span></span><br></pre></td></tr></table></figure><h4 id="改进版"><a href="#改进版" class="headerlink" title="改进版"></a>改进版</h4><p>异步模式之生产者/消费者：</p><ul><li>消费队列可以用来平衡生产和消费的线程资源，不需要产生结果和消费结果的线程一一对应</li><li>生产者仅负责产生结果数据，不关心数据该如何处理，而消费者专心处理结果数据</li><li>消息队列是有容量限制的，满时不会再加入数据，空时不会再消耗数据</li><li>JDK 中各种阻塞队列，采用的就是这种模式</li></ul><p><img src="https://gitee.com/seazean/images/raw/master/Java/JUC-%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        MessageQueue queue = <span class="keyword">new</span> MessageQueue(<span class="number">2</span>);        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;            <span class="keyword">int</span> id = i;            <span class="keyword">new</span> Thread(() -&gt; &#123;                queue.put(<span class="keyword">new</span> Message(id,<span class="string">&quot;值&quot;</span>+id));            &#125;, <span class="string">&quot;生产者&quot;</span> + i).start();        &#125;                <span class="keyword">new</span> Thread(() -&gt; &#123;            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;                <span class="keyword">try</span> &#123;                    Thread.sleep(<span class="number">1000</span>);                    Message message = queue.take();                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;,<span class="string">&quot;消费者&quot;</span>).start();    &#125;&#125;<span class="comment">//消息队列类，Java间线程之间通信class MessageQueue &#123;    private LinkedList&lt;Message&gt; list = new LinkedList&lt;&gt;();//消息的队列集合    private int capacity;//队列容量    public MessageQueue(int capacity) &#123;        this.capacity = capacity;    &#125;    //获取消息    public Message take() &#123;        //检查队列是否为空        synchronized (list) &#123;            while (list.isEmpty()) &#123;                try &#123;                    sout(Thread.currentThread().getName() + &quot;:队列为空，消费者线程等待&quot;);                    list.wait();                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;            //从队列的头部获取消息返回            Message message = list.removeFirst();            sout(Thread.currentThread().getName() + &quot;：已消费消息--&quot; + message);            list.notifyAll();            return message;        &#125;    &#125;    //存入消息    public void put(Message message) &#123;        synchronized (list) &#123;            //检查队列是否满            while (list.size() == capacity) &#123;                try &#123;                    sout(Thread.currentThread().getName()+&quot;:队列为已满，生产者线程等待&quot;);                    list.wait();                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;            //将消息加入队列尾部            list.addLast(message);            sout(Thread.currentThread().getName() + &quot;:已生产消息--&quot; + message);            list.notifyAll();        &#125;    &#125;&#125;final class Message &#123;    private int id;    private Object value;//get set&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    ExecutorService consumer = Executors.newFixedThreadPool(<span class="number">1</span>);    ExecutorService producer = Executors.newFixedThreadPool(<span class="number">1</span>);    BlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> SynchronousQueue&lt;&gt;();    producer.submit(() -&gt; &#123;        <span class="keyword">try</span> &#123;            System.out.println(<span class="string">&quot;生产...&quot;</span>);            Thread.sleep(<span class="number">1000</span>);            queue.put(<span class="number">10</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;);    consumer.submit(() -&gt; &#123;        <span class="keyword">try</span> &#123;            System.out.println(<span class="string">&quot;等待消费...&quot;</span>);            Integer result = queue.take();            System.out.println(<span class="string">&quot;结果为:&quot;</span> + result);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;);&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><h3 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h3><h4 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h4><p>Java 内存模型是 Java Memory Model（JMM），本身是一种<strong>抽象的概念</strong>，实际上并不存在，描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式</p><p>JMM 作用：</p><ul><li>屏蔽各种硬件和操作系统的内存访问差异，实现让 Java 程序在各种平台下都能达到一致的内存访问效果</li><li>规定了线程和内存之间的一些关系</li></ul><p>根据 JMM 的设计，系统存在一个主内存（Main Memory），Java 中所有变量都存储在主存中，对于所有线程都是共享的；每条线程都有自己的工作内存（Working Memory），工作内存中保存的是主存中某些<strong>变量的拷贝</strong>，线程对所有变量的操作都是先对变量进行拷贝，然后在工作内存中进行，不能直接操作主内存中的变量；线程之间无法相互直接访问，线程间的通信（传递）必须通过主内存来完成</p><p><img src="https://gitee.com/seazean/images/raw/master/Java/JMM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png"></p><p>主内存和工作内存：</p><ul><li>主内存：计算机的内存，也就是经常提到的 8G 内存，16G 内存，存储所有共享变量的值</li><li>工作内存：存储该线程使用到的共享变量在主内存的的值的副本拷贝</li></ul><p><strong>JVM 和 JMM 之间的关系</strong>：JMM 中的主内存、工作内存与 JVM 中的 Java 堆、栈、方法区等并不是同一个层次的内存划分，这两者基本上是没有关系的，如果两者一定要勉强对应起来：</p><ul><li>主内存主要对应于 Java 堆中的对象实例数据部分，而工作内存则对应于虚拟机栈中的部分区域</li><li>从更低层次上说，主内存直接对应于物理硬件的内存，工作内存对应寄存器和高速缓存</li></ul><hr><h4 id="内存交互"><a href="#内存交互" class="headerlink" title="内存交互"></a>内存交互</h4><p>Java 内存模型定义了 8 个操作来完成主内存和工作内存的交互操作：</p><img src="https://gitee.com/seazean/images/raw/master/Java/JMM-内存交互.png" style="zoom: 67%;"><ul><li>lock：将一个变量标识为被一个线程<strong>独占状态</strong></li><li>unclock：将一个变量从独占状态释放出来，释放后的变量才可以被其他线程锁定</li><li>read：把一个变量的值从主内存传输到工作内存中</li><li>load：在 read 之后执行，把 read 得到的值放入工作内存的变量副本中</li><li>use：把工作内存中一个变量的值传递给执行引擎，每当遇到一个使用到变量的操作时都要使用该指令</li><li>assign：把从执行引擎接收到的一个值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的操作时，都要使用该指令</li><li>store：把工作内存的一个变量的值传送到主内存中</li><li>write：在 store 之后执行，把 store 得到的值放入主内存的变量中</li></ul><p>参考文章：<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md">https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md</a></p><hr><h4 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h4><h5 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h5><p>可见性：是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值</p><p>存在不可见问题的根本原因是由于缓存的存在，线程持有的是共享变量的副本，无法感知其他线程对于共享变量的更改，导致读取的值不是最新的</p><p>main 线程对 run 变量的修改对于 t 线程不可见，导致了 t 线程无法停止：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">boolean</span> run = <span class="keyword">true</span>;<span class="comment">//添加volatilepublic static void main(String[] args) throws InterruptedException &#123;    Thread t = new Thread(()-&gt;&#123;        while(run)&#123;        // ....        &#125;&#125;);    t.start();    sleep(1);    run = false; // 线程t不会如预想的停下来&#125;</span></span><br></pre></td></tr></table></figure><p>原因：</p><ul><li>初始状态， t 线程刚开始从主内存读取了 run 的值到工作内存</li><li>因为 t 线程要频繁从主内存中读取 run 的值，JIT 编译器会将 run 的值缓存至自己工作内存中的高速缓存中，减少对主存中 run 的访问，提高效率</li><li>1 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读取这个变量的值，结果永远是旧值</li></ul><p><img src="https://gitee.com/seazean/images/raw/master/Java/JMM-%E5%8F%AF%E8%A7%81%E6%80%A7%E4%BE%8B%E5%AD%90.png"></p><hr><h5 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h5><p>原子性：不可分割，完整性，也就是说某个线程正在做某个具体业务时，中间不可以被分割，需要具体完成，要么同时成功，要么同时失败，保证指令不会受到线程上下文切换的影响 </p><p>定义原子操作的使用规则：</p><ol><li>不允许一个线程无原因地（没有发生过任何 assign 操作）把数据从工作内存同步会主内存中</li><li>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（assign 或者 load）的变量，即对一个变量实施 use 和 store 操作之前，必须先自行 assign 和 load 操作</li><li>一个变量在同一时刻只允许一条线程对其进行 lock 操作，但 lock 操作可以被同一线程重复执行多次，多次执行 lock 后，只有<strong>执行相同次数的 unlock</strong> 操作，变量才会被解锁，<strong>lock 和 unlock 必须成对出现</strong></li><li>如果对一个变量执行 lock 操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量之前需要重新执行 load 或 assign 操作初始化变量的值</li><li>如果一个变量事先没有被 lock 操作锁定，则不允许对它执行 unlock 操作，也不允许去 unlock 一个被其他线程锁定的变量</li><li>对一个变量执行 unlock 操作之前，必须先把此变量同步到主内存中（执行 store 和 write 操作）</li></ol><hr><h5 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h5><p>有序性：在本线程内观察，所有操作都是有序的；在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了指令重排序</p><p>CPU 的基本工作是执行存储的指令序列，即程序，程序的执行过程实际上是不断地取出指令、分析指令、执行指令的过程，为了提高性能，编译器和处理器会对指令重排，一般分为以下三种：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">源代码 -&gt; 编译器优化的重排 -&gt; 指令并行的重排 -&gt; 内存系统的重排 -&gt; 最终执行指令</span><br></pre></td></tr></table></figure><p>现代 CPU 支持多级指令流水线，几乎所有的冯•诺伊曼型计算机的 CPU，其工作都可以分为 5 个阶段：取指令、指令译码、执行指令、访存取数和结果写回，可以称之为<strong>五级指令流水线</strong>。CPU 可以在一个时钟周期内，同时运行五条指令的<strong>不同阶段</strong>（每个线程不同的阶段），本质上流水线技术并不能缩短单条指令的执行时间，但变相地提高了指令地吞吐率</p><p>处理器在进行重排序时，必须要考虑<strong>指令之间的数据依赖性</strong></p><ul><li>单线程环境也存在指令重排，由于存在依赖性，最终执行结果和代码顺序的结果一致</li><li>多线程环境中线程交替执行，由于编译器优化重排，会获取其他线程处在不同阶段的指令同时执行</li></ul><hr><h3 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h3><h4 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h4><h5 id="缓存结构"><a href="#缓存结构" class="headerlink" title="缓存结构"></a>缓存结构</h5><p>在计算机系统中，CPU 高速缓存（CPU Cache，简称缓存）是用于减少处理器访问内存所需平均时间的部件；在存储体系中位于自顶向下的第二层，仅次于 CPU 寄存器；其容量远小于内存，但速度却可以接近处理器的频率</p><p>CPU 处理器速度远远大于在主内存中的，为了解决速度差异，在它们之间架设了多级缓存，如 L1、L2、L3 级别的缓存，这些缓存离CPU越近就越快，将频繁操作的数据缓存到这里，加快访问速度</p><img src="https://gitee.com/seazean/images/raw/master/Java/JMM-CPU缓存结构.png" style="zoom: 50%;"><table><thead><tr><th>从 cpu 到</th><th>大约需要的时钟周期</th></tr></thead><tbody><tr><td>寄存器</td><td>1 cycle (4GHz 的 CPU 约为 0.25ns)</td></tr><tr><td>L1</td><td>3~4 cycle</td></tr><tr><td>L2</td><td>10~20 cycle</td></tr><tr><td>L3</td><td>40~45 cycle</td></tr><tr><td>内存</td><td>120~240 cycle</td></tr></tbody></table><h5 id="缓存使用"><a href="#缓存使用" class="headerlink" title="缓存使用"></a>缓存使用</h5><p>当处理器发出内存访问请求时，会先查看缓存内是否有请求数据，如果存在（命中），则不用访问内存直接返回该数据；如果不存在（失效），则要先把内存中的相应数据载入缓存，再将其返回处理器</p><p>缓存之所以有效，主要因为程序运行时对内存的访问呈现局部性（Locality）特征。既包括空间局部性（Spatial Locality），也包括时间局部性（Temporal Locality），有效利用这种局部性，缓存可以达到极高的命中率。</p><hr><h4 id="伪共享"><a href="#伪共享" class="headerlink" title="伪共享"></a>伪共享</h4><p><strong>缓存以缓存行 cache line 为单位</strong>，每个缓存行对应着一块内存，一般是 64 byte（8 个 long），在 CPU 从主存获取数据时，以 cache line 为单位加载，于是相邻的数据会一并加载到缓存中</p><p>缓存会造成数据副本的产生，即同一份数据会缓存在不同核心的缓存行中，CPU 要保证数据的一致性，需要做到某个 CPU 核心更改了数据，其它 CPU 核心对应的<strong>整个缓存行必须失效</strong>，这就是伪共享</p><img src="https://gitee.com/seazean/images/raw/master/Java/JUC-内存伪共享.png" style="zoom: 67%;"><p>解决方法：</p><ul><li><p>padding：通过填充，让数据落在不同的 cache line 中</p></li><li><p>@Contended：原理参考 无锁 → Adder → 优化机制 → 伪共享</p></li></ul><p>Linux 查看 CPU 缓存行：</p><ul><li>命令：<code>cat /sys/devices/system/cpu/cpu0/cache/index0/coherency_line_size64</code></li><li>内存地址格式：[高位组标记] [低位索引] [偏移量]</li></ul><hr><h4 id="缓存一致"><a href="#缓存一致" class="headerlink" title="缓存一致"></a>缓存一致</h4><p>缓存一致性：当多个处理器运算任务都涉及到同一块主内存区域的时候，将可能导致各自的缓存数据不一样</p><p>MESI（Modified Exclusive Shared Or Invalid）是一种广泛使用的<strong>支持写回策略的缓存一致性协议</strong>，CPU 中每个缓存行（caceh line）使用 4 种状态进行标记（使用额外的两位 bit 表示)：</p><ul><li><p>M：被修改（Modified）</p><p>该缓存行只被缓存在该 CPU 的缓存中，并且是被修改过的，与主存中的数据不一致 (dirty)，该缓存行中的内存需要在未来的某个时间点（其它 CPU 读取主存中相应数据之前）写回 (write back) 主存</p><p>当被写回主存之后，该缓存行的状态会变成独享 (exclusive) 状态。</p></li><li><p>E：独享的（Exclusive）</p><p>该缓存行只被缓存在该 CPU 的缓存中，是未被修改过的 (clear)，与主存中数据一致，该状态可以在任何时刻有其它 CPU 读取该内存时变成共享状态 (shared)</p><p>当 CPU 修改该缓存行中内容时，该状态可以变成 Modified 状态</p></li><li><p>S：共享的（Shared）</p><p>该状态意味着该缓存行可能被多个 CPU 缓存，并且各个缓存中的数据与主存数据一致，当有一个 CPU 修改该缓存行中，其它 CPU 中该缓存行变成无效状态 (Invalid)</p></li><li><p>I：无效的（Invalid）</p><p>该缓存是无效的，可能有其它 CPU 修改了该缓存行</p></li></ul><p>解决方法：各个处理器访问缓存时都遵循一些协议，在读写时要根据协议进行操作，协议主要有 MSI、MESI 等</p><hr><h4 id="处理机制"><a href="#处理机制" class="headerlink" title="处理机制"></a>处理机制</h4><p>单核 CPU 处理器会自动保证基本内存操作的原子性</p><p>多核 CPU 处理器，每个 CPU 处理器内维护了一块内存，每个内核内部维护着一块缓存，当多线程并发读写时，就会出现缓存数据不一致的情况。处理器提供：</p><ul><li>总线锁定：当处理器要操作共享变量时，在 BUS 总线上发出一个 LOCK 信号，其他处理器就无法操作这个共享变量，该操作会导致大量阻塞，从而增加系统的性能开销（<strong>平台级别的加锁</strong>）</li><li>缓存锁定：当处理器对缓存中的共享变量进行了操作，其他处理器有嗅探机制，将该共享变量的缓存失效，其他线程读取时会重新从主内存中读取最新的数据，基于 MESI 缓存一致性协议来实现</li></ul><p>有如下两种情况处理器不会使用缓存锁定：</p><ul><li><p>当操作的数据跨多个缓存行，或没被缓存在处理器内部，则处理器会使用总线锁定</p></li><li><p>有些处理器不支持缓存锁定，比如：Intel 486 和 Pentium 处理器也会调用总线锁定</p></li></ul><p>总线机制：</p><ul><li><p>总线嗅探：每个处理器通过嗅探在总线上传播的数据来检查自己缓存值是否过期了，当处理器发现自己的缓存对应的内存地址的数据被修改，就<strong>将当前处理器的缓存行设置为无效状态</strong>，当处理器对这个数据进行操作时，会重新从内存中把数据读取到处理器缓存中</p></li><li><p>总线风暴：由于 volatile 的 MESI 缓存一致性协议，需要不断的从主内存嗅探和 CAS 循环，无效的交互会导致总线带宽达到峰值；因此不要大量使用 volatile 关键字，使用 volatile、syschonized 都需要根据实际场景</p></li></ul><hr><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><h4 id="基本特性"><a href="#基本特性" class="headerlink" title="基本特性"></a>基本特性</h4><p>volatile 是 Java 虚拟机提供的<strong>轻量级</strong>的同步机制（三大特性）</p><ul><li>保证可见性</li><li>不保证原子性</li><li>保证有序性（禁止指令重排）</li></ul><p>性能：volatile 修饰的变量进行读操作与普通变量几乎没什么差别，但是写操作相对慢一些，因为需要在本地代码中插入很多内存屏障来保证指令不会发生乱序执行，但是开销比锁要小</p><hr><h4 id="解决重排"><a href="#解决重排" class="headerlink" title="解决重排"></a>解决重排</h4><p><strong>volatile 修饰的变量，可以禁用指令重排</strong></p><p><strong>synchronized 无法禁止指令重排和处理器优化</strong>，为什么可以保证有序性可见性</p><ul><li>加了锁之后，只能有一个线程获得到了锁，获得不到锁的线程就要阻塞，所以同一时间只有一个线程执行，相当于单线程，由于数据依赖性的存在，单线程的指令重排是没有问题的</li><li>线程解锁前，必须把共享变量的最新值刷新到主内存中。线程加锁前，将清空工作内存中共享变量的值，使用共享变量时需要从主内存中重新读取最新的值</li></ul><p>指令重排实例：</p><ul><li><p>example 1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mySort</span><span class="params">()</span> </span>&#123;<span class="keyword">int</span> x = <span class="number">11</span>;<span class="comment">//语句1int y = 12;//语句2  谁先执行效果一样x = x + 5;//语句3y = x * x;//语句4&#125;</span></span><br></pre></td></tr></table></figure><p>执行顺序是：1 2 3 4、2 1 3 4、1 3 2 4</p><p>指令重排也有限制不会出现：4321，语句 4 需要依赖于 y 以及 x 的申明，因为存在数据依赖，无法首先执行</p></li><li><p>example 2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;<span class="keyword">boolean</span> ready = <span class="keyword">false</span>;<span class="comment">// 线程1 执行此方法public void actor1(I_Result r) &#123;    if(ready) &#123;    r.r1 = num + num;    &#125; else &#123;    r.r1 = 1;    &#125;&#125;// 线程2 执行此方法public void actor2(I_Result r) &#123;num = 2;ready = true;&#125;</span></span><br></pre></td></tr></table></figure><p>情况一：线程1 先执行，ready = false，结果为 r.r1 = 1</p><p>情况二：线程2 先执行 num = 2，但还没执行 ready = true，线程1 执行，结果为 r.r1 = 1</p><p>情况三：线程2 先执行 ready = true，线程1 执行，进入 if 分支结果为 r.r1 = 4</p><p>情况四：线程2 执行 ready = true，切换到线程1，进入 if 分支为 r.r1 = 0，再切回线程2 执行 num = 2，发生指令重排</p></li></ul><hr><h4 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h4><p>使用 volatile 修饰的共享变量，总线会开启 <strong>CPU 总线嗅探机制</strong>来解决 JMM 缓存一致性问题，也就是共享变量在多线程中可见性的问题，实现 MESI 缓存一致性协议</p><p>底层是通过汇编 lock 前缀指令，共享变量加了 lock 前缀指令，在线程修改完共享变量后，会马上执行 store 和 write 操作。在执行 store 操作前，会先执行<strong>缓存锁定</strong>的操作然后写回主存，其他的 CPU 上运行的线程根据 CPU 总线嗅探机制会修改其共享变量为失效状态，读取时会重新从主内存中读取最新的数据</p><p>lock 前缀指令就相当于内存屏障，Memory Barrier（Memory Fence）</p><ul><li>对 volatile 变量的写指令后会加入写屏障</li><li>对 volatile 变量的读指令前会加入读屏障</li></ul><p>内存屏障有三个作用：</p><ul><li>确保对内存的读-改-写操作原子执行</li><li>阻止屏障两侧的指令重排序</li><li>强制把缓存中的脏数据写回主内存，让缓存行中相应的数据失效</li></ul><p><strong>保证可见性</strong>：</p><ul><li><p>写屏障（sfence，Store Barrier）保证在该屏障之前的，对共享变量的改动，都同步到主存当中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor2</span><span class="params">(I_Result r)</span> </span>&#123;    num = <span class="number">2</span>;    ready = <span class="keyword">true</span>; <span class="comment">// ready 是 volatile 赋值带写屏障    // 写屏障&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>读屏障（lfence，Load Barrier）保证在该屏障之后的，对共享变量的读取，加载的是主存中最新数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor1</span><span class="params">(I_Result r)</span> </span>&#123;    <span class="comment">// 读屏障    // ready 是 volatile 读取值带读屏障    if(ready) &#123;    r.r1 = num + num;    &#125; else &#123;    r.r1 = 1;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><img src="https://gitee.com/seazean/images/raw/master/Java/JMM-volatile保证可见性.png" style="zoom:67%;"></li><li><p>全能屏障：mfence（modify/mix Barrier），兼具 sfence 和 lfence 的功能</p></li></ul><p><strong>保证有序性</strong>：</p><ul><li>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</li><li>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</li></ul><p>不能解决指令交错：</p><ul><li><p>写屏障仅仅是保证之后的读能够读到最新的结果，但不能保证其他的读跑到写屏障之前</p></li><li><p>有序性的保证也只是保证了本线程内相关代码不被重排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> i = <span class="number">0</span>;<span class="keyword">new</span> Thread(() -&gt; &#123;i++&#125;);<span class="keyword">new</span> Thread(() -&gt; &#123;i--&#125;);</span><br></pre></td></tr></table></figure><p>i++ 反编译后的指令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: iconst_1<span class="comment">// 当int取值 -1~5 时，JVM采用iconst指令将常量压入栈中1: istore_1// 将操作数栈顶数据弹出，存入局部变量表的 slot 12: iinc1, 1</span></span><br></pre></td></tr></table></figure><img src="https://gitee.com/seazean/images/raw/master/Java/JMM-volatile不能保证原子性.png" style="zoom:67%;"></li></ul><hr><h4 id="双端检锁"><a href="#双端检锁" class="headerlink" title="双端检锁"></a>双端检锁</h4><h5 id="检锁机制"><a href="#检锁机制" class="headerlink" title="检锁机制"></a>检锁机制</h5><p>Double-Checked Locking：双端检锁机制</p><p>DCL（双端检锁）机制不一定是线程安全的，原因是有指令重排的存在，加入 volatile 可以禁止指令重排</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;    <span class="keyword">private</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">null</span>;        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;        <span class="keyword">if</span>(INSTANCE == <span class="keyword">null</span>) &#123; <span class="comment">// t2，这里的判断不是线程安全的            // 首次访问会同步，而之后的使用没有 synchronized            synchronized(Singleton.class) &#123;                // 这里是线程安全的判断，防止其他线程在当前线程等待锁的期间完成了初始化                if (INSTANCE == null) &#123;                     INSTANCE = new Singleton();                &#125;            &#125;        &#125;        return INSTANCE;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>不锁 INSTANCE 的原因：</p><ul><li>INSTANCE 要重新赋值</li><li>INSTANCE 是 null，线程加锁之前需要获取对象的引用，设置对象头，null 没有引用</li></ul><p>实现特点： </p><ul><li>懒惰初始化</li><li>首次使用 getInstance() 才使用 synchronized 加锁，后续使用时无需加锁</li><li>第一个 if 使用了 INSTANCE 变量，是在同步块之外，但在多线程环境下会产生问题</li></ul><hr><h5 id="DCL问题"><a href="#DCL问题" class="headerlink" title="DCL问题"></a>DCL问题</h5><p>getInstance 方法对应的字节码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: getstatic #<span class="number">2</span> <span class="comment">// Field INSTANCE:Ltest/Singleton;3: ifnonnull 376: ldc #3 // class test/Singleton8: dup9: astore_010: monitorenter11: getstatic #2 // Field INSTANCE:Ltest/Singleton;14: ifnonnull 2717: new #3 // class test/Singleton20: dup21: invokespecial #4 // Method &quot;&lt;init&gt;&quot;:()V24: putstatic #2 // Field INSTANCE:Ltest/Singleton;27: aload_028: monitorexit29: goto 3732: astore_133: aload_034: monitorexit35: aload_136: athrow37: getstatic #2 // Field INSTANCE:Ltest/Singleton;40: areturn</span></span><br></pre></td></tr></table></figure><ul><li>17 表示创建对象，将对象引用入栈 </li><li>20 表示复制一份对象引用，引用地址</li><li>21 表示利用一个对象引用，调用构造方法初始化对象</li><li>24 表示利用一个对象引用，赋值给 static INSTANCE</li></ul><p>步骤 21 和 24 之间不存在数据依赖关系，而且无论重排前后，程序的执行结果在单线程中并没有改变，因此这种重排优化是允许的</p><ul><li>关键在于 0:getstatic 这行代码在 monitor 控制之外，可以越过 monitor 读取 INSTANCE 变量的值</li><li>当其他线程访问 instance 不为 null 时，由于 instance 实例未必已初始化，那么 t2 拿到的是将是一个未初始化完毕的单例返回，这就造成了线程安全的问题</li></ul><p><img src="https://gitee.com/seazean/images/raw/master/Java/JMM-DCL%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98.png"></p><hr><h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><p>指令重排只会保证串行语义的执行一致性（单线程），但并不会关系多线程间的语义一致性</p><p>引入 volatile，来保证出现指令重排的问题，从而保证单例模式的线程安全性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> SingletonDemo INSTANCE = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="ha-be"><a href="#ha-be" class="headerlink" title="ha-be"></a>ha-be</h3><p>happens-before 先行发生</p><p>Java 内存模型具备一些先天的“有序性”，即不需要通过任何同步手段（volatile、synchronized 等）就能够得到保证的安全，这个通常也称为 happens-before 原则，它是可见性与有序性的一套规则总结</p><p>不符合 happens-before 规则，JMM 并不能保证一个线程的可见性和有序性</p><ol><li><p>程序次序规则 (Program Order Rule)：一个线程内，逻辑上书写在前面的操作先行发生于书写在后面的操作 ，因为多个操作之间有先后依赖关系，则不允许对这些操作进行重排序</p></li><li><p>锁定规则 (Monitor Lock Rule)：一个 unlock 操作先行发生于后面（时间的先后）对同一个锁的 lock 操作，所以线程解锁 m 之前对变量的写（解锁前会刷新到主内存中），对于接下来对 m 加锁的其它线程对该变量的读可见</p></li><li><p><strong>volatile 变量规则</strong>  (Volatile Variable Rule)：对 volatile 变量的写操作先行发生于后面对这个变量的读</p></li><li><p>传递规则 (Transitivity)：具有传递性，如果操作 A 先行发生于操作 B，而操作 B 又先行发生于操作 C，则可以得出操作 A 先行发生于操作 C</p></li><li><p>线程启动规则 (Thread Start Rule)：Thread 对象的 start()方 法先行发生于此线程中的每一个操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">10</span>;<span class="comment">//线程 start 前对变量的写，对该线程开始后对该变量的读可见new Thread(()-&gt;&#123;System.out.println(x);&#125;,&quot;t1&quot;).start();</span></span><br></pre></td></tr></table></figure></li><li><p>线程中断规则 (Thread Interruption Rule)：对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生</p></li><li><p>线程终止规则 (Thread Termination Rule)：线程中所有的操作都先行发生于线程的终止检测，可以通过 Thread.join() 方法结束、Thread.isAlive() 的返回值手段检测到线程已经终止执行</p></li><li><p>对象终结规则（Finaizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始</p></li></ol><hr><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><h4 id="终止模式-1"><a href="#终止模式-1" class="headerlink" title="终止模式"></a>终止模式</h4><p>终止模式之两阶段终止模式：停止标记用 volatile 是为了保证该变量在多个线程之间的可见性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwoPhaseTermination</span> </span>&#123;    <span class="comment">// 监控线程    private Thread monitor;    // 停止标记    private volatile boolean stop = false;;    // 启动监控线程    public void start() &#123;        monitor = new Thread(() -&gt; &#123;            while (true) &#123;                Thread thread = Thread.currentThread();                if (stop) &#123;                    System.out.println(&quot;后置处理&quot;);                    break;                &#125;                try &#123;                    Thread.sleep(1000);// 睡眠                    System.out.println(thread.getName() + &quot;执行监控记录&quot;);                &#125; catch (InterruptedException e) &#123;                   System.out.println(&quot;被打断，退出睡眠&quot;);                &#125;            &#125;        &#125;);        monitor.start();    &#125;    // 停止监控线程    public void stop() &#123;        stop = true;        monitor.interrupt();// 让线程尽快退出Timed Waiting    &#125;&#125;// 测试public static void main(String[] args) throws InterruptedException &#123;    TwoPhaseTermination tpt = new TwoPhaseTermination();    tpt.start();    Thread.sleep(3500);    System.out.println(&quot;停止监控&quot;);    tpt.stop();&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="Balking"><a href="#Balking" class="headerlink" title="Balking"></a>Balking</h4><p>Balking （犹豫）模式用在一个线程发现另一个线程或本线程已经做了某一件相同的事，那么本线程就无需再做了，直接结束返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonitorService</span> </span>&#123;    <span class="comment">// 用来表示是否已经有线程已经在执行启动了    private volatile boolean starting = false;    public void start() &#123;        System.out.println(&quot;尝试启动监控线程...&quot;);        synchronized (this) &#123;            if (starting) &#123;            return;            &#125;            starting = true;        &#125;        // 真正启动监控线程...    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>对比保护性暂停模式：保护性暂停模式用在一个线程等待另一个线程的执行结果，当条件不满足时线程等待</p><p>例子：希望 doInit() 方法仅被调用一次，下面的实现出现的问题：</p><ul><li>当 t1 线程进入 init() 准备 doInit()，t2 线程进来，initialized 还为f alse，则 t2 就又初始化一次</li><li>volatile 适合一个线程写，其他线程读的情况，这个代码需要加锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestVolatile</span> </span>&#123;    <span class="keyword">volatile</span> <span class="keyword">boolean</span> initialized = <span class="keyword">false</span>;        <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;        <span class="keyword">if</span> (initialized) &#123;            <span class="keyword">return</span>;        &#125;    doInit();    initialized = <span class="keyword">true</span>;    &#125;    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doInit</span><span class="params">()</span> </span>&#123;    &#125;&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h2><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>无锁编程：Lock Free</p><p>CAS 的全称是 Compare-And-Swap，是 <strong>CPU 并发原语</strong></p><ul><li>CAS 并发原语体现在 Java 语言中就是 sun.misc.Unsafe 类的各个方法，调用 UnSafe 类中的 CAS 方法，JVM 会实现出 CAS 汇编指令，这是一种完全依赖于硬件的功能，实现了原子操作</li><li>CAS 是一种系统原语，原语属于操作系统范畴，是由若干条指令组成 ，用于完成某个功能的一个过程，并且原语的执行必须是连续的，执行过程中不允许被中断，所以 CAS 是一条 CPU 的原子指令，不会造成数据不一致的问题，是线程安全的</li></ul><p>底层原理：CAS 的底层是 <code>lock cmpxchg</code> 指令（X86 架构），在单核和多核 CPU 下都能够保证比较交换的原子性</p><ul><li><p>程序是在单核处理器上运行，会省略 lock 前缀，单处理器自身会维护处理器内的顺序一致性，不需要 lock 前缀的内存屏障效果</p></li><li><p>程序是在多核处理器上运行，会为 cmpxchg 指令加上 lock 前缀。当某个核执行到带 lock 的指令时，CPU 会执行<strong>总线锁定或缓存锁定</strong>，将修改的变量写入到主存，这个过程不会被线程的调度机制所打断，保证了多个线程对内存操作的原子性</p></li></ul><p>作用：比较当前工作内存中的值和主物理内存中的值，如果相同则执行规定操作，否者继续比较直到主内存和工作内存的值一致为止</p><p>CAS 特点：</p><ul><li>CAS 体现的是<strong>无锁并发、无阻塞并发</strong>，线程不会陷入阻塞，线程不需要频繁切换状态（上下文切换，系统调用）</li><li>CAS 是基于乐观锁的思想</li></ul><p>CAS 缺点：</p><ul><li>循环时间长，开销大，因为执行的是循环操作，如果比较不成功一直在循环，最差的情况某个线程一直取到的值和预期值都不一样，就会无限循环导致饥饿，<strong>使用 CAS 线程数不要超过 CPU的 核心数</strong></li><li>只能保证一个共享变量的原子操作<ul><li>对于一个共享变量执行操作时，可以通过循环 CAS 的方式来保证原子操作</li><li>对于多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候<strong>只能用锁来保证原子性</strong></li></ul></li><li>引出来 ABA 问题</li></ul><hr><h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>CAS 与 synchronized 总结：</p><ul><li>synchronized 是从悲观的角度出发：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞（<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong>），因此 synchronized 也称之为悲观锁，ReentrantLock 也是一种悲观锁，<strong>性能较差</strong></li><li>CAS 是从乐观的角度出发：总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据。<strong>如果别人修改过，则获取现在最新的值，如果别人没修改过，直接修改共享数据的值</strong>，CAS 这种机制也称之为乐观锁，<strong>综合性能较好</strong></li></ul><hr><h3 id="Atomic"><a href="#Atomic" class="headerlink" title="Atomic"></a>Atomic</h3><h4 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h4><p>常见原子类：AtomicInteger、AtomicBoolean、AtomicLong</p><p>构造方法：</p><ul><li><code>public AtomicInteger()</code>：初始化一个默认值为 0 的原子型 Integer</li><li><code>public AtomicInteger(int initialValue)</code>：初始化一个指定值的原子型 Integer</li></ul><p>常用API：</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>public final int get()</td><td>获取 AtomicInteger 的值</td></tr><tr><td>public final int getAndIncrement()</td><td>以原子方式将当前值加 1，返回的是自增前的值</td></tr><tr><td>public final int incrementAndGet()</td><td>以原子方式将当前值加 1，返回的是自增后的值</td></tr><tr><td>public final int getAndSet(int value)</td><td>以原子方式设置为 newValue 的值，返回旧值</td></tr><tr><td>public final int addAndGet(int data)</td><td>以原子方式将输入的数值与实例中的值相加并返回<br>实例：AtomicInteger 里的 value</td></tr></tbody></table><hr><h4 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h4><p><strong>AtomicInteger 原理</strong>：自旋锁  + CAS 算法</p><p>CAS 算法：有 3 个操作数（内存值 V， 旧的预期值 A，要修改的值 B）</p><ul><li>当旧的预期值 A == 内存值 V   此时可以修改，将 V 改为 B</li><li>当旧的预期值 A !=  内存值 V   此时不能修改，并重新获取现在的最新值，重新获取的动作就是自旋 </li></ul><p>分析 getAndSet 方法：</p><ul><li><p>AtomicInteger：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;    <span class="comment">/**    * this: 当前对象    * valueOffset:内存偏移量，内存地址    */</span>    <span class="keyword">return</span> unsafe.getAndSetInt(<span class="keyword">this</span>, valueOffset, newValue);&#125;</span><br></pre></td></tr></table></figure><p>valueOffset：偏移量表示该变量值相对于当前对象地址的偏移，Unsafe 就是根据内存偏移地址获取数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">valueOffset = unsafe.objectFieldOffset                (AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));<span class="comment">//调用本地方法   --&gt;public native long objectFieldOffset(Field var1);</span></span><br></pre></td></tr></table></figure></li><li><p>unsafe类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// val1: AtomicInteger对象本身，var2: 该对象值得引用地址，var4: 需要变动的数public final int getAndSetInt(Object var1, long var2, int var4) &#123;    int var5;    do &#123;        // var5: 用 var1 和 var2 找到的内存中的真实值        var5 = this.getIntVolatile(var1, var2);    &#125; while(!this.compareAndSwapInt(var1, var2, var5, var4));    return var5;&#125;</span></span><br></pre></td></tr></table></figure><p>var5：从主内存中拷贝到工作内存中的值（每次都要从主内存拿到最新的值到本地内存），然后执行 <code>compareAndSwapInt()</code> 再和主内存的值进行比较，假设方法返回 false，那么就一直执行 while 方法，直到期望的值和真实值一样，修改数据</p></li><li><p>变量 value 用 volatile 修饰，保证了多线程之间的内存可见性，避免线程从工作缓存中获取失效的变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value</span><br></pre></td></tr></table></figure><p>CAS 必须借助 volatile 才能读取到共享变量的最新值来实现<strong>比较并交换</strong>的效果</p></li></ul><p>分析 getAndUpdate 方法：</p><ul><li><p>getAndUpdate：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndUpdate</span><span class="params">(IntUnaryOperator updateFunction)</span> </span>&#123;    <span class="keyword">int</span> prev, next;    <span class="keyword">do</span> &#123;        prev = get();<span class="comment">//当前值，cas的期望值        next = updateFunction.applyAsInt(prev);//期望值更新到该值    &#125; while (!compareAndSet(prev, next));//自旋    return prev;&#125;</span></span><br></pre></td></tr></table></figure><p>函数式接口：可以自定义操作逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AtomicInteger a = <span class="keyword">new</span> AtomicInteger();a.getAndUpdate(i -&gt; i + <span class="number">10</span>);</span><br></pre></td></tr></table></figure></li><li><p>compareAndSet：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;    <span class="comment">/**    * this: 当前对象    * valueOffset:内存偏移量，内存地址    * expect:期望的值    * update: 更新的值    */</span>    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="原子引用"><a href="#原子引用" class="headerlink" title="原子引用"></a>原子引用</h4><p>原子引用：对 Object 进行原子操作，提供一种读和写都是原子性的对象引用变量</p><p>原子引用类：AtomicReference、AtomicStampedReference、AtomicMarkableReference</p><p>AtomicReference 类：</p><ul><li><p>构造方法：<code>AtomicReference&lt;T&gt; atomicReference = new AtomicReference&lt;T&gt;()</code></p></li><li><p>常用 API：</p><ul><li><code>public final boolean compareAndSet(V expectedValue, V newValue)</code>：CAS 操作</li><li><code>public final void set(V newValue)</code>：将值设置为 newValue </li><li><code>public final V get()</code>：返回当前值</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicReferenceDemo</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        Student s1 = <span class="keyword">new</span> Student(<span class="number">33</span>, <span class="string">&quot;z3&quot;</span>);                <span class="comment">// 创建原子引用包装类        AtomicReference&lt;Student&gt; atomicReference = new AtomicReference&lt;&gt;();        // 设置主内存共享变量为s1        atomicReference.set(s1);        // 比较并交换，如果现在主物理内存的值为 z3，那么交换成 l4        while (true) &#123;            Student s2 = new Student(44, &quot;l4&quot;);            if (atomicReference.compareAndSet(s1, s2)) &#123;                break;            &#125;        &#125;        System.out.println(atomicReference.get());    &#125;&#125;class Student &#123;    private int id;    private String name;    //。。。。&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="原子数组"><a href="#原子数组" class="headerlink" title="原子数组"></a>原子数组</h4><p>原子数组类：AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray</p><p>AtomicIntegerArray 类方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***   ithe index* expect the expected value* update the new value*/</span><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;    <span class="keyword">return</span> compareAndSetRaw(checkedByteOffset(i), expect, update);&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="原子更新器"><a href="#原子更新器" class="headerlink" title="原子更新器"></a>原子更新器</h4><p>原子更新器类：AtomicReferenceFieldUpdater、AtomicIntegerFieldUpdater、AtomicLongFieldUpdater</p><p>利用字段更新器，可以针对对象的某个域（Field）进行原子操作，只能配合 volatile 修饰的字段使用，否则会出现异常 <code>IllegalArgumentException: Must be volatile type</code></p><p>常用 API：</p><ul><li><code>static &lt;U&gt; AtomicIntegerFieldUpdater&lt;U&gt; newUpdater(Class&lt;U&gt; c, String fieldName)</code>：构造方法</li><li><code>abstract boolean compareAndSet(T obj, int expect, int update)</code>：CAS</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UpdateDemo</span> </span>&#123;    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> field;        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        AtomicIntegerFieldUpdater fieldUpdater = AtomicIntegerFieldUpdater            .newUpdater(UpdateDemo.class, <span class="string">&quot;field&quot;</span>);        UpdateDemo updateDemo = <span class="keyword">new</span> UpdateDemo();        fieldUpdater.compareAndSet(updateDemo, <span class="number">0</span>, <span class="number">10</span>);        System.out.println(updateDemo.field);<span class="comment">//10    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="原子累加器"><a href="#原子累加器" class="headerlink" title="原子累加器"></a>原子累加器</h4><p>原子累加器类：LongAdder、DoubleAdder、LongAccumulator、DoubleAccumulator </p><p>LongAdder 和 LongAccumulator 区别：</p><p>相同点：</p><ul><li>LongAddr 与 LongAccumulator 类都是使用非阻塞算法 CAS 实现的，</li><li>LongAddr 类是 LongAccumulator 类的一个特例，只是 LongAccumulator 提供了更强大的功能，可以自定义累加规则，当accumulatorFunction 为 null 时就等价于 LongAddr</li></ul><p>不同点：</p><ul><li><p>调用 casBase 时，LongAccumulator 使用 function.applyAsLong(b = base, x) 来计算，LongAddr 使用 casBase(b = base, b + x) </p></li><li><p>LongAccumulator 类功能更加强大，构造方法参数中</p><ul><li>accumulatorFunction 是一个双目运算器接口，可以指定累加规则，比如累加或者相乘，其根据输入的两个参数返回一个计算值，LongAdder 内置累加规则</li><li>identity 则是 LongAccumulator 累加器的初始值，LongAccumulator 可以为累加器提供非0的初始值，而 LongAdder 只能提供默认的 0</li></ul></li></ul><hr><h3 id="Adder"><a href="#Adder" class="headerlink" title="Adder"></a>Adder</h3><h4 id="优化机制"><a href="#优化机制" class="headerlink" title="优化机制"></a>优化机制</h4><p>LongAdder 是 Java8 提供的类，跟 AtomicLong 有相同的效果，但对 CAS 机制进行了优化，尝试使用分段 CAS 以及自动分段迁移的方式来大幅度提升多线程高并发执行 CAS 操作的性能</p><p>CAS 底层实现是在一个循环中不断地尝试修改目标值，直到修改成功。如果竞争不激烈修改成功率很高，否则失败率很高，失败后这些重复的原子性操作会耗费性能（导致大量线程<strong>空循环，自旋转</strong>）</p><p>优化核心思想：数据分离，将 AtomicLong 的<strong>单点的更新压力分担到各个节点，空间换时间</strong>，在低并发的时候直接更新，可以保障和 AtomicLong 的性能基本一致，而在高并发的时候通过分散减少竞争，提高了性能</p><p><strong>分段 CAS 机制</strong>：</p><ul><li>在发生竞争时，创建 Cell 数组用于将不同线程的操作离散（通过 hash 等算法映射）到不同的节点上</li><li>设置多个累加单元（会根据需要扩容，最大为 CPU 核数），Therad-0 累加 Cell[0]，而 Thread-1 累加 Cell[1] 等，最后将结果汇总</li><li>在累加时操作的不同的 Cell 变量，因此减少了 CAS 重试失败，从而提高性能</li></ul><p><strong>自动分段迁移机制</strong>：某个 Cell 的 value 执行 CAS 失败，就会自动寻找另一个 Cell 分段内的 value 值进行 CAS 操作</p><hr><h4 id="伪共享-1"><a href="#伪共享-1" class="headerlink" title="伪共享"></a>伪共享</h4><p>Cell 为累加单元：数组访问索引是通过 Thread 里的 threadLocalRandomProbe 域取模实现的，这个域是 ThreadLocalRandom 更新的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Striped64.Cell@sun.misc.Contended static final class Cell &#123;    volatile long value;    Cell(long x) &#123; value = x; &#125;    // 用 cas 方式进行累加, prev 表示旧值, next 表示新值    final boolean cas(long prev, long next) &#123;    return UNSAFE.compareAndSwapLong(this, valueOffset, prev, next);    &#125;    // 省略不重要代码&#125;</span></span><br></pre></td></tr></table></figure><p>Cell 是数组形式，<strong>在内存中是连续存储的</strong>，64 位系统中，一个 Cell 为 24 字节（16 字节的对象头和 8 字节的 value），每一个 cache line 为 64 字节，因此缓存行可以存下 2 个的 Cell 对象，当 Core-0 要修改 Cell[0]、Core-1 要修改 Cell[1]，无论谁修改成功都会导致当前缓存行失效，从而导致对方的数据失效，需要重新去主存获取，影响效率</p><p><img src="https://gitee.com/seazean/images/raw/master/Java/JUC-%E4%BC%AA%E5%85%B1%E4%BA%AB1.png"></p><p>@sun.misc.Contended：防止缓存行伪共享，在使用此注解的对象或字段的前后各增加 128 字节大小的 padding，使用 2 倍于大多数硬件缓存行让 CPU 将对象预读至缓存时占用不同的缓存行，这样就不会造成对方缓存行的失效</p><p><img src="https://gitee.com/seazean/images/raw/master/Java/JUC-%E4%BC%AA%E5%85%B1%E4%BA%AB2.png"></p><hr><h4 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h4><p>Striped64 类成员属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示当前计算机CPU数量static final int NCPU = Runtime.getRuntime().availableProcessors()// 累加单元数组, 懒惰初始化transient volatile Cell[] cells;// 基础值, 如果没有竞争, 则用 cas 累加这个域，当 cells 扩容时，也会将数据写到 base 中transient volatile long base;// 在 cells 初始化或扩容时只能有一个线程执行, 通过 CAS 更新 cellsBusy 置为 1 来实现一个锁transient volatile int cellsBusy;</span></span><br></pre></td></tr></table></figure><p>工作流程：</p><ul><li><p>cells 占用内存是相对比较大的，是惰性加载的，在无竞争或者其他线程正在初始化 cells 数组的情况下，直接更新 base 域</p></li><li><p>在第一次发生竞争时（casBase 失败）会创建一个大小为 2 的 cells 数组，将当前累加的值包装为 Cell 对象，放入映射的槽位上</p></li><li><p>分段累加的过程中，如果当前线程对应的 cells 槽位为空，就会新建 Cell 填充，如果出现竞争，就会重新计算线程对应的槽位，继续自旋尝试修改</p></li><li><p>分段迁移后还出现竞争就会扩容 cells 数组长度为原来的两倍，然后 rehash，<strong>数组长度总是 2 的 n 次幂</strong>，默认最大为 CPU 核数，但是可以超过，如果核数是 6 核，数组最长是 8 </p></li></ul><p>方法分析：</p><ul><li><p>LongAdder#add：累加方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;    <span class="comment">// as 为累加单元数组的引用，b 为基础值，v 表示期望值    // m 表示 cells 数组的长度 - 1，a 表示当前线程命中的 cell 单元格    Cell[] as; long b, v; int m; Cell a;        // cells 不为空说明 cells 已经被初始化，线程发生了竞争，去更新对应的 cell 槽位    // 进入 || 后的逻辑去更新 base 域，更新失败表示发生竞争进入条件    if ((as = cells) != null || !casBase(b = base, b + x)) &#123;        // uncontended 为 true 表示 cell 没有竞争        boolean uncontended = true;                // 条件一: true 说明 cells 未初始化，多线程写 base 发生竞争需要进行初始化 cells 数组        //  fasle 说明 cells 已经初始化，进行下一个条件寻找自己的 cell 去累加        // 条件二: getProbe() 获取 hash 值，&amp; m 的逻辑和 HashMap 的逻辑相同，保证散列的均匀性        //   true 说明当前线程对应下标的 cell 为空，需要创建 cell        //        false 说明当前线程对应的 cell 不为空，进行下一个条件【将 x 值累加到对应的 cell 中】        // 条件三: 有取反符号，false 说明 cas 成功，直接返回，true 说明失败，当前线程对应的 cell 有竞争        if (as == null || (m = as.length - 1) &lt; 0 ||            (a = as[getProbe() &amp; m]) == null ||            !(uncontended = a.cas(v = a.value, v + x)))            longAccumulate(x, null, uncontended);        // 【uncontended 在对应的 cell 上累加失败的时候才为 false，其余情况均为 true】    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>Striped64#longAccumulate：cell 数组创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// x  null false | truefinal void longAccumulate(long x, LongBinaryOperator fn, boolean wasUncontended) &#123;    int h;    // 当前线程还没有对应的 cell, 需要随机生成一个 hash 值用来将当前线程绑定到 cell    if ((h = getProbe()) == 0) &#123;        // 初始化 probe，获取 hash 值        ThreadLocalRandom.current();         h = getProbe();        // 默认情况下 当前线程肯定是写入到了 cells[0] 位置，不把它当做一次真正的竞争        wasUncontended = true;    &#125;    // 表示【扩容意向】，false 一定不会扩容，true 可能会扩容    boolean collide = false;     //自旋    for (;;) &#123;        // as 表示cells引用，a 表示当前线程命中的 cell，n 表示 cells 数组长度，v 表示 期望值        Cell[] as; Cell a; int n; long v;        // 【CASE1】: 表示 cells 已经初始化了，当前线程应该将数据写入到对应的 cell 中        if ((as = cells) != null &amp;&amp; (n = as.length) &gt; 0) &#123;            // CASE1.1: true 表示当前线程对应的索引下标的 Cell 为 null，需要创建 new Cell            if ((a = as[(n - 1) &amp; h]) == null) &#123;                // 判断 cellsBusy 是否被锁                if (cellsBusy == 0) &#123;                       // 创建 cell, 初始累加值为 x                    Cell r = new Cell(x);                      // 加锁                    if (cellsBusy == 0 &amp;&amp; casCellsBusy()) &#123;                        // 创建成功标记，进入【创建 cell 逻辑】                        boolean created = false;                        try &#123;                            Cell[] rs; int m, j;                            // 把当前 cells 数组赋值给 rs，并且不为 null                            if ((rs = cells) != null &amp;&amp;                                (m = rs.length) &gt; 0 &amp;&amp;                                // 再次判断防止其它线程初始化过该位置，当前线程再次初始化该位置会造成数据丢失                                // 因为这里是线程安全的判断，进行的逻辑不会被其他线程影响                                rs[j = (m - 1) &amp; h] == null) &#123;                                // 把新创建的 cell 填充至当前位置                                rs[j] = r;                                created = true;// 表示创建完成                            &#125;                        &#125; finally &#123;                            cellsBusy = 0;// 解锁                        &#125;                        if (created)// true 表示创建完成，可以推出循环了                            break;                        continue;                    &#125;                &#125;                collide = false;            &#125;            // CASE1.2: 条件成立说明线程对应的 cell 有竞争, 改变线程对应的 cell 来重试 cas            else if (!wasUncontended)                wasUncontended = true;            // CASE 1.3: 当前线程 rehash 过，如果新命中的 cell 不为空，就尝试累加，false 说明新命中也有竞争            else if (a.cas(v = a.value, ((fn == null) ? v + x : fn.applyAsLong(v, x))))                break;            // CASE 1.4: cells 长度已经超过了最大长度 CPU 内核的数量或者已经扩容            else if (n &gt;= NCPU || cells != as)                collide = false; // 扩容意向改为false，【表示不能扩容了】            // CASE 1.5: 更改扩容意向，如果 n &gt;= NCPU，这里就永远不会执行到，case1.4 永远先于 1.5 执行            else if (!collide)                collide = true;            // CASE 1.6: 【扩容逻辑】，进行加锁            else if (cellsBusy == 0 &amp;&amp; casCellsBusy()) &#123;                try &#123;                    // 线程安全的检查，防止期间被其他线程扩容了                    if (cells == as) &#123;                             // 扩容为以前的 2 倍                        Cell[] rs = new Cell[n &lt;&lt; 1];                        // 遍历移动值                        for (int i = 0; i &lt; n; ++i)                            rs[i] = as[i];                        // 把扩容后的引用给 cells                        cells = rs;                    &#125;                &#125; finally &#123;                    cellsBusy = 0;// 解锁                &#125;                collide = false;// 扩容意向改为 false，表示不扩容了                continue;            &#125;            // 重置当前线程 Hash 值，这就是【分段迁移机制】            h = advanceProbe(h);        &#125;        // 【CASE2】: 运行到这说明 cells 还未初始化，as 为null        // 判断是否没有加锁，没有加锁就用 CAS 加锁        // 条件二判断是否其它线程在当前线程给 as 赋值之后修改了 cells，这里不是线程安全的判断        else if (cellsBusy == 0 &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123;            // 初始化标志，开始 【初始化 cells 数组】            boolean init = false;            try &#123;                // 再次判断 cells == as 防止其它线程已经提前初始化了，当前线程再次初始化导致丢失数据                // 因为这里是【线程安全的，重新检查，经典 DCL】                if (cells == as) &#123;                    Cell[] rs = new Cell[2];// 初始化数组大小为2                    rs[h &amp; 1] = new Cell(x);// 填充线程对应的cell                    cells = rs;                    init = true;// 初始化成功，标记置为 true                &#125;            &#125; finally &#123;                cellsBusy = 0;// 解锁啊            &#125;            if (init)                break;// 初始化成功直接跳出自旋        &#125;        // 【CASE3】: 运行到这说明其他线程在初始化 cells，当前线程将值累加到 base，累加成功直接结束自旋        else if (casBase(v = base, ((fn == null) ? v + x :                                    fn.applyAsLong(v, x))))            break;     &#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>sum：获取最终结果通过 sum 整合，<strong>保证最终一致性，不保证强一致性</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sum</span><span class="params">()</span> </span>&#123;    Cell[] as = cells; Cell a;    <span class="keyword">long</span> sum = base;    <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;        <span class="comment">// 遍历 累加        for (int i = 0; i &lt; as.length; ++i) &#123;            if ((a = as[i]) != null)                sum += a.value;        &#125;    &#125;    return sum;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="ABA"><a href="#ABA" class="headerlink" title="ABA"></a>ABA</h3><p>ABA 问题：当进行获取主内存值时，该内存值在写入主内存时已经被修改了 N 次，但是最终又改成原来的值</p><p>其他线程先把 A 改成 B 又改回 A，主线程<strong>仅能判断出共享变量的值与最初值 A 是否相同</strong>，不能感知到这种从 A 改为 B 又 改回 A 的情况，这时 CAS 虽然成功，但是过程存在问题</p><ul><li><p>构造方法：</p><ul><li><code>public AtomicStampedReference(V initialRef, int initialStamp)</code>：初始值和初始版本号</li></ul></li><li><p>常用API：</p><ul><li><code> public boolean compareAndSet(V expectedReference, V newReference, int expectedStamp, int newStamp)</code>：期望引用和期望版本号都一致才进行 CAS 修改数据</li><li><code>public void set(V newReference, int newStamp)</code>：设置值和版本号</li><li><code>public V getReference()</code>：返回引用的值</li><li><code>public int getStamp()</code>：返回当前版本号</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    AtomicStampedReference&lt;Integer&gt; atomicReference = <span class="keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="number">100</span>,<span class="number">1</span>);    <span class="keyword">int</span> startStamp = atomicReference.getStamp();    <span class="keyword">new</span> Thread(() -&gt;&#123;        <span class="keyword">int</span> stamp = atomicReference.getStamp();        atomicReference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>, stamp, stamp + <span class="number">1</span>);        stamp = atomicReference.getStamp();        atomicReference.compareAndSet(<span class="number">101</span>, <span class="number">100</span>, stamp, stamp + <span class="number">1</span>);    &#125;,<span class="string">&quot;t1&quot;</span>).start();    <span class="keyword">new</span> Thread(() -&gt;&#123;        <span class="keyword">try</span> &#123;            Thread.sleep(<span class="number">1000</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        <span class="keyword">if</span> (!atomicReference.compareAndSet(<span class="number">100</span>, <span class="number">200</span>, startStamp, startStamp + <span class="number">1</span>)) &#123;            System.out.println(atomicReference.getReference());<span class="comment">//100            System.out.println(Thread.currentThread().getName() + &quot;线程修改失败&quot;);        &#125;    &#125;,&quot;t2&quot;).start();&#125;</span></span><br></pre></td></tr></table></figure><hr><h3 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h3><p>Unsafe 是 CAS 的核心类，由于 Java 无法直接访问底层系统，需要通过本地（Native）方法来访问</p><p>Unsafe 类存在 sun.misc 包，其中所有方法都是 native 修饰的，都是直接调用<strong>操作系统底层资源</strong>执行相应的任务，基于该类可以直接操作特定的内存数据，其内部方法操作类似 C 的指针</p><p>模拟实现原子整数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    MyAtomicInteger atomicInteger = <span class="keyword">new</span> MyAtomicInteger(<span class="number">10</span>);    <span class="keyword">if</span> (atomicInteger.compareAndSwap(<span class="number">20</span>)) &#123;        System.out.println(atomicInteger.getValue());    &#125;&#125;<span class="class"><span class="keyword">class</span> <span class="title">MyAtomicInteger</span> </span>&#123;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe UNSAFE;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> VALUE_OFFSET;    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;    <span class="keyword">static</span> &#123;        <span class="keyword">try</span> &#123;            <span class="comment">//Unsafe unsafe = Unsafe.getUnsafe()这样会报错，需要反射获取            Field theUnsafe = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);            theUnsafe.setAccessible(true);            UNSAFE = (Unsafe) theUnsafe.get(null);            // 获取 value 属性的内存地址，value 属性指向该地址，直接设置该地址的值可以修改 value 的值            VALUE_OFFSET = UNSAFE.objectFieldOffset(                   MyAtomicInteger.class.getDeclaredField(&quot;value&quot;));        &#125; catch (NoSuchFieldException | IllegalAccessException e) &#123;            e.printStackTrace();            throw new RuntimeException();        &#125;    &#125;    public MyAtomicInteger(int value) &#123;        this.value = value;    &#125;    public int getValue() &#123;        return value;    &#125;    public boolean compareAndSwap(int update) &#123;        while (true) &#123;            int prev = this.value;            int next = update;            //当前对象  内存偏移量    期望值 更新值            if (UNSAFE.compareAndSwapInt(this, VALUE_OFFSET, prev, update)) &#123;                System.out.println(&quot;CAS成功&quot;);                return true;            &#125;        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFinal</span> </span>&#123;<span class="keyword">final</span> <span class="keyword">int</span> a = <span class="number">20</span>;&#125;</span><br></pre></td></tr></table></figure><p>字节码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: aload_01: invokespecial #<span class="number">1</span> <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V4: aload_05: bipush 20// 将值直接放入栈中7: putfield #2 // Field a:I&lt;-- 写屏障10: return</span></span><br></pre></td></tr></table></figure><p>final 变量的赋值通过 putfield 指令来完成，在这条指令之后也会加入写屏障，保证在其它线程读到它的值时不会出现为 0 的情况</p><p>其他线程访问 final 修饰的变量<strong>会复制一份放入栈中</strong>，效率更高</p><hr><h4 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h4><p>不可变：如果一个对象不能够修改其内部状态（属性），那么就是不可变对象</p><p>不可变对象线程安全的，因为不存在并发修改，是另一种避免竞争的方式</p><p>String 类也是不可变的，该类和类中所有属性都是 final 的</p><ul><li><p>类用 final 修饰保证了该类中的方法不能被覆盖，防止子类无意间破坏不可变性</p></li><li><p>无写入方法（set）确保外部不能对内部属性进行修改</p></li><li><p>属性用 final 修饰保证了该属性是只读的，不能修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span>    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;    <span class="comment">/** The value is used for character storage. */</span>    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];    <span class="comment">//....&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>更改 String 类数据时，会构造新字符串对象，生成新的 char[] value，通过<strong>创建副本对象来避免共享的方式称之为保护性拷贝</strong></p></li></ul><hr><h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p>无状态：成员变量保存的数据也可以称为状态信息，无状态就是没有成员变量</p><p>Servlet 为了保证其线程安全，一般不为 Servlet 设置成员变量，这种没有任何成员变量的类是线程安全的</p><hr><h3 id="Local"><a href="#Local" class="headerlink" title="Local"></a>Local</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>ThreadLocal 类用来提供线程内部的局部变量，这种变量在多线程环境下访问（通过 get 和 set 方法访问）时能保证各个线程的变量相对独立于其他线程内的变量，分配在堆内的 TLAB 中</p><p>ThreadLocal 实例通常来说都是 <code>private static</code> 类型的，属于一个线程的本地变量，用于关联线程和线程上下文。每个线程都会在 ThreadLocal 中保存一份该线程独有的数据，所以是线程安全的</p><p>ThreadLocal 作用：</p><ul><li><p>线程并发：应用在多线程并发的场景下</p></li><li><p>传递数据：通过 ThreadLocal 实现在同一线程不同函数或组件中传递公共变量，减少传递复杂度</p></li><li><p>线程隔离：每个线程的变量都是独立的，不会互相影响</p></li></ul><p>对比 synchronized：</p><table><thead><tr><th></th><th>synchronized</th><th>ThreadLocal</th></tr></thead><tbody><tr><td>原理</td><td>同步机制采用<strong>以时间换空间</strong>的方式，只提供了一份变量，让不同的线程排队访问</td><td>ThreadLocal 采用<strong>以空间换时间</strong>的方式，为每个线程都提供了一份变量的副本，从而实现同时访问而相不干扰</td></tr><tr><td>侧重点</td><td>多个线程之间访问资源的同步</td><td>多线程中让每个线程之间的数据相互隔离</td></tr></tbody></table><hr><h4 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h4><h5 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h5><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>ThreadLocal&lt;&gt;()</td><td>创建 ThreadLocal 对象</td></tr><tr><td>protected T initialValue()</td><td>返回当前线程局部变量的初始值</td></tr><tr><td>public void set( T value)</td><td>设置当前线程绑定的局部变量</td></tr><tr><td>public T get()</td><td>获取当前线程绑定的局部变量</td></tr><tr><td>public void remove()</td><td>移除当前线程绑定的局部变量</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDemo</span> </span>&#123;    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; tl = <span class="keyword">new</span> ThreadLocal&lt;&gt;();    <span class="keyword">private</span> String content;    <span class="function"><span class="keyword">private</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;        <span class="comment">// 获取当前线程绑定的变量        return tl.get();    &#125;    private void setContent(String content) &#123;        // 变量content绑定到当前线程        tl.set(content);    &#125;    public static void main(String[] args) &#123;        MyDemo demo = new MyDemo();        for (int i = 0; i &lt; 5; i++) &#123;            Thread thread = new Thread(new Runnable() &#123;                @Override                public void run() &#123;                    // 设置数据                    demo.setContent(Thread.currentThread().getName() + &quot;的数据&quot;);                    System.out.println(&quot;-----------------------&quot;);                    System.out.println(Thread.currentThread().getName() + &quot;---&gt;&quot; + demo.getContent());                &#125;            &#125;);            thread.setName(&quot;线程&quot; + i);            thread.start();        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h5 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h5><p>ThreadLocal 适用于下面两种场景：</p><ul><li>每个线程需要有自己单独的实例</li><li>实例需要在多个方法中共享，但不希望被多线程共享</li></ul><p>ThreadLocal 方案有两个突出的优势： </p><ol><li>传递数据：保存每个线程绑定的数据，在需要的地方可以直接获取，避免参数直接传递带来的代码耦合问题</li><li>线程隔离：各线程之间的数据相互隔离却又具备并发性，避免同步方式带来的性能损失</li></ol><p>ThreadLocal 用于数据连接的事务管理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcUtils</span> </span>&#123;    <span class="comment">// ThreadLocal对象，将connection绑定在当前线程中    private static final ThreadLocal&lt;Connection&gt; tl = new ThreadLocal();    // c3p0 数据库连接池对象属性    private static final ComboPooledDataSource ds = new ComboPooledDataSource();    // 获取连接    public static Connection getConnection() throws SQLException &#123;        //取出当前线程绑定的connection对象        Connection conn = tl.get();        if (conn == null) &#123;            //如果没有，则从连接池中取出            conn = ds.getConnection();            //再将connection对象绑定到当前线程中，非常重要的操作            tl.set(conn);        &#125;        return conn;    &#125;// ...&#125;</span></span><br></pre></td></tr></table></figure><p>用 ThreadLocal 使 SimpleDateFormat 从独享变量变成单个线程变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalDateUtil</span> </span>&#123;    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;DateFormat&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;DateFormat&gt;() &#123;        <span class="meta">@Override</span>        <span class="function"><span class="keyword">protected</span> DateFormat <span class="title">initialValue</span><span class="params">()</span> </span>&#123;            <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);        &#125;    &#125;;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">parse</span><span class="params">(String dateStr)</span> <span class="keyword">throws</span> ParseException </span>&#123;        <span class="keyword">return</span> threadLocal.get().parse(dateStr);    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">format</span><span class="params">(Date date)</span> </span>&#123;        <span class="keyword">return</span> threadLocal.get().format(date);    &#125;&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><h5 id="底层结构"><a href="#底层结构" class="headerlink" title="底层结构"></a>底层结构</h5><p>JDK8 以前：每个 ThreadLocal 都创建一个 Map，然后用线程作为 Map 的 key，要存储的局部变量作为 Map 的 value，达到各个线程的局部变量隔离的效果。这种结构会造成 Map 结构过大和内存泄露，因为 Thread 停止后无法通过 key 删除对应的数据</p><p><img src="https://gitee.com/seazean/images/raw/master/Java/JUC-ThreadLocal%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84JDK8%E5%89%8D.png"></p><p>JDK8 以后：每个 Thread 维护一个 ThreadLocalMap，这个 Map 的 key 是 ThreadLocal 实例本身，value 是真正要存储的值</p><ul><li>每个 Thread 线程内部都有一个 Map (ThreadLocalMap)</li><li>Map 里面存储 ThreadLocal 对象（key）和线程的变量副本（value）</li><li>Thread 内部的 Map 是由 ThreadLocal 维护的，由 ThreadLocal 负责向 map 获取和设置线程的变量值</li><li>对于不同的线程，每次获取副本值时，别的线程并不能获取到当前线程的副本值，形成副本的隔离，互不干扰</li></ul><p><img src="https://gitee.com/seazean/images/raw/master/Java/JUC-ThreadLocal%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84JDK8%E5%90%8E.png"></p><p>JDK8 前后对比：</p><ul><li>每个 Map 存储的 Entry 数量会变少，因为之前的存储数量由 Thread 的数量决定，现在由 ThreadLocal 的数量决定，在实际编程当中，往往 ThreadLocal 的数量要少于 Thread 的数量</li><li>当 Thread 销毁之后，对应的 ThreadLocalMap 也会随之销毁，能减少内存的使用，<strong>防止内存泄露</strong></li></ul><hr><h5 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h5><ul><li><p>Thread 类的相关属性：<strong>每一个线程持有一个 ThreadLocalMap 对象</strong>，存放由 ThreadLocal 和数据组成的 Entry 键值对</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span></span><br></pre></td></tr></table></figure></li><li><p>计算 ThreadLocal 对象的哈希值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode()</span><br></pre></td></tr></table></figure><p>使用 <code>threadLocalHashCode &amp; (table.length - 1)</code> 计算当前 entry 需要存放的位置</p></li><li><p>每创建一个 ThreadLocal 对象就会使用 nextHashCode 分配一个 hash 值给这个对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode = <span class="keyword">new</span> AtomicInteger()</span><br></pre></td></tr></table></figure></li><li><p>斐波那契数也叫黄金分割数，hash 的<strong>增量</strong>就是这个数字，带来的好处是 hash 分布非常均匀：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span></span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h5><p>方法都是线程安全的，因为 ThreadLocal 属于一个线程的，ThreadLocal 中的方法，逻辑都是获取当前线程维护的 ThreadLocalMap 对象，然后进行数据的增删改查，没有指定初始值的 threadlcoal 对象默认赋值为 null</p><ul><li><p>initialValue()：返回该线程局部变量的初始值</p><ul><li>延迟调用的方法，在执行 get 方法时才执行</li><li>该方法缺省（默认）实现直接返回一个 null</li><li>如果想要一个初始值，可以重写此方法， 该方法是一个 <code>protected</code> 的方法，为了让子类覆盖而设计的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;    <span class="keyword">return</span> <span class="keyword">null</span>;&#125;</span><br></pre></td></tr></table></figure></li><li><p>nextHashCode()：计算哈希值，ThreadLocal 的散列方式称之为<strong>斐波那契散列</strong>，每次获取哈希值都会加上 HASH_INCREMENT，这样做可以尽量避免 hash 冲突，让哈希值能均匀的分布在 2 的 n 次方的数组中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;    <span class="comment">// 哈希值自增一个 HASH_INCREMENT 数值    return nextHashCode.getAndAdd(HASH_INCREMENT);&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>set()：修改当前线程与当前 threadlocal 对象相关联的线程局部变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;    <span class="comment">// 获取当前线程对象    Thread t = Thread.currentThread();    // 获取此线程对象中维护的 ThreadLocalMap 对象    ThreadLocalMap map = getMap(t);    // 判断 map 是否存在    if (map != null)        // 调用 threadLocalMap.set 方法进行重写或者添加        map.set(this, value);    else        // map 为空，调用 createMap 进行 ThreadLocalMap 对象的初始化。参数1是当前线程，参数2是局部变量        createMap(t, value);&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前线程 Thread 对应维护的 ThreadLocalMap ThreadLocalMap getMap(Thread t) &#123;    return t.threadLocals;&#125;// 创建当前线程Thread对应维护的ThreadLocalMap void createMap(Thread t, T firstValue) &#123;    // 【这里的 this 是调用此方法的 threadLocal】，创建一个新的 Map 并设置第一个数据    t.threadLocals = new ThreadLocalMap(this, firstValue);&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>get()：获取当前线程与当前 ThreadLocal 对象相关联的线程局部变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;    Thread t = Thread.currentThread();    ThreadLocalMap map = getMap(t);    <span class="comment">// 如果此map存在    if (map != null) &#123;        // 以当前的 ThreadLocal 为 key，调用 getEntry 获取对应的存储实体 e        ThreadLocalMap.Entry e = map.getEntry(this);        // 对 e 进行判空         if (e != null) &#123;            // 获取存储实体 e 对应的 value值            T result = (T)e.value;            return result;        &#125;    &#125;    /*有两种情况有执行当前代码      第一种情况: map 不存在，表示此线程没有维护的 ThreadLocalMap 对象      第二种情况: map 存在, 但是【没有与当前 ThreadLocal 关联的 entry】，就会设置为默认值 */    // 初始化当前线程与当前 threadLocal 对象相关联的 value    return setInitialValue();&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;    <span class="comment">// 调用initialValue获取初始化的值，此方法可以被子类重写, 如果不重写默认返回 null    T value = initialValue();    Thread t = Thread.currentThread();    ThreadLocalMap map = getMap(t);    // 判断 map 是否初始化过    if (map != null)        // 存在则调用 map.set 设置此实体 entry，value 是默认的值        map.set(this, value);    else        // 调用 createMap 进行 ThreadLocalMap 对象的初始化中        createMap(t, value);    // 返回线程与当前 threadLocal 关联的局部变量    return value;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>remove()：移除当前线程与当前 threadLocal 对象相关联的线程局部变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;    <span class="comment">// 获取当前线程对象中维护的 ThreadLocalMap 对象    ThreadLocalMap m = getMap(Thread.currentThread());    if (m != null)        // map 存在则调用 map.remove，this时当前ThreadLocal，以this为key删除对应的实体        m.remove(this);&#125;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="LocalMap"><a href="#LocalMap" class="headerlink" title="LocalMap"></a>LocalMap</h4><h5 id="成员属性"><a href="#成员属性" class="headerlink" title="成员属性"></a>成员属性</h5><p>ThreadLocalMap 是 ThreadLocal 的内部类，没有实现 Map 接口，用独立的方式实现了 Map 的功能，其内部 Entry 也是独立实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化当前 map 内部散列表数组的初始长度 16private static final int INITIAL_CAPACITY = 16;// 存放数据的table，数组长度必须是2的整次幂。private Entry[] table;// 数组里面 entrys 的个数，可以用于判断 table 当前使用量是否超过阈值private int size = 0;// 进行扩容的阈值，表使用量大于它的时候进行扩容。private int threshold;</span></span><br></pre></td></tr></table></figure><p>存储结构 Entry：</p><ul><li>Entry 继承 WeakReference，key 是弱引用，目的是将 ThreadLocal 对象的生命周期和线程生命周期解绑</li><li>Entry 限制只能用 ThreadLocal 作为 key，key 为 null (entry.get() == null) 意味着 key 不再被引用，entry 也可以从 table 中清除</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;    Object value;    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;        <span class="comment">// this.referent = referent = key;        super(k);        value = v;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>构造方法：延迟初始化的，线程第一次存储 threadLocal - value 时才会创建 threadLocalMap 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;    <span class="comment">// 初始化table，创建一个长度为16的Entry数组    table = new Entry[INITIAL_CAPACITY];    // 【寻址算法】计算索引    int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1);    // 创建 entry 对象，存放到指定位置的 slot 中    table[i] = new Entry(firstKey, firstValue);    // 数据总量是 1    size = 1;    // 将阈值设置为 （当前数组长度 * 2）/ 3。    setThreshold(INITIAL_CAPACITY);&#125;</span></span><br></pre></td></tr></table></figure><hr><h5 id="成员方法-1"><a href="#成员方法-1" class="headerlink" title="成员方法"></a>成员方法</h5><ul><li><p>set()：添加数据，ThreadLocalMap 使用<strong>线性探测法来解决哈希冲突</strong></p><ul><li><p>该方法会一直探测下一个地址，直到有空的地址后插入，若插入后 Map 数量超过阈值，数组会扩容为原来的 2 倍</p><p>假设当前 table 长度为16，计算出来 key 的 hash 值为 14，如果 table[14] 上已经有值，并且其 key 与当前 key 不一致，那么就发生了 hash 冲突，这个时候将 14 加 1 得到 15，取 table[15] 进行判断，如果还是冲突会回到 0，取 table[0]，以此类推，直到可以插入，可以把 Entry[]  table 看成一个<strong>环形数组</strong></p></li><li><p>线性探测法会出现<strong>堆积问题</strong>，可以采取平方探测法解决</p></li><li><p>在探测过程中 ThreadLocal 会复用 key 为 null 的脏 Entry 对象，并进行垃圾清理，防止出现内存泄漏</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;    <span class="comment">// 获取散列表    ThreadLocal.ThreadLocalMap.Entry[] tab = table;    int len = tab.length;    // 哈希寻址    int i = key.threadLocalHashCode &amp; (len-1);    // 使用线性探测法向后查找元素，碰到 entry 为空时停止探测    for (ThreadLocal.ThreadLocalMap.Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123;        // 获取当前元素 key        ThreadLocal&lt;?&gt; k = e.get();        // ThreadLocal 对应的 key 存在，【直接覆盖之前的值】        if (k == key) &#123;            e.value = value;            return;        &#125;        // 【这两个条件谁先成立不一定，所以 replaceStaleEntry 中还需要判断 k == key 的情况】                // key 为 null，但是值不为 null，说明之前的 ThreadLocal 对象已经被回收了，当前是【过期数据】        if (k == null) &#123;            // 【碰到一个过期的 slot，当前数据复用该槽位，替换过期数据】            // 这个方法还进行了垃圾清理动作，防止内存泄漏            replaceStaleEntry(key, value, i);            return;        &#125;    &#125;// 逻辑到这说明碰到 slot == null 的位置，则在空元素的位置创建一个新的 Entry    tab[i] = new Entry(key, value);    // 数量 + 1    int sz = ++size;        // 【做一次启发式清理】，如果没有清除任何 entry 并且【当前使用量达到了负载因子所定义，那么进行 rehash    if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)        // 扩容        rehash();&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取【环形数组】的下一个索引private static int nextIndex(int i, int len) &#123;    // 索引越界后从 0 开始继续获取    return ((i + 1 &lt; len) ? i + 1 : 0);&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在指定位置插入指定的数据private void replaceStaleEntry(ThreadLocal&lt;?&gt; key, Object value, int staleSlot) &#123;    // 获取散列表    Entry[] tab = table;    int len = tab.length;    Entry e;// 探测式清理的开始下标，默认从当前 staleSlot 开始    int slotToExpunge = staleSlot;    // 以当前 staleSlot 开始【向前迭代查找】，找到索引靠前过期数据，找到以后替换 slotToExpunge 值    // 【保证在一个区间段内，从最前面的过期数据开始清理】    for (int i = prevIndex(staleSlot, len); (e = tab[i]) != null; i = prevIndex(i, len))        if (e.get() == null)            slotToExpunge = i;// 以 staleSlot 【向后去查找】，直到碰到 null 为止，还是线性探测    for (int i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) &#123;        // 获取当前节点的 key        ThreadLocal&lt;?&gt; k = e.get();// 条件成立说明是【替换逻辑】        if (k == key) &#123;            e.value = value;            // 因为本来要在 staleSlot 索引处插入该数据，现在找到了i索引处的key与数据一致            // 但是 i 位置距离正确的位置更远，因为是向后查找，所以还是要在 staleSlot 位置插入当前 entry            // 然后将 table[staleSlot] 这个过期数据放到当前循环到的 table[i] 这个位置，            tab[i] = tab[staleSlot];            tab[staleSlot] = e;            // 条件成立说明向前查找过期数据并未找到过期的 entry，但 staleSlot 位置已经不是过期数据了，i 位置才是            if (slotToExpunge == staleSlot)                slotToExpunge = i;                        // 【清理过期数据，expungeStaleEntry 探测式清理，cleanSomeSlots 启发式清理】            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);            return;        &#125;// 条件成立说明当前遍历的 entry 是一个过期数据，并且该位置前面也没有过期数据        if (k == null &amp;&amp; slotToExpunge == staleSlot)            // 探测式清理过期数据的开始下标修改为当前循环的 index，因为 staleSlot 会放入要添加的数据            slotToExpunge = i;    &#125;// 向后查找过程中并未发现 k == key 的 entry，说明当前是一个【取代过期数据逻辑】    // 删除原有的数据引用，防止内存泄露    tab[staleSlot].value = null;    // staleSlot 位置添加数据，【上面的所有逻辑都不会更改 staleSlot 的值】    tab[staleSlot] = new Entry(key, value);    // 条件成立说明除了 staleSlot 以外，还发现其它的过期 slot，所以要【开启清理数据的逻辑】    if (slotToExpunge != staleSlot)        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);&#125;</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/seazean/images/raw/master/Java/JUC-replaceStaleEntry%E6%B5%81%E7%A8%8B.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">prevIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;    <span class="comment">// 形成一个环绕式的访问，头索引越界后置为尾索引    return ((i - 1 &gt;= 0) ? i - 1 : len - 1);&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>getEntry()：ThreadLocal 的 get 方法以当前的 ThreadLocal 为 key，调用 getEntry 获取对应的存储实体 e</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;    <span class="comment">// 哈希寻址    int i = key.threadLocalHashCode &amp; (table.length - 1);    // 访问散列表中指定指定位置的 slot     Entry e = table[i];    // 条件成立，说明 slot 有值并且 key 就是要寻找的 key，直接返回    if (e != null &amp;&amp; e.get() == key)        return e;    else        // 进行线性探测        return getEntryAfterMiss(key, i, e);&#125;// 线性探测寻址private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) &#123;    // 获取散列表    Entry[] tab = table;    int len = tab.length;    // 开始遍历，碰到 slot == null 的情况，搜索结束    while (e != null) &#123;// 获取当前 slot 中 entry 对象的 key        ThreadLocal&lt;?&gt; k = e.get();        // 条件成立说明找到了，直接返回        if (k == key)            return e;        if (k == null)             // 过期数据，【探测式过期数据回收】            expungeStaleEntry(i);        else            // 更新 index 继续向后走            i = nextIndex(i, len);        // 获取下一个槽位中的 entry        e = tab[i];    &#125;    // 说明当前区段没有找到相应数据    // 【因为存放数据是线性的向后寻找槽位，都是紧挨着的，不可能越过一个 空槽位 在后面放】，可以减少遍历的次数    return null;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>rehash()：触发一次全量清理，如果数组长度大于等于长度的 <code>2/3 * 3/4 = 1/2</code>，则进行 resize</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;    <span class="comment">// 清楚当前散列表内的【所有】过期的数据    expungeStaleEntries();        // threshold = len * 2 / 3，就是 2/3 * (1 - 1/4)    if (size &gt;= threshold - threshold / 4)        resize();&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expungeStaleEntries</span><span class="params">()</span> </span>&#123;    Entry[] tab = table;    <span class="keyword">int</span> len = tab.length;    <span class="comment">// 【遍历所有的槽位，清理过期数据】    for (int j = 0; j &lt; len; j++) &#123;        Entry e = tab[j];        if (e != null &amp;&amp; e.get() == null)            expungeStaleEntry(j);    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>Entry <strong>数组为扩容为原来的 2 倍</strong> ，重新计算 key 的散列值，如果遇到 key 为 null 的情况，会将其 value 也置为 null，帮助 GC</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;    Entry[] oldTab = table;    <span class="keyword">int</span> oldLen = oldTab.length;    <span class="comment">// 新数组的长度是老数组的二倍    int newLen = oldLen * 2;    Entry[] newTab = new Entry[newLen];    // 统计新table中的entry数量    int count = 0;// 遍历老表，进行【数据迁移】    for (int j = 0; j &lt; oldLen; ++j) &#123;        // 访问老表的指定位置的 entry        Entry e = oldTab[j];        // 条件成立说明老表中该位置有数据，可能是过期数据也可能不是        if (e != null) &#123;            ThreadLocal&lt;?&gt; k = e.get();            // 过期数据            if (k == null) &#123;                e.value = null; // Help the GC            &#125; else &#123;                // 非过期数据，在新表中进行哈希寻址                int h = k.threadLocalHashCode &amp; (newLen - 1);                // 【线程探测】                while (newTab[h] != null)                    h = nextIndex(h, newLen);                // 将数据存放到新表合适的 slot 中                newTab[h] = e;                count++;            &#125;        &#125;    &#125;// 设置下一次触发扩容的指标：threshold = len * 2 / 3;    setThreshold(newLen);    size = count;    // 将扩容后的新表赋值给 threadLocalMap 内部散列表数组引用    table = newTab;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>remove()：删除 Entry</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;    Entry[] tab = table;    <span class="keyword">int</span> len = tab.length;    <span class="comment">// 哈希寻址    int i = key.threadLocalHashCode &amp; (len-1);    for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123;        // 找到了对应的 key        if (e.get() == key) &#123;            // 设置 key 为 null            e.clear();            // 探测式清理            expungeStaleEntry(i);            return;        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="清理方法"><a href="#清理方法" class="headerlink" title="清理方法"></a>清理方法</h5><ul><li><p>探测式清理：沿着开始位置向后探测清理过期数据，沿途中碰到未过期数据则将此数据 rehash 在 table 数组中的定位，重定位后的元素理论上更接近 <code>i = entry.key &amp; (table.length - 1)</code>，让<strong>数据的排列更紧凑</strong>，会优化整个散列表查询性能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// table[staleSlot] 是一个过期数据，以这个位置开始继续向后查找过期数据private int expungeStaleEntry(int staleSlot) &#123;    // 获取散列表和数组长度    Entry[] tab = table;    int len = tab.length;    // help gc，先把当前过期的 entry 置空，在取消对 entry 的引用    tab[staleSlot].value = null;    tab[staleSlot] = null;    // 数量-1    size--;    Entry e;    int i;    // 从 staleSlot 开始向后遍历，直到碰到 slot == null 结束，【区间内清理过期数据】    for (i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) &#123;        ThreadLocal&lt;?&gt; k = e.get();        // 当前 entry 是过期数据        if (k == null) &#123;            // help gc            e.value = null;            tab[i] = null;            size--;        &#125; else &#123;            // 当前 entry 不是过期数据的逻辑            // 重新计算当前 entry 对应的 index            int h = k.threadLocalHashCode &amp; (len - 1);            // 条件成立说明当前 entry 存储时发生过 hash 冲突，向后偏移过了            if (h != i) &#123;                // 当前位置置空                tab[i] = null;                // 以正确位置 h 开始，向后查找第一个可以存放 entry 的位置                while (tab[h] != null)                    h = nextIndex(h, len);                // 将当前元素放入到【距离正确位置更近的位置，有可能就是正确位置】                tab[h] = e;            &#125;        &#125;    &#125;    // 返回 slot = null 的槽位索引，图例是 7，这个索引代表【索引前面的区间已经清理完成垃圾了】    return i;&#125;</span></span><br></pre></td></tr></table></figure><img src="https://gitee.com/seazean/images/raw/master/Java/JUC-ThreadLocal探测式清理1.png" style="zoom:67%;"><img src="https://gitee.com/seazean/images/raw/master/Java/JUC-ThreadLocal探测式清理2.png" style="zoom:67%;"></li><li><p>启发式清理：向后循环扫描过期数据，发现过期数据调用探测式清理方法，如果连续几次的循环都没有发现过期数据，就停止扫描</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  i 表示启发式清理工作开始位置，一般是空 slot，n 一般传递的是 table.length private boolean cleanSomeSlots(int i, int n) &#123;    // 表示启发式清理工作是否清除了过期数据    boolean removed = false;    // 获取当前 map 的散列表引用    Entry[] tab = table;    int len = tab.length;    do &#123;        // 获取下一个索引，因为探测式返回的 slot 为 null        i = nextIndex(i, len);        Entry e = tab[i];        // 条件成立说明是过期的数据，key 被 gc 了        if (e != null &amp;&amp; e.get() == null) &#123;            // 【发现过期数据重置 n 为数组的长度】            n = len;            // 表示清理过过期数据            removed = true;            // 以当前过期的 slot 为开始节点 做一次探测式清理工作            i = expungeStaleEntry(i);        &#125;        // 假设 table 长度为 16        // 16 &gt;&gt;&gt; 1 ==&gt; 8，8 &gt;&gt;&gt; 1 ==&gt; 4，4 &gt;&gt;&gt; 1 ==&gt; 2，2 &gt;&gt;&gt; 1 ==&gt; 1，1 &gt;&gt;&gt; 1 ==&gt; 0        // 连续经过这么多次循环【没有扫描到过期数据】，就停止循环，扫描到空 slot 不算，因为不是过期数据    &#125; while ((n &gt;&gt;&gt;= 1) != 0);        // 返回清除标记    return removed;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><p>参考视频：<a href="https://space.bilibili.com/457326371/">https://space.bilibili.com/457326371/</a></p><hr><h4 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h4><p>Memory leak：内存泄漏是指程序中动态分配的堆内存由于某种原因未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果，内存泄漏的堆积终将导致内存溢出</p><ul><li><p>如果 key 使用强引用：使用完 ThreadLocal ，threadLocal Ref 被回收，但是 threadLocalMap 的 Entry 强引用了 threadLocal，造成 threadLocal 无法被回收，无法完全避免内存泄漏</p><img src="https://gitee.com/seazean/images/raw/master/Java/JUC-ThreadLocal内存泄漏强引用.png" style="zoom:67%;"></li><li><p>如果 key 使用弱引用：使用完 ThreadLocal ，threadLocal Ref 被回收，ThreadLocalMap 只持有 ThreadLocal 的弱引用，所以threadlocal 也可以被回收，此时 Entry 中的 key = null。但没有手动删除这个 Entry 或者 CurrentThread 依然运行，依然存在强引用链，value 不会被回收，而这块 value 永远不会被访问到，也会导致 value 内存泄漏</p><img src="https://gitee.com/seazean/images/raw/master/Java/JUC-ThreadLocal内存泄漏弱引用.png" style="zoom:67%;"></li><li><p>两个主要原因：</p><ul><li>没有手动删除这个 Entry</li><li>CurrentThread 依然运行</li></ul></li></ul><p>根本原因：ThreadLocalMap 是 Thread的一个属性，生命周期跟 Thread 一样长，如果没有手动删除对应 Entry 就会导致内存泄漏</p><p>解决方法：使用完 ThreadLocal 中存储的内容后将它 remove 掉就可以</p><p>ThreadLocal 内部解决方法：在 ThreadLocalMap 中的 set/getEntry 方法中，通过线性探测法对 key 进行判断，如果 key 为 null（ThreadLocal 为 null）会对 Entry 进行垃圾回收。所以<strong>使用弱引用比强引用多一层保障</strong>，就算不调用 remove，也有机会进行 GC</p><hr><h4 id="变量传递"><a href="#变量传递" class="headerlink" title="变量传递"></a>变量传递</h4><h5 id="基本使用-2"><a href="#基本使用-2" class="headerlink" title="基本使用"></a>基本使用</h5><p>父子线程：<strong>创建子线程的线程是父线程</strong>，比如实例中的 main 线程就是父线程</p><p>ThreadLocal 中存储的是线程的局部变量，如果想实现线程间局部变量传递可以使用 InheritableThreadLocal 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> InheritableThreadLocal&lt;&gt;();    threadLocal.set(<span class="string">&quot;父线程设置的值&quot;</span>);    <span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">&quot;子线程输出：&quot;</span> + threadLocal.get())).start();&#125;<span class="comment">// 子线程输出：父线程设置的值</span></span><br></pre></td></tr></table></figure><hr><h5 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h5><p>InheritableThreadLocal 源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritableThreadLocal</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;    <span class="function"><span class="keyword">protected</span> T <span class="title">childValue</span><span class="params">(T parentValue)</span> </span>&#123;        <span class="keyword">return</span> parentValue;    &#125;    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;       <span class="keyword">return</span> t.inheritableThreadLocals;    &#125;    <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;        t.inheritableThreadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);    &#125;&#125;</span><br></pre></td></tr></table></figure><p>实现父子线程间的局部变量共享需要追溯到 Thread 对象的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name, <span class="keyword">long</span> stackSize, AccessControlContext acc,                  // 该参数默认是 <span class="keyword">true</span>                  <span class="keyword">boolean</span> inheritThreadLocals)</span> </span>&#123;  <span class="comment">// ...    Thread parent = currentThread();    // 判断父线程（创建子线程的线程）的 inheritableThreadLocals 属性不为 null    if (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != null) &#123;        // 复制父线程的 inheritableThreadLocals 属性，实现父子线程局部变量共享        this.inheritableThreadLocals = ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);     &#125;    // ..&#125;// 【本质上还是创建 ThreadLocalMap，只是把父类中的可继承数据设置进去了】static ThreadLocalMap createInheritedMap(ThreadLocalMap parentMap) &#123;    return new ThreadLocalMap(parentMap);&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ThreadLocalMap</span><span class="params">(ThreadLocalMap parentMap)</span> </span>&#123;    <span class="comment">// 获取父线程的哈希表    Entry[] parentTable = parentMap.table;    int len = parentTable.length;    setThreshold(len);    table = new Entry[len];// 【逐个复制父线程 ThreadLocalMap 中的数据】    for (int j = 0; j &lt; len; j++) &#123;        Entry e = parentTable[j];        if (e != null) &#123;            ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get();            if (key != null) &#123;                // 调用的是 InheritableThreadLocal#childValue(T parentValue)                Object value = key.childValue(e.value);                Entry c = new Entry(key, value);                int h = key.threadLocalHashCode &amp; (len - 1);                // 线性探测                while (table[h] != null)                    h = nextIndex(h, len);                table[h] = c;                size++;            &#125;        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>参考文章：<a href="https://blog.csdn.net/feichitianxia/article/details/110495764">https://blog.csdn.net/feichitianxia/article/details/110495764</a></p><hr><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h3><p>线程池：一个容纳多个线程的容器，容器中的线程可以重复使用，省去了频繁创建和销毁线程对象的操作</p><p>线程池作用：</p><ol><li>降低资源消耗，减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务</li><li>提高响应速度，当任务到达时，如果有线程可以直接用，不会出现系统僵死</li><li>提高线程的可管理性，如果无限制的创建线程，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控</li></ol><p>线程池的核心思想：<strong>线程复用</strong>，同一个线程可以被重复使用，来处理多个任务</p><p>池化技术 (Pool) ：一种编程技巧，核心思想是资源复用，在请求量大时能优化应用性能，降低系统频繁建连的资源开销</p><hr><h3 id="阻塞队列-1"><a href="#阻塞队列-1" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><h4 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>有界队列和无界队列：</p><ul><li><p>有界队列：有固定大小的队列，比如设定了固定大小的 LinkedBlockingQueue，又或者大小为 0</p></li><li><p>无界队列：没有设置固定大小的队列，这些队列可以直接入队，直到溢出（超过 Integer.MAX_VALUE），所以相当于无界</p></li></ul><p>java.util.concurrent.BlockingQueue 接口有以下阻塞队列的实现：<strong>FIFO 队列</strong> </p><ul><li>ArrayBlockQueue：由数组结构组成的有界阻塞队列</li><li>LinkedBlockingQueue：由链表结构组成的无界（默认大小 Integer.MAX_VALUE）的阻塞队列</li><li>PriorityBlockQueue：支持优先级排序的无界阻塞队列</li><li>DelayedWorkQueue：使用优先级队列实现的延迟无界阻塞队列</li><li>SynchronousQueue：不存储元素的阻塞队列，每一个生产线程会阻塞到有一个 put 的线程放入元素为止</li><li>LinkedTransferQueue：由链表结构组成的无界阻塞队列</li><li>LinkedBlockingDeque：由链表结构组成的<strong>双向</strong>阻塞队列</li></ul><p>与普通队列（LinkedList、ArrayList等）的不同点在于阻塞队列中阻塞添加和阻塞删除方法，以及线程安全：</p><ul><li>阻塞添加 take()：当阻塞队列元素已满时，添加队列元素的线程会被阻塞，直到队列元素不满时才重新唤醒线程执行</li><li>阻塞删除 put()：在队列元素为空时，删除队列元素的线程将被阻塞，直到队列不为空再执行删除操作(一般都会返回被删除的元素)</li></ul><hr><h4 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h4><table><thead><tr><th>方法类型</th><th>抛出异常</th><th>特殊值</th><th>阻塞</th><th>超时</th></tr></thead><tbody><tr><td>插入</td><td>add(e)</td><td>offer(e)</td><td>put(e)</td><td>offer(e,time,unit)</td></tr><tr><td>移除</td><td>remove()</td><td>poll()</td><td>take()</td><td>poll(time,unit)</td></tr><tr><td>检查（队首元素）</td><td>element()</td><td>peek()</td><td>不可用</td><td>不可用</td></tr></tbody></table><ul><li>抛出异常组：<ul><li>当阻塞队列满时：在往队列中 add 插入元素会抛出 IIIegalStateException: Queue full</li><li>当阻塞队列空时：再往队列中 remove 移除元素，会抛出 NoSuchException</li></ul></li><li>特殊值组：<ul><li>插入方法：成功 true，失败 false</li><li>移除方法：成功返回出队列元素，队列没有就返回 null</li></ul></li><li>阻塞组：<ul><li>当阻塞队列满时，生产者继续往队列里 put 元素，队列会一直阻塞生产线程直到 put 数据或响应中断退出</li><li>当阻塞队列空时，消费者线程试图从队列里 take 元素，队列会一直阻塞消费者线程直到队列中有可用元素</li></ul></li><li>超时退出：当阻塞队列满时，队里会阻塞生产者线程一定时间，超过限时后生产者线程会退出</li></ul><hr><h4 id="链表队列"><a href="#链表队列" class="headerlink" title="链表队列"></a>链表队列</h4><h5 id="入队出队"><a href="#入队出队" class="headerlink" title="入队出队"></a>入队出队</h5><p>LinkedBlockingQueue源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;<span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;        E item;        <span class="comment">/**        * 下列三种情况之一        * - 真正的后继节点        * - 自己, 发生在出队时        * - null, 表示是没有后继节点, 是尾节点了        */</span>        Node&lt;E&gt; next;        Node(E x) &#123; item = x; &#125;    &#125;&#125;</span><br></pre></td></tr></table></figure><p>入队：<strong>尾插法</strong></p><ul><li><p>初始化链表 <code>last = head = new Node&lt;E&gt;(null)</code>，<strong>Dummy 节点用来占位</strong>，item 为 null</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;    <span class="comment">// 默认是 Integer.MAX_VALUE    if (capacity &lt;= 0) throw new IllegalArgumentException();    this.capacity = capacity;    last = head = new Node&lt;E&gt;(null);&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>当一个节点入队：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;    <span class="comment">// 从右向左计算    last = last.next = node;&#125;</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/seazean/images/raw/master/Java/JUC-LinkedBlockingQueue%E5%85%A5%E9%98%9F%E6%B5%81%E7%A8%8B.png"></p></li><li><p>再来一个节点入队 <code>last = last.next = node</code></p></li></ul><p>出队：<strong>出队头节点</strong>，FIFO</p><ul><li><p>出队源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;    Node&lt;E&gt; h = head;    <span class="comment">// 获取临头节点    Node&lt;E&gt; first = h.next;    // 自己指向自己，help GC    h.next = h;    head = first;    // 出队的元素    E x = first.item;    // 【当前节点置为 Dummy 节点】    first.item = null;    return x;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p><code>h = head</code> → <code>first = h.next</code> </p><p><img src="https://gitee.com/seazean/images/raw/master/Java/JUC-LinkedBlockingQueue%E5%87%BA%E9%98%9F%E6%B5%81%E7%A8%8B1.png"></p></li><li><p><code>h.next = h</code> → <code>head = first</code></p><p><img src="https://gitee.com/seazean/images/raw/master/Java/JUC-LinkedBlockingQueue%E5%87%BA%E9%98%9F%E6%B5%81%E7%A8%8B2.png"></p></li></ul><hr><h5 id="加锁分析"><a href="#加锁分析" class="headerlink" title="加锁分析"></a>加锁分析</h5><p>用了两把锁和 dummy 节点：</p><ul><li>用一把锁，同一时刻，最多只允许有一个线程（生产者或消费者，二选一）执行</li><li>用两把锁，同一时刻，可以允许两个线程同时（一个生产者与一个消费者）执行<ul><li>消费者与消费者线程仍然串行</li><li>生产者与生产者线程仍然串行</li></ul></li></ul><p>线程安全分析：</p><ul><li><p>当节点总数大于 2 时（包括 dummy 节点），<strong>putLock 保证的是 last 节点的线程安全，takeLock 保证的是 head 节点的线程安全</strong>，两把锁保证了入队和出队没有竞争</p></li><li><p>当节点总数等于 2 时（即一个 dummy 节点，一个正常节点）这时候，仍然是两把锁锁两个对象，不会竞争</p></li><li><p>当节点总数等于 1 时（就一个 dummy 节点）这时 take 线程会被 notEmpty 条件阻塞，有竞争，会阻塞</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于 put(阻塞) offer(非阻塞)private final ReentrantLock putLock = new ReentrantLock();private final Condition notFull = putLock.newCondition();// 阻塞等待不满，说明已经满了// 用于 take(阻塞) poll(非阻塞)private final ReentrantLock takeLock = new ReentrantLock();private final Condition notEmpty = takeLock.newCondition();// 阻塞等待不空，说明已经是空的</span></span><br></pre></td></tr></table></figure></li></ul><p>入队出队：</p><ul><li><p>put 操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;    <span class="comment">// 空指针异常    if (e == null) throw new NullPointerException();    int c = -1;    // 把待添加的元素封装为 node 节点    Node&lt;E&gt; node = new Node&lt;E&gt;(e);    // 获取全局生产锁    final ReentrantLock putLock = this.putLock;    // count 用来维护元素计数    final AtomicInteger count = this.count;    // 获取可打断锁，会抛出异常    putLock.lockInterruptibly();    try &#123;    // 队列满了等待        while (count.get() == capacity) &#123;            // 【等待队列不满时，就可以生产数据】，线程处于 Waiting            notFull.await();        &#125;        // 有空位, 入队且计数加一，尾插法        enqueue(node);        // 返回自增前的数字        c = count.getAndIncrement();        // put 完队列还有空位, 唤醒其他生产 put 线程，唤醒一个减少竞争        if (c + 1 &lt; capacity)            notFull.signal();    &#125; finally &#123;        // 解锁        putLock.unlock();    &#125;    // c自增前是0，说明生产了一个元素，唤醒一个 take 线程    if (c == 0)        signalNotEmpty();&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">signalNotEmpty</span><span class="params">()</span> </span>&#123;    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;    takeLock.lock();    <span class="keyword">try</span> &#123;        <span class="comment">// 调用 notEmpty.signal()，而不是 notEmpty.signalAll() 是为了减少竞争，因为只剩下一个元素        notEmpty.signal();    &#125; finally &#123;        takeLock.unlock();    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>take 操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;    E x;    <span class="keyword">int</span> c = -<span class="number">1</span>;    <span class="comment">// 元素个数    final AtomicInteger count = this.count;    // 获取全局消费锁    final ReentrantLock takeLock = this.takeLock;    // 可打断锁    takeLock.lockInterruptibly();    try &#123;        // 没有元素可以出队        while (count.get() == 0) &#123;            // 【阻塞等待队列不空，就可以消费数据】，线程处于 Waiting            notEmpty.await();        &#125;        // 出队，计数减一，FIFO，出队头节点        x = dequeue();        // 返回自减前的数字        c = count.getAndDecrement();        // 队列还有元素        if (c &gt; 1)            // 唤醒一个消费take线程            notEmpty.signal();    &#125; finally &#123;        takeLock.unlock();    &#125;    // c 是消费前的数据，消费前满了，消费一个后还剩一个空位，唤醒生产线程    if (c == capacity)        // 调用的是 notFull.signal() 而不是 notFull.signalAll() 是为了减少竞争        signalNotFull();    return x;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h5><p>主要列举 LinkedBlockingQueue 与 ArrayBlockingQueue 的性能比较：</p><ul><li>Linked 支持有界，Array 强制有界</li><li>Linked 实现是链表，Array 实现是数组</li><li>Linked 是懒惰的，而 Array 需要提前初始化 Node 数组</li><li>Linked 每次入队会生成新 Node，而 Array 的 Node 是提前创建好的</li><li>Linked 两把锁，Array 一把锁</li></ul><hr><h4 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h4><h5 id="成员属性-1"><a href="#成员属性-1" class="headerlink" title="成员属性"></a>成员属性</h5><p>与其他 BlockingQueue 不同，SynchronousQueue 是一个不存储元素的 BlockingQueue，每一个生产者必须阻塞匹配到一个消费者</p><p>成员变量：</p><ul><li><p>运行当前程序的平台拥有 CPU 的数量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NCPUS = Runtime.getRuntime().availableProcessors()</span><br></pre></td></tr></table></figure></li><li><p>指定超时时间后，当前线程最大自旋次数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只有一个 CPU 时自旋次数为 0，所有程序都是串行执行，多核 CPU 时自旋 32 次是一个经验值static final int maxTimedSpins = (NCPUS &lt; 2) ? 0 : 32;</span></span><br></pre></td></tr></table></figure><p>自旋的原因：线程挂起唤醒需要进行上下文切换，涉及到用户态和内核态的转变，是非常消耗资源的。自旋期间线程会一直检查自己的状态是否被匹配到，如果自旋期间被匹配到，那么直接就返回了，如果自旋次数达到某个指标后，还是会将当前线程挂起</p></li><li><p>未指定超时时间，当前线程最大自旋次数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> maxUntimedSpins = maxTimedSpins * <span class="number">16</span>;<span class="comment">// maxTimedSpins 的 16 倍</span></span><br></pre></td></tr></table></figure></li><li><p>指定超时限制的阈值，小于该值的线程不会被挂起：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> spinForTimeoutThreshold = <span class="number">1000L</span>;<span class="comment">// 纳秒</span></span><br></pre></td></tr></table></figure><p>超时时间设置的小于该值，就会被禁止挂起，阻塞在唤醒的成本太高，不如选择自旋空转</p></li><li><p>转换器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Transferer&lt;E&gt; transferer;<span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Transferer</span>&lt;<span class="title">E</span>&gt; </span>&#123;    <span class="comment">/**    * 参数一：可以为 null，null 时表示这个请求是一个 REQUEST 类型的请求，反之是一个 DATA 类型的请求    * 参数二：如果为 true 表示指定了超时时间，如果为 false 表示不支持超时，会一直阻塞到匹配或者被打断    * 参数三：超时时间限制，单位是纳秒        * 返回值：返回值如果不为 null 表示匹配成功，DATA 类型的请求返回当前线程 put 的数据    *      如果返回 null，表示请求超时或被中断    */</span>    <span class="function"><span class="keyword">abstract</span> E <span class="title">transfer</span><span class="params">(E e, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span>;&#125;</span><br></pre></td></tr></table></figure></li><li><p>构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SynchronousQueue</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;    <span class="comment">// fair 默认 false    // 非公平模式实现的数据结构是栈，公平模式的数据结构是队列    transferer = fair ? new TransferQueue&lt;E&gt;() : new TransferStack&lt;E&gt;();&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>成员方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();    <span class="keyword">return</span> transferer.transfer(e, <span class="keyword">true</span>, <span class="number">0</span>) != <span class="keyword">null</span>;&#125;<span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;    <span class="keyword">return</span> transferer.transfer(<span class="keyword">null</span>, <span class="keyword">true</span>, <span class="number">0</span>);&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="非公实现"><a href="#非公实现" class="headerlink" title="非公实现"></a>非公实现</h5><p>TransferStack 是非公平的同步队列，因为所有的请求都被压入栈中，栈顶的元素会最先得到匹配，造成栈底的等待线程饥饿</p><p>TransferStack 类成员变量：</p><ul><li><p>请求类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示 Node 类型为请求类型static final int REQUEST    = 0;// 表示 Node类 型为数据类型static final int DATA       = 1;// 表示 Node 类型为匹配中类型// 假设栈顶元素为 REQUEST-NODE，当前请求类型为 DATA，入栈会修改类型为 FULFILLING 【栈顶 &amp; 栈顶之下的一个node】// 假设栈顶元素为 DATA-NODE，当前请求类型为 REQUEST，入栈会修改类型为 FULFILLING 【栈顶 &amp; 栈顶之下的一个node】static final int FULFILLING = 2;</span></span><br></pre></td></tr></table></figure></li><li><p>栈顶元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> SNode head;</span><br></pre></td></tr></table></figure></li></ul><p>内部类 SNode：</p><ul><li><p>成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SNode</span> </span>&#123;    <span class="comment">// 指向下一个栈帧    volatile SNode next;     // 与当前 node 匹配的节点    volatile SNode match;    // 假设当前node对应的线程自旋期间未被匹配成功，那么node对应的线程需要挂起，    // 挂起前 waiter 保存对应的线程引用，方便匹配成功后，被唤醒。    volatile Thread waiter;        // 数据域，不为空表示当前 Node 对应的请求类型为 DATA 类型，反之则表示 Node 为 REQUEST 类型    Object item;     // 表示当前Node的模式 【DATA/REQUEST/FULFILLING】    int mode;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SNode(Object item) &#123;    <span class="keyword">this</span>.item = item;&#125;</span><br></pre></td></tr></table></figure></li><li><p>设置方法：设置 Node 对象的 next 字段，此处<strong>对 CAS 进行了优化</strong>，提升了 CAS 的效率</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">casNext</span><span class="params">(SNode cmp, SNode val)</span> </span>&#123;    <span class="comment">//【优化：cmp == next】，可以提升一部分性能。 cmp == next 不相等，就没必要走 cas指令。    return cmp == next &amp;&amp; UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val);&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>匹配方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryMatch</span><span class="params">(SNode s)</span> </span>&#123;    <span class="comment">// 当前 node 尚未与任何节点发生过匹配，CAS 设置 match 字段为 s 节点，表示当前 node 已经被匹配    if (match == null &amp;&amp; UNSAFE.compareAndSwapObject(this, matchOffset, null, s)) &#123;        // 当前 node 如果自旋结束，会 park 阻塞，阻塞前将 node 对应的 Thread 保留到 waiter 字段        // 获取当前 node 对应的阻塞线程        Thread w = waiter;        // 条件成立说明 node 对应的 Thread 正在阻塞        if (w != null) &#123;            waiter = null;            // 使用 unpark 方式唤醒线程            LockSupport.unpark(w);        &#125;        return true;    &#125;    // 匹配成功返回 true    return match == s;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>取消方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取消节点的方法void tryCancel() &#123;    // match 字段指向自己，表示这个 node 是取消状态，取消状态的 node，最终会被强制移除出栈    UNSAFE.compareAndSwapObject(this, matchOffset, null, this);&#125;boolean isCancelled() &#123;    return match == this;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><p>TransferStack 类成员方法：</p><ul><li><p>snode()：填充节点方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> SNode <span class="title">snode</span><span class="params">(SNode s, Object e, SNode next, <span class="keyword">int</span> mode)</span> </span>&#123;    <span class="comment">// 引用指向空时，snode 方法会创建一个 SNode 对象     if (s == null) s = new SNode(e);    // 填充数据    s.mode = mode;    s.next = next;    return s;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>transfer()：核心方法，请求匹配出栈，不匹配阻塞</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">transfer</span><span class="params">(E e, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span> </span>&#123;<span class="comment">// 包装当前线程的 node    SNode s = null;    // 根据元素判断当前的请求类型    int mode = (e == null) ? REQUEST : DATA;// 自旋    for (;;) &#123;        // 获取栈顶指针        SNode h = head;       // 【CASE1】：当前栈为空或者栈顶 node 模式与当前请求模式一致无法匹配，做入栈操作        if (h == null || h.mode == mode) &#123;            // 当前请求是支持超时的，但是 nanos &lt;= 0 说明这个请求不支持 “阻塞等待”            if (timed &amp;&amp; nanos &lt;= 0) &#123;                 // 栈顶元素是取消状态                if (h != null &amp;&amp; h.isCancelled())                    // 栈顶出栈，设置新的栈顶                    casHead(h, h.next);                else                    // 表示【匹配失败】                    return null;            // 入栈            &#125; else if (casHead(h, s = snode(s, e, h, mode))) &#123;                // 等待被匹配的逻辑，正常情况返回匹配的节点；取消情况返回当前节点，就是 s                SNode m = awaitFulfill(s, timed, nanos);                // 说明当前 node 是【取消状态】                if (m == s) &#123;                     // 将取消节点出栈                    clean(s);                    return null;                &#125;                // 执行到这说明【匹配成功】了                // 栈顶有节点并且 匹配节点还未出栈，需要协助出栈                if ((h = head) != null &amp;&amp; h.next == s)                    casHead(h, s.next);                // 当前 node 模式为 REQUEST 类型，返回匹配节点的 m.item 数据域                // 当前 node 模式为 DATA 类型：返回 node.item 数据域，当前请求提交的数据 e                return (E) ((mode == REQUEST) ? m.item : s.item);            &#125;        // 【CASE2】：逻辑到这说明请求模式不一致，如果栈顶不是 FULFILLING 说明没被其他节点匹配，【当前可以匹配】        &#125; else if (!isFulfilling(h.mode)) &#123;            // 头节点是取消节点，match 指向自己，协助出栈            if (h.isCancelled())                casHead(h, h.next);            // 入栈当前请求的节点            else if (casHead(h, s=snode(s, e, h, FULFILLING|mode))) &#123;                for (;;) &#123;                     // m 是 s 的匹配的节点                    SNode m = s.next;                    // m 节点在 awaitFulfill 方法中被中断，clean 了自己                    if (m == null) &#123;                        // 清空栈                        casHead(s, null);                        s = null;                        // 返回到外层自旋中                        break;                    &#125;                    // 获取匹配节点的下一个节点                    SNode mn = m.next;                    // 尝试匹配，【匹配成功】，则将 fulfilling 和 m 一起出栈，并且唤醒被匹配的节点的线程                    if (m.tryMatch(s)) &#123;                        casHead(s, mn);                        return (E) ((mode == REQUEST) ? m.item : s.item);                    &#125; else                        // 匹配失败，出栈 m                        s.casNext(m, mn);                &#125;            &#125;        // 【CASE3】：栈顶模式为 FULFILLING 模式，表示【栈顶和栈顶下面的节点正在发生匹配】，当前请求需要做协助工作        &#125; else &#123;            // h 表示的是 fulfilling 节点，m 表示 fulfilling 匹配的节点            SNode m = h.next;            if (m == null)                // 清空栈                casHead(h, null);            else &#123;                SNode mn = m.next;                // m 和 h 匹配，唤醒 m 中的线程                if (m.tryMatch(h))                    casHead(h, mn);                else                    h.casNext(m, mn);            &#125;        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>awaitFulfill()：阻塞当前线程等待被匹配，返回匹配的节点，或者被取消的节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SNode <span class="title">awaitFulfill</span><span class="params">(SNode s, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span> </span>&#123;    <span class="comment">// 等待的截止时间    final long deadline = timed ? System.nanoTime() + nanos : 0L;    // 当前线程    Thread w = Thread.currentThread();    // 表示当前请求线程在下面的 for(;;) 自旋检查的次数    int spins = (shouldSpin(s) ? (timed ? maxTimedSpins : maxUntimedSpins) : 0);    // 自旋检查逻辑：是否匹配、是否超时、是否被中断    for (;;) &#123;        // 当前线程收到中断信号，需要设置 node 状态为取消状态        if (w.isInterrupted())            s.tryCancel();        // 获取与当前 s 匹配的节点        SNode m = s.match;        if (m != null)            // 可能是正常的匹配的，也可能是取消的            return m;        // 执行了超时限制就判断是否超时        if (timed) &#123;            nanos = deadline - System.nanoTime();            // 【超时了，取消节点】            if (nanos &lt;= 0L) &#123;                s.tryCancel();                continue;            &#125;        &#125;        // 说明当前线程还可以进行自旋检查        if (spins &gt; 0)            // 自旋一次 递减 1            spins = shouldSpin(s) ? (spins - 1) : 0;        // 说明没有自旋次数了        else if (s.waiter == null)            //【把当前 node 对应的 Thread 保存到 node.waiter 字段中，要阻塞了】            s.waiter = w;        // 没有超时限制直接阻塞        else if (!timed)            LockSupport.park(this);        // nanos &gt; 1000 纳秒的情况下，才允许挂起当前线程        else if (nanos &gt; spinForTimeoutThreshold)            LockSupport.parkNanos(this, nanos);    &#125;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">shouldSpin</span><span class="params">(SNode s)</span> </span>&#123;    <span class="comment">// 获取栈顶    SNode h = head;    // 条件一成立说明当前 s 就是栈顶，允许自旋检查    // 条件二成立说明当前 s 节点自旋检查期间，又来了一个与当前 s 节点匹配的请求，双双出栈后条件会成立    // 条件三成立前提当前 s 不是栈顶元素，并且当前栈顶正在匹配中，这种状态栈顶下面的元素，都允许自旋检查    return (h == s || h == null || isFulfilling(h.mode));&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>clear()：指定节点出栈</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clean</span><span class="params">(SNode s)</span> </span>&#123;    <span class="comment">// 清空数据域和关联线程    s.item = null;    s.waiter = null;    // 获取取消节点的下一个节点    SNode past = s.next;    // 判断后继节点是不是取消节点，是就更新 past    if (past != null &amp;&amp; past.isCancelled())        past = past.next;    SNode p;    // 从栈顶开始向下检查，【将栈顶开始向下的 取消状态 的节点全部清理出去】，直到碰到 past 或者不是取消状态为止    while ((p = head) != null &amp;&amp; p != past &amp;&amp; p.isCancelled())        // 修改的是内存地址对应的值，p 指向该内存地址所以数据一直在变化        casHead(p, p.next);// 说明中间遇到了不是取消状态的节点，继续迭代下去    while (p != null &amp;&amp; p != past) &#123;        SNode n = p.next;        if (n != null &amp;&amp; n.isCancelled())            p.casNext(n, n.next);        else            p = n;    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="公平实现"><a href="#公平实现" class="headerlink" title="公平实现"></a>公平实现</h5><p>TransferQueue 是公平的同步队列，采用 FIFO 的队列实现</p><p>TransferQueue 类成员变量：</p><ul><li><p>指向队列的 dummy 节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> QNode head;</span><br></pre></td></tr></table></figure></li><li><p>指向队列的尾节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> QNode tail;</span><br></pre></td></tr></table></figure></li><li><p>被清理节点的前驱节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> QNode cleanMe;</span><br></pre></td></tr></table></figure><p>入队操作是两步完成的，第一步是 t.next = newNode，第二步是 tail = newNode，所以队尾节点出队，是一种非常特殊的情况</p></li></ul><p>TransferQueue 内部类：</p><ul><li><p>QNode：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">QNode</span> </span>&#123;    <span class="comment">// 指向当前节点的下一个节点    volatile QNode next;    // 数据域，Node 代表的是 DATA 类型 item 表示数据，否则 Node 代表的 REQUEST 类型，item == null    volatile Object item;    // 假设当前 node 对应的线程自旋期间未被匹配成功，那么 node 对应的线程需要挂起，    // 挂起前 waiter 保存对应的线程引用，方便匹配成功后被唤醒。    volatile Thread waiter;    // true 当前 Node 是一个 DATA 类型，false 表示当前 Node 是一个 REQUEST 类型    final boolean isData;// 构建方法    QNode(Object item, boolean isData) &#123;        this.item = item;        this.isData = isData;    &#125;    // 尝试取消当前 node，取消状态的 node 的 item 域指向自己    void tryCancel(Object cmp) &#123;        UNSAFE.compareAndSwapObject(this, itemOffset, cmp, this);    &#125;    // 判断当前 node 是否为取消状态    boolean isCancelled() &#123;        return item == this;    &#125;    // 判断当前节点是否 “不在” 队列内，当 next 指向自己时，说明节点已经出队。    boolean isOffList() &#123;        return next == this;    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><p>TransferQueue 类成员方法：</p><ul><li><p>设置头尾节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">advanceHead</span><span class="params">(QNode h, QNode nh)</span> </span>&#123;    <span class="comment">// 设置头指针指向新的节点，    if (h == head &amp;&amp; UNSAFE.compareAndSwapObject(this, headOffset, h, nh))        // 老的头节点出队        h.next = h;&#125;void advanceTail(QNode t, QNode nt) &#123;    if (tail == t)        // 更新队尾节点为新的队尾        UNSAFE.compareAndSwapObject(this, tailOffset, t, nt);&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>transfer()：核心方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">transfer</span><span class="params">(E e, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span> </span>&#123;    <span class="comment">// s 指向当前请求对应的 node    QNode s = null;    // 是否是 DATA 类型的请求    boolean isData = (e != null);// 自旋    for (;;) &#123;        QNode t = tail;        QNode h = head;        if (t == null || h == null)            continue;// head 和 tail 同时指向 dummy 节点，说明是空队列        // 队尾节点与当前请求类型是一致的情况，说明阻塞队列中都无法匹配，        if (h == t || t.isData == isData) &#123;            // 获取队尾 t 的 next 节点            QNode tn = t.next;            // 多线程环境中其他线程可能修改尾节点            if (t != tail)                continue;            // 已经有线程入队了，更新 tail            if (tn != null) &#123;                advanceTail(t, tn);                continue;            &#125;            // 允许超时，超时时间小于 0，这种方法不支持阻塞等待            if (timed &amp;&amp; nanos &lt;= 0)                return null;            // 创建 node 的逻辑            if (s == null)                s = new QNode(e, isData);            // 将 node 添加到队尾            if (!t.casNext(null, s))                continue;// 更新队尾指针            advanceTail(t, s);                        // 当前节点 等待匹配....            Object x = awaitFulfill(s, e, timed, nanos);                        // 说明【当前 node 状态为 取消状态】，需要做出队逻辑            if (x == s) &#123;                clean(t, s);                return null;            &#125;// 说明当前 node 仍然在队列内，匹配成功，需要做出队逻辑            if (!s.isOffList()) &#123;                // t 是当前 s 节点的前驱节点，判断 t 是不是头节点，是就更新 dummy 节点为 s 节点                advanceHead(t, s);                // s 节点已经出队，所以需要把它的 item 域设置为它自己，表示它是个取消状态                if (x != null)                    s.item = s;                s.waiter = null;            &#125;            return (x != null) ? (E)x : e;// 队尾节点与当前请求节点【互补匹配】        &#125; else &#123;            // h.next 节点，请求节点与队尾模式不同，需要与队头发生匹配，TransferQueue 是一个【公平模式】            QNode m = h.next;            // 并发导致其他线程修改了队尾节点，或者已经把 head.next 匹配走了            if (t != tail || m == null || h != head)                continue;// 获取匹配节点的数据域保存到 x            Object x = m.item;            // 判断是否匹配成功            if (isData == (x != null) ||                x == m ||                !m.casItem(x, e)) &#123;                advanceHead(h, m);                continue;            &#125;// 【匹配完成】，将头节点出队，让这个新的头结点成为 dummy 节点            advanceHead(h, m);            // 唤醒该匹配节点的线程            LockSupport.unpark(m.waiter);            return (x != null) ? (E)x : e;        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>awaitFulfill()：阻塞当前线程等待被匹配</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">awaitFulfill</span><span class="params">(QNode s, E e, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span> </span>&#123;    <span class="comment">// 表示等待截止时间    final long deadline = timed ? System.nanoTime() + nanos : 0L;    Thread w = Thread.currentThread();    // 自选检查的次数    int spins = ((head.next == s) ? (timed ? maxTimedSpins : maxUntimedSpins) : 0);    for (;;) &#123;        // 被打断就取消节点        if (w.isInterrupted())            s.tryCancel(e);        // 获取当前 Node 数据域        Object x = s.item;                // 当前请求为 DATA 模式时：e 请求带来的数据        // s.item 修改为 this，说明当前 QNode 对应的线程 取消状态        // s.item 修改为 null 表示已经有匹配节点了，并且匹配节点拿走了 item 数据        // 当前请求为 REQUEST 模式时：e == null        // s.item 修改为 this，说明当前 QNode 对应的线程 取消状态        // s.item != null 且 item != this  表示当前 REQUEST 类型的 Node 已经匹配到 DATA 了         if (x != e)            return x;        // 超时检查        if (timed) &#123;            nanos = deadline - System.nanoTime();            if (nanos &lt;= 0L) &#123;                s.tryCancel(e);                continue;            &#125;        &#125;        // 自旋次数减一        if (spins &gt; 0)            --spins;        // 没有自旋次数了，把当前线程封装进去 waiter        else if (s.waiter == null)            s.waiter = w;        // 阻塞        else if (!timed)            LockSupport.park(this);        else if (nanos &gt; spinForTimeoutThreshold)            LockSupport.parkNanos(this, nanos);    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="操作Pool"><a href="#操作Pool" class="headerlink" title="操作Pool"></a>操作Pool</h3><h4 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h4><h5 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h5><p>存放线程的容器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;Worker&gt;();</span><br></pre></td></tr></table></figure><p>构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,                          <span class="keyword">int</span> maximumPoolSize,                          <span class="keyword">long</span> keepAliveTime,                          TimeUnit unit,                          BlockingQueue&lt;Runnable&gt; workQueue,                          ThreadFactory threadFactory,                          RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure><p>参数介绍：</p><ul><li><p>corePoolSize：核心线程数，定义了最小可以同时运行的线程数量</p></li><li><p>maximumPoolSize：最大线程数，当队列中存放的任务达到队列容量时，当前可以同时运行的数量变为最大线程数，创建线程并立即执行最新的任务，与核心线程数之间的差值又叫救急线程数</p></li><li><p>keepAliveTime：救急线程最大存活时间，当线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等到 <code>keepAliveTime</code> 时间超过销毁</p></li><li><p>unit：<code>keepAliveTime</code> 参数的时间单位</p></li><li><p>workQueue：阻塞队列，存放被提交但尚未被执行的任务</p></li><li><p>threadFactory：线程工厂，创建新线程时用到，可以为线程创建时起名字</p></li><li><p>handler：拒绝策略，线程到达最大线程数仍有新任务时会执行拒绝策略</p><p>RejectedExecutionHandler 下有 4 个实现类：</p><ul><li>AbortPolicy：让调用者抛出 RejectedExecutionException 异常，<strong>默认策略</strong></li><li>CallerRunsPolicy：让调用者运行的调节机制，将某些任务回退到调用者，从而降低新任务的流量</li><li>DiscardPolicy：直接丢弃任务，不予任何处理也不抛出异常</li><li>DiscardOldestPolicy：放弃队列中最早的任务，把当前任务加入队列中尝试再次提交当前任务</li></ul><p>补充：其他框架拒绝策略</p><ul><li>Dubbo：在抛出 RejectedExecutionException 异常前记录日志，并 dump 线程栈信息，方便定位问题</li><li>Netty：创建一个新线程来执行任务</li><li>ActiveMQ：带超时等待（60s）尝试放入队列</li><li>PinPoint：它使用了一个拒绝策略链，会逐一尝试策略链中每种拒绝策略</li></ul></li></ul><p>工作原理：</p><p><img src="https://gitee.com/seazean/images/raw/master/Java/JUC-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png"></p><ol><li><p>创建线程池，这时没有创建线程（<strong>懒惰</strong>），等待提交过来的任务请求，调用 execute 方法才会创建线程</p></li><li><p>当调用 execute() 方法添加一个请求任务时，线程池会做如下判断：</p><ul><li>如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务</li><li>如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列</li><li>如果这时队列满了且正在运行的线程数量还小于 maximumPoolSize，那么会创建非核心线程<strong>立刻运行这个任务</strong>，对于阻塞队列中的任务不公平。这是因为创建每个 Worker （线程）对象会绑定一个初始任务，启动 Worker 时会优先执行</li><li>如果队列满了且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会启动饱和<strong>拒绝策略</strong>来执行</li></ul></li><li><p>当一个线程完成任务时，会从队列中取下一个任务来执行</p></li><li><p>当一个线程空闲超过一定的时间（keepAliveTime）时，线程池会判断：如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉，所以线程池的所有任务完成后最终会收缩到 corePoolSize 大小</p></li></ol><p>图片来源：<a href="https://space.bilibili.com/457326371/">https://space.bilibili.com/457326371/</a></p><hr><h5 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h5><p>Executors 提供了四种线程池的创建：newCachedThreadPool、newFixedThreadPool、newSingleThreadExecutor、newScheduledThreadPool</p><ul><li><p>newFixedThreadPool：创建一个拥有 n 个线程的线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads, <span class="number">0L</span>, TimeUnit.MILLISECONDS,                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());&#125;</span><br></pre></td></tr></table></figure><ul><li>核心线程数 == 最大线程数（没有救急线程被创建），因此也无需超时时间</li><li>LinkedBlockingQueue 是一个单向链表实现的阻塞队列，默认大小为 <code>Integer.MAX_VALUE</code>，也就是无界队列，可以放任意数量的任务，在任务比较多的时候会导致 OOM（内存溢出）</li><li>适用于任务量已知，相对耗时的长期任务</li></ul></li><li><p>newCachedThreadPool：创建一个可扩容的线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60L</span>, TimeUnit.SECONDS,                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());&#125;</span><br></pre></td></tr></table></figure><ul><li><p>核心线程数是 0， 最大线程数是 29 个 1，全部都是救急线程（60s 后可以回收），可能会创建大量线程，从而导致 <strong>OOM</strong></p></li><li><p>SynchronousQueue 作为阻塞队列，没有容量，对于每一个 take 的线程会阻塞直到有一个 put 的线程放入元素为止（类似一手交钱、一手交货）</p></li><li><p>适合任务数比较密集，但每个任务执行时间较短的情况</p></li></ul></li><li><p>newSingleThreadExecutor：创建一个只有 1 个线程的单线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,<span class="number">0L</span>, TimeUnit.MILLISECONDS,                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));&#125;</span><br></pre></td></tr></table></figure><ul><li>保证所有任务按照<strong>指定顺序执行</strong>，线程数固定为 1，任务数多于 1 时会放入无界队列排队，任务执行完毕，这唯一的线程也不会被释放</li></ul><p>对比：</p><ul><li>创建一个单线程串行执行任务，如果任务执行失败而终止那么没有任何补救措施，线程池会新建一个线程，保证池的正常工作</li></ul></li><li><p>Executors.newSingleThreadExecutor() 线程个数始终为1，不能修改。FinalizableDelegatedExecutorService 应用的是装饰器模式，只对外暴露了 ExecutorService 接口，因此不能调用 ThreadPoolExecutor 中特有的方法</p><p>原因：父类不能直接调用子类中的方法，需要反射或者创建对象的方式，可以调用子类静态方法</p></li><li><p>Executors.newFixedThreadPool(1) 初始时为1，可以修改。对外暴露的是 ThreadPoolExecutor 对象，可以强转后调用 setCorePoolSize 等方法进行修改</p></li></ul><p><img src="https://gitee.com/seazean/images/raw/master/Java/JUC-newSingleThreadExecutor.png"></p><hr><h5 id="开发要求"><a href="#开发要求" class="headerlink" title="开发要求"></a>开发要求</h5><p>阿里巴巴 Java 开发手册要求：</p><ul><li><p><strong>线程资源必须通过线程池提供，不允许在应用中自行显式创建线程</strong></p><ul><li>使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源的开销，解决资源不足的问题</li><li>如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者过度切换的问题</li></ul></li><li><p>线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式更加明确线程池的运行规则，规避资源耗尽的风险</p><p>Executors 返回的线程池对象弊端如下：</p><ul><li>FixedThreadPool 和 SingleThreadPool：请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM</li><li>CacheThreadPool 和 ScheduledThreadPool：允许创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，导致 OOM</li></ul></li></ul><p>创建多大容量的线程池合适？</p><ul><li><p>一般来说池中<strong>总线程数是核心池线程数量两倍</strong>，确保当核心池有线程停止时，核心池外有线程进入核心池</p></li><li><p>过小会导致程序不能充分地利用系统资源、容易导致饥饿</p></li><li><p>过大会导致更多的线程上下文切换，占用更多内存</p><p>上下文切换：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态，任务从保存到再加载的过程就是一次上下文切换</p></li></ul><p>核心线程数常用公式：</p><ul><li><p><strong>CPU 密集型任务(N+1)：</strong> 这种任务消耗的是 CPU 资源，可以将核心线程数设置为 N (CPU 核心数) + 1，比 CPU 核心数多出来的一个线程是为了防止线程发生缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 某个核心就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间</p><p>CPU 密集型简单理解就是利用 CPU 计算能力的任务比如在内存中对大量数据进行分析</p></li><li><p><strong>I/O 密集型任务：</strong> 这种系统 CPU 处于阻塞状态，用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用，因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N 或 CPU 核数/ (1-阻塞系数)，阻塞系数在 0.8~0.9 之间</p><p>IO 密集型就是涉及到网络读取，文件读取此类任务 ，特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上</p></li></ul><hr><h4 id="提交方法"><a href="#提交方法" class="headerlink" title="提交方法"></a>提交方法</h4><p>ExecutorService 类 API：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>void execute(Runnable command)</td><td>执行任务（Executor 类 API）</td></tr><tr><td>Future&lt;?&gt; submit(Runnable task)</td><td>提交任务 task()</td></tr><tr><td>Future submit(Callable<T> task)</T></td><td>提交任务 task，用返回值 Future 获得任务执行结果</td></tr><tr><td>List&lt;Future<T>&gt; invokeAll(Collection&lt;? extends Callable<T>&gt; tasks)</T></T></td><td>提交 tasks 中所有任务</td></tr><tr><td>List&lt;Future<T>&gt; invokeAll(Collection&lt;? extends Callable<T>&gt; tasks, long timeout, TimeUnit unit)</T></T></td><td>提交 tasks 中所有任务，超时时间针对所有task，超时会取消没有执行完的任务，并抛出超时异常</td></tr><tr><td>T invokeAny(Collection&lt;? extends Callable<T>&gt; tasks)</T></td><td>提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消</td></tr></tbody></table><p>execute 和 submit 都属于线程池的方法，对比：</p><ul><li><p>execute 只能执行 Runnable 类型的任务，没有返回值； submit 既能提交 Runnable 类型任务也能提交 Callable 类型任务，底层是封装成 FutureTask，然后调用 execute 执行</p></li><li><p>execute 会直接抛出任务执行时的异常，submit 会吞掉异常，可通过 Future 的 get 方法将任务执行时的异常重新抛出</p></li></ul><hr><h4 id="关闭方法"><a href="#关闭方法" class="headerlink" title="关闭方法"></a>关闭方法</h4><p>ExecutorService 类 API：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>void shutdown()</td><td>线程池状态变为 SHUTDOWN，等待任务执行完后关闭线程池，不会接收新任务，但已提交任务会执行完，而且也可以添加线程</td></tr><tr><td>List<Runnable> shutdownNow()</Runnable></td><td>线程池状态变为 STOP，用 interrupt 中断正在执行的任务，直接关闭线程池，不会接收新任务，会将队列中的任务返回</td></tr><tr><td>boolean isShutdown()</td><td>不在 RUNNING 状态的线程池，此执行者已被关闭，方法返回 true</td></tr><tr><td>boolean isTerminated()</td><td>线程池状态是否是 TERMINATED，如果所有任务在关闭后完成，返回 true</td></tr><tr><td>boolean awaitTermination(long timeout, TimeUnit unit)</td><td>调用 shutdown 后，由于调用线程不会等待所有任务运行结束，如果它想在线程池 TERMINATED 后做些事情，可以利用此方法等待</td></tr></tbody></table><hr><h4 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h4><p>execute 会直接抛出任务执行时的异常，submit 会吞掉异常，有两种处理方法</p><p>方法 1：主动捉异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">1</span>);pool.submit(() -&gt; &#123;    <span class="keyword">try</span> &#123;        System.out.println(<span class="string">&quot;task1&quot;</span>);        <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;    &#125; <span class="keyword">catch</span> (Exception e) &#123;        e.printStackTrace();    &#125;&#125;);</span><br></pre></td></tr></table></figure><p>方法 2：使用 Future 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">1</span>);Future&lt;?&gt; future = pool.submit(() -&gt; &#123;    System.out.println(<span class="string">&quot;task1&quot;</span>);    <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;    <span class="keyword">return</span> <span class="keyword">true</span>;&#125;);System.out.println(future.get());</span><br></pre></td></tr></table></figure><hr><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><h4 id="状态信息"><a href="#状态信息" class="headerlink" title="状态信息"></a>状态信息</h4><p>ThreadPoolExecutor 使用 int 的<strong>高 3 位来表示线程池状态，低 29 位表示线程数量</strong>。这些信息存储在一个原子变量 ctl 中，目的是将线程池状态与线程个数合二为一，这样就可以用一次 CAS 原子操作进行赋值</p><ul><li><p>状态表示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 高3位：表示当前线程池运行状态，除去高3位之后的低位：表示当前线程池中所拥有的线程数量private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));// 表示在 ctl 中，低 COUNT_BITS 位，是用于存放当前线程数量的位private static final int COUNT_BITS = Integer.SIZE - 3;// 低 COUNT_BITS 位所能表达的最大数值，000 11111111111111111111 =&gt; 5亿多private static final int CAPACITY   = (1 &lt;&lt; COUNT_BITS) - 1;</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/seazean/images/raw/master/Java/JUC-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE.png"></p></li><li><p>四种状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 111 000000000000000000，转换成整数后其实就是一个【负数】private static final int RUNNING    = -1 &lt;&lt; COUNT_BITS;// 000 000000000000000000private static final int SHUTDOWN   =  0 &lt;&lt; COUNT_BITS;// 001 000000000000000000private static final int STOP       =  1 &lt;&lt; COUNT_BITS;// 010 000000000000000000private static final int TIDYING    =  2 &lt;&lt; COUNT_BITS;// 011 000000000000000000private static final int TERMINATED =  3 &lt;&lt; COUNT_BITS;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>状态</th><th>高3位</th><th>接收新任务</th><th>处理阻塞任务队列</th><th>说明</th></tr></thead><tbody><tr><td>RUNNING</td><td>111</td><td>Y</td><td>Y</td><td></td></tr><tr><td>SHUTDOWN</td><td>000</td><td>N</td><td>Y</td><td>不接收新任务，但处理阻塞队列剩余任务</td></tr><tr><td>STOP</td><td>001</td><td>N</td><td>N</td><td>中断正在执行的任务，并抛弃阻塞队列任务</td></tr><tr><td>TIDYING</td><td>010</td><td>-</td><td>-</td><td>任务全执行完毕，活动线程为 0 即将进入终结</td></tr><tr><td>TERMINATED</td><td>011</td><td>-</td><td>-</td><td>终止状态</td></tr></tbody></table></li><li><p>获取当前线程池运行状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ~CAPACITY = ~000 11111111111111111111 = 111 000000000000000000000（取反）// c == ctl = 111 000000000000000000111// 111 000000000000000000111// 111 000000000000000000000// 111 000000000000000000000获取到了运行状态private static int runStateOf(int c)     &#123; return c &amp; ~CAPACITY; &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>获取当前线程池线程数量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//        c = 111 000000000000000000111// CAPACITY = 000 111111111111111111111//            000 000000000000000000111 =&gt; 7private static int workerCountOf(int c)  &#123; return c &amp; CAPACITY; &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>重置当前线程池状态 ctl：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rs 表示线程池状态，wc 表示当前线程池中 worker（线程）数量，相与以后就是合并后的状态private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>比较当前线程池 ctl 所表示的状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较当前线程池 ctl 所表示的状态，是否小于某个状态 s// 状态对比：RUNNING &lt; SHUTDOWN &lt; STOP &lt; TIDYING &lt; TERMINATEDprivate static boolean runStateLessThan(int c, int s) &#123; return c &lt; s; &#125;// 比较当前线程池 ctl 所表示的状态，是否大于等于某个状态sprivate static boolean runStateAtLeast(int c, int s) &#123; return c &gt;= s; &#125;// 小于 SHUTDOWN 的一定是 RUNNING，SHUTDOWN == 0private static boolean isRunning(int c) &#123; return c &lt; SHUTDOWN; &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>设置线程池 ctl：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 CAS 方式 让 ctl 值 +1 ，成功返回 true, 失败返回 falseprivate boolean compareAndIncrementWorkerCount(int expect) &#123;    return ctl.compareAndSet(expect, expect + 1);&#125;// 使用 CAS 方式 让 ctl 值 -1 ，成功返回 true, 失败返回 falseprivate boolean compareAndDecrementWorkerCount(int expect) &#123;    return ctl.compareAndSet(expect, expect - 1);&#125;// 将 ctl 值减一，do while 循环会一直重试，直到成功为止private void decrementWorkerCount() &#123;    do &#123;&#125; while (!compareAndDecrementWorkerCount(ctl.get()));&#125;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="成员属性-2"><a href="#成员属性-2" class="headerlink" title="成员属性"></a>成员属性</h4><p>成员变量</p><ul><li><p>线程池中存放 Worker 的容器：线程池没有初始化，直接往池中加线程即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;Worker&gt;();</span><br></pre></td></tr></table></figure></li><li><p>线程全局锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增加减少 worker 或者时修改线程池运行状态需要持有 mainLockprivate final ReentrantLock mainLock = new ReentrantLock();</span></span><br></pre></td></tr></table></figure></li><li><p>可重入锁的条件变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当外部线程调用 awaitTermination() 方法时，会等待当前线程池状态为 Termination 为止private final Condition termination = mainLock.newCondition()</span></span><br></pre></td></tr></table></figure></li><li><p>线程池相关参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> corePoolSize;<span class="comment">// 核心线程数量private volatile int maximumPoolSize;// 线程池最大线程数量private volatile long keepAliveTime;// 空闲线程存活时间private volatile ThreadFactory threadFactory;// 创建线程时使用的线程工厂，默认是 DefaultThreadFactoryprivate final BlockingQueue&lt;Runnable&gt; workQueue;// 【超过核心线程提交任务就放入 阻塞队列】</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler;<span class="comment">// 拒绝策略，juc包提供了4中方式private static final RejectedExecutionHandler defaultHandler = new AbortPolicy();// 默认策略</span></span><br></pre></td></tr></table></figure></li><li><p>记录线程池相关属性的数值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> largestPoolSize;<span class="comment">// 记录线程池生命周期内线程数最大值private long completedTaskCount;// 记录线程池所完成任务总数，当某个 worker 退出时将完成的任务累加到该属性</span></span><br></pre></td></tr></table></figure></li><li><p>控制核心线程数量内的线程是否可以被回收：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// false（默认）代表不可以，为 true 时核心线程空闲超过 keepAliveTime 也会被回收// allowCoreThreadTimeOut(boolean value) 方法可以设置该值private volatile boolean allowCoreThreadTimeOut;</span></span><br></pre></td></tr></table></figure></li></ul><p>内部类：</p><ul><li><p>Worker 类：<strong>每个 Worker 对象会绑定一个初始任务</strong>，启动 Worker 时优先执行，这也是造成线程池不公平的原因。Worker 继承自 AQS，本身具有锁的特性，采用独占锁模式，state = 0 表示未被占用，&gt; 0 表示被占用，&lt; 0 表示初始状态不能被抢锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;<span class="keyword">final</span> Thread thread;<span class="comment">// worker 内部封装的工作线程    Runnable firstTask;// worker 第一个执行的任务，普通的 Runnable 实现类或者是 FutureTask    volatile long completedTasks;// 记录当前 worker 所完成任务数量        // 构造方法    Worker(Runnable firstTask) &#123;        // 设置AQS独占模式为初始化中状态，这个状态不能被抢占锁       setState(-1);        // firstTask不为空时，当worker启动后，内部线程会优先执行firstTask，执行完后会到queue中去获取下个任务        this.firstTask = firstTask;        // 使用线程工厂创建一个线程，并且【将当前worker指定为Runnable】，所以thread启动时会调用 worker.run()        this.thread = getThreadFactory().newThread(this);    &#125;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;    <span class="comment">// 将当前 worker 指定为 thread 的执行方法，线程调用 start 会调用 r.run()    Thread t = new Thread(group, r, namePrefix + threadNumber.getAndIncrement(), 0);    if (t.isDaemon())        t.setDaemon(false);    if (t.getPriority() != Thread.NORM_PRIORITY)        t.setPriority(Thread.NORM_PRIORITY);    return t;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>拒绝策略相关的内部类</p></li></ul><hr><h4 id="成员方法-2"><a href="#成员方法-2" class="headerlink" title="成员方法"></a>成员方法</h4><h5 id="提交方法-1"><a href="#提交方法-1" class="headerlink" title="提交方法"></a>提交方法</h5><ul><li><p>AbstractExecutorService#submit()：提交任务，<strong>把 Runnable 或 Callable 任务封装成 FutureTask 执行</strong>，可以通过方法返回的任务对象调用 get 阻塞获取任务执行的结果或者异常，源码分析在笔记的 Future 部分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;    <span class="comment">// 空指针异常    if (task == null) throw new NullPointerException();    // 把 Runnable 封装成未来任务对象，执行结果就是 null，也可以通过参数指定 FutureTask#get 返回数据    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, null);    // 执行方法    execute(ftask);    return ftask;&#125;public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) &#123;    if (task == null) throw new NullPointerException();    // 把 Callable 封装成未来任务对象    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);    // 执行方法    execute(ftask);    // 返回未来任务对象，用来获取返回值    return ftask;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> </span>&#123;    <span class="comment">// Runnable 封装成 FutureTask，【指定返回值】    return new FutureTask&lt;T&gt;(runnable, value);&#125;protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Callable&lt;T&gt; callable) &#123;    // Callable 直接封装成 FutureTask    return new FutureTask&lt;T&gt;(callable);&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>execute()：执行任务，但是没有返回值，没办法获取任务执行结果，出现异常会直接抛出任务执行时的异常。根据线程池中的线程数，选择添加任务时的处理方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// command 可以是普通的 Runnable 实现类，也可以是 FutureTask，不能是 Callablepublic void execute(Runnable command) &#123;    // 非空判断    if (command == null)        throw new NullPointerException();  // 获取 ctl 最新值赋值给 c，ctl 高 3 位表示线程池状态，低位表示当前线程池线程数量。    int c = ctl.get();    // 【1】当前线程数量小于核心线程数，此次提交任务直接创建一个新的 worker，线程池中多了一个新的线程    if (workerCountOf(c) &lt; corePoolSize) &#123;        // addWorker 为创建线程的过程，会创建 worker 对象并且将 command 作为 firstTask，优先执行        if (addWorker(command, true))            return;                // 执行到这条语句，说明 addWorker 一定是失败的，存在并发现象或者线程池状态被改变，重新获取状态        // SHUTDOWN 状态下也有可能创建成功，前提 firstTask == null 而且当前 queue 不为空（特殊情况）        c = ctl.get();    &#125;    // 【2】执行到这说明当前线程数量已经达到核心线程数量 或者 addWorker 失败    // 判断当前线程池是否处于running状态，成立就尝试将 task 放入到 workQueue 中    if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;        int recheck = ctl.get();        // 条件一成立说明线程池状态被外部线程给修改了，可能是执行了 shutdown() 方法，该状态不能接收新提交的任务        // 所以要把刚提交的任务删除，删除成功说明提交之后线程池中的线程还未消费（处理）该任务        if (!isRunning(recheck) &amp;&amp; remove(command))            // 任务出队成功，走拒绝策略            reject(command);        // 执行到这说明线程池是 running 状态，获取线程池中的线程数量，判断是否是 0        // 【担保机制】，保证线程池在 running 状态下，最起码得有一个线程在工作        else if (workerCountOf(recheck) == 0)            addWorker(null, false);    &#125;    // 【3】offer失败说明queue满了    // 如果线程数量尚未达到 maximumPoolSize，会创建非核心 worker 线程直接执行 command，【这也是不公平的原因】    // 如果当前线程数量达到 maximumPoolSiz，这里 addWorker 也会失败，走拒绝策略    else if (!addWorker(command, false))        reject(command);&#125;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="添加线程"><a href="#添加线程" class="headerlink" title="添加线程"></a>添加线程</h5><ul><li><p>addWorker()：<strong>添加线程到线程池</strong>，返回 true 表示创建 Worker 成功，且线程启动。首先判断线程池是否允许添加线程，允许就让线程数量 + 1，然后去创建 Worker 加入线程池</p><p>注意：SHUTDOWN 状态也能添加线程，但是要求新加的 Woker 没有 firstTask</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// core == true 表示采用核心线程数量限制，false 表示采用 maximumPoolSizeprivate boolean addWorker(Runnable firstTask, boolean core) &#123;    // 自旋【判断当前线程池状态是否允许创建线程】，允许就设置线程数量 + 1    retry:    for (;;) &#123;        // 获取 ctl 的值        int c = ctl.get();        // 获取当前线程池运行状态        int rs = runStateOf(c);                // 判断当前线程池状态【是否允许添加线程】                // 当前线程池是 SHUTDOWN 状态，但是队列里面还有任务尚未处理完，需要处理完 queue 中的任务        // 【不允许再提交新的 task，所以 firstTask 为空，但是可以继续添加 worker】        if (rs &gt;= SHUTDOWN &amp;&amp; !(rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; !workQueue.isEmpty()))            return false;        for (;;) &#123;            // 获取线程池中线程数量            int wc = workerCountOf(c);            // 条件一一般不成立，CAPACITY是5亿多，根据 core 判断使用哪个大小限制线程数量，超过了返回 false            if (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize))                return false;            // 记录线程数量已经加 1，类比于申请到了一块令牌，条件失败说明其他线程修改了数量            if (compareAndIncrementWorkerCount(c))                // 申请成功，跳出了 retry 这个 for 自旋                break retry;            // CAS 失败，没有成功的申请到令牌            c = ctl.get();            // 判断当前线程池状态是否发生过变化，被其他线程修改了，可能其他线程调用了 shutdown() 方法            if (runStateOf(c) != rs)                // 返回外层循环检查是否能创建线程，在 if 语句中返回 false                continue retry;                   &#125;    &#125;        //【令牌申请成功，开始创建线程】    // 运行标记，表示创建的 worker 是否已经启动，false未启动  true启动    boolean workerStarted = false;    // 添加标记，表示创建的 worker 是否添加到池子中了，默认false未添加，true是添加。    boolean workerAdded = false;    Worker w = null;    try &#123;        // 【创建 Worker，底层通过线程工厂 newThread 方法创建执行线程，指定了首先执行的任务】        w = new Worker(firstTask);        // 将新创建的 worker 节点中的线程赋值给 t        final Thread t = w.thread;        // 这里的判断为了防止 程序员自定义的 ThreadFactory 实现类有 bug，创造不出线程        if (t != null) &#123;            final ReentrantLock mainLock = this.mainLock;            // 加互斥锁，要添加 worker 了            mainLock.lock();            try &#123;                // 获取最新线程池运行状态保存到 rs                int rs = runStateOf(ctl.get());// 判断线程池是否为RUNNING状态，不是再【判断当前是否为SHUTDOWN状态且firstTask为空，特殊情况】                if (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123;                    // 当线程start后，线程isAlive会返回true，这里还没开始启动线程，如果被启动了就需要报错                    if (t.isAlive())                        throw new IllegalThreadStateException();                                        //【将新建的 Worker 添加到线程池中】                    workers.add(w);                    int s = workers.size();// 当前池中的线程数量是一个新高，更新 largestPoolSize                    if (s &gt; largestPoolSize)                        largestPoolSize = s;                    // 添加标记置为 true                    workerAdded = true;                &#125;            &#125; finally &#123;                // 解锁啊                mainLock.unlock();            &#125;            // 添加成功就【启动线程执行任务】            if (workerAdded) &#123;                // Thread 类中持有 Runnable 任务对象，调用的是 Runnable 的 run ，也就是 FutureTask                t.start();                // 运行标记置为 true                workerStarted = true;            &#125;        &#125;    &#125; finally &#123;        // 如果启动线程失败，做清理工作        if (! workerStarted)            addWorkerFailed(w);    &#125;    // 返回新创建的线程是否启动    return workerStarted;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>addWorkerFailed()：清理任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addWorkerFailed</span><span class="params">(Worker w)</span> </span>&#123;    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;    <span class="comment">// 持有线程池全局锁，因为操作的是线程池相关的东西    mainLock.lock();    try &#123;        //条件成立需要将 worker 在 workers 中清理出去。        if (w != null)            workers.remove(w);        // 将线程池计数 -1，相当于归还令牌。        decrementWorkerCount();        // 尝试停止线程池        tryTerminate();    &#125; finally &#123;        //释放线程池全局锁。        mainLock.unlock();    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="运行方法"><a href="#运行方法" class="headerlink" title="运行方法"></a>运行方法</h5><ul><li><p>Worker#run：Worker 实现了 Runnable 接口，当线程启动时，会调用 Worker 的 run() 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;    <span class="comment">// ThreadPoolExecutor#runWorker()    runWorker(this);&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>runWorker()：<strong>执行任务</strong>，线程会一直 while 循环获取任务执行任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;    Thread wt = Thread.currentThread();    <span class="comment">// 获取 worker 的 firstTask    Runnable task = w.firstTask;    // 引用置空，【防止复用该线程时重复执行该任务】    w.firstTask = null;    // 初始化 worker 时设置 state = -1，表示不允许抢占锁    // 这里需要设置 state = 0 和 exclusiveOwnerThread = null，开始独占模式抢锁    w.unlock();    // true 表示发生异常退出，false 表示正常退出。    boolean completedAbruptly = true;    try &#123;        // firstTask 不是 null 就直接运行，否则去 queue 中获取任务        // 【getTask 如果是阻塞获取任务，会一直阻塞在take方法，直到获取任务，不会走返回null的逻辑】        while (task != null || (task = getTask()) != null) &#123;            // worker 加锁，shutdown 时会判断当前 worker 状态，【根据独占锁状态判断是否空闲】            w.lock();            // 说明线程池状态大于 STOP，目前处于 STOP/TIDYING/TERMINATION，此时给线程一个中断信号            if ((runStateAtLeast(ctl.get(), STOP) ||                 // 说明线程处于 RUNNING 或者 SHUTDOWN 状态，清除打断标记                 (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted())                // 中断线程，设置线程的中断标志位为 true                wt.interrupt();            try &#123;                // 钩子方法，【任务执行的前置处理】                beforeExecute(wt, task);                Throwable thrown = null;                try &#123;                    // 【执行任务】                    task.run();                &#125; catch (Exception x) &#123;                 //.....                &#125; finally &#123;                    // 钩子方法，【任务执行的后置处理】                    afterExecute(task, thrown);                &#125;            &#125; finally &#123;                task = null;// 将局部变量task置为null，代表任务执行完成                w.completedTasks++;// 更新worker完成任务数量                w.unlock();// 解锁            &#125;        &#125;        // getTask()方法返回null时会走到这里，表示queue为空并且线程空闲超过保活时间，【当前线程执行退出逻辑】        completedAbruptly = false;    &#125; finally &#123;        // 正常退出 completedAbruptly = false       // 异常退出 completedAbruptly = true，【从 task.run() 内部抛出异常】时，跳到这一行        processWorkerExit(w, completedAbruptly);    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>unlock()：重置锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123; release(<span class="number">1</span>); &#125;<span class="comment">// 外部不会直接调用这个方法 这个方法是 AQS 内调用的，外部调用 unlock 时触发此方法protected boolean tryRelease(int unused) &#123;    setExclusiveOwnerThread(null);// 设置持有者为 null    setState(0);// 设置 state = 0    return true;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>getTask()：获取任务，线程空闲时间超过 keepAliveTime 就会被回收，判断的依据是<strong>当前线程阻塞获取任务超过保活时间</strong>，方法返回 null 就代表当前线程要被回收了，返回到 runWorker 执行线程退出逻辑。线程池具有担保机制，对于 RUNNING 状态下的超时回收，要保证线程池中最少有一个线程运行，或者任务阻塞队列已经是空</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;    <span class="comment">// 超时标记，表示当前线程获取任务是否超时，true 表示已超时    boolean timedOut = false;     for (;;) &#123;        int c = ctl.get();        // 获取线程池当前运行状态        int rs = runStateOf(c);        // 【tryTerminate】打断线程后执行到这，此时线程池状态为STOP或者线程池状态为SHUTDOWN并且队列已经是空        // 所以下面的 if 条件一定是成立的，可以直接返回 null，线程就应该退出了        if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;            // 使用 CAS 自旋的方式让 ctl 值 -1            decrementWorkerCount();            return null;        &#125;        // 获取线程池中的线程数量        int wc = workerCountOf(c);        // 线程没有明确的区分谁是核心或者非核心线程，是根据当前池中的线程数量判断                // timed = false 表示当前这个线程 获取task时不支持超时机制的，当前线程会使用 queue.take() 阻塞获取        // timed = true 表示当前这个线程 获取task时支持超时机制，使用 queue.poll(xxx,xxx) 超时获取        // 条件一代表允许回收核心线程，那就无所谓了，全部线程都执行超时回收        // 条件二成立说明线程数量大于核心线程数，当前线程认为是非核心线程，有保活时间，去超时获取任务        boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;        // 如果线程数量是否超过最大线程数，直接回收        // 如果当前线程【允许超时回收并且已经超时了】，就应该被回收了，由于【担保机制】还要做判断：        //   wc &gt; 1 说明线程池还用其他线程，当前线程可以直接回收        //    workQueue.isEmpty() 前置条件是 wc = 1，【如果当前任务队列也是空了，最后一个线程就可以退出】        if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)) &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123;            // 使用 CAS 机制将 ctl 值 -1 ,减 1 成功的线程，返回 null，代表可以退出            if (compareAndDecrementWorkerCount(c))                return null;            continue;        &#125;        try &#123;            // 根据当前线程是否需要超时回收，【选择从队列获取任务的方法】是超时获取或者阻塞获取            Runnable r = timed ?                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take();            // 获取到任务返回任务，【阻塞获取会阻塞到获取任务为止】，不会返回 null            if (r != null)                return r;            // 获取任务为 null 说明超时了，将超时标记设置为 true，下次自旋时返 null            timedOut = true;        &#125; catch (InterruptedException retry) &#123;            // 阻塞线程被打断后超时标记置为 false，【说明被打断不算超时】，要继续获取，直到超时或者获取到任务            // 如果线程池 SHUTDOWN 状态下的打断，会在循环获取任务前判断，返回 null            timedOut = false;        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>processWorkerExit()：<strong>线程退出线程池</strong>，也有担保机制，保证队列中的任务被执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常退出 completedAbruptly = false，异常退出为 trueprivate void processWorkerExit(Worker w, boolean completedAbruptly) &#123;    // 条件成立代表当前 worker 是发生异常退出的，task 任务执行过程中向上抛出异常了    if (completedAbruptly)         // 从异常时到这里 ctl 一直没有 -1，需要在这里 -1        decrementWorkerCount();    final ReentrantLock mainLock = this.mainLock;    // 加锁    mainLock.lock();    try &#123;        // 将当前 worker 完成的 task 数量，汇总到线程池的 completedTaskCount        completedTaskCount += w.completedTasks;// 将 worker 从线程池中移除        workers.remove(w);    &#125; finally &#123;        mainLock.unlock();// 解锁    &#125;// 尝试停止线程池，唤醒下一个线程    tryTerminate();    int c = ctl.get();    // 线程池不是停止状态就应该有线程运行【担保机制】    if (runStateLessThan(c, STOP)) &#123;        // 正常退出的逻辑，是对空闲线程回收，不是执行出错        if (!completedAbruptly) &#123;            // 根据是否回收核心线程确定【线程池中的线程数量最小值】            int min = allowCoreThreadTimeOut ? 0 : corePoolSize;            // 最小值为 0，但是线程队列不为空，需要一个线程来完成任务担保机制            if (min == 0 &amp;&amp; !workQueue.isEmpty())                min = 1;            // 线程池中的线程数量大于最小值可以直接返回            if (workerCountOf(c) &gt;= min)                return;        &#125;        // 执行 task 时发生异常，有个线程因为异常终止了，需要添加        // 或者线程池中的数量小于最小值，这里要创建一个新 worker 加进线程池        addWorker(null, false);    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="停止方法"><a href="#停止方法" class="headerlink" title="停止方法"></a>停止方法</h5><ul><li><p>shutdown()：停止线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;    <span class="comment">// 获取线程池全局锁    mainLock.lock();    try &#123;        checkShutdownAccess();        // 设置线程池状态为 SHUTDOWN，如果线程池状态大于 SHUTDOWN，就不会设置直接返回        advanceRunState(SHUTDOWN);        // 中断空闲线程        interruptIdleWorkers();        // 空方法，子类可以扩展        onShutdown();     &#125; finally &#123;        // 释放线程池全局锁        mainLock.unlock();    &#125;    tryTerminate();&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>interruptIdleWorkers()：shutdown 方法会<strong>中断所有空闲线程</strong>，根据是否可以获取 AQS 独占锁判断是否处于工作状态。线程之所以空闲是因为阻塞队列没有任务，不会中断正在运行的线程，所以 shutdown 方法会让所有的任务执行完毕。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onlyOne == true 说明只中断一个线程 ，false 则中断所有线程private void interruptIdleWorkers(boolean onlyOne) &#123;    final ReentrantLock mainLock = this.mainLock;    / /持有全局锁    mainLock.lock();    try &#123;        // 遍历所有 worker        for (Worker w : workers) &#123;            // 获取当前 worker 的线程            Thread t = w.thread;            // 条件一成立：说明当前迭代的这个线程尚未中断            // 条件二成立：说明当前worker处于空闲状态，阻塞在poll或者take，因为worker执行task时是要加锁的            //           每个worker有一个独占锁，w.tryLock()尝试加锁，加锁成功返回 true            if (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;                try &#123;                    // 中断线程，处于 queue 阻塞的线程会被唤醒，进入下一次自旋，返回 null，执行退出相逻辑                    t.interrupt();                &#125; catch (SecurityException ignore) &#123;                &#125; finally &#123;                    // 释放worker的独占锁                    w.unlock();                &#125;            &#125;            // false，代表中断所有的线程            if (onlyOne)                break;        &#125;    &#125; finally &#123;        // 释放全局锁        mainLock.unlock();    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>shutdownNow()：直接关闭线程池，不会等待任务执行完成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123;    <span class="comment">// 返回值引用    List&lt;Runnable&gt; tasks;    final ReentrantLock mainLock = this.mainLock;    // 获取线程池全局锁    mainLock.lock();    try &#123;        checkShutdownAccess();        // 设置线程池状态为STOP        advanceRunState(STOP);        // 中断线程池中【所有线程】        interruptWorkers();        // 从阻塞队列中导出未处理的task        tasks = drainQueue();    &#125; finally &#123;        mainLock.unlock();    &#125;    tryTerminate();    // 返回当前任务队列中 未处理的任务。    return tasks;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>tryTerminate()：设置为 TERMINATED 状态 if either (SHUTDOWN and pool and queue empty) or (STOP and pool empty)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryTerminate</span><span class="params">()</span> </span>&#123;    <span class="keyword">for</span> (;;) &#123;        <span class="comment">// 获取 ctl 的值        int c = ctl.get();        // 线程池正常，或者有其他线程执行了状态转换的方法，当前线程直接返回        if (isRunning(c) || runStateAtLeast(c, TIDYING) ||            // 线程池是 SHUTDOWN 并且任务队列不是空，需要去处理队列中的任务            (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))            return;                // 执行到这里说明线程池状态为 STOP 或者线程池状态为 SHUTDOWN 并且队列已经是空        // 判断线程池中线程的数量        if (workerCountOf(c) != 0) &#123;            // 【中断一个空闲线程】，在 queue.take() | queue.poll() 阻塞空闲            // 唤醒后的线程会在getTask()方法返回null，            // 执行 processWorkerExit 退出逻辑时会再次调用 tryTerminate() 唤醒下一个空闲线程            interruptIdleWorkers(ONLY_ONE);            return;        &#125;// 池中的线程数量为 0 来到这里        final ReentrantLock mainLock = this.mainLock;        // 加全局锁        mainLock.lock();        try &#123;            // 设置线程池状态为 TIDYING 状态，线程数量为 0            if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) &#123;                try &#123;                    // 结束线程池                    terminated();                &#125; finally &#123;                    // 设置线程池状态为TERMINATED状态。                    ctl.set(ctlOf(TERMINATED, 0));                    // 【唤醒所有调用 awaitTermination() 方法的线程】                    termination.signalAll();                &#125;                return;            &#125;        &#125; finally &#123;// 释放线程池全局锁            mainLock.unlock();        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h4><h5 id="线程使用"><a href="#线程使用" class="headerlink" title="线程使用"></a>线程使用</h5><p>FutureTask 未来任务对象，继承 Runnable、Future 接口，用于包装 Callable 对象，实现任务的提交</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;    FutureTask&lt;String&gt; task = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;        <span class="meta">@Override</span>        <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;            <span class="keyword">return</span> <span class="string">&quot;Hello World&quot;</span>;        &#125;    &#125;);    <span class="keyword">new</span> Thread(task).start();<span class="comment">//启动线程    String msg = task.get();//获取返回任务数据    System.out.println(msg);&#125;</span></span><br></pre></td></tr></table></figure><p>构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span></span>&#123;<span class="keyword">this</span>.callable = callable;<span class="comment">// 属性注入    this.state = NEW; // 任务状态设置为 new&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;    <span class="comment">// 适配器模式    this.callable = Executors.callable(runnable, result);    this.state = NEW;       &#125;public static &lt;T&gt; Callable&lt;T&gt; callable(Runnable task, T result) &#123;    if (task == null) throw new NullPointerException();    // 使用装饰者模式将 runnable 转换成 callable 接口，外部线程通过 get 获取    // 当前任务执行结果时，结果可能为 null 也可能为【传进来】的值，传进来什么返回什么    return new RunnableAdapter&lt;T&gt;(task, result);&#125;static final class RunnableAdapter&lt;T&gt; implements Callable&lt;T&gt; &#123;    final Runnable task;    final T result;    // 构造方法    RunnableAdapter(Runnable task, T result) &#123;        this.task = task;        this.result = result;    &#125;    public T call() &#123;        // 实则调用 Runnable#run 方法        task.run();        // 返回值为构造 FutureTask 对象时传入的返回值或者是 null        return result;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h5 id="成员属性-3"><a href="#成员属性-3" class="headerlink" title="成员属性"></a>成员属性</h5><p>FutureTask 类的成员属性：</p><ul><li><p>任务状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示当前task状态private volatile int state;// 当前任务尚未执行private static final int NEW          = 0;// 当前任务正在结束，尚未完全结束，一种临界状态private static final int COMPLETING   = 1;// 当前任务正常结束private static final int NORMAL       = 2;// 当前任务执行过程中发生了异常，内部封装的 callable.run() 向上抛出异常了private static final int EXCEPTIONAL  = 3;// 当前任务被取消private static final int CANCELLED    = 4;// 当前任务中断中private static final int INTERRUPTING = 5;// 当前任务已中断private static final int INTERRUPTED  = 6;</span></span><br></pre></td></tr></table></figure></li><li><p>任务对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Callable&lt;V&gt; callable;<span class="comment">// Runnable 使用装饰者模式伪装成 Callable</span></span><br></pre></td></tr></table></figure></li><li><p><strong>存储任务执行的结果</strong>，这是 run 方法返回值是 void 也可以获取到执行结果的原因：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常情况下：任务正常执行结束，outcome 保存执行结果，callable 返回值// 非正常情况：callable 向上抛出异常，outcome 保存异常private Object outcome; </span></span><br></pre></td></tr></table></figure></li><li><p>执行当前任务的线程对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Thread runner;<span class="comment">// 当前任务被线程执行期间，保存当前执行任务的线程对象引用</span></span><br></pre></td></tr></table></figure></li><li><p>线程阻塞队列的头节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 会有很多线程去 get 当前任务的结果，这里使用了一种数据结构头插头取（类似栈）的一个队列来保存所有的 get 线程private volatile WaitNode waiters;</span></span><br></pre></td></tr></table></figure></li><li><p>内部类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNode</span> </span>&#123;    <span class="comment">// 单向链表    volatile Thread thread;    volatile WaitNode next;    WaitNode() &#123; thread = Thread.currentThread(); &#125;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="成员方法-3"><a href="#成员方法-3" class="headerlink" title="成员方法"></a>成员方法</h5><p>FutureTask 类的成员方法：</p><ul><li><p><strong>FutureTask#run</strong>：任务执行入口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;    <span class="comment">//条件一：成立说明当前 task 已经被执行过了或者被 cancel 了，非 NEW 状态的任务，线程就不需要处理了    //条件二：线程是 NEW 状态，尝试设置当前任务对象的线程是当前线程，设置失败说明其他线程抢占了该任务，直接返回    if (state != NEW ||        !UNSAFE.compareAndSwapObject(this, runnerOffset, null, Thread.currentThread()))        return;    try &#123;        // 执行到这里，当前 task 一定是 NEW 状态，而且【当前线程也抢占 task 成功】        Callable&lt;V&gt; c = callable;        // 判断任务是否为空，防止空指针异常；判断 state 状态，防止外部线程在此期间 cancel 掉当前任务        // 【因为 task 的执行者已经设置为当前线程，所以这里是线程安全的】        if (c != null &amp;&amp; state == NEW) &#123;            V result;            // true 表示 callable.run 代码块执行成功 未抛出异常            // false 表示 callable.run 代码块执行失败 抛出异常            boolean ran;            try &#123;// 【调用自定义的方法，执行结果赋值给 result】                result = c.call();                // 没有出现异常                ran = true;            &#125; catch (Throwable ex) &#123;                // 出现异常，返回值置空，ran 置为 false                result = null;                ran = false;                // 设置返回的异常                setException(ex);            &#125;            // 代码块执行正常            if (ran)                // 设置返回的结果                set(result);        &#125;    &#125; finally &#123;        // 任务执行完成，取消线程的引用，help GC        runner = null;        int s = state;        // 判断任务是不是被中断        if (s &gt;= INTERRUPTING)            // 执行中断处理方法            handlePossibleCancellationInterrupt(s);    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>FutureTask#set：设置正常返回值，首先将任务状态设置为 COMPLETING 状态代表完成中，逻辑执行完设置为 NORMAL 状态代表任务正常执行完成，最后唤醒 get() 阻塞线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V v)</span> </span>&#123;    <span class="comment">// CAS 方式设置当前任务状态为完成中，设置失败说明其他线程取消了该任务    if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) &#123;        // 【将结果赋值给 outcome】        outcome = v;        // 将当前任务状态修改为 NORMAL 正常结束状态。        UNSAFE.putOrderedInt(this, stateOffset, NORMAL);        finishCompletion();    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>FutureTask#setException：设置异常返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setException</span><span class="params">(Throwable t)</span> </span>&#123;    <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW, COMPLETING)) &#123;        <span class="comment">// 赋值给返回结果，用来向上层抛出来的异常        outcome = t;        // 将当前任务的状态 修改为 EXCEPTIONAL        UNSAFE.putOrderedInt(this, stateOffset, EXCEPTIONAL);        finishCompletion();    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>FutureTask#finishCompletion：<strong>唤醒 get() 阻塞线程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishCompletion</span><span class="params">()</span> </span>&#123;    <span class="comment">// 遍历所有的等待的节点，q 指向头节点    for (WaitNode q; (q = waiters) != null;) &#123;        // 使用cas设置 waiters 为 null，防止外部线程使用cancel取消当前任务，触发finishCompletion方法重复执行        if (UNSAFE.compareAndSwapObject(this, waitersOffset, q, null)) &#123;            // 自旋            for (;;) &#123;                // 获取当前 WaitNode 节点封装的 thread                Thread t = q.thread;                // 当前线程不为 null，唤醒当前 get() 等待获取数据的线程                if (t != null) &#123;                    q.thread = null;                    LockSupport.unpark(t);                &#125;                // 获取当前节点的下一个节点                WaitNode next = q.next;                // 当前节点是最后一个节点了                if (next == null)                    break;                // 断开链表                q.next = null; // help gc                q = next;            &#125;            break;        &#125;    &#125;    done();    callable = null;// help GC&#125;</span></span><br></pre></td></tr></table></figure><p>FutureTask#handlePossibleCancellationInterrupt：任务中断处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handlePossibleCancellationInterrupt</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;    <span class="keyword">if</span> (s == INTERRUPTING)        <span class="comment">// 中断状态中        while (state == INTERRUPTING)            // 等待中断完成            Thread.yield();&#125;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>FutureTask#get</strong>：获取任务执行的返回值，执行 run 和 get 的不是同一个线程，一般有多个线程 get，只有一个线程 run</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;    <span class="comment">// 获取当前任务状态    int s = state;    // 条件成立说明任务还没执行完成    if (s &lt;= COMPLETING)        // 返回 task 当前状态，可能当前线程在里面已经睡了一会        s = awaitDone(false, 0L);    return report(s);&#125;</span></span><br></pre></td></tr></table></figure><p>FutureTask#awaitDone：<strong>get 线程封装成 WaitNode 对象进入阻塞队列阻塞等待</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">awaitDone</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;    <span class="comment">// 0 不带超时    final long deadline = timed ? System.nanoTime() + nanos : 0L;    // 引用当前线程，封装成 WaitNode 对象    WaitNode q = null;    // 表示当前线程 waitNode 对象，是否进入阻塞队列    boolean queued = false;    // 【三次自旋开始休眠】    for (;;) &#123;        // 判断当前 get() 线程是否被打断，打断返回 true，清除打断标记        if (Thread.interrupted()) &#123;            // 当前线程对应的等待 node 出队，            removeWaiter(q);            throw new InterruptedException();        &#125;// 获取任务状态        int s = state;        // 条件成立说明当前任务执行完成已经有结果了        if (s &gt; COMPLETING) &#123;            // 条件成立说明已经为当前线程创建了 WaitNode，置空 help GC            if (q != null)                q.thread = null;            // 返回当前的状态            return s;        &#125;        // 条件成立说明当前任务接近完成状态，这里让当前线程释放一下 cpu ，等待进行下一次抢占 cpu        else if (s == COMPLETING)             Thread.yield();        // 【第一次自旋】，当前线程还未创建 WaitNode 对象，此时为当前线程创建 WaitNode对象        else if (q == null)            q = new WaitNode();        // 【第二次自旋】，当前线程已经创建 WaitNode 对象了，但是node对象还未入队        else if (!queued)            // waiters 指向队首，让当前 WaitNode 成为新的队首，【头插法】，失败说明其他线程修改了新的队首            queued = UNSAFE.compareAndSwapObject(this, waitersOffset, q.next = waiters, q);        // 【第三次自旋】，会到这里，或者 else 内        else if (timed) &#123;            nanos = deadline - System.nanoTime();            if (nanos &lt;= 0L) &#123;                removeWaiter(q);                return state;            &#125;            // 阻塞指定的时间            LockSupport.parkNanos(this, nanos);        &#125;        // 条件成立：说明需要阻塞        else            // 【当前 get 操作的线程被 park 阻塞】，除非有其它线程将唤醒或者将当前线程中断            LockSupport.park(this);    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>FutureTask#report：封装运行结果，可以获取 run() 方法中设置的成员变量 outcome，<strong>这是 run 方法的返回值是 void 也可以获取到任务执行的结果的原因</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">report</span><span class="params">(<span class="keyword">int</span> s)</span> <span class="keyword">throws</span> ExecutionException </span>&#123;    <span class="comment">// 获取执行结果，是在一个 futuretask 对象中的属性，可以直接获取    Object x = outcome;    // 当前任务状态正常结束    if (s == NORMAL)        return (V)x;// 直接返回 callable 的逻辑结果    // 当前任务被取消或者中断    if (s &gt;= CANCELLED)        throw new CancellationException();// 抛出异常    // 执行到这里说明自定义的 callable 中的方法有异常，使用 outcome 上层抛出异常    throw new ExecutionException((Throwable)x);&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>FutureTask#cancel：任务取消，打断正在执行该任务的线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span> </span>&#123;    <span class="comment">// 条件一：表示当前任务处于运行中或者处于线程池任务队列中    // 条件二：表示修改状态，成功可以去执行下面逻辑，否则返回 false 表示 cancel 失败    if (!(state == NEW &amp;&amp;          UNSAFE.compareAndSwapInt(this, stateOffset, NEW,                                   mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))        return false;    try &#123;        // 如果任务已经被执行，是否允许打断        if (mayInterruptIfRunning) &#123;            try &#123;                // 获取执行当前 FutureTask 的线程                Thread t = runner;                if (t != null)                    // 打断执行的线程                    t.interrupt();            &#125; finally &#123;                // 设置任务状态为【中断完成】                UNSAFE.putOrderedInt(this, stateOffset, INTERRUPTED);            &#125;        &#125;    &#125; finally &#123;        // 唤醒所有 get() 阻塞的线程        finishCompletion();    &#125;    return true;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><p>参考视频：<a href="https://www.bilibili.com/video/BV13E411N7pp">https://www.bilibili.com/video/BV13E411N7pp</a></p><hr><h3 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h3><h4 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h4><p>Timer 实现定时功能，Timer 的优点在于简单易用，但由于所有任务都是由同一个线程来调度，因此所有任务都是串行执行的，同一时间只能有一个任务在执行，前一个任务的延迟或异常都将会影响到之后的任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;    Timer timer = <span class="keyword">new</span> Timer();    TimerTask task1 = <span class="keyword">new</span> TimerTask() &#123;        <span class="meta">@Override</span>        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;            System.out.println(<span class="string">&quot;task 1&quot;</span>);            <span class="comment">//int i = 1 / 0;//任务一的出错会导致任务二无法执行            Thread.sleep(2000);        &#125;    &#125;;    TimerTask task2 = new TimerTask() &#123;        @Override        public void run() &#123;            System.out.println(&quot;task 2&quot;);        &#125;    &#125;;    // 使用 timer 添加两个任务，希望它们都在 1s 后执行// 但由于 timer 内只有一个线程来顺序执行队列中的任务，因此任务1的延时，影响了任务2的执行    timer.schedule(task1,1000);//17:45:56 c.ThreadPool [Timer-0] - task 1    timer.schedule(task2,1000);//17:45:58 c.ThreadPool [Timer-0] - task 2&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="Scheduled"><a href="#Scheduled" class="headerlink" title="Scheduled"></a>Scheduled</h4><p>任务调度线程池 ScheduledThreadPoolExecutor 继承 ThreadPoolExecutor：</p><ul><li>使用内部类 ScheduledFutureTask 封装任务</li><li>使用内部类 DelayedWorkQueue 作为线程池队列</li><li>重写 onShutdown 方法去处理 shutdown 后的任务</li><li>提供 decorateTask 方法作为 ScheduledFutureTask 的修饰方法，以便开发者进行扩展</li></ul><p>构造方法：<code>Executors.newScheduledThreadPool(int corePoolSize)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;    <span class="comment">// 最大线程数固定为 Integer.MAX_VALUE，保活时间 keepAliveTime 固定为 0    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,          // 阻塞队列是 DelayedWorkQueue          new DelayedWorkQueue());&#125;</span></span><br></pre></td></tr></table></figure><p>常用 API：</p><ul><li><code>ScheduledFuture&lt;?&gt; schedule(Runnable/Callable&lt;V&gt;, long delay, TimeUnit u)</code>：延迟执行任务</li><li><code>ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable/Callable&lt;V&gt;, long initialDelay, long period, TimeUnit unit)</code>：定时执行任务，参数为初始延迟时间、间隔时间、单位</li><li><code>ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable/Callable&lt;V&gt;, long initialDelay, long delay, TimeUnit unit)</code>：定时执行任务，参数为初始延迟时间、间隔时间、单位</li></ul><p>基本使用：</p><ul><li><p>延迟任务，但是出现异常并不会在控制台打印，也不会影响其他线程的执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;    <span class="comment">// 线程池大小为1时也是串行执行    ScheduledExecutorService executor = Executors.newScheduledThreadPool(2);    // 添加两个任务，都在 1s 后同时执行    executor.schedule(() -&gt; &#123;    System.out.println(&quot;任务1，执行时间：&quot; + new Date());        //int i = 1 / 0;    try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; &#125;    &#125;, 1000, TimeUnit.MILLISECONDS);        executor.schedule(() -&gt; &#123;    System.out.println(&quot;任务2，执行时间：&quot; + new Date());    &#125;, 1000, TimeUnit.MILLISECONDS);&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>定时任务 scheduleAtFixedRate：<strong>一次任务的启动到下一次任务的启动</strong>之间只要大于等于间隔时间，抢占到 CPU 就会立即执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    ScheduledExecutorService pool = Executors.newScheduledThreadPool(<span class="number">1</span>);    System.out.println(<span class="string">&quot;start...&quot;</span> + <span class="keyword">new</span> Date());        pool.scheduleAtFixedRate(() -&gt; &#123;        System.out.println(<span class="string">&quot;running...&quot;</span> + <span class="keyword">new</span> Date());        Thread.sleep(<span class="number">2000</span>);    &#125;, <span class="number">1</span>, <span class="number">1</span>, TimeUnit.SECONDS);&#125;<span class="comment">/*start...Sat Apr 24 18:08:12 CST 2021running...Sat Apr 24 18:08:13 CST 2021running...Sat Apr 24 18:08:15 CST 2021running...Sat Apr 24 18:08:17 CST 2021</span></span><br></pre></td></tr></table></figure></li><li><p>定时任务 scheduleWithFixedDelay：<strong>一次任务的结束到下一次任务的启动之间</strong>等于间隔时间，抢占到 CPU 就会立即执行，这个方法才是真正的设置两个任务之间的间隔</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;    ScheduledExecutorService pool = Executors.newScheduledThreadPool(<span class="number">3</span>);    System.out.println(<span class="string">&quot;start...&quot;</span> + <span class="keyword">new</span> Date());        pool.scheduleWithFixedDelay(() -&gt; &#123;        System.out.println(<span class="string">&quot;running...&quot;</span> + <span class="keyword">new</span> Date());        Thread.sleep(<span class="number">2000</span>);    &#125;, <span class="number">1</span>, <span class="number">1</span>, TimeUnit.SECONDS);&#125;<span class="comment">/*start...Sat Apr 24 18:11:41 CST 2021running...Sat Apr 24 18:11:42 CST 2021running...Sat Apr 24 18:11:45 CST 2021running...Sat Apr 24 18:11:48 CST 2021</span></span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="成员属性-4"><a href="#成员属性-4" class="headerlink" title="成员属性"></a>成员属性</h4><h5 id="成员变量-1"><a href="#成员变量-1" class="headerlink" title="成员变量"></a>成员变量</h5><ul><li><p>shutdown 后是否继续执行定时任务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> continueExistingPeriodicTasksAfterShutdown;</span><br></pre></td></tr></table></figure></li><li><p>shutdown 后是否继续执行延迟任务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> executeExistingDelayedTasksAfterShutdown = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure></li><li><p>取消方法是否将该任务从队列中移除：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> removeOnCancel = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure></li><li><p>任务的序列号：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLong sequencer = <span class="keyword">new</span> AtomicLong();</span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="延迟任务"><a href="#延迟任务" class="headerlink" title="延迟任务"></a>延迟任务</h5><p>ScheduledFutureTask 继承 FutureTask，实现 RunnableScheduledFuture 接口，具有延迟执行的特点，覆盖 FutureTask 的 run 方法来实现对<strong>延时执行、周期执行</strong>的支持。对于延时任务调用 FutureTask#run，而对于周期性任务则调用 FutureTask#runAndReset 并且在成功之后根据 fixed-delay/fixed-rate 模式来设置下次执行时间并重新将任务塞到工作队列。</p><p>在调度线程池中无论是 runnable 还是 callable，无论是否需要延迟和定时，所有的任务都会被封装成 ScheduledFutureTask</p><p>成员变量：</p><ul><li><p>任务序列号：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> sequenceNumber;</span><br></pre></td></tr></table></figure></li><li><p>执行时间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> time;<span class="comment">// 任务可以被执行的时间，以纳秒表示private final long period;// 0 表示非周期任务，正数表示 fixed-rate 模式的周期，负数表示 fixed-delay 模式</span></span><br></pre></td></tr></table></figure><p>fixed-rate：两次开始启动的间隔，fixed-delay：一次执行结束到下一次开始启动</p></li><li><p>实际的任务对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RunnableScheduledFuture&lt;V&gt; outerTask = <span class="keyword">this</span>;</span><br></pre></td></tr></table></figure></li><li><p>任务在队列数组中的索引下标：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> heapIndex;<span class="comment">// -1 代表删除</span></span><br></pre></td></tr></table></figure></li></ul><p>成员方法：</p><ul><li><p>构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ScheduledFutureTask(Runnable r, V result, <span class="keyword">long</span> ns, <span class="keyword">long</span> period) &#123;    <span class="keyword">super</span>(r, result);    <span class="comment">// 任务的触发时间    this.time = ns;    // 任务的周期，多长时间执行一次    this.period = period;    // 任务的序号    this.sequenceNumber = sequencer.getAndIncrement();&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>compareTo()：ScheduledFutureTask 根据执行时间 time 正序排列，如果执行时间相同，在按照序列号 sequenceNumber 正序排列，任务需要放入 DelayedWorkQueue，延迟队列中使用该方法按照从小到大进行排序</p></li><li><p>run()：执行任务，非周期任务直接完成直接结束，<strong>周期任务执行完后会设置下一次的执行时间，重新放入线程池的阻塞队列</strong>，如果线程池中的线程数量少于核心线程，就会添加 Worker 开启新线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;    <span class="comment">// 是否周期性，就是判断 period 是否为 0    boolean periodic = isPeriodic();    // 检查当前状态能否执行任务，不能执行就取消任务    if (!canRunInCurrentRunState(periodic))        cancel(false);    // 非周期任务，直接调用 FutureTask#run 执行    else if (!periodic)        ScheduledFutureTask.super.run();    // 周期任务的执行，返回 true 表示执行成功    else if (ScheduledFutureTask.super.runAndReset()) &#123;        // 设置周期任务的下一次执行时间        setNextRunTime();        // 任务的下一次执行安排，如果当前线程池状态可以执行周期任务，加入队列，并开启新线程        reExecutePeriodic(outerTask);    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>周期任务正常完成后任务的状态不会变化，依旧是 NEW，不会设置 outcome 属性。但是如果本次任务执行出现异常，会进入 setException 方法将任务状态置为异常，把异常保存在 outcome 中，方法返回 false，后续的该任务将不会再周期的执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">runAndReset</span><span class="params">()</span> </span>&#123;    <span class="comment">// 任务不是新建的状态了，或者被别的线程执行了，直接返回 false    if (state != NEW ||        !UNSAFE.compareAndSwapObject(this, runnerOffset, null, Thread.currentThread()))        return false;    boolean ran = false;    int s = state;    try &#123;        Callable&lt;V&gt; c = callable;        if (c != null &amp;&amp; s == NEW) &#123;            try &#123;                // 执行方法，没有返回值                c.call();                ran = true;            &#125; catch (Throwable ex) &#123;                // 出现异常，把任务设置为异常状态，唤醒所有的 get 阻塞线程                setException(ex);            &#125;        &#125;    &#125; finally &#123;// 执行完成把执行线程引用置为 null        runner = null;        s = state;        // 如果线程被中断进行中断处理        if (s &gt;= INTERRUPTING)            handlePossibleCancellationInterrupt(s);    &#125;    // 如果正常执行，返回 true，并且任务状态没有被取消    return ran &amp;&amp; s == NEW;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 任务下一次的触发时间private void setNextRunTime() &#123;    long p = period;    if (p &gt; 0)        // fixed-rate 模式，【时间设置为上一次执行任务的时间 +p】，两次任务执行的时间差        time += p;    else        // fixed-delay 模式，下一次执行时间是当【前这次任务结束的时间（就是现在） +delay 值】        time = triggerTime(-p);&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>reExecutePeriodic()<strong>：准备任务的下一次执行，重新放入阻塞任务队列</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ScheduledThreadPoolExecutor#reExecutePeriodicvoid reExecutePeriodic(RunnableScheduledFuture&lt;?&gt; task) &#123;    if (canRunInCurrentRunState(true)) &#123;        // 【放入任务队列】        super.getQueue().add(task);        // 再次检查是否可以执行，如果不能执行且任务还在队列中未被取走，则取消任务        if (!canRunInCurrentRunState(true) &amp;&amp; remove(task))            task.cancel(false);        else            // 当前线程池状态可以执行周期任务，加入队列，并【根据线程数量是否大于核心线程数确定是否开启新线程】            ensurePrestart();    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>cancel()：取消任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span> </span>&#123;    <span class="comment">// 调用父类 FutureTask#cancel 来取消任务    boolean cancelled = super.cancel(mayInterruptIfRunning);    // removeOnCancel 用于控制任务取消后是否应该从阻塞队列中移除    if (cancelled &amp;&amp; removeOnCancel &amp;&amp; heapIndex &gt;= 0)        // 从等待队列中删除该任务，并调用 tryTerminate() 判断是否需要停止线程池        remove(this);    return cancelled;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h5><p>DelayedWorkQueue 是支持延时获取元素的阻塞队列，内部采用优先队列 PriorityQueue（小根堆）存储元素</p><p>其他阻塞队列存储节点的数据结构大都是链表，<strong>延迟队列是数组</strong>，所以延迟队列出队头元素后需要让其他元素（尾）替换到头节点，防止空指针异常</p><p>成员变量：</p><ul><li><p>容量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;<span class="comment">// 初始容量private int size = 0;// 节点数量private RunnableScheduledFuture&lt;?&gt;[] queue =     new RunnableScheduledFuture&lt;?&gt;[INITIAL_CAPACITY];// 存放节点</span></span><br></pre></td></tr></table></figure></li><li><p>锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();<span class="comment">// 控制并发private final Condition available = lock.newCondition();// 条件队列</span></span><br></pre></td></tr></table></figure></li><li><p>阻塞等待头节点的线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过阻塞方式去获取头结点，那么 leader 线程的等待时间为头结点的延迟时间，其它线程则会陷入阻塞状态// leader 线程获取到头结点后需要发送信号唤醒其它线程 available.asignAll()// 使用了 Leader/Follower 来避免不必要的等待，只让leader来等待需要等待的时间，其余线程无限等待直至被唤醒即可private Thread leader = null;</span></span><br></pre></td></tr></table></figure></li></ul><p>成员方法</p><ul><li><p>offer()：插入节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(Runnable x)</span> </span>&#123;    <span class="comment">// 判空    if (x == null)        throw new NullPointerException();    RunnableScheduledFuture&lt;?&gt; e = (RunnableScheduledFuture&lt;?&gt;)x;    // 队列锁    final ReentrantLock lock = this.lock;    lock.lock();    try &#123;        int i = size;        // 队列数量大于存放节点的数组长度，需要扩容        if (i &gt;= queue.length)            // 扩容为原来长度的 1.5 倍            grow();        size = i + 1;        // 当前是第一个要插入的节点        if (i == 0) &#123;            queue[0] = e;            // 修改 ScheduledFutureTask 的 heapIndex 属性，表示该对象在队列里的下标            setIndex(e, 0);        &#125; else &#123;            // 向上调整元素的位置，并更新 heapIndex             siftUp(i, e);        &#125;        // 【插入的元素是头节点，原先的 leader 等待的是原先的头节点，所以 leader 已经无效】        if (queue[0] == e) &#123;            // 将 leader 设置为 null            leader = null;            // 直接随便唤醒等待头结点的阻塞线程            available.signal();        &#125;    &#125; finally &#123;        lock.unlock();    &#125;    return true;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入新节点后对堆进行调整，进行节点上移，保持其特性【节点的值小于子节点的值】，小顶堆private void siftUp(int k, RunnableScheduledFuture&lt;?&gt; key) &#123;    while (k &gt; 0) &#123;        // 父节点，就是堆排序        int parent = (k - 1) &gt;&gt;&gt; 1;        RunnableScheduledFuture&lt;?&gt; e = queue[parent];        // key 和父节点比，如果大于父节点可以直接返回，否则就继续上浮        if (key.compareTo(e) &gt;= 0)            break;        queue[k] = e;        setIndex(e, k);        k = parent;    &#125;    queue[k] = key;    setIndex(key, k);&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>poll()：非阻塞获取头结点，<strong>获取执行时间最近并且可以执行的</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非阻塞获取public RunnableScheduledFuture&lt;?&gt; poll() &#123;    final ReentrantLock lock = this.lock;    lock.lock();    try &#123;        // 获取队头节点，因为是小顶堆        RunnableScheduledFuture&lt;?&gt; first = queue[0];        // 头结点为空或者的延迟时间没到返回 null        if (first == null || first.getDelay(NANOSECONDS) &gt; 0)            return null;        else            // 头结点达到延迟时间，【尾节点成为替代节点下移调整堆结构】，返回头结点            return finishPoll(first);    &#125; finally &#123;        lock.unlock();    &#125;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> RunnableScheduledFuture&lt;?&gt; finishPoll(RunnableScheduledFuture&lt;?&gt; f) &#123;    <span class="keyword">int</span> s = --size;    <span class="comment">// 获取尾节点    RunnableScheduledFuture&lt;?&gt; x = queue[s];    // 置空    queue[s] = null;    if (s != 0)        // 从索引处 0 开始向下调整        siftDown(0, x);    // 出队的元素索引设置为 -1    setIndex(f, -1);    return f;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>take()：阻塞获取头节点，读取当前堆中最小的也就是执行开始时间最近的任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> RunnableScheduledFuture&lt;?&gt; take() <span class="keyword">throws</span> InterruptedException &#123;    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;    lock.lockInterruptibly();    <span class="keyword">try</span> &#123;        <span class="keyword">for</span> (;;) &#123;            <span class="comment">// 头节点            RunnableScheduledFuture&lt;?&gt; first = queue[0];            if (first == null)                // 等待队列不空，直至有任务通过 offer 入队并唤醒                available.await();            else &#123;                // 获取头节点的剩延迟时间是否到时                long delay = first.getDelay(NANOSECONDS);                if (delay &lt;= 0)                    // 到时了，获取头节点并调整堆，重新选择延迟时间最小的节点放入头部                    return finishPoll(first);                                // 逻辑到这说明头节点的延迟时间还没到                first = null;                // 说明有 leader 线程在等待获取头节点，需要阻塞等待                if (leader != null)                    available.await();                else &#123;                    // 没有 leader 线程，【当前线程作为leader线程，并设置头结点的延迟时间作为阻塞时间】                    Thread thisThread = Thread.currentThread();                    leader = thisThread;                    try &#123;                        available.awaitNanos(delay);                    &#125; finally &#123;                        // 条件成立的情况：                        // 1. 原先 thisThread == leader, 然后堆顶更新了，leader 被置为 null                        // 2. 堆顶更新，offer 方法释放锁后,有其它线程通过 take/poll 拿到锁,                        //    读到 leader == null，然后将自身更新为leader。                        if (leader == thisThread)                            // leader 置为 null 用以接下来判断是否需要唤醒后继线程                            leader = null;                    &#125;                &#125;            &#125;        &#125;    &#125; finally &#123;        // 没有 leader 线程没有，头结点不为 null，唤醒阻塞获取头节点的线程        if (leader == null &amp;&amp; queue[0] != null)            available.signal();        lock.unlock();    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>remove()：删除节点，堆移除一个元素的时间复杂度是 O(log n)，<strong>延迟任务维护了 heapIndex</strong>，直接访问的时间复杂度是 O(1)，从而可以更快的移除元素，任务在队列中被取消后会进入该逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object x)</span> </span>&#123;    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;    lock.lock();    <span class="keyword">try</span> &#123;        <span class="comment">// 查找对象在队列数组中的下标        int i = indexOf(x);        // 节点不存在，返回 false        if (i &lt; 0)            return false;// 修改元素的 heapIndex，-1 代表删除        setIndex(queue[i], -1);        // 尾索引是长度-1        int s = --size;        // 尾节点作为替代节点        RunnableScheduledFuture&lt;?&gt; replacement = queue[s];        queue[s] = null;        // s == i 说明头节点就是尾节点，队列空了        if (s != i) &#123;            // 向下调整            siftDown(i, replacement);            // 说明没发生调整            if (queue[i] == replacement)                // 上移和下移不可能同时发生，替代节点大于子节点时下移，否则上移                siftUp(i, replacement);        &#125;        return true;    &#125; finally &#123;        lock.unlock();    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="成员方法-4"><a href="#成员方法-4" class="headerlink" title="成员方法"></a>成员方法</h4><h5 id="提交任务"><a href="#提交任务" class="headerlink" title="提交任务"></a>提交任务</h5><ul><li><p>schedule()：延迟执行方法，并指定执行的时间，默认是当前时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;    <span class="comment">// 以零延时任务的形式实现    schedule(command, 0, NANOSECONDS);&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command, <span class="keyword">long</span> delay, TimeUnit unit) &#123;    <span class="comment">// 判空    if (command == null || unit == null) throw new NullPointerException();    // 没有做任何操作，直接将 task 返回，该方法主要目的是用于子类扩展，并且【根据延迟时间设置任务触发的时间点】    RunnableScheduledFuture&lt;?&gt; t = decorateTask(command, new ScheduledFutureTask&lt;Void&gt;(        command, null, triggerTime(delay, unit)));    // 延迟执行    delayedExecute(t);    return t;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回【当前时间 + 延迟时间】，就是触发当前任务执行的时间private long triggerTime(long delay, TimeUnit unit) &#123;    // 设置触发的时间    return triggerTime(unit.toNanos((delay &lt; 0) ? 0 : delay));&#125;long triggerTime(long delay) &#123;    // 如果 delay &lt; Long.Max_VALUE/2，则下次执行时间为当前时间 +delay    // 否则为了避免队列中出现由于溢出导致的排序紊乱,需要调用overflowFree来修正一下delay    return now() + ((delay &lt; (Long.MAX_VALUE &gt;&gt; 1)) ? delay : overflowFree(delay));&#125;</span></span><br></pre></td></tr></table></figure><p>overflowFree 的原因：如果某个任务的 delay 为负数，说明当前可以执行（其实早该执行了）。阻塞队列中维护任务顺序是基于 compareTo 比较的，比较两个任务的顺序会用 time 相减。那么可能出现一个 delay 为正数减去另一个为负数的 delay，结果上溢为负数，则会导致 compareTo 产生错误的结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">overflowFree</span><span class="params">(<span class="keyword">long</span> delay)</span> </span>&#123;    Delayed head = (Delayed) <span class="keyword">super</span>.getQueue().peek();    <span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123;        <span class="keyword">long</span> headDelay = head.getDelay(NANOSECONDS);        <span class="comment">// 判断一下队首的delay是不是负数，如果是正数就不用管，怎么减都不会溢出        // 否则拿当前 delay 减去队首的 delay 来比较看，如果不出现上溢，排序不会乱// 不然就把当前 delay 值给调整为 Long.MAX_VALUE + 队首 delay        if (headDelay &lt; 0 &amp;&amp; (delay - headDelay &lt; 0))            delay = Long.MAX_VALUE + headDelay;    &#125;    return delay;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>scheduleAtFixedRate()：定时执行，一次任务的启动到下一次任务的启动的间隔</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, <span class="keyword">long</span> initialDelay, <span class="keyword">long</span> period,                                              TimeUnit unit) &#123;    <span class="keyword">if</span> (command == <span class="keyword">null</span> || unit == <span class="keyword">null</span>)        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();    <span class="keyword">if</span> (period &lt;= <span class="number">0</span>)        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();    <span class="comment">// 任务封装，【指定初始的延迟时间和周期时间】    ScheduledFutureTask&lt;Void&gt; sft =new ScheduledFutureTask&lt;Void&gt;(command, null,                                      triggerTime(initialDelay, unit), unit.toNanos(period));    // 默认返回本身    RunnableScheduledFuture&lt;Void&gt; t = decorateTask(command, sft);    sft.outerTask = t;    // 开始执行这个任务    delayedExecute(t);    return t;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>scheduleWithFixedDelay()：定时执行，一次任务的结束到下一次任务的启动的间隔</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, <span class="keyword">long</span> initialDelay, <span class="keyword">long</span> delay,                                                 TimeUnit unit) &#123;    <span class="keyword">if</span> (command == <span class="keyword">null</span> || unit == <span class="keyword">null</span>)         <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();    <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();    <span class="comment">// 任务封装，【指定初始的延迟时间和周期时间】，周期时间为 - 表示是 fixed-delay 模式    ScheduledFutureTask&lt;Void&gt; sft = new ScheduledFutureTask&lt;Void&gt;(command, null,                                      triggerTime(initialDelay, unit), unit.toNanos(-delay));    RunnableScheduledFuture&lt;Void&gt; t = decorateTask(command, sft);    sft.outerTask = t;    delayedExecute(t);    return t;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="运行任务"><a href="#运行任务" class="headerlink" title="运行任务"></a>运行任务</h5><ul><li><p>delayedExecute()：<strong>校验线程池状态</strong>，延迟或周期性任务的主要执行方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">delayedExecute</span><span class="params">(RunnableScheduledFuture&lt;?&gt; task)</span> </span>&#123;    <span class="comment">// 线程池是 SHUTDOWN 状态，需要执行拒绝策略    if (isShutdown())        reject(task);    else &#123;        // 把当前任务放入阻塞队列，因为需要【获取执行时间最近的】，当前任务需要比较        super.getQueue().add(task);        // 线程池状态为 SHUTDOWN 并且不允许执行任务了，就从队列删除该任务，并设置任务的状态为取消状态        if (isShutdown() &amp;&amp; !canRunInCurrentRunState(task.isPeriodic()) &amp;&amp; remove(task))            task.cancel(false);        else            // 可以执行            ensurePrestart();    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>ensurePrestart()：<strong>开启线程执行任务</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ThreadPoolExecutor#ensurePrestartvoid ensurePrestart() &#123;    int wc = workerCountOf(ctl.get());    // worker数目小于corePoolSize，则添加一个worker。    if (wc &lt; corePoolSize)        // 第二个参数 true 表示采用核心线程数量限制，false 表示采用 maximumPoolSize        addWorker(null, true);    // corePoolSize = 0的情况，至少开启一个线程，【担保机制】    else if (wc == 0)        addWorker(null, false);&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>canRunInCurrentRunState()：任务运行时都会被调用以校验当前状态是否可以运行任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">canRunInCurrentRunState</span><span class="params">(<span class="keyword">boolean</span> periodic)</span> </span>&#123;    <span class="comment">// 根据是否是周期任务判断，在线程池 shutdown 后是否继续执行该任务，默认非周期任务是继续执行的    return isRunningOrShutdown(periodic ? continueExistingPeriodicTasksAfterShutdown :                               executeExistingDelayedTasksAfterShutdown);&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>onShutdown()：删除并取消工作队列中的不需要再执行的任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onShutdown</span><span class="params">()</span> </span>&#123;    BlockingQueue&lt;Runnable&gt; q = <span class="keyword">super</span>.getQueue();    <span class="comment">// shutdown 后是否仍然执行延时任务    boolean keepDelayed = getExecuteExistingDelayedTasksAfterShutdownPolicy();    // shutdown 后是否仍然执行周期任务    boolean keepPeriodic = getContinueExistingPeriodicTasksAfterShutdownPolicy();    // 如果两者皆不可，则对队列中【所有任务】调用 cancel 取消并清空队列    if (!keepDelayed &amp;&amp; !keepPeriodic) &#123;        for (Object e : q.toArray())            if (e instanceof RunnableScheduledFuture&lt;?&gt;)                ((RunnableScheduledFuture&lt;?&gt;) e).cancel(false);        q.clear();    &#125;    else &#123;        for (Object e : q.toArray()) &#123;            if (e instanceof RunnableScheduledFuture) &#123;                RunnableScheduledFuture&lt;?&gt; t = (RunnableScheduledFuture&lt;?&gt;)e;                // 不需要执行的任务删除并取消，已经取消的任务也需要从队列中删除                if ((t.isPeriodic() ? !keepPeriodic : !keepDelayed) ||                    t.isCancelled()) &#123;                    if (q.remove(t))                        t.cancel(false);                &#125;            &#125;        &#125;    &#125;    // 因为任务被从队列中清理掉，所以需要调用 tryTerminate 尝试【改变线程池的状态】    tryTerminate();&#125;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="ForkJoin"><a href="#ForkJoin" class="headerlink" title="ForkJoin"></a>ForkJoin</h3><p>Fork/Join：线程池的实现，体现是分治思想，适用于能够进行任务拆分的 CPU 密集型运算，用于<strong>并行计算</strong></p><p>任务拆分：将一个大任务拆分为算法上相同的小任务，直至不能拆分可以直接求解。跟递归相关的一些计算，如归并排序、斐波那契数列都可以用分治思想进行求解</p><ul><li><p>Fork/Join 在<strong>分治的基础上加入了多线程</strong>，把每个任务的分解和合并交给不同的线程来完成，提升了运算效率</p></li><li><p>ForkJoin 使用 ForkJoinPool 来启动，是一个特殊的线程池，默认会创建与 CPU 核心数大小相同的线程池</p></li><li><p>任务有返回值继承 RecursiveTask，没有返回值继承 RecursiveAction</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool(<span class="number">4</span>);    System.out.println(pool.invoke(<span class="keyword">new</span> MyTask(<span class="number">5</span>)));    <span class="comment">//拆分  5 + MyTask(4) --&gt; 4 + MyTask(3) --&gt;&#125;// 1~ n 之间整数的和class MyTask extends RecursiveTask&lt;Integer&gt; &#123;    private int n;    public MyTask(int n) &#123;        this.n = n;    &#125;    @Override    public String toString() &#123;        return &quot;MyTask&#123;&quot; + &quot;n=&quot; + n + &#x27;&#125;&#x27;;    &#125;    @Override    protected Integer compute() &#123;        // 如果 n 已经为 1，可以求得结果了        if (n == 1) &#123;            return n;        &#125;        // 将任务进行拆分(fork)        MyTask t1 = new MyTask(n - 1);        t1.fork();        // 合并(join)结果        int result = n + t1.join();        return result;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>继续拆分优化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;    <span class="keyword">int</span> begin;    <span class="keyword">int</span> end;    <span class="function"><span class="keyword">public</span> <span class="title">AddTask</span><span class="params">(<span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;        <span class="keyword">this</span>.begin = begin;        <span class="keyword">this</span>.end = end;    &#125;        <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> <span class="string">&quot;&#123;&quot;</span> + begin + <span class="string">&quot;,&quot;</span> + end + <span class="string">&#x27;&#125;&#x27;</span>;    &#125;        <span class="meta">@Override</span>    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;        <span class="comment">// 5, 5        if (begin == end) &#123;            return begin;        &#125;        // 4, 5  防止多余的拆分  提高效率        if (end - begin == 1) &#123;            return end + begin;        &#125;        // 1 5        int mid = (end + begin) / 2; // 3        AddTask t1 = new AddTask(begin, mid); // 1,3        t1.fork();        AddTask t2 = new AddTask(mid + 1, end); // 4,5        t2.fork();        int result = t1.join() + t2.join();        return result;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>ForkJoinPool 实现了<strong>工作窃取算法</strong>来提高 CPU 的利用率：</p><ul><li>每个线程都维护了一个<strong>双端队列</strong>，用来存储需要执行的任务</li><li>工作窃取算法允许空闲的线程从其它线程的双端队列中窃取一个任务来执行</li><li>窃取的必须是<strong>最晚的任务</strong>，避免和队列所属线程发生竞争，但是队列中只有一个任务时还是会发生竞争</li></ul><hr><h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><p>享元模式 (Flyweight pattern)： 用于减少创建对象的数量，以减少内存占用和提高性能，这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式</p><p>异步模式：让有限的工作线程（Worker Thread）来轮流异步处理无限多的任务，也可将其归类为分工模式，典型实现就是线程池</p><p>工作机制：享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象</p><p>自定义连接池：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    Pool pool = <span class="keyword">new</span> Pool(<span class="number">2</span>);    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;        <span class="keyword">new</span> Thread(() -&gt; &#123;            Connection con = pool.borrow();            <span class="keyword">try</span> &#123;                Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            pool.free(con);        &#125;).start();    &#125;&#125;<span class="class"><span class="keyword">class</span> <span class="title">Pool</span> </span>&#123;    <span class="comment">//连接池的大小    private final int poolSize;    //连接对象的数组    private Connection[] connections;    //连接状态数组 0表示空闲  1表示繁忙    private AtomicIntegerArray states;  //int[] -&gt; AtomicIntegerArray    //构造方法    public Pool(int poolSize) &#123;        this.poolSize = poolSize;        this.connections = new Connection[poolSize];        this.states = new AtomicIntegerArray(new int[poolSize]);        for (int i = 0; i &lt; poolSize; i++) &#123;            connections[i] = new MockConnection(&quot;连接&quot; + (i + 1));        &#125;    &#125;    //使用连接    public Connection borrow() &#123;        while (true) &#123;            for (int i = 0; i &lt; poolSize; i++) &#123;                if (states.get(i) == 0) &#123;                    if (states.compareAndSet(i, 0, 1)) &#123;                        System.out.println(Thread.currentThread().getName() + &quot; borrow &quot; +  connections[i]);                        return connections[i];                    &#125;                &#125;            &#125;            //如果没有空闲连接，当前线程等待            synchronized (this) &#123;                try &#123;                    System.out.println(Thread.currentThread().getName() + &quot; wait...&quot;);                    this.wait();                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;    //归还连接    public void free(Connection con) &#123;        for (int i = 0; i &lt; poolSize; i++) &#123;            if (connections[i] == con) &#123;//判断是否是同一个对象                states.set(i, 0);//不用cas的原因是只会有一个线程使用该连接                synchronized (this) &#123;                    System.out.println(Thread.currentThread().getName() + &quot; free &quot; + con);                    this.notifyAll();                &#125;                break;            &#125;        &#125;    &#125;&#125;class MockConnection implements Connection &#123;    private String name;    //.....&#125;</span></span><br></pre></td></tr></table></figure><hr><h2 id="同步器"><a href="#同步器" class="headerlink" title="同步器"></a>同步器</h2><h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><h4 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h4><p>AQS：AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架，许多同步类实现都依赖于该同步器</p><p>AQS 用状态属性来表示资源的状态（分<strong>独占模式和共享模式</strong>），子类需要定义如何维护这个状态，控制如何获取锁和释放锁</p><ul><li>独占模式是只有一个线程能够访问资源，如 ReentrantLock</li><li>共享模式允许多个线程访问资源，如 Semaphore，ReentrantReadWriteLock 是组合式</li></ul><p>AQS 核心思想：</p><ul><li><p>如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置锁定状态</p></li><li><p>请求的共享资源被占用，AQS 用 CLH 队列实现线程阻塞等待以及被唤醒时锁分配的机制，将暂时获取不到锁的线程加入到队列中</p><p>CLH 是一种基于单向链表的<strong>高性能、公平的自旋锁</strong>，AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配</p><img src="https://gitee.com/seazean/images/raw/master/Java/JUC-AQS原理图.png" style="zoom: 80%;"></li></ul><hr><h4 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h4><p>设计原理：</p><ul><li><p>获取锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(state 状态不允许获取) &#123;<span class="comment">// tryAcquire(arg)    if(队列中还没有此线程) &#123;        入队并阻塞 park    &#125;&#125;当前线程出队</span></span><br></pre></td></tr></table></figure></li><li><p>释放锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(state 状态允许了) &#123;<span class="comment">// tryRelease(arg)恢复阻塞的线程(s) unpark&#125;</span></span><br></pre></td></tr></table></figure></li></ul><p>AbstractQueuedSynchronizer 中 state 设计：</p><ul><li><p>state 使用了 32bit int 来维护同步状态，独占模式 0 表示未加锁状态，大于 0 表示已经加锁状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br></pre></td></tr></table></figure></li><li><p>state <strong>使用 volatile 修饰配合 cas</strong> 保证其修改时的原子性</p></li><li><p>state 表示<strong>线程重入的次数（独占模式）或者剩余许可数（共享模式）</strong></p></li><li><p>state API：</p><ul><li><code>protected final int getState()</code>：获取 state 状态</li><li><code>protected final void setState(int newState)</code>：设置 state 状态</li><li><code>protected final boolean compareAndSetState(int expect,int update)</code>：<strong>CAS</strong> 安全设置 state</li></ul></li></ul><p>封装线程的 Node 节点中 waitstate 设计：</p><ul><li><p>使用 <strong>volatile 修饰配合 CAS</strong> 保证其修改时的原子性</p></li><li><p>表示 Node 节点的状态，有以下几种状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认为 0volatile int waitStatus;// 由于超时或中断，此节点被取消，不会再改变状态static final int CANCELLED =  1;// 此节点后面的节点已（或即将）被阻止（通过park），【当前节点在释放或取消时必须唤醒后面的节点】static final int SIGNAL    = -1;// 此节点当前在条件队列中static final int CONDITION = -2;// 将releaseShared传播到其他节点static final int PROPAGATE = -3;</span></span><br></pre></td></tr></table></figure></li></ul><p>阻塞恢复设计：</p><ul><li>使用 park &amp; unpark 来实现线程的暂停和恢复，因为命令的先后顺序不影响结果</li><li>park &amp; unpark 是针对线程的，而不是针对同步器的，因此控制粒度更为精细</li><li>park 线程可以通过 interrupt 打断</li></ul><p>队列设计：</p><ul><li><p>使用了 FIFO 先入先出队列，并不支持优先级队列，<strong>同步队列是双向链表，便于出队入队</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头结点，指向哑元节点private transient volatile Node head;// 阻塞队列的尾节点，阻塞队列不包含头结点，从 head.next → tail 认为是阻塞队列private transient volatile Node tail;static final class Node &#123;    // 枚举：共享模式    static final Node SHARED = new Node();    // 枚举：独占模式    static final Node EXCLUSIVE = null;    // node 需要构建成 FIFO 队列，prev 指向前继节点    volatile Node prev;    // next 指向后继节点    volatile Node next;    // 当前 node 封装的线程    volatile Thread thread;    // 条件队列是单向链表，只有后继指针    Node nextWaiter;&#125;</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/seazean/images/raw/master/Java/JUC-AQS%E9%98%9F%E5%88%97%E8%AE%BE%E8%AE%A1.png"></p></li><li><p>条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet，<strong>条件队列是单向链表</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionObject</span> <span class="keyword">implements</span> <span class="title">Condition</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;     <span class="comment">// 指向条件队列的第一个 node 节点     private transient Node firstWaiter;     // 指向条件队列的最后一个 node 节点     private transient Node lastWaiter; &#125;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="模板对象"><a href="#模板对象" class="headerlink" title="模板对象"></a>模板对象</h4><p>同步器的设计是基于模板方法模式，该模式是基于继承的，主要是为了在不改变模板结构的前提下在子类中重新定义模板中的内容以实现复用代码</p><ul><li>使用者继承 <code>AbstractQueuedSynchronizer</code> 并重写指定的方法</li><li>将 AQS 组合在自定义同步组件的实现中，并调用其模板方法，这些模板方法会调用使用者重写的方法</li></ul><p>AQS 使用了模板方法模式，自定义同步器时需要重写下面几个 AQS 提供的模板方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isHeldExclusively()<span class="comment">//该线程是否正在独占资源。只有用到condition才需要去实现它tryAcquire(int)//独占方式。尝试获取资源，成功则返回true，失败则返回falsetryRelease(int)//独占方式。尝试释放资源，成功则返回true，失败则返回falsetryAcquireShared(int)//共享方式。尝试获取资源。负数表示失败；0表示成功但没有剩余可用资源；正数表示成功且有剩余资源tryReleaseShared(int)//共享方式。尝试释放资源，成功则返回true，失败则返回false</span></span><br></pre></td></tr></table></figure><ul><li>默认情况下，每个方法都抛出 <code>UnsupportedOperationException</code></li><li>这些方法的实现必须是内部线程安全的</li><li>AQS 类中的其他方法都是 final ，所以无法被其他类使用，只有这几个方法可以被其他类使用</li></ul><hr><h4 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h4><p>自定义一个不可重入锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLock</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;    <span class="comment">//独占锁 不可重入    class MySync extends AbstractQueuedSynchronizer &#123;        @Override        protected boolean tryAcquire(int arg) &#123;            if (compareAndSetState(0, 1)) &#123;                // 加上锁 设置 owner 为当前线程                setExclusiveOwnerThread(Thread.currentThread());                return true;            &#125;            return false;        &#125;        @Override   //解锁        protected boolean tryRelease(int arg) &#123;            setExclusiveOwnerThread(null);            setState(0);//volatile 修饰的变量放在后面，防止指令重排            return true;        &#125;        @Override   //是否持有独占锁        protected boolean isHeldExclusively() &#123;            return getState() == 1;        &#125;        public Condition newCondition() &#123;            return new ConditionObject();        &#125;    &#125;    private MySync sync = new MySync();    @Override   //加锁（不成功进入等待队列等待）    public void lock() &#123;        sync.acquire(1);    &#125;    @Override   //加锁 可打断    public void lockInterruptibly() throws InterruptedException &#123;        sync.acquireInterruptibly(1);    &#125;    @Override   //尝试加锁，尝试一次    public boolean tryLock() &#123;        return sync.tryAcquire(1);    &#125;    @Override   //尝试加锁，带超时    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException &#123;        return sync.tryAcquireNanos(1, unit.toNanos(time));    &#125;        @Override   //解锁    public void unlock() &#123;        sync.release(1);    &#125;        @Override   //条件变量    public Condition newCondition() &#123;        return sync.newCondition();    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h3 id="Re-Lock"><a href="#Re-Lock" class="headerlink" title="Re-Lock"></a>Re-Lock</h3><h4 id="锁对比"><a href="#锁对比" class="headerlink" title="锁对比"></a>锁对比</h4><p>ReentrantLock 相对于 synchronized 具备如下特点：</p><ol><li>锁的实现：synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的</li><li>性能：新版本 Java 对 synchronized 进行了很多优化，synchronized 与 ReentrantLock 大致相同</li><li>使用：ReentrantLock 需要手动解锁，synchronized 执行完代码块自动解锁</li><li>可中断：ReentrantLock 可中断，而 synchronized 不行</li><li><strong>公平锁</strong>：公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁<ul><li>ReentrantLock 可以设置公平锁，synchronized 中的锁是非公平的</li><li>不公平锁的含义是阻塞队列内公平，队列外非公平</li></ul></li><li>锁超时：尝试获取锁，超时获取不到直接放弃，不进入阻塞队列<ul><li>ReentrantLock 可以设置超时时间，synchronized 会一直等待</li></ul></li><li>锁绑定多个条件：一个 ReentrantLock 可以同时绑定多个 Condition 对象 </li><li>两者都是可重入锁</li></ol><hr><h4 id="使用锁-1"><a href="#使用锁-1" class="headerlink" title="使用锁"></a>使用锁</h4><p>构造方法：<code>ReentrantLock lock = new ReentrantLock();</code></p><p>ReentrantLock 类 API：</p><ul><li><p><code>public void lock()</code>：获得锁</p><ul><li><p>如果锁没有被另一个线程占用，则将锁定计数设置为 1</p></li><li><p>如果当前线程已经保持锁定，则保持计数增加 1 </p></li><li><p>如果锁被另一个线程保持，则当前线程被禁用线程调度，并且在锁定已被获取之前处于休眠状态</p></li></ul></li><li><p><code>public void unlock()</code>：尝试释放锁</p><ul><li>如果当前线程是该锁的持有者，则保持计数递减</li><li>如果保持计数现在为零，则锁定被释放</li><li>如果当前线程不是该锁的持有者，则抛出异常</li></ul></li></ul><p>基本语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取锁reentrantLock.lock();try &#123;    // 临界区&#125; finally &#123;// 释放锁reentrantLock.unlock();&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><h5 id="基本使用-3"><a href="#基本使用-3" class="headerlink" title="基本使用"></a>基本使用</h5><p>构造方法：<code>ReentrantLock lock = new ReentrantLock(true)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();&#125;</span><br></pre></td></tr></table></figure><p>ReentrantLock 默认是不公平的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;    sync = <span class="keyword">new</span> NonfairSync();&#125;</span><br></pre></td></tr></table></figure><p>说明：公平锁一般没有必要，会降低并发度</p><hr><h5 id="非公原理"><a href="#非公原理" class="headerlink" title="非公原理"></a>非公原理</h5><h6 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h6><p>NonfairSync 继承自 AQS</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;    sync.lock();&#125;</span><br></pre></td></tr></table></figure><ul><li><p>没有竞争：ExclusiveOwnerThread 属于 Thread-0，state 设置为 1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReentrantLock.NonfairSync#lockfinal void lock() &#123;    // 用 cas 尝试（仅尝试一次）将 state 从 0 改为 1, 如果成功表示【获得了独占锁】    if (compareAndSetState(0, 1))        // 设置当前线程为独占线程        setExclusiveOwnerThread(Thread.currentThread());    else        acquire(1);//失败进入&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>第一个竞争出现：Thread-1 执行，CAS 尝试将 state 由 0 改为 1，结果失败（第一次），进入 acquire 逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractQueuedSynchronizer#acquirepublic final void acquire(int arg) &#123;    // tryAcquire 尝试获取锁失败时, 会调用 addWaiter 将当前线程封装成node入队，acquireQueued 阻塞当前线程，    // acquireQueued 返回 true 表示挂起过程中线程被中断唤醒过，false 表示未被中断过    if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))        // 如果线程被中断了逻辑来到这，完成一次真正的打断效果        selfInterrupt();&#125;</span></span><br></pre></td></tr></table></figure></li></ul><img src="https://gitee.com/seazean/images/raw/master/Java/JUC-ReentrantLock-非公平锁1.png" style="zoom:80%;"><ul><li><p>进入 tryAcquire 尝试获取锁逻辑，这时 state 已经是1，结果仍然失败（第二次），加锁成功有两种情况：</p><ul><li>当前 AQS 处于无锁状态</li><li>加锁线程就是当前线程，说明发生了锁重入</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReentrantLock.NonfairSync#tryAcquireprotected final boolean tryAcquire(int acquires) &#123;    return nonfairTryAcquire(acquires);&#125;// 抢占成功返回 true，抢占失败返回 falsefinal boolean nonfairTryAcquire(int acquires) &#123;    final Thread current = Thread.currentThread();    // state 值    int c = getState();    // 条件成立说明当前处于【无锁状态】    if (c == 0) &#123;        //如果还没有获得锁，尝试用cas获得，这里体现非公平性: 不去检查 AQS 队列是否有阻塞线程直接获取锁            if (compareAndSetState(0, acquires)) &#123;            // 获取锁成功设置当前线程为独占锁线程。            setExclusiveOwnerThread(current);            return true;         &#125;    &#125;       // 如果已经有线程获得了锁, 独占锁线程还是当前线程, 表示【发生了锁重入】else if (current == getExclusiveOwnerThread()) &#123;        // 更新锁重入的值        int nextc = c + acquires;        // 越界判断，当重入的深度很深时，会导致 nextc &lt; 0，int值达到最大之后再 + 1 变负数        if (nextc &lt; 0) // overflow            throw new Error(&quot;Maximum lock count exceeded&quot;);        // 更新 state 的值，这里不使用 cas 是因为当前线程正在持有锁，所以这里的操作相当于在一个管程内        setState(nextc);        return true;    &#125;    // 获取失败    return false;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>接下来进入 addWaiter 逻辑，构造 Node 队列，前置条件是当前线程获取锁失败，说明有线程占用了锁</p><ul><li>图中黄色三角表示该 Node 的 waitStatus 状态，其中 0 为默认<strong>正常状态</strong></li><li>Node 的创建是懒惰的，其中第一个 Node 称为 <strong>Dummy（哑元）或哨兵</strong>，用来占位，并不关联线程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractQueuedSynchronizer#addWaiter，返回当前线程的 node 节点private Node addWaiter(Node mode) &#123;    // 将当前线程关联到一个 Node 对象上, 模式为独占模式       Node node = new Node(Thread.currentThread(), mode);    Node pred = tail;    // 快速入队，如果 tail 不为 null，说明存在阻塞队列    if (pred != null) &#123;        // 将当前节点的前驱节点指向 尾节点        node.prev = pred;        // 通过 cas 将 Node 对象加入 AQS 队列，成为尾节点，【尾插法】        if (compareAndSetTail(pred, node)) &#123;            pred.next = node;// 双向链表            return node;        &#125;    &#125;    // 初始时没有队列为空，或者 CAS 失败进入这里    enq(node);    return node;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractQueuedSynchronizer#enqprivate Node enq(final Node node) &#123;    // 自旋入队，必须入队成功才结束循环    for (;;) &#123;        Node t = tail;        // 说明当前锁被占用，且当前线程可能是【第一个获取锁失败】的线程，【还没有建立队列】        if (t == null) &#123;            // 设置一个【哑元节点】，头尾指针都指向该节点            if (compareAndSetHead(new Node()))                tail = head;        &#125; else &#123;            // 自旋到这，普通入队方式，【尾插法】            node.prev = t;            if (compareAndSetTail(t, node)) &#123;                t.next = node;                return t;// 返回当前 node 的前驱节点            &#125;        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><img src="https://gitee.com/seazean/images/raw/master/Java/JUC-ReentrantLock-非公平锁2.png" style="zoom:80%;"></li><li><p>线程节点加入阻塞队列成功，进入 AbstractQueuedSynchronizer#acquireQueued 逻辑阻塞线程</p><ul><li><p>acquireQueued 会在一个自旋中不断尝试获得锁，失败后进入 park 阻塞</p></li><li><p>如果当前线程是在 head 节点后，会再次 tryAcquire 尝试获取锁，state 仍为 1 则失败（第三次）</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;    <span class="comment">// true 表示当前线程抢占锁失败，false 表示成功    boolean failed = true;    try &#123;        // 中断标记，表示当前线程是否被中断        boolean interrupted = false;        for (;;) &#123;            // 获得当前线程节点的前驱节点            final Node p = node.predecessor();            // 前驱节点是 head, FIFO 队列的特性表示轮到当前线程可以去获取锁            if (p == head &amp;&amp; tryAcquire(arg)) &#123;                // 获取成功, 设置当前线程自己的 node 为 head                setHead(node);                p.next = null; // help GC                // 表示抢占锁成功                failed = false;                // 返回当前线程是否被中断                return interrupted;            &#125;            // 判断是否应当 park，返回 false 后需要新一轮的循环，返回 true 进入条件二阻塞线程            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())                // 条件二返回结果是当前线程是否被打断，没有被打断返回 false 不进入这里的逻辑                interrupted = true;        &#125;    &#125; finally &#123;        // 【可打断模式下才会进入该逻辑】        if (failed)            cancelAcquire(node);    &#125;&#125;</span></span><br></pre></td></tr></table></figure><ul><li>进入 shouldParkAfterFailedAcquire 逻辑，<strong>将前驱 node 的 waitStatus 改为 -1</strong>，返回 false；waitStatus 为 -1 的节点用来唤醒下一个节点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;    <span class="keyword">int</span> ws = pred.waitStatus;    <span class="comment">// 表示前置节点是个可以唤醒当前节点的节点，返回 true    if (ws == Node.SIGNAL)        return true;    // 前置节点的状态处于取消状态，需要【删除前面所有取消的节点】, 返回到外层循环重试    if (ws &gt; 0) &#123;        do &#123;            node.prev = pred = pred.prev;        &#125; while (pred.waitStatus &gt; 0);        // 获取到非取消的节点，连接上当前节点        pred.next = node;    // 默认情况下 node 的 waitStatus 是 0，进入这里的逻辑    &#125; else &#123;        // 【设置上一个节点状态为 Node.SIGNAL】，返回外层循环重试        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);    &#125;    // 返回不应该 park，再次尝试一次    return false;&#125;</span></span><br></pre></td></tr></table></figure><ul><li>shouldParkAfterFailedAcquire 执行完毕回到 acquireQueued ，再次 tryAcquire 尝试获取锁，这时 state 仍为 1 获取失败（第四次）</li><li>当再次进入 shouldParkAfterFailedAcquire 时，这时其前驱 node 的 waitStatus 已经是 -1 了，返回 true</li><li>进入 parkAndCheckInterrupt， Thread-1 park（灰色表示）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;    <span class="comment">// 阻塞当前线程，如果打断标记已经是 true, 则 park 会失效    LockSupport.park(this);    // 判断当前线程是否被打断，清除打断标记    return Thread.interrupted();&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>再有多个线程经历竞争失败后：</p><p><img src="https://gitee.com/seazean/images/raw/master/Java/JUC-ReentrantLock-%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%813.png"></p></li></ul><hr><h6 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h6><p>ReentrantLock#unlock：释放锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;    sync.release(<span class="number">1</span>);&#125;</span><br></pre></td></tr></table></figure><p>Thread-0 释放锁，进入 release 流程</p><ul><li><p>进入 tryRelease，设置 exclusiveOwnerThread 为 null，state = 0</p></li><li><p>当前队列不为 null，并且 head 的 waitStatus = -1，进入 unparkSuccessor</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractQueuedSynchronizer#releasepublic final boolean release(int arg) &#123;    // 尝试释放锁，tryRelease 返回 true 表示当前线程已经【完全释放锁，重入的释放了】    if (tryRelease(arg)) &#123;        // 队列头节点        Node h = head;        // 头节点什么时候是空？没有发生锁竞争，没有竞争线程创建哑元节点        // 条件成立说明阻塞队列有等待线程，需要唤醒 head 节点后面的线程        if (h != null &amp;&amp; h.waitStatus != 0)            unparkSuccessor(h);        return true;    &#125;        return false;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReentrantLock.Sync#tryReleaseprotected final boolean tryRelease(int releases) &#123;    // 减去释放的值，可能重入    int c = getState() - releases;    // 如果当前线程不是持有锁的线程直接报错    if (Thread.currentThread() != getExclusiveOwnerThread())        throw new IllegalMonitorStateException();    // 是否已经完全释放锁    boolean free = false;    // 支持锁重入, 只有 state 减为 0, 才完全释放锁成功    if (c == 0) &#123;        free = true;        setExclusiveOwnerThread(null);    &#125;    // 当前线程就是持有锁线程，所以可以直接更新锁，不需要使用 CAS    setState(c);    return free;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>进入 AbstractQueuedSynchronizer#unparkSuccessor 方法，唤醒当前节点的后继节点</p><ul><li>找到队列中距离 head 最近的一个没取消的 Node，unpark 恢复其运行，本例中即为 Thread-1</li><li>回到 Thread-1 的 acquireQueued 流程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;    <span class="comment">// 当前节点的状态    int ws = node.waitStatus;        if (ws &lt; 0)                // 【尝试重置状态为 0】，因为当前节点要完成对后续节点的唤醒任务了，不需要 -1 了        compareAndSetWaitStatus(node, ws, 0);        // 找到需要 unpark 的节点，当前节点的下一个        Node s = node.next;        // 已取消的节点不能唤醒，需要找到距离头节点最近的非取消的节点    if (s == null || s.waitStatus &gt; 0) &#123;        s = null;        // AQS 队列【从后至前】找需要 unpark 的节点，直到 t == 当前的 node 为止，找不到就不唤醒了        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)            // 说明当前线程状态需要被唤醒            if (t.waitStatus &lt;= 0)                // 置换引用                s = t;    &#125;    // 【找到合适的可以被唤醒的 node，则唤醒线程】    if (s != null)        LockSupport.unpark(s.thread);&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>唤醒的线程会从 park 位置开始执行，如果加锁成功（没有竞争），会设置</p><ul><li>exclusiveOwnerThread 为 Thread-1，state = 1</li><li>head 指向刚刚 Thread-1 所在的 Node，该 Node 会清空 Thread</li><li>原本的 head 因为从链表断开，而可被垃圾回收（图中有错误，原来的头节点的 waitStatus 被改为 0 了）</li></ul><p><img src="https://gitee.com/seazean/images/raw/master/Java/JUC-ReentrantLock-%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%814.png"></p></li><li><p>如果这时有其它线程来竞争<strong>（非公平）</strong>，例如这时有 Thread-4 来了并抢占了锁</p><ul><li>Thread-4 被设置为 exclusiveOwnerThread，state = 1</li><li>Thread-1 再次进入 acquireQueued 流程，获取锁失败，重新进入 park 阻塞</li></ul><p><img src="https://gitee.com/seazean/images/raw/master/Java/JUC-ReentrantLock-%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%815.png"></p></li></ul><hr><h5 id="公平原理"><a href="#公平原理" class="headerlink" title="公平原理"></a>公平原理</h5><p>与非公平锁主要区别在于 tryAcquire 方法：先检查 AQS 队列中是否有前驱节点，没有才去 CAS 竞争</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;        acquire(<span class="number">1</span>);    &#125;    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;        <span class="keyword">final</span> Thread current = Thread.currentThread();        <span class="keyword">int</span> c = getState();        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;            <span class="comment">// 先检查 AQS 队列中是否有前驱节点, 没有(false)才去竞争            if (!hasQueuedPredecessors() &amp;&amp;                compareAndSetState(0, acquires)) &#123;                setExclusiveOwnerThread(current);                return true;            &#125;        &#125;        // 锁重入        return false;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;        Node t = tail;    Node h = head;    Node s;        <span class="comment">// 头尾指向一个节点，链表为空，返回false    return h != t &amp;&amp;        // 头尾之间有节点，判断头节点的下一个是不是空        // 不是空进入最后的判断，第二个节点的线程是否是本线程，不是返回 true，表示当前节点有前驱节点，洛矶歪        ((s = h.next) == null || s.thread != Thread.currentThread());&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h4><p>可重入是指同一个线程如果首次获得了这把锁，那么它是这把锁的拥有者，因此有权利再次获取这把锁，如果不可重入锁，那么第二次获得锁时，自己也会被锁挡住，直接造成死锁</p><p>源码解析参考：<code>nonfairTryAcquire(int acquires)) </code> 和 <code>tryRelease(int releases)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    method1();&#125;<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;    lock.lock();    <span class="keyword">try</span> &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; execute method1&quot;</span>);        method2();    &#125; <span class="keyword">finally</span> &#123;        lock.unlock();    &#125;&#125;<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;    lock.lock();    <span class="keyword">try</span> &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; execute method2&quot;</span>);    &#125; <span class="keyword">finally</span> &#123;        lock.unlock();    &#125;&#125;</span><br></pre></td></tr></table></figure><p>面试题：在 Lock 方法加两把锁会是什么情况呢？</p><ul><li>加锁两次解锁两次：正常执行</li><li>加锁两次解锁一次：程序直接卡死，线程不能出来，也就说明<strong>申请几把锁，最后需要解除几把锁</strong></li><li>加锁一次解锁两次：运行程序会直接报错</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getLock</span><span class="params">()</span> </span>&#123;    lock.lock();    lock.lock();    <span class="keyword">try</span> &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t get Lock&quot;</span>);    &#125; <span class="keyword">finally</span> &#123;        lock.unlock();        <span class="comment">//lock.unlock();    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="可打断"><a href="#可打断" class="headerlink" title="可打断"></a>可打断</h4><h5 id="基本使用-4"><a href="#基本使用-4" class="headerlink" title="基本使用"></a>基本使用</h5><p><code>public void lockInterruptibly()</code>：获得可打断的锁</p><ul><li>如果没有竞争此方法就会获取 lock 对象锁</li><li>如果有竞争就进入阻塞队列，可以被其他线程用 interrupt 打断</li></ul><p>注意：如果是不可中断模式，那么即使使用了 interrupt 也不会让等待状态中的线程中断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;        ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;                <span class="keyword">try</span> &#123;                        System.out.println(<span class="string">&quot;尝试获取锁&quot;</span>);                        lock.lockInterruptibly();                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                        System.out.println(<span class="string">&quot;没有获取到锁，被打断，直接返回&quot;</span>);                        <span class="keyword">return</span>;                &#125;                <span class="keyword">try</span> &#123;                        System.out.println(<span class="string">&quot;获取到锁&quot;</span>);                &#125; <span class="keyword">finally</span> &#123;                        lock.unlock();                &#125;        &#125;, <span class="string">&quot;t1&quot;</span>);        lock.lock();        t1.start();        Thread.sleep(<span class="number">2000</span>);        System.out.println(<span class="string">&quot;主线程进行打断锁&quot;</span>);        t1.interrupt();&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="实现原理-2"><a href="#实现原理-2" class="headerlink" title="实现原理"></a>实现原理</h5><ul><li><p>不可打断模式：即使它被打断，仍会驻留在 AQS 阻塞队列中，一直要<strong>等到获得锁后才能得知自己被打断</strong>了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<span class="comment">//阻塞等待                // 如果acquireQueued返回true，打断状态 interrupted = true                selfInterrupt();&#125;static void selfInterrupt() &#123;    // 知道自己被打断了，需要重新产生一次中断完成中断效果    Thread.currentThread().interrupt();&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;        <span class="keyword">try</span> &#123;                <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;                <span class="keyword">for</span> (;;) &#123;                        <span class="keyword">final</span> Node p = node.predecessor();                        <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;                                setHead(node);                                p.next = <span class="keyword">null</span>; <span class="comment">// help GC                                failed = false;                                // 还是需要获得锁后, 才能返回打断状态                return interrupted;                        &#125;                        if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())&#123;                // 条件二中判断当前线程是否被打断，被打断返回true，设置中断标记为 true，获取锁后返回                interrupted = true;              &#125;                          &#125;     &#125; finally &#123;        if (failed)            cancelAcquire(node);    &#125;&#125; private final boolean parkAndCheckInterrupt() &#123;         // 阻塞当前线程，如果打断标记已经是 true, 则 park 会失效     LockSupport.park(this);         // 判断当前线程是否被打断，清除打断标记，被打断返回true     return Thread.interrupted(); &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>可打断模式：AbstractQueuedSynchronizer#acquireInterruptibly，<strong>被打断后会直接抛出异常</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;        sync.acquireInterruptibly(<span class="number">1</span>);&#125;<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;    <span class="comment">// 被其他线程打断了直接返回 false    if (Thread.interrupted())throw new InterruptedException();    if (!tryAcquire(arg))        // 没获取到锁，进入这里        doAcquireInterruptibly(arg);&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;    <span class="comment">// 返回封装当前线程的节点    final Node node = addWaiter(Node.EXCLUSIVE);    boolean failed = true;    try &#123;        for (;;) &#123;            //...            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())                // 【在 park 过程中如果被 interrupt 会抛出异常】, 而不会再次进入循环获取锁后才完成打断效果                throw new InterruptedException();        &#125;        &#125; finally &#123;        // 抛出异常前会进入这里        if (failed)            // 取消当前线程的节点            cancelAcquire(node);    &#125;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取消节点出队的逻辑private void cancelAcquire(Node node) &#123;    // 判空    if (node == null)        return;// 把当前节点封装的 Thread 置为空    node.thread = null;// 获取当前取消的 node 的前驱节点    Node pred = node.prev;    // 前驱节点也被取消了，循环找到前面最近的没被取消的节点    while (pred.waitStatus &gt; 0)        node.prev = pred = pred.prev;    // 获取前驱节点的后继节点，可能是当前 node，也可能是 waitStatus &gt; 0 的节点    Node predNext = pred.next;    // 把当前节点的状态设置为 【取消状态 1】    node.waitStatus = Node.CANCELLED;    // 条件成立说明当前节点是尾节点，把当前节点的前驱节点设置为尾节点    if (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;        // 把前驱节点的后继节点置空，这里直接把所有的取消节点出队        compareAndSetNext(pred, predNext, null);    &#125; else &#123;        // 说明当前节点不是 tail 节点        int ws;        // 条件一成立说明当前节点不是 head.next 节点        if (pred != head &amp;&amp;            // 判断前驱节点的状态是不是 -1，不成立说明前驱状态可能是 0 或者刚被其他线程取消排队了            ((ws = pred.waitStatus) == Node.SIGNAL ||             // 如果状态不是 -1，设置前驱节点的状态为 -1             (ws &lt;= 0 &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;            // 前驱节点的线程不为null            pred.thread != null) &#123;                        Node next = node.next;            // 当前节点的后继节点是正常节点            if (next != null &amp;&amp; next.waitStatus &lt;= 0)                // 把 前驱节点的后继节点 设置为 当前节点的后继节点，【从队列中删除了当前节点】                compareAndSetNext(pred, predNext, next);        &#125; else &#123;            // 当前节点是 head.next 节点，唤醒当前节点的后继节点            unparkSuccessor(node);        &#125;        node.next = node; // help GC    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="锁超时"><a href="#锁超时" class="headerlink" title="锁超时"></a>锁超时</h4><h5 id="基本使用-5"><a href="#基本使用-5" class="headerlink" title="基本使用"></a>基本使用</h5><p><code>public boolean tryLock()</code>：尝试获取锁，获取到返回 true，获取不到直接放弃，不进入阻塞队列</p><p><code>public boolean tryLock(long timeout, TimeUnit unit)</code>：在给定时间内获取锁，获取不到就退出</p><p>注意：tryLock 期间也可以被打断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();    Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;        <span class="keyword">try</span> &#123;            <span class="keyword">if</span> (!lock.tryLock(<span class="number">2</span>, TimeUnit.SECONDS)) &#123;                System.out.println(<span class="string">&quot;获取不到锁&quot;</span>);                <span class="keyword">return</span>;            &#125;        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            System.out.println(<span class="string">&quot;被打断，获取不到锁&quot;</span>);            <span class="keyword">return</span>;        &#125;        <span class="keyword">try</span> &#123;            log.debug(<span class="string">&quot;获取到锁&quot;</span>);        &#125; <span class="keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;, <span class="string">&quot;t1&quot;</span>);    lock.lock();    System.out.println(<span class="string">&quot;主线程获取到锁&quot;</span>);    t1.start();        Thread.sleep(<span class="number">1000</span>);    <span class="keyword">try</span> &#123;        System.out.println(<span class="string">&quot;主线程释放了锁&quot;</span>);    &#125; <span class="keyword">finally</span> &#123;        lock.unlock();    &#125;&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="实现原理-3"><a href="#实现原理-3" class="headerlink" title="实现原理"></a>实现原理</h5><ul><li><p>成员变量：指定超时限制的阈值，小于该值的线程不会被挂起</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> spinForTimeoutThreshold = <span class="number">1000L</span>;</span><br></pre></td></tr></table></figure><p>超时时间设置的小于该值，就会被禁止挂起，因为阻塞在唤醒的成本太高，不如选择自旋空转</p></li><li><p>tryLock()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;       <span class="comment">// 只尝试一次    return sync.nonfairTryAcquire(1);&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>tryLock(long timeout, TimeUnit unit)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span> </span>&#123;    <span class="keyword">if</span> (Thread.interrupted())                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();        <span class="comment">// tryAcquire 尝试一次    return tryAcquire(arg) || doAcquireNanos(arg, nanosTimeout);&#125;protected final boolean tryAcquire(int acquires) &#123;        return nonfairTryAcquire(acquires);&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span> </span>&#123;        <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)        <span class="keyword">return</span> <span class="keyword">false</span>;    <span class="comment">// 获取最后期限的时间戳    final long deadline = System.nanoTime() + nanosTimeout;    //...    try &#123;        for (;;) &#123;            //...            // 计算还需等待的时间            nanosTimeout = deadline - System.nanoTime();            if (nanosTimeout &lt;= 0L)//时间已到                     return false;            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;                // 如果 nanosTimeout 大于该值，才有阻塞的意义，否则直接自旋会好点                nanosTimeout &gt; spinForTimeoutThreshold)                LockSupport.parkNanos(this, nanosTimeout);            // 【被打断会报异常】            if (Thread.interrupted())                throw new InterruptedException();        &#125;        &#125;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="哲学家就餐"><a href="#哲学家就餐" class="headerlink" title="哲学家就餐"></a>哲学家就餐</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    Chopstick c1 = <span class="keyword">new</span> Chopstick(<span class="string">&quot;1&quot;</span>);<span class="comment">//...    Chopstick c5 = new Chopstick(&quot;5&quot;);    new Philosopher(&quot;苏格拉底&quot;, c1, c2).start();    new Philosopher(&quot;柏拉图&quot;, c2, c3).start();    new Philosopher(&quot;亚里士多德&quot;, c3, c4).start();    new Philosopher(&quot;赫拉克利特&quot;, c4, c5).start();        new Philosopher(&quot;阿基米德&quot;, c5, c1).start();&#125;class Philosopher extends Thread &#123;    Chopstick left;    Chopstick right;    public void run() &#123;        while (true) &#123;            // 尝试获得左手筷子            if (left.tryLock()) &#123;                try &#123;                    // 尝试获得右手筷子                    if (right.tryLock()) &#123;                        try &#123;                            System.out.println(&quot;eating...&quot;);                            Thread.sleep(1000);                        &#125; finally &#123;                            right.unlock();                        &#125;                    &#125;                &#125; finally &#123;                    left.unlock();                &#125;            &#125;        &#125;    &#125;&#125;class Chopstick extends ReentrantLock &#123;    String name;    public Chopstick(String name) &#123;        this.name = name;    &#125;    @Override    public String toString() &#123;        return &quot;筷子&#123;&quot; + name + &#x27;&#125;&#x27;;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><h5 id="基本使用-6"><a href="#基本使用-6" class="headerlink" title="基本使用"></a>基本使用</h5><p>synchronized 的条件变量，是当条件不满足时进入 WaitSet 等待；ReentrantLock 的条件变量比 synchronized 强大之处在于，它支持多个条件变量</p><p>ReentrantLock 类获取 Condition 对象：<code>public Condition newCondition()</code></p><p>Condition 类 API：</p><ul><li><code>void await()</code>：当前线程从运行状态进入等待状态，释放锁</li><li><code>void signal()</code>：唤醒一个等待在 Condition 上的线程，但是必须获得与该 Condition 相关的锁</li></ul><p>使用流程：</p><ul><li><p><strong>await / signal 前需要获得锁</strong></p></li><li><p>await 执行后，会释放锁进入 ConditionObject 等待</p></li><li><p>await 的线程被唤醒去重新竞争 lock 锁</p></li><li><p><strong>线程在条件队列被打断会抛出中断异常</strong></p></li><li><p>竞争 lock 锁成功后，从 await 后继续执行</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;        ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();    <span class="comment">//创建一个新的条件变量    Condition condition1 = lock.newCondition();    Condition condition2 = lock.newCondition();    new Thread(() -&gt; &#123;        try &#123;            lock.lock();            System.out.println(&quot;进入等待&quot;);            //进入休息室等待            condition1.await();            System.out.println(&quot;被唤醒了&quot;);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125; finally &#123;            lock.unlock();        &#125;        &#125;).start();    Thread.sleep(1000);    //叫醒    new Thread(() -&gt; &#123;        try &#123;                        lock.lock();            //唤醒            condition2.signal();        &#125; finally &#123;            lock.unlock();        &#125;    &#125;).start();&#125;</span></span><br></pre></td></tr></table></figure><hr><h5 id="实现原理-4"><a href="#实现原理-4" class="headerlink" title="实现原理"></a>实现原理</h5><h6 id="await"><a href="#await" class="headerlink" title="await"></a>await</h6><p>总体流程是将 await 线程包装成 node 节点放入 ConditionObject 的阻条件塞队列，如果被唤醒就将 node 转移到 AQS 的执行阻塞队列，等待获取锁</p><ul><li><p>开始 Thread-0 持有锁，调用 await，线程进入 ConditionObject 等待，直到被唤醒或打断，调用 await 方法的线程都是持锁状态的，所以说逻辑里<strong>不存在并发</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;     <span class="comment">// 判断当前线程是否是中断状态，是就直接给个中断异常    if (Thread.interrupted())        throw new InterruptedException();    // 将调用 await 的线程包装成 Node，添加到条件队列并返回    Node node = addConditionWaiter();    // 完全释放节点持有的锁，因为其他线程唤醒当前线程的前提是【持有锁】    int savedState = fullyRelease(node);        // 设置打断模式为没有被打断，状态码为 0    int interruptMode = 0;        // 如果该节点还没有转移至 AQS 阻塞队列, park 阻塞    while (!isOnSyncQueue(node)) &#123;        LockSupport.park(this);        // 如果被打断，退出等待队列，对应的 node 【也会被迁移到阻塞队列】        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)            break;    &#125;    // 逻辑到这说明当前线程退出等待队列，进入【阻塞队列】        // 释放了多少锁就【重新获取多少锁】，获取锁成功判断打断模式    if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)        interruptMode = REINTERRUPT;        // node 在条件队列时 如果被外部线程中断唤醒，会加入到阻塞队列，但是并未设 nextWaiter = null    if (node.nextWaiter != null)        // 清理条件队列内所有已取消的 Node        unlinkCancelledWaiters();    // 条件成立说明挂起期间发生过中断    if (interruptMode != 0)        // 应用打断模式        reportInterruptAfterWait(interruptMode);&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打断模式 - 在退出等待时重新设置打断状态private static final int REINTERRUPT = 1;// 打断模式 - 在退出等待时抛出异常private static final int THROW_IE = -1;</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/seazean/images/raw/master/Java/JUC-ReentrantLock-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F1.png"></p></li><li><p><strong>创建新的 Node 状态为 -2（Node.CONDITION）</strong>，关联 Thread-0，加入等待队列尾部</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;    <span class="comment">// 获取当前条件队列的尾节点的引用，保存到局部变量 t 中    Node t = lastWaiter;    // 当前队列中不是空，并且节点的状态不是 CONDITION（-2），说明当前节点发生了中断    if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) &#123;        // 清理条件队列内所有已取消的 Node        unlinkCancelledWaiters();        // 清理完成重新获取 尾节点 的引用        t = lastWaiter;    &#125;    // 创建一个关联当前线程的新 node, 设置状态为 CONDITION(-2)，添加至队列尾部    Node node = new Node(Thread.currentThread(), Node.CONDITION);    if (t == null)        firstWaiter = node;// 空队列直接放在队首【不用CAS因为执行线程是持锁线程，并发安全】    else        t.nextWaiter = node;// 非空队列队尾追加    lastWaiter = node;// 更新队尾的引用    return node;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清理条件队列内所有已取消（不是CONDITION）的 node，【链表删除的逻辑】private void unlinkCancelledWaiters() &#123;    // 从头节点开始遍历【FIFO】    Node t = firstWaiter;    // 指向正常的 CONDITION 节点    Node trail = null;    // 等待队列不空    while (t != null) &#123;        // 获取当前节点的后继节点        Node next = t.nextWaiter;        // 判断 t 节点是不是 CONDITION 节点        if (t.waitStatus != Node.CONDITION) &#123;             // 不是正常节点，需要 t 与下一个节点断开            t.nextWaiter = null;            // 条件成立说明遍历到的节点还未碰到过正常节点            if (trail == null)                // 更新 firstWaiter 指针为下个节点                firstWaiter = next;            else                // 让上一个正常节点指向 当前取消节点的 下一个节点，【删除非正常的节点】                trail.nextWaiter = next;            // t 是尾节点了，更新 lastWaiter 指向最后一个正常节点            if (next == null)                lastWaiter = trail;        &#125; else &#123;            // trail 指向的是正常节点             trail = t;        &#125;        // 把 t.next 赋值给 t，循环遍历        t = next;     &#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>接下来进入 AQS 的 fullyRelease 流程，释放同步器上的锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程可能重入，需要将 state 全部释放final int fullyRelease(Node node) &#123;    // 完全释放锁是否成功，false 代表成功    boolean failed = true;    try &#123;        // 获取当前线程所持有的 state 值总数        int savedState = getState();        // release -&gt; tryRelease 解锁重入锁        if (release(savedState)) &#123;            // 释放成功            failed = false;            // 返回解锁的深度            return savedState;        &#125; else &#123;            // 解锁失败抛出异常            throw new IllegalMonitorStateException();        &#125;    &#125; finally &#123;        // 没有释放成功，将当前 node 设置为取消状态        if (failed)            node.waitStatus = Node.CANCELLED;    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>fullyRelease 中会 unpark AQS 队列中的下一个节点竞争锁，假设 Thread-1 竞争成功</p><p><img src="https://gitee.com/seazean/images/raw/master/Java/JUC-ReentrantLock-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F2.png"></p></li><li><p>进入 isOnSyncQueue 逻辑判断节点<strong>是否移动到阻塞队列</strong>，没有就 park 阻塞 Thread-0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isOnSyncQueue</span><span class="params">(Node node)</span> </span>&#123;    <span class="comment">// node 的状态是 CONDITION，signal 方法是先修改状态再迁移，所以前驱节点为空证明还【没有完成迁移】    if (node.waitStatus == Node.CONDITION || node.prev == null)        return false;    // 说明当前节点已经成功入队到阻塞队列，且当前节点后面已经有其它 node，因为条件队列的 next 指针为 null    if (node.next != null)        return true;// 说明【可能在阻塞队列，但是是尾节点】    // 从阻塞队列的尾节点开始向前遍历查找 node，如果查找到返回 true，查找不到返回 false    return findNodeFromTail(node);&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>await 线程 park 后如果被 unpark 或者被打断，都会进入 checkInterruptWhileWaiting 判断线程是否被打断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">checkInterruptWhileWaiting</span><span class="params">(Node node)</span> </span>&#123;    <span class="comment">// Thread.interrupted() 返回当前线程中断标记位，并且重置当前标记位 为 false    // 如果被中断了，根据是否在条件队列被中断的，设置中断状态码    return Thread.interrupted() ?(transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) : 0;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个方法只有在线程是被打断唤醒时才会调用final boolean transferAfterCancelledWait(Node node) &#123;    // 条件成立说明当前node一定是在条件队列内，因为 signal 迁移节点到阻塞队列时，会将节点的状态修改为 0    if (compareAndSetWaitStatus(node, Node.CONDITION, 0)) &#123;        // 把【中断唤醒的 node 加入到阻塞队列中】        enq(node);        // 表示是在条件队列内被中断了，设置为 THROW_IE 为 -1        return true;    &#125;    //执行到这里的情况：    //1.当前node已经被外部线程调用 signal 方法将其迁移到 阻塞队列 内了    //2.当前node正在被外部线程调用 signal 方法将其迁移至 阻塞队列 进行中状态        // 如果当前线程还没到阻塞队列，一直释放 CPU    while (!isOnSyncQueue(node))        Thread.yield();    // 表示当前节点被中断唤醒时不在条件队列了，设置为 REINTERRUPT 为 1    return false;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>最后开始处理中断状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reportInterruptAfterWait</span><span class="params">(<span class="keyword">int</span> interruptMode)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;    <span class="comment">// 条件成立说明【在条件队列内发生过中断，此时 await 方法抛出中断异常】    if (interruptMode == THROW_IE)        throw new InterruptedException();    // 条件成立说明【在条件队列外发生的中断，此时设置当前线程的中断标记位为 true】    else if (interruptMode == REINTERRUPT)        // 进行一次自己打断，产生中断的效果        selfInterrupt();&#125;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h6 id="signal"><a href="#signal" class="headerlink" title="signal"></a>signal</h6><ul><li><p>假设 Thread-1 要来唤醒 Thread-0，进入 ConditionObject 的 doSignal 流程，<strong>取得等待队列中第一个 Node</strong>，即 Thread-0 所在 Node，必须持有锁才能唤醒, 因此 doSignal 内线程安全</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;    <span class="comment">// 判断调用 signal 方法的线程是否是独占锁持有线程    if (!isHeldExclusively())        throw new IllegalMonitorStateException();    // 获取条件队列中第一个 Node    Node first = firstWaiter;    // 不为空就将第该节点【迁移到阻塞队列】    if (first != null)        doSignal(first);&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 唤醒 - 【将没取消的第一个节点转移至 AQS 队列尾部】private void doSignal(Node first) &#123;    do &#123;        // 成立说明当前节点的下一个节点是 null，当前节点是尾节点了，队列中只有当前一个节点了        if ((firstWaiter = first.nextWaiter) == null)            lastWaiter = null;        first.nextWaiter = null;    // 将等待队列中的 Node 转移至 AQS 队列，不成功且还有节点则继续循环    &#125; while (!transferForSignal(first) &amp;&amp; (first = firstWaiter) != null);&#125;// signalAll() 会调用这个函数，唤醒所有的节点private void doSignalAll(Node first) &#123;    lastWaiter = firstWaiter = null;    do &#123;        Node next = first.nextWaiter;        first.nextWaiter = null;        transferForSignal(first);        first = next;    // 唤醒所有的节点，都放到阻塞队列中    &#125; while (first != null);&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>执行 transferForSignal，<strong>先将节点的 waitStatus 改为 0，然后加入 AQS 阻塞队列尾部</strong>，将 Thread-3 的 waitStatus 改为 -1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果节点状态是取消, 返回 false 表示转移失败, 否则转移成功final boolean transferForSignal(Node node) &#123;    // CAS 修改当前节点的状态，修改为 0，因为当前节点马上要迁移到阻塞队列了    // 如果状态已经不是 CONDITION, 说明线程被取消（await 释放全部锁失败）或者被中断（可打断 cancelAcquire）    if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))        // 返回函数调用处继续寻找下一个节点        return false;        // 【先改状态，再进行迁移】    // 将当前 node 入阻塞队列，p 是当前节点在阻塞队列的【前驱节点】    Node p = enq(node);    int ws = p.waitStatus;        // 如果前驱节点被取消或者不能设置状态为 Node.SIGNAL，就 unpark 取消当前节点线程的阻塞状态,     // 让 thread-0 线程竞争锁，重新同步状态    if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))        LockSupport.unpark(node.thread);    return true;&#125;</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/seazean/images/raw/master/Java/JUC-ReentrantLock-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F3.png"></p></li><li><p>Thread-1 释放锁，进入 unlock 流程</p></li></ul><hr><h3 id="ReadWrite"><a href="#ReadWrite" class="headerlink" title="ReadWrite"></a>ReadWrite</h3><h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><p>独占锁：指该锁一次只能被一个线程所持有，对 ReentrantLock 和 Synchronized 而言都是独占锁</p><p>共享锁：指该锁可以被多个线程锁持有</p><p>ReentrantReadWriteLock 其<strong>读锁是共享锁，写锁是独占锁</strong></p><p>作用：多个线程同时读一个资源类没有任何问题，为了满足并发量，读取共享资源应该同时进行，但是如果一个线程想去写共享资源，就不应该再有其它线程可以对该资源进行读或写</p><p>使用规则：</p><ul><li><p>加锁解锁格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r.lock();<span class="keyword">try</span> &#123;    <span class="comment">// 临界区&#125; finally &#123;r.unlock();&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>读-读能共存、读-写不能共存、写-写不能共存</p></li><li><p>读锁不支持条件变量</p></li><li><p><strong>重入时升级不支持</strong>：持有读锁的情况下去获取写锁会导致获取写锁永久等待，需要先释放读，再去获得写</p></li><li><p><strong>重入时降级支持</strong>：持有写锁的情况下去获取读锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w.lock();<span class="keyword">try</span> &#123;    r.lock();<span class="comment">// 降级为读锁, 释放写锁, 这样能够让其它线程读取缓存    try &#123;        // ...    &#125; finally&#123;    w.unlock();// 要在写锁释放之前获取读锁    &#125;&#125; finally&#123;r.unlock();&#125;</span></span><br></pre></td></tr></table></figure></li></ul><p>构造方法：</p><ul><li><code>public ReentrantReadWriteLock()</code>：默认构造方法，非公平锁</li><li><code>public ReentrantReadWriteLock(boolean fair)</code>：true 为公平锁</li></ul><p>常用API：</p><ul><li><code>public ReentrantReadWriteLock.ReadLock readLock()</code>：返回读锁</li><li><code>public ReentrantReadWriteLock.WriteLock writeLock()</code>：返回写锁</li><li><code>public void lock()</code>：加锁</li><li><code>public void unlock()</code>：解锁</li><li><code>public boolean tryLock()</code>：尝试获取锁</li></ul><p>读读并发：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    ReentrantReadWriteLock rw = <span class="keyword">new</span> ReentrantReadWriteLock();    ReentrantReadWriteLock.ReadLock r = rw.readLock();    ReentrantReadWriteLock.WriteLock w = rw.writeLock();    <span class="keyword">new</span> Thread(() -&gt; &#123;        r.lock();        <span class="keyword">try</span> &#123;            Thread.sleep(<span class="number">2000</span>);            System.out.println(<span class="string">&quot;Thread 1 running &quot;</span> + <span class="keyword">new</span> Date());        &#125; <span class="keyword">finally</span> &#123;            r.unlock();        &#125;    &#125;,<span class="string">&quot;t1&quot;</span>).start();    <span class="keyword">new</span> Thread(() -&gt; &#123;        r.lock();        <span class="keyword">try</span> &#123;            Thread.sleep(<span class="number">2000</span>);            System.out.println(<span class="string">&quot;Thread 2 running &quot;</span> + <span class="keyword">new</span> Date());        &#125; <span class="keyword">finally</span> &#123;            r.unlock();        &#125;    &#125;,<span class="string">&quot;t2&quot;</span>).start();&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="缓存应用"><a href="#缓存应用" class="headerlink" title="缓存应用"></a>缓存应用</h4><p>缓存更新时，是先清缓存还是先更新数据库</p><ul><li><p>先清缓存：可能造成刚清理缓存还没有更新数据库，线程直接查询了数据库更新缓存</p></li><li><p>先更新据库：可能造成刚更新数据库，还没清空缓存就有线程从缓存拿到了旧数据</p></li><li><p>补充情况：查询线程 A 查询数据时恰好缓存数据由于时间到期失效，或是第一次查询</p><img src="https://gitee.com/seazean/images/raw/master/Java/JUC-ReentrantReadWriteLock缓存.png" style="zoom:80%;"></li></ul><p>可以使用读写锁进行操作</p><hr><h4 id="实现原理-5"><a href="#实现原理-5" class="headerlink" title="实现原理"></a>实现原理</h4><h5 id="加锁原理"><a href="#加锁原理" class="headerlink" title="加锁原理"></a>加锁原理</h5><p>读写锁用的是同一个 Sycn 同步器，因此等待队列、state 等也是同一个，原理与 ReentrantLock 加锁相比没有特殊之处，不同是<strong>写锁状态占了 state 的低 16 位，而读锁使用的是 state 的高 16 位</strong></p><ul><li><p>t1 w.lock（写锁），成功上锁 state = 0_1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lock()  -&gt; sync.acquire(1);public void lock() &#123;    sync.acquire(1);&#125;public final void acquire(int arg) &#123;    // 尝试获得写锁，获得写锁失败，将当前线程关联到一个 Node 对象上, 模式为独占模式     if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))        selfInterrupt();&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;    Thread current = Thread.currentThread();    <span class="keyword">int</span> c = getState();    <span class="comment">// 获得低 16 位, 代表写锁的 state 计数    int w = exclusiveCount(c);    if (c != 0) &#123;        // c != 0 and w == 0 表示 r != 0，有读锁，读锁不能升级，直接返回false        // w != 0 说明有写锁，写锁的拥有者不是自己，获取失败        if (w == 0 || current != getExclusiveOwnerThread())            return false;        // 锁重入计数超过低 16 位, 报异常        if (w + exclusiveCount(acquires) &gt; MAX_COUNT)            throw new Error(&quot;Maximum lock count exceeded&quot;);        // 【写锁重入, 获得锁成功】        setState(c + acquires);        return true;    &#125;        // c == 0，没有任何锁，判断写锁是否该阻塞，是 false 就尝试获取锁，失败返回 false    if (writerShouldBlock() || !compareAndSetState(c, c + acquires))        return false;    // 获得锁成功，设置锁的持有线程为当前线程    setExclusiveOwnerThread(current);    return true;&#125;// 非公平锁 writerShouldBlock 总是返回 false, 无需阻塞final boolean writerShouldBlock() &#123;    return false; &#125;// 公平锁会检查 AQS 队列中是否有前驱节点, 没有(false)才去竞争final boolean writerShouldBlock() &#123;    return hasQueuedPredecessors();&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>t2 r.lock（读锁），进入 tryAcquireShared 流程，如果有写锁占据，那么 tryAcquireShared </p><ul><li>返回 -1 表示失败</li><li>如果返回 0 表示成功</li><li>返回正数表示还有多少后继节点支持共享模式，读写锁返回1</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;    sync.acquireShared(<span class="number">1</span>);&#125;<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;    <span class="comment">// tryAcquireShared 返回负数, 表示获取读锁失败    if (tryAcquireShared(arg) &lt; 0)        doAcquireShared(arg);&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尝试以共享模式获取protected final int tryAcquireShared(int unused) &#123;    Thread current = Thread.currentThread();    int c = getState();    // 低 16 位, 代表写锁的 state    // 如果是其它线程持有写锁, 并且写锁的持有者不是当前线程，获取读锁失败，【写锁允许降级】    if (exclusiveCount(c) != 0 &amp;&amp; getExclusiveOwnerThread() != current)        return -1;        // 高 16 位，代表读锁的 state    int r = sharedCount(c);    if (!readerShouldBlock() &amp;&amp;// 读锁不该阻塞        r &lt; MAX_COUNT &amp;&amp;// 小于读锁计数        compareAndSetState(c, c + SHARED_UNIT)) &#123;// 尝试增加计数成功        // ....        // 读锁加锁成功        return 1;    &#125;    // 与 tryAcquireShared 功能类似, 但会不断尝试 for (;;) 获取读锁, 执行过程中无阻塞    return fullTryAcquireShared(current);&#125;// 非公平锁 readerShouldBlock 看 AQS 队列中第一个节点是否是写锁，是则阻塞，反之不阻塞// true 则该阻塞, false 则不阻塞final boolean readerShouldBlock() &#123;    return apparentlyFirstQueuedIsExclusive();&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>获取读锁失败，进入 sync.doAcquireShared(1) 流程开始阻塞，首先也是调用 addWaiter 添加节点，不同之处在于节点被设置为 Node.SHARED 模式而非 Node.EXCLUSIVE 模式，注意此时 t2 仍处于活跃状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;    <span class="comment">// 将当前线程关联到一个 Node 对象上, 模式为共享模式    final Node node = addWaiter(Node.SHARED);    boolean failed = true;    try &#123;        boolean interrupted = false;        for (;;) &#123;            // 获取前驱节点            final Node p = node.predecessor();            // 如果前驱节点就头节点就去尝试获取锁            if (p == head) &#123;                // 再一次尝试获取读锁                int r = tryAcquireShared(arg);                // r &gt;= 0 表示获取成功                if (r &gt;= 0) &#123;                    //【这里会设置自己为头节点，唤醒相连的后序的共享节点】                    setHeadAndPropagate(node, r);                    p.next = null; // help GC                    if (interrupted)                        selfInterrupt();                    failed = false;                    return;                &#125;            &#125;            // 是否在获取读锁失败时阻塞       park 当前线程            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())                interrupted = true;        &#125;    &#125; finally &#123;        if (failed)            cancelAcquire(node);    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>如果没有成功，在 doAcquireShared 内 for (;;) 循环一次，shouldParkAfterFailedAcquire 内把前驱节点的 waitStatus 改为 -1，再 for (;;) 循环一次尝试 tryAcquireShared，不成功在 parkAndCheckInterrupt() 处 park</p><img src="https://gitee.com/seazean/images/raw/master/Java/JUC-ReentrantReadWriteLock加锁1.png" style="zoom: 80%;"></li><li><p>这种状态下，假设又有 t3 r.lock，t4 w.lock，这期间 t1 仍然持有锁，就变成了下面的样子</p><p><img src="https://gitee.com/seazean/images/raw/master/Java/JUC-ReentrantReadWriteLock%E5%8A%A0%E9%94%812.png"></p></li></ul><hr><h5 id="解锁原理"><a href="#解锁原理" class="headerlink" title="解锁原理"></a>解锁原理</h5><ul><li><p>t1 w.unlock， 写锁解锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;    <span class="comment">// 释放锁    sync.release(1);&#125;public final boolean release(int arg) &#123;    // 尝试释放锁    if (tryRelease(arg)) &#123;        Node h = head;        // 头节点不为空并且不是等待状态不是 0，唤醒后继的非取消节点        if (h != null &amp;&amp; h.waitStatus != 0)            unparkSuccessor(h);        return true;    &#125;    return false;&#125;protected final boolean tryRelease(int releases) &#123;    if (!isHeldExclusively())        throw new IllegalMonitorStateException();    int nextc = getState() - releases;    // 因为可重入的原因, 写锁计数为 0, 才算释放成功    boolean free = exclusiveCount(nextc) == 0;    if (free)        setExclusiveOwnerThread(null);    setState(nextc);    return free;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>唤醒流程 sync.unparkSuccessor，这时 t2 在 doAcquireShared 的 parkAndCheckInterrupt() 处恢复运行，继续循环，执行 tryAcquireShared 成功则让读锁计数加一</p></li><li><p>接下来 t2 调用 setHeadAndPropagate(node, 1)，它原本所在节点被置为头节点；还会检查下一个节点是否是 shared，如果是则调用 doReleaseShared() 将 head 的状态从 -1 改为 0 并唤醒下一个节点，这时 t3 在 doAcquireShared 内 parkAndCheckInterrupt() 处恢复运行，<strong>唤醒连续的所有的共享节点</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;    Node h = head;     <span class="comment">// 设置自己为 head 节点    setHead(node);    // propagate 表示有共享资源（例如共享读锁或信号量），为 0 就没有资源    if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 ||        (h = head) == null || h.waitStatus &lt; 0) &#123;        // 获取下一个节点        Node s = node.next;        // 如果当前是最后一个节点，或者下一个节点是【等待共享读锁的节点】        if (s == null || s.isShared())            // 唤醒后继节点            doReleaseShared();    &#125;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;    <span class="comment">// 如果 head.waitStatus == Node.SIGNAL ==&gt; 0 成功, 下一个节点 unpark// 如果 head.waitStatus == 0 ==&gt; Node.PROPAGATE    for (;;) &#123;        Node h = head;        if (h != null &amp;&amp; h != tail) &#123;            int ws = h.waitStatus;            // SIGNAL 唤醒后继            if (ws == Node.SIGNAL) &#123;                // 因为读锁共享，如果其它线程也在释放读锁，那么需要将 waitStatus 先改为 0            // 防止 unparkSuccessor 被多次执行                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))                    continue;                  // 唤醒后继节点                unparkSuccessor(h);            &#125;            // 如果已经是 0 了，改为 -3，用来解决传播性            else if (ws == 0 &amp;&amp; !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))                continue;                        &#125;        // 条件不成立说明被唤醒的节点非常积极，直接将自己设置为了新的head，        // 此时唤醒它的节点（前驱）执行 h == head 不成立，所以不会跳出循环，会继续唤醒新的 head 节点的后继节点        if (h == head)                               break;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><img src="https://gitee.com/seazean/images/raw/master/Java/JUC-ReentrantReadWriteLock解锁1.png" style="zoom: 67%;"></li><li><p>下一个节点不是 shared 了，因此不会继续唤醒 t4 所在节点</p></li><li><p>t2 读锁解锁，进入 sync.releaseShared(1) 中，调用 tryReleaseShared(1) 让计数减一，但计数还不为零，t3 同样让计数减一，计数为零，进入doReleaseShared() 将头节点从 -1 改为 0 并唤醒下一个节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;    sync.releaseShared(<span class="number">1</span>);&#125;<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;        doReleaseShared();        <span class="keyword">return</span> <span class="keyword">true</span>;    &#125;    <span class="keyword">return</span> <span class="keyword">false</span>;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;    <span class="comment">//      for (;;) &#123;        int c = getState();        int nextc = c - SHARED_UNIT;        // 读锁的计数不会影响其它获取读锁线程, 但会影响其它获取写锁线程，计数为 0 才是真正释放        if (compareAndSetState(c, nextc))            // 返回是否已经完全释放了             return nextc == 0;    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>t4 在 acquireQueued 中 parkAndCheckInterrupt 处恢复运行，再次 for (;;) 这次自己是头节点的临节点，并且没有其他节点竞争，tryAcquire(1) 成功，修改头结点，流程结束</p><img src="https://gitee.com/seazean/images/raw/master/Java/JUC-ReentrantReadWriteLock解锁2.png" style="zoom: 67%;"></li></ul><hr><h4 id="Stamped"><a href="#Stamped" class="headerlink" title="Stamped"></a>Stamped</h4><p>StampedLock：读写锁，该类自 JDK 8 加入，是为了进一步优化读性能</p><p>特点：</p><ul><li><p>在使用读锁、写锁时都必须配合戳使用</p></li><li><p>StampedLock 不支持条件变量</p></li><li><p>StampedLock <strong>不支持可重入</strong></p></li></ul><p>基本用法</p><ul><li><p>加解读锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> stamp = lock.readLock();lock.unlockRead(stamp);<span class="comment">// 类似于 unpark，解指定的锁</span></span><br></pre></td></tr></table></figure></li><li><p>加解写锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> stamp = lock.writeLock();lock.unlockWrite(stamp);</span><br></pre></td></tr></table></figure></li><li><p>乐观读，StampedLock 支持 <code>tryOptimisticRead()</code> 方法，读取完毕后做一次<strong>戳校验</strong>，如果校验通过，表示这期间没有其他线程的写操作，数据可以安全使用，如果校验没通过，需要重新获取读锁，保证数据一致性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> stamp = lock.tryOptimisticRead();<span class="comment">// 验戳if(!lock.validate(stamp))&#123;// 锁升级&#125;</span></span><br></pre></td></tr></table></figure></li></ul><p>提供一个数据容器类内部分别使用读锁保护数据的 read() 方法，写锁保护数据的 write() 方法：</p><ul><li>读-读可以优化</li><li>读-写优化读，补加读锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;    DataContainerStamped dataContainer = <span class="keyword">new</span> DataContainerStamped(<span class="number">1</span>);    <span class="keyword">new</span> Thread(() -&gt; &#123;    dataContainer.read(<span class="number">1000</span>);    &#125;,<span class="string">&quot;t1&quot;</span>).start();    Thread.sleep(<span class="number">500</span>);        <span class="keyword">new</span> Thread(() -&gt; &#123;        dataContainer.write(<span class="number">1000</span>);    &#125;,<span class="string">&quot;t2&quot;</span>).start();&#125;<span class="class"><span class="keyword">class</span> <span class="title">DataContainerStamped</span> </span>&#123;    <span class="keyword">private</span> <span class="keyword">int</span> data;    <span class="keyword">private</span> <span class="keyword">final</span> StampedLock lock = <span class="keyword">new</span> StampedLock();    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> readTime)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;        <span class="keyword">long</span> stamp = lock.tryOptimisticRead();        System.out.println(<span class="keyword">new</span> Date() + <span class="string">&quot; optimistic read locking&quot;</span> + stamp);        Thread.sleep(readTime);        <span class="comment">// 戳有效，直接返回数据        if (lock.validate(stamp)) &#123;            Sout(new Date() + &quot; optimistic read finish...&quot; + stamp);            return data;        &#125;        // 说明其他线程更改了戳，需要锁升级了，从乐观读升级到读锁        System.out.println(new Date() + &quot; updating to read lock&quot; + stamp);        try &#123;            stamp = lock.readLock();            System.out.println(new Date() + &quot; read lock&quot; + stamp);            Thread.sleep(readTime);            System.out.println(new Date() + &quot; read finish...&quot; + stamp);            return data;        &#125; finally &#123;            System.out.println(new Date() + &quot; read unlock &quot; +  stamp);            lock.unlockRead(stamp);        &#125;    &#125;    public void write(int newData) &#123;        long stamp = lock.writeLock();        System.out.println(new Date() + &quot; write lock &quot; + stamp);        try &#123;            Thread.sleep(2000);            this.data = newData;        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125; finally &#123;            System.out.println(new Date() + &quot; write unlock &quot; + stamp);            lock.unlockWrite(stamp);        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h3 id="CountDown"><a href="#CountDown" class="headerlink" title="CountDown"></a>CountDown</h3><h4 id="基本使用-7"><a href="#基本使用-7" class="headerlink" title="基本使用"></a>基本使用</h4><p>CountDownLatch：计数器，用来进行线程同步协作，<strong>等待所有线程完成</strong></p><p>构造器：</p><ul><li><code>public CountDownLatch(int count)</code>：初始化唤醒需要的 down 几步</li></ul><p>常用API：</p><ul><li><code>public void await() </code>：让当前线程等待，必须 down 完初始化的数字才可以被唤醒，否则进入无限等待</li><li><code>public void countDown()</code>：计数器进行减1（down 1）</li></ul><p>应用：同步等待多个 Rest 远程调用结束</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOL 10人进入游戏倒计时public static void main(String[] args) throws InterruptedException &#123;    CountDownLatch latch = new CountDownLatch(10);    ExecutorService service = Executors.newFixedThreadPool(10);    String[] all = new String[10];    Random random = new Random();    for (int j = 0; j &lt; 10; j++) &#123;        int finalJ = j;//常量        service.submit(() -&gt; &#123;            for (int i = 0; i &lt;= 100; i++) &#123;                Thread.sleep(random.nextInt(100));//随机休眠                all[finalJ] = i + &quot;%&quot;;                System.out.print(&quot;\r&quot; + Arrays.toString(all));// \r代表覆盖            &#125;            latch.countDown();        &#125;);    &#125;    latch.await();    System.out.println(&quot;\n游戏开始&quot;);    service.shutdown();&#125;/*[100%, 100%, 100%, 100%, 100%, 100%, 100%, 100%, 100%, 100%]游戏开始</span></span><br></pre></td></tr></table></figure><hr><h4 id="实现原理-6"><a href="#实现原理-6" class="headerlink" title="实现原理"></a>实现原理</h4><p>阻塞等待：</p><ul><li><p>线程调用 await() 等待其他线程完成任务：支持打断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;    sync.acquireSharedInterruptibly(<span class="number">1</span>);&#125;<span class="comment">// AbstractQueuedSynchronizer#acquireSharedInterruptiblypublic final void acquireSharedInterruptibly(int arg) throws InterruptedException &#123;    // 判断线程是否被打断，抛出打断异常    if (Thread.interrupted())        throw new InterruptedException();    // 尝试获取共享锁，条件成立说明 state &gt; 0，此时线程入队阻塞等待，等待其他线程获取共享资源    // 条件不成立说明 state = 0，此时不需要阻塞线程，直接结束函数调用    if (tryAcquireShared(arg) &lt; 0)        doAcquireSharedInterruptibly(arg);&#125;// CountDownLatch.Sync#tryAcquireSharedprotected int tryAcquireShared(int acquires) &#123;    return (getState() == 0) ? 1 : -1;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>线程进入 AbstractQueuedSynchronizer#doAcquireSharedInterruptibly 函数阻塞挂起，等待 latch 变为 0：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;    <span class="comment">// 将调用latch.await()方法的线程 包装成 SHARED 类型的 node 加入到 AQS 的阻塞队列中    final Node node = addWaiter(Node.SHARED);    boolean failed = true;    try &#123;        for (;;) &#123;            // 获取当前节点的前驱节点            final Node p = node.predecessor();            // 前驱节点时头节点就可以尝试获取锁            if (p == head) &#123;                // 再次尝试获取锁，获取成功返回 1                int r = tryAcquireShared(arg);                if (r &gt;= 0) &#123;                    // 获取锁成功，设置当前节点为 head 节点，并且向后传播                    setHeadAndPropagate(node, r);                    p.next = null; // help GC                    failed = false;                    return;                &#125;            &#125;            // 阻塞在这里            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())                throw new InterruptedException();        &#125;    &#125; finally &#123;        // 阻塞线程被中断后抛出异常，进入取消节点的逻辑        if (failed)            cancelAcquire(node);    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>获取共享锁成功，进入唤醒阻塞队列中与头节点相连的 SHARED 模式的节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;    Node h = head;    <span class="comment">// 将当前节点设置为新的 head 节点，前驱节点和持有线程置为 null    setHead(node);// propagate = 1，条件一成立    if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 || (h = head) == null || h.waitStatus &lt; 0) &#123;        // 获取当前节点的后继节点        Node s = node.next;        // 当前节点是尾节点时 next 为 null，或者后继节点是 SHARED 共享模式        if (s == null || s.isShared())            // 唤醒所有的等待共享锁的节点            doReleaseShared();    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><p>计数减一：</p><ul><li><p>线程进入 countDown() 完成计数器减一（释放锁）的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;    sync.releaseShared(<span class="number">1</span>);&#125;<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;    <span class="comment">// 尝试释放共享锁    if (tryReleaseShared(arg)) &#123;        // 释放锁成功开始唤醒阻塞节点        doReleaseShared();        return true;    &#125;    return false;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>更新 state 值，每调用一次，state 值减一，当 state -1 正好为 0 时，返回 true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;    <span class="keyword">for</span> (;;) &#123;        <span class="keyword">int</span> c = getState();        <span class="comment">// 条件成立说明前面【已经有线程触发唤醒操作】了，这里返回 false        if (c == 0)            return false;        // 计数器减一        int nextc = c-1;        if (compareAndSetState(c, nextc))            // 计数器为 0 时返回 true            return nextc == 0;    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>state = 0 时，当前线程需要执行<strong>唤醒阻塞节点的任务</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;    <span class="keyword">for</span> (;;) &#123;        Node h = head;        <span class="comment">// 判断队列是否是空队列        if (h != null &amp;&amp; h != tail) &#123;            int ws = h.waitStatus;            // 头节点的状态为 signal，说明后继节点没有被唤醒过            if (ws == Node.SIGNAL) &#123;                // cas 设置头节点的状态为 0，设置失败继续自旋                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))                    continue;                // 唤醒后继节点                unparkSuccessor(h);            &#125;            // 如果有其他线程已经设置了头节点的状态，重新设置为 PROPAGATE 传播属性            else if (ws == 0 &amp;&amp; !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))                continue;        &#125;        // 条件不成立说明被唤醒的节点非常积极，直接将自己设置为了新的head，        // 此时唤醒它的节点（前驱）执行 h == head 不成立，所以不会跳出循环，会继续唤醒新的 head 节点的后继节点        if (h == head)            break;    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><h4 id="基本使用-8"><a href="#基本使用-8" class="headerlink" title="基本使用"></a>基本使用</h4><p>CyclicBarrier：循环屏障，用来进行线程协作，等待线程满足某个计数，才能触发自己执行</p><p>常用方法：</p><ul><li><code>public CyclicBarrier(int parties, Runnable barrierAction)</code>：用于在线程到达屏障 parties 时，执行 barrierAction<ul><li>parties：代表多少个线程到达屏障开始触发线程任务</li><li>barrierAction：线程任务</li></ul></li><li><code>public int await()</code>：线程调用 await 方法通知 CyclicBarrier 本线程已经到达屏障</li></ul><p>与 CountDownLatch 的区别：CyclicBarrier 是可以重用的</p><p>应用：可以实现多线程中，某个任务在等待其他线程执行完毕以后触发</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    ExecutorService service = Executors.newFixedThreadPool(<span class="number">2</span>);    CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>, () -&gt; &#123;        System.out.println(<span class="string">&quot;task1 task2 finish...&quot;</span>);    &#125;);    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123; <span class="comment">// 循环重用        service.submit(() -&gt; &#123;            System.out.println(&quot;task1 begin...&quot;);            try &#123;                Thread.sleep(1000);                barrier.await();    // 2 - 1 = 1            &#125; catch (InterruptedException | BrokenBarrierException e) &#123;                e.printStackTrace();            &#125;        &#125;);        service.submit(() -&gt; &#123;            System.out.println(&quot;task2 begin...&quot;);            try &#123;                Thread.sleep(2000);                barrier.await();    // 1 - 1 = 0            &#125; catch (InterruptedException | BrokenBarrierException e) &#123;                e.printStackTrace();            &#125;        &#125;);    &#125;    service.shutdown();&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="实现原理-7"><a href="#实现原理-7" class="headerlink" title="实现原理"></a>实现原理</h4><h5 id="成员属性-5"><a href="#成员属性-5" class="headerlink" title="成员属性"></a>成员属性</h5><ul><li><p>全局锁：利用可重入锁实现的工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// barrier 实现是依赖于Condition条件队列，condition 条件队列必须依赖lock才能使用private final ReentrantLock lock = new ReentrantLock();// 线程挂起实现使用的 condition 队列，当前代所有线程到位，这个条件队列内的线程才会被唤醒private final Condition trip = lock.newCondition();</span></span><br></pre></td></tr></table></figure></li><li><p>线程数量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parties;<span class="comment">// 代表多少个线程到达屏障开始触发线程任务private int count;// 表示当前“代”还有多少个线程未到位，初始值为 parties</span></span><br></pre></td></tr></table></figure></li><li><p>当前代中最后一个线程到位后要执行的事件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable barrierCommand;</span><br></pre></td></tr></table></figure></li><li><p>代：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示 barrier 对象当前 代private Generation generation = new Generation();private static class Generation &#123;    // 表示当前“代”是否被打破，如果被打破再来到这一代的线程 就会直接抛出 BrokenException 异常    // 且在这一代挂起的线程都会被唤醒，然后抛出 BrokerException 异常。    boolean broken = false;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrie</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;    <span class="comment">// 因为小于等于 0 的 barrier 没有任何意义    if (parties &lt;= 0) throw new IllegalArgumentException();    this.parties = parties;    this.count = parties;    // 可以为 null    this.barrierCommand = barrierAction;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><img src="https://gitee.com/seazean/images/raw/master/Java/JUC-CyclicBarrier工作原理.png" style="zoom: 80%;"><hr><h5 id="成员方法-5"><a href="#成员方法-5" class="headerlink" title="成员方法"></a>成员方法</h5><ul><li><p>await()：阻塞等待所有线程到位</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;    <span class="keyword">try</span> &#123;        <span class="keyword">return</span> dowait(<span class="keyword">false</span>, <span class="number">0L</span>);    &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;        <span class="keyword">throw</span> <span class="keyword">new</span> Error(toe); <span class="comment">// cannot happen    &#125;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// timed：表示当前调用await方法的线程是否指定了超时时长，如果 true 表示线程是响应超时的// nanos：线程等待超时时长，单位是纳秒private int dowait(boolean timed, long nanos) &#123;    final ReentrantLock lock = this.lock;    // 加锁    lock.lock();    try &#123;        // 获取当前代        final Generation g = generation;        // 【如果当前代是已经被打破状态，则当前调用await方法的线程，直接抛出Broken异常】        if (g.broken)            throw new BrokenBarrierException();// 如果当前线程被中断了，则打破当前代，然后当前线程抛出中断异常        if (Thread.interrupted()) &#123;            // 设置当前代的状态为 broken 状态，唤醒在 trip 条件队列内的线程            breakBarrier();            throw new InterruptedException();        &#125;        // 逻辑到这说明，当前线程中断状态是 false， 当前代的 broken 为 false（未打破状态）                // 假设 parties 给的是 5，那么index对应的值为 4,3,2,1,0        int index = --count;        // 条件成立说明当前线程是最后一个到达 barrier 的线程，【需要开启新代，唤醒阻塞线程】        if (index == 0) &#123;            // 栅栏任务启动标记            boolean ranAction = false;            try &#123;                final Runnable command = barrierCommand;                if (command != null)                    // 启动触发的任务                    command.run();                // run()未抛出异常的话，启动标记设置为 true                ranAction = true;                // 开启新的一代，这里会【唤醒所有的阻塞队列】                nextGeneration();                // 返回 0 因为当前线程是此代最后一个到达的线程，index == 0                return 0;            &#125; finally &#123;                // 如果 command.run() 执行抛出异常的话，会进入到这里                if (!ranAction)                    breakBarrier();            &#125;        &#125;        // 自旋，一直到条件满足、当前代被打破、线程被中断，等待超时        for (;;) &#123;            try &#123;                // 根据是否需要超时等待选择阻塞方法                if (!timed)                    // 当前线程释放掉 lock，进入到 trip 条件队列的尾部挂起自己，等待被唤醒                    trip.await();                else if (nanos &gt; 0L)                    nanos = trip.awaitNanos(nanos);            &#125; catch (InterruptedException ie) &#123;                // 被中断后来到这里的逻辑                                // 当前代没有变化并且没有被打破                if (g == generation &amp;&amp; !g.broken) &#123;                    // 打破屏障                    breakBarrier();                    // node 节点在【条件队列】内收到中断信号时 会抛出中断异常                    throw ie;                &#125; else &#123;                    // 等待过程中代变化了，完成一次自我打断                    Thread.currentThread().interrupt();                &#125;            &#125;// 唤醒后的线程，【判断当前代已经被打破，线程唤醒后依次抛出 BrokenBarrier 异常】            if (g.broken)                throw new BrokenBarrierException();            // 当前线程挂起期间，最后一个线程到位了，然后触发了开启新的一代的逻辑            if (g != generation)                return index;// 当前线程 trip 中等待超时，然后主动转移到阻塞队列            if (timed &amp;&amp; nanos &lt;= 0L) &#123;                breakBarrier();                // 抛出超时异常                throw new TimeoutException();            &#125;        &#125;    &#125; finally &#123;        // 解锁        lock.unlock();    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>breakBarrier()：打破 Barrier 屏障</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">breakBarrier</span><span class="params">()</span> </span>&#123;    <span class="comment">// 将代中的 broken 设置为 true，表示这一代是被打破了，再来到这一代的线程，直接抛出异常    generation.broken = true;    // 重置 count 为 parties    count = parties;    // 将在trip条件队列内挂起的线程全部唤醒，唤醒后的线程会检查当前是否是打破的，然后抛出异常    trip.signalAll();&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>nextGeneration()：开启新的下一代 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextGeneration</span><span class="params">()</span> </span>&#123;    <span class="comment">// 将在 trip 条件队列内挂起的线程全部唤醒    trip.signalAll();    // 重置 count 为 parties    count = parties;    // 开启新的一代，使用一个新的generation对象，表示新的一代，新的一代和上一代【没有任何关系】    generation = new Generation();&#125;</span></span><br></pre></td></tr></table></figure></li></ul><p>参考视频：<a href="https://space.bilibili.com/457326371/">https://space.bilibili.com/457326371/</a></p><hr><h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><h4 id="基本使用-9"><a href="#基本使用-9" class="headerlink" title="基本使用"></a>基本使用</h4><p>synchronized 可以起到锁的作用，但某个时间段内，只能有一个线程允许执行</p><p>Semaphore（信号量）用来限制能同时访问共享资源的线程上限，非重入锁</p><p>构造方法：</p><ul><li><code>public Semaphore(int permits)</code>：permits 表示许可线程的数量（state）</li><li><code>public Semaphore(int permits, boolean fair)</code>：fair 表示公平性，如果这个设为 true 的话，下次执行的线程会是等待最久的线程</li></ul><p>常用API：</p><ul><li><code>public void acquire()</code>：表示获取许可</li><li><code>public void release()</code>：表示释放许可，acquire() 和 release() 方法之间的代码为同步代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    <span class="comment">// 1.创建Semaphore对象    Semaphore semaphore = new Semaphore(3);    // 2. 10个线程同时运行    for (int i = 0; i &lt; 10; i++) &#123;        new Thread(() -&gt; &#123;            try &#123;                // 3. 获取许可                semaphore.acquire();                sout(Thread.currentThread().getName() + &quot; running...&quot;);                Thread.sleep(1000);                sout(Thread.currentThread().getName() + &quot; end...&quot;);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125; finally &#123;                // 4. 释放许可                semaphore.release();            &#125;        &#125;).start();    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="实现原理-8"><a href="#实现原理-8" class="headerlink" title="实现原理"></a>实现原理</h4><p>加锁流程：</p><ul><li><p>Semaphore 的 permits（state）为 3，这时 5 个线程来获取资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sync(<span class="keyword">int</span> permits) &#123;    setState(permits);&#125;</span><br></pre></td></tr></table></figure><p>假设其中 Thread-1，Thread-2，Thread-4 CAS 竞争成功，permits 变为 0，而 Thread-0 和 Thread-3 竞争失败，进入 AQS 队列park 阻塞</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// acquire() -&gt; sync.acquireSharedInterruptibly(1)，可中断public final void acquireSharedInterruptibly(int arg) &#123;    if (Thread.interrupted())        throw new InterruptedException();    // 尝试获取通行证，获取成功返回 &gt;= 0的值    if (tryAcquireShared(arg) &lt; 0)        // 获取许可证失败，进入阻塞        doAcquireSharedInterruptibly(arg);&#125;// tryAcquireShared() -&gt; nonfairTryAcquireShared()// 非公平，公平锁会在循环内 hasQueuedPredecessors()方法判断阻塞队列是否有临头节点(第二个节点)final int nonfairTryAcquireShared(int acquires) &#123;    for (;;) &#123;        // 获取 state ，state 这里【表示通行证】        int available = getState();        // 计算当前线程获取通行证完成之后，通行证还剩余数量        int remaining = available - acquires;        // 如果许可已经用完, 返回负数, 表示获取失败,        if (remaining &lt; 0 ||            // 许可证足够分配的，如果 cas 重试成功, 返回正数, 表示获取成功            compareAndSetState(available, remaining))            return remaining;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;    <span class="comment">// 将调用 Semaphore.aquire 方法的线程，包装成 node 加入到 AQS 的阻塞队列中    final Node node = addWaiter(Node.SHARED);    // 获取标记    boolean failed = true;    try &#123;        for (;;) &#123;            final Node p = node.predecessor();            // 前驱节点是头节点可以再次获取许可            if (p == head) &#123;                // 再次尝试获取许可，【返回剩余的许可证数量】                int r = tryAcquireShared(arg);                if (r &gt;= 0) &#123;                    // 成功后本线程出队（AQS）, 所在 Node设置为 head                    // r 表示【可用资源数】, 为 0 则不会继续传播                    setHeadAndPropagate(node, r);                     p.next = null; // help GC                    failed = false;                    return;                &#125;            &#125;            // 不成功, 设置上一个节点 waitStatus = Node.SIGNAL, 下轮进入 park 阻塞            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())                throw new InterruptedException();        &#125;    &#125; finally &#123;        // 被打断后进入该逻辑        if (failed)            cancelAcquire(node);    &#125;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;        Node h = head;    <span class="comment">// 设置自己为 head 节点    setHead(node);    // propagate 表示有【共享资源】（例如共享读锁或信号量）    // head waitStatus == Node.SIGNAL 或 Node.PROPAGATE，doReleaseShared 函数中设置的    if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 ||        (h = head) == null || h.waitStatus &lt; 0) &#123;        Node s = node.next;        // 如果是最后一个节点或者是等待共享读锁的节点，做一次唤醒        if (s == null || s.isShared())            doReleaseShared();    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/seazean/images/raw/master/Java/JUC-Semaphore%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B1.png"></p></li><li><p>这时 Thread-4 释放了 permits，状态如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// release() -&gt; releaseShared()public final boolean releaseShared(int arg) &#123;    // 尝试释放锁    if (tryReleaseShared(arg)) &#123;        doReleaseShared();        return true;    &#125;        return false;&#125;protected final boolean tryReleaseShared(int releases) &#123;        for (;;) &#123;        // 获取当前锁资源的可用许可证数量        int current = getState();        int next = current + releases;        // 索引越界判断        if (next &lt; current)                        throw new Error(&quot;Maximum permit count exceeded&quot;);                // 释放锁        if (compareAndSetState(current, next))                        return true;        &#125;&#125;private void doReleaseShared() &#123;        // PROPAGATE 详解        // 如果 head.waitStatus == Node.SIGNAL ==&gt; 0 成功, 下一个节点 unpark    // 如果 head.waitStatus == 0 ==&gt; Node.PROPAGATE&#125;</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/seazean/images/raw/master/Java/JUC-Semaphore%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B2.png"></p></li><li><p>接下来 Thread-0 竞争成功，permits 再次设置为 0，设置自己为 head 节点，并且 unpark 接下来的共享状态的 Thread-3 节点，但由于 permits 是 0，因此 Thread-3 在尝试不成功后再次进入 park 状态</p></li></ul><hr><h4 id="PROPAGATE"><a href="#PROPAGATE" class="headerlink" title="PROPAGATE"></a>PROPAGATE</h4><p>假设存在某次循环中队列里排队的结点情况为 <code>head(-1) → t1(-1) → t2(0)</code>，存在将要释放信号量的 T3 和 T4，释放顺序为先 T3 后 T4</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 老版本代码private void setHeadAndPropagate(Node node, int propagate) &#123;        setHead(node);        // 有空闲资源        if (propagate &gt; 0 &amp;&amp; node.waitStatus != 0) &#123;            Node s = node.next;                // 下一个                if (s == null || s.isShared())                        unparkSuccessor(node);            &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>正常流程：</p><ul><li>T3 调用 releaseShared(1)，直接调用了 unparkSuccessor(head)，head.waitStatus 从 -1 变为 0</li><li>T1 由于 T3 释放信号量被唤醒，然后 T4 释放，唤醒 T2</li></ul><p>BUG 流程：</p><ul><li>T3 调用 releaseShared(1)，直接调用了 unparkSuccessor(head)，head.waitStatus 从 -1 变为 0</li><li>T1 由于 T3 释放信号量被唤醒，调用 tryAcquireShared，返回值为 0（获取锁成功，但没有剩余资源量）</li><li>T1 还没调用 setHeadAndPropagate 方法，T4 调用 releaseShared(1)，此时 head.waitStatus 为 0（此时读到的 head 和 1 中为同一个 head），不满足条件，因此不调用 unparkSuccessor(head)</li><li>T1 获取信号量成功，调用 setHeadAndPropagate(t1.node, 0) 时，因为不满足 propagate &gt; 0（剩余资源量 == 0），从而不会唤醒后继结点， <strong>T2 线程得不到唤醒</strong></li></ul><p>更新后流程：</p><ul><li><p>T3 调用 releaseShared(1)，直接调用了 unparkSuccessor(head)，head.waitStatus 从 -1 变为 0</p></li><li><p>T1 由于 T3 释放信号量被唤醒，调用 tryAcquireShared，返回值为 0（获取锁成功，但没有剩余资源量）</p></li><li><p>T1 还没调用 setHeadAndPropagate 方法，T4 调用 releaseShared()，此时 head.waitStatus 为 0（此时读到的 head 和 1 中为同一个 head），调用 doReleaseShared() 将等待状态置为 <strong>PROPAGATE（-3）</strong></p></li><li><p>T1 获取信号量成功，调用 setHeadAndPropagate 时，读到 h.waitStatus &lt; 0，从而调用 doReleaseShared() 唤醒 T2</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;        Node h = head;    <span class="comment">// 设置自己为 head 节点    setHead(node);    // propagate 表示有共享资源（例如共享读锁或信号量）    // head waitStatus == Node.SIGNAL 或 Node.PROPAGATE    if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 ||        (h = head) == null || h.waitStatus &lt; 0) &#123;        Node s = node.next;        // 如果是最后一个节点或者是等待共享读锁的节点，做一次唤醒        if (s == null || s.isShared())            doReleaseShared();    &#125;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 唤醒private void doReleaseShared() &#123;    // 如果 head.waitStatus == Node.SIGNAL ==&gt; 0 成功, 下一个节点 unpark    // 如果 head.waitStatus == 0 ==&gt; Node.PROPAGATE        for (;;) &#123;        Node h = head;        if (h != null &amp;&amp; h != tail) &#123;            int ws = h.waitStatus;            if (ws == Node.SIGNAL) &#123;                // 防止 unparkSuccessor 被多次执行                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))                    continue;                // 唤醒后继节点                unparkSuccessor(h);            &#125;            // 如果已经是 0 了，改为 -3，用来解决传播性            else if (ws == 0 &amp;&amp; !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))                continue;        &#125;        if (h == head)            break;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h3 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h3><p>Exchanger：交换器，是一个用于线程间协作的工具类，用于进行线程间的数据交换</p><p>工作流程：两个线程通过 exchange 方法交换数据，如果第一个线程先执行 exchange() 方法，它会一直等待第二个线程也执行 exchange 方法，当两个线程都到达同步点时，这两个线程就可以交换数据</p><p>常用方法：</p><ul><li><code>public Exchanger()</code>：创建一个新的交换器</li><li><code>public V exchange(V x)</code>：等待另一个线程到达此交换点</li><li><code>public V exchange(V x, long timeout, TimeUnit unit)</code>：等待一定的时间</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangerDemo</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        <span class="comment">// 创建交换对象（信使）        Exchanger&lt;String&gt; exchanger = new Exchanger&lt;&gt;();        new ThreadA(exchanger).start();        new ThreadA(exchanger).start();    &#125; &#125;class ThreadA extends Thread&#123;    private Exchanger&lt;String&gt; exchanger();        public ThreadA(Exchanger&lt;String&gt; exchanger)&#123;        this.exchanger = exchanger;    &#125;        @Override    public void run() &#123;        try&#123;            sout(&quot;线程A，做好了礼物A，等待线程B送来的礼物B&quot;);            //如果等待了5s还没有交换就死亡（抛出异常）！            String s = exchanger.exchange(&quot;礼物A&quot;,5,TimeUnit.SECONDS);            sout(&quot;线程A收到线程B的礼物：&quot; + s);        &#125; catch (Exception e) &#123;            System.out.println(&quot;线程A等待了5s，没有收到礼物,最终就执行结束了!&quot;);        &#125;    &#125;&#125;class ThreadB extends Thread&#123;    private Exchanger&lt;String&gt; exchanger;        public ThreadB(Exchanger&lt;String&gt; exchanger) &#123;        this.exchanger = exchanger;    &#125;        @Override    public void run() &#123;        try &#123;            sout(&quot;线程B,做好了礼物B,等待线程A送来的礼物A.....&quot;);            // 开始交换礼物。参数是送给其他线程的礼物!            sout(&quot;线程B收到线程A的礼物：&quot; + exchanger.exchange(&quot;礼物B&quot;));        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h2 id="并发包"><a href="#并发包" class="headerlink" title="并发包"></a>并发包</h2><h3 id="ConHashMap"><a href="#ConHashMap" class="headerlink" title="ConHashMap"></a>ConHashMap</h3><h4 id="并发集合"><a href="#并发集合" class="headerlink" title="并发集合"></a>并发集合</h4><h5 id="集合对比"><a href="#集合对比" class="headerlink" title="集合对比"></a>集合对比</h5><p>三种集合：</p><ul><li>HashMap 是线程不安全的，性能好</li><li>Hashtable 线程安全基于 synchronized，综合性能差，已经被淘汰</li><li>ConcurrentHashMap 保证了线程安全，综合性能较好，不止线程安全，而且效率高，性能好</li></ul><p>集合对比：</p><ol><li>Hashtable 继承 Dictionary 类，HashMap、ConcurrentHashMap 继承 AbstractMap，均实现 Map 接口</li><li>Hashtable 底层是数组 + 链表，JDK8 以后 HashMap 和 ConcurrentHashMap 底层是数组 + 链表 + 红黑树</li><li>HashMap 线程非安全，Hashtable 线程安全，Hashtable 的方法都加了 synchronized 关来确保线程同步</li><li>ConcurrentHashMap、Hashtable <strong>不允许 null 值</strong>，HashMap 允许 null 值</li><li>ConcurrentHashMap、HashMap 的初始容量为 16，Hashtable 初始容量为11，填充因子默认都是 0.75，两种 Map 扩容是当前容量翻倍：capacity * 2，Hashtable 扩容时是容量翻倍 + 1：capacity*2 + 1</li></ol><p><img src="https://gitee.com/seazean/images/raw/master/Java/ConcurrentHashMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="ConcurrentHashMap数据结构"></p><p>工作步骤：</p><ol><li>初始化，使用 cas 来保证并发安全，懒惰初始化 table</li><li>树化，当 table.length &lt; 64 时，先尝试扩容，超过 64 时，并且 bin.length &gt; 8 时，会将<strong>链表树化</strong>，树化过程会用 synchronized 锁住链表头</li><li>put，如果该 bin 尚未创建，只需要使用 cas 创建 bin；如果已经有了，锁住链表头进行后续 put 操作，元素添加至 bin 的尾部</li><li>get，无锁操作仅需要保证可见性，扩容过程中 get 操作拿到的是 ForwardingNode 会让 get 操作在新 table 进行搜索</li><li>扩容，扩容时以 bin 为单位进行，需要对 bin 进行 synchronized，但这时其它竞争线程也不是无事可做，它们会帮助把其它 bin 进行扩容</li><li>size，元素个数保存在 baseCount 中，并发时的个数变动保存在 CounterCell[] 当中，最后统计数量时累加</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需求：多个线程同时往HashMap容器中存入数据会出现安全问题public class ConcurrentHashMapDemo&#123;    public static Map&lt;String,String&gt; map = new ConcurrentHashMap();        public static void main(String[] args)&#123;        new AddMapDataThread().start();        new AddMapDataThread().start();                Thread.sleep(1000 * 5);//休息5秒，确保两个线程执行完毕        System.out.println(&quot;Map大小：&quot; + map.size());//20万    &#125;&#125;public class AddMapDataThread extends Thread&#123;    @Override    public void run() &#123;        for(int i = 0 ; i &lt; 1000000 ; i++ )&#123;            ConcurrentHashMapDemo.map.put(&quot;键：&quot;+i , &quot;值&quot;+i);        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h5 id="并发死链"><a href="#并发死链" class="headerlink" title="并发死链"></a>并发死链</h5><p>JDK1.7 的 HashMap 采用的头插法（拉链法）进行节点的添加，HashMap 的扩容长度为原来的 2 倍</p><p>resize() 中节点（Entry）转移的源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;    <span class="keyword">int</span> newCapacity = newTable.length;<span class="comment">//得到新数组的长度       // 遍历整个数组对应下标下的链表，e代表一个节点    for (Entry&lt;K,V&gt; e : table) &#123;           // 当e == null时，则该链表遍历完了，继续遍历下一数组下标的链表         while(null != e) &#123;             // 先把e节点的下一节点存起来            Entry&lt;K,V&gt; next = e.next;             if (rehash) &#123;              //得到新的hash值                e.hash = null == e.key ? 0 : hash(e.key);              &#125;            // 在新数组下得到新的数组下标            int i = indexFor(e.hash, newCapacity);               // 将e的next指针指向新数组下标的位置            e.next = newTable[i];               // 将该数组下标的节点变为e节点            newTable[i] = e;             // 遍历链表的下一节点            e = next;                                           &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>JDK 8 虽然将扩容算法做了调整，改用了尾插法，但仍不意味着能够在多线程环境下能够安全扩容，还会出现其它问题（如扩容丢数据）</p><p>B站视频解析：<a href="https://www.bilibili.com/video/BV1n541177Ea">https://www.bilibili.com/video/BV1n541177Ea</a></p><hr><h4 id="成员属性-6"><a href="#成员属性-6" class="headerlink" title="成员属性"></a>成员属性</h4><h5 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h5><ul><li><p>存储数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure></li><li><p>散列表的长度：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;<span class="comment">// 最大长度private static final int DEFAULT_CAPACITY = 16;// 默认长度</span></span><br></pre></td></tr></table></figure></li><li><p>并发级别，JDK7 遗留下来，1.8 中不代表并发级别：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br></pre></td></tr></table></figure></li><li><p>负载因子，JDK1.8 的 ConcurrentHashMap 中是固定值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> LOAD_FACTOR = <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure></li><li><p>阈值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;<span class="comment">// 链表树化的阈值static final int UNTREEIFY_THRESHOLD = 6;// 红黑树转化为链表的阈值static final int MIN_TREEIFY_CAPACITY = 64;// 当数组长度达到64且某个桶位中的链表长度超过8，才会真正树化</span></span><br></pre></td></tr></table></figure></li><li><p>扩容相关：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TRANSFER_STRIDE = <span class="number">16</span>;<span class="comment">// 线程迁移数据【最小步长】，控制线程迁移任务的最小区间private static int RESIZE_STAMP_BITS = 16;// 用来计算扩容时生成的【标识戳】private static final int MAX_RESIZERS = (1 &lt;&lt; (32 - RESIZE_STAMP_BITS)) - 1;// 65535-1并发扩容最多线程数private static final int RESIZE_STAMP_SHIFT = 32 - RESIZE_STAMP_BITS;// 扩容时使用</span></span><br></pre></td></tr></table></figure></li><li><p>节点哈希值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED     = -<span class="number">1</span>; <span class="comment">// 表示当前节点是 FWD 节点static final int TREEBIN   = -2; // 表示当前节点已经树化，且当前节点为 TreeBin 对象static final int RESERVED  = -3; // 表示节点时临时节点static final int HASH_BITS = 0x7fffffff; // 正常节点的哈希值的可用的位数</span></span><br></pre></td></tr></table></figure></li><li><p>扩容过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扩容过程中，会将扩容中的新 table 赋值给 nextTable 保持引用，扩容结束之后，这里会被设置为 nullprivate transient volatile Node&lt;K,V&gt;[] nextTable;// 记录扩容进度，所有线程都要从 0 - transferIndex 中分配区间任务，简单说就是老表转移到哪了，索引从高到低转移private transient volatile int transferIndex;</span></span><br></pre></td></tr></table></figure></li><li><p>累加统计：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LongAdder 中的 baseCount 未发生竞争时或者当前LongAdder处于加锁状态时，增量累到到 baseCount 中private transient volatile long baseCount;// LongAdder 中的 cellsBuzy，0 表示当前 LongAdder 对象无锁状态，1 表示当前 LongAdder 对象加锁状态private transient volatile int cellsBusy;// LongAdder 中的 cells 数组，private transient volatile CounterCell[] counterCells;</span></span><br></pre></td></tr></table></figure></li><li><p>控制变量：</p><p><strong>sizeCtl</strong> &lt; 0：</p><ul><li><p>-1 表示当前 table 正在初始化（有线程在创建 table 数组），当前线程需要自旋等待</p></li><li><p>其他负数表示当前 map 的 table 数组正在进行扩容，高 16 位表示扩容的标识戳；低 16 位表示 (1 + nThread) 当前参与并发扩容的线程数量 + 1</p></li></ul><p>sizeCtl = 0，表示创建 table 数组时使用 DEFAULT_CAPACITY 为数组大小</p><p>sizeCtl &gt; 0：</p><ul><li>如果 table 未初始化，表示初始化大小</li><li>如果 table 已经初始化，表示下次扩容时的触发条件（阈值，元素个数，不是数组的长度）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;<span class="comment">// volatile 保持可见性</span></span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h5><ul><li><p>Node 节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;    <span class="comment">// 节点哈希值    final int hash;    final K key;    volatile V val;    // 单向链表    volatile Node&lt;K,V&gt; next;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>TreeBin 节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeBin</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;     <span class="comment">// 红黑树根节点     TreeNode&lt;K,V&gt; root;     // 链表的头节点     volatile TreeNode&lt;K,V&gt; first;     // 等待者线程     volatile Thread waiter;     volatile int lockState;     // 写锁状态 写锁是独占状态，以散列表来看，真正进入到 TreeBin 中的写线程同一时刻只有一个线程     static final int WRITER = 1;     // 等待者状态（写线程在等待），当 TreeBin 中有读线程目前正在读取数据时，写线程无法修改数据     static final int WAITER = 2;     // 读锁状态是共享，同一时刻可以有多个线程 同时进入到 TreeBi 对象中获取数据，每一个线程都给 lockState + 4     static final int READER = 4; &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>TreeNode 节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links    TreeNode&lt;K,V&gt; left;    TreeNode&lt;K,V&gt; right;    TreeNode&lt;K,V&gt; prev;   //双向链表    boolean red;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>ForwardingNode 节点：转移节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ForwardingNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;     <span class="comment">// 持有扩容后新的哈希表的引用     final Node&lt;K,V&gt;[] nextTable;     ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;         // ForwardingNode 节点的 hash 值设为 -1         super(MOVED, null, null, null);         this.nextTable = tab;     &#125; &#125;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h5><ul><li><p>变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示sizeCtl属性在 ConcurrentHashMap 中内存偏移地址private static final long SIZECTL;// 表示transferIndex属性在 ConcurrentHashMap 中内存偏移地址private static final long TRANSFERINDEX;// 表示baseCount属性在 ConcurrentHashMap 中内存偏移地址private static final long BASECOUNT;// 表示cellsBusy属性在 ConcurrentHashMap 中内存偏移地址private static final long CELLSBUSY;// 表示cellValue属性在 CounterCell 中内存偏移地址private static final long CELLVALUE;// 表示数组第一个元素的偏移地址private static final long ABASE;// 用位移运算替代乘法private static final int ASHIFT;</span></span><br></pre></td></tr></table></figure></li><li><p>赋值方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示数组单元所占用空间大小，scale 表示 Node[] 数组中每一个单元所占用空间大小，int 是 4 字节int scale = U.arrayIndexScale(ak);// 判断一个数是不是 2 的 n 次幂，比如 8：1000 &amp; 0111 = 0000if ((scale &amp; (scale - 1)) != 0)    throw new Error(&quot;data type scale not a power of two&quot;);// numberOfLeadingZeros(n)：返回当前数值转换为二进制后，从高位到低位开始统计，看有多少个0连续在一起// 8 → 1000 numberOfLeadingZeros(8) = 28// 4 → 100 numberOfLeadingZeros(4) = 29   int 值就是占4个字节ASHIFT = 31 - Integer.numberOfLeadingZeros(scale);// ASHIFT = 31 - 29 = 2 ，int 的大小就是 2 的 2 次方// ABASE + （5 &lt;&lt; ASHIFT） 用位移运算替代了乘法，获取 arr[5] 的值</span></span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><ul><li><p>无参构造， 散列表结构延迟初始化，默认的数组大小是 16：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>有参构造：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;    <span class="comment">// 指定容量初始化    if (initialCapacity &lt; 0) throw new IllegalArgumentException();    int cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ?               MAXIMUM_CAPACITY :               // 假如传入的参数是 16，16 + 8 + 1 ，最后得到 32               // 传入 12， 12 + 6 + 1 = 19，最后得到 32，尽可能的大，与 HashMap不一样               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; 1) + 1));    // sizeCtl &gt; 0，当目前 table 未初始化时，sizeCtl 表示初始化容量    this.sizeCtl = cap;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;    <span class="keyword">int</span> n = c - <span class="number">1</span>;    n |= n &gt;&gt;&gt; <span class="number">1</span>;    n |= n &gt;&gt;&gt; <span class="number">2</span>;    n |= n &gt;&gt;&gt; <span class="number">4</span>;    n |= n &gt;&gt;&gt; <span class="number">8</span>;    n |= n &gt;&gt;&gt; <span class="number">16</span>;    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;&#125;</span><br></pre></td></tr></table></figure><p>HashMap 部分详解了该函数，核心思想就是<strong>把最高位是 1 的位以及右边的位全部置 1</strong>，结果加 1 后就是 2 的 n 次幂</p></li><li><p>多个参数构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0f</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();    <span class="comment">// 初始容量小于并发级别    if (initialCapacity &lt; concurrencyLevel)          // 把并发级别赋值给初始容量        initialCapacity = concurrencyLevel; // loadFactor 默认是 0.75    long size = (long)(1.0 + (long)initialCapacity / loadFactor);    int cap = (size &gt;= (long)MAXIMUM_CAPACITY) ?        MAXIMUM_CAPACITY : tableSizeFor((int)size);    // sizeCtl &gt; 0，当目前 table 未初始化时，sizeCtl 表示初始化容量    this.sizeCtl = cap;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>集合构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;    <span class="keyword">this</span>.sizeCtl = DEFAULT_CAPACITY;<span class="comment">// 默认16    putAll(m);&#125;public void putAll(Map&lt;? extends K, ? extends V&gt; m) &#123;    // 尝试触发扩容    tryPresize(m.size());    for (Entry&lt;? extends K, ? extends V&gt; e : m.entrySet())        putVal(e.getKey(), e.getValue(), false);&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryPresize</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;    <span class="comment">// 扩容为大于 2 倍的最小的 2 的 n 次幂    int c = (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ? MAXIMUM_CAPACITY :    tableSizeFor(size + (size &gt;&gt;&gt; 1) + 1);    int sc;    while ((sc = sizeCtl) &gt;= 0) &#123;        Node&lt;K,V&gt;[] tab = table; int n;        // 数组还未初始化，【一般是调用集合构造方法才会成立，put 后调用该方法都是不成立的】        if (tab == null || (n = tab.length) == 0) &#123;            n = (sc &gt; c) ? sc : c;            if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123;                try &#123;                    if (table == tab) &#123;                        Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];                        table = nt;                        sc = n - (n &gt;&gt;&gt; 2);// 扩容阈值：n - 1/4 n                    &#125;                &#125; finally &#123;                    sizeCtl = sc;// 扩容阈值赋值给sizeCtl                &#125;            &#125;        &#125;        // 未达到扩容阈值或者数组长度已经大于最大长度        else if (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY)            break;        // 与 addCount 逻辑相同        else if (tab == table) &#123;            int rs = resizeStamp(n);            if (sc &lt; 0) &#123;                Node&lt;K,V&gt;[] nt;                if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||                    sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||                    transferIndex &lt;= 0)                    break;                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))                    transfer(tab, nt);            &#125;            else if (U.compareAndSwapInt(this, SIZECTL, sc,                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))                transfer(tab, null);        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="成员方法-6"><a href="#成员方法-6" class="headerlink" title="成员方法"></a>成员方法</h4><h5 id="数据访存"><a href="#数据访存" class="headerlink" title="数据访存"></a>数据访存</h5><ul><li><p>tabAt()：获取数组某个槽位的头节点，类似于数组中的直接寻址 arr[i]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// i 是数组索引static final &lt;K,V&gt; Node&lt;K,V&gt; tabAt(Node&lt;K,V&gt;[] tab, int i) &#123;    // (i &lt;&lt; ASHIFT) + ABASE == ABASE + i * 4 （一个 int 占 4 个字节），这就相当于寻址，替代了乘法    return (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE);&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>casTabAt()：指定数组索引位置修改原值为指定的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i, Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> </span>&#123;    <span class="keyword">return</span> U.compareAndSwapObject(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);&#125;</span><br></pre></td></tr></table></figure></li><li><p>setTabAt()：指定数组索引位置设置值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">setTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i, Node&lt;K,V&gt; v)</span> </span>&#123;    U.putObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, v);&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="添加方法"><a href="#添加方法" class="headerlink" title="添加方法"></a>添加方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;    <span class="comment">// 第三个参数 onlyIfAbsent 为 false 表示哈希表中存在相同的 key 时【用当前数据覆盖旧数据】    return putVal(key, value, false);&#125;</span></span><br></pre></td></tr></table></figure><ul><li><p>putVal()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;    <span class="comment">// 【ConcurrentHashMap 不能存放 null 值】    if (key == null || value == null) throw new NullPointerException();    // 扰动运算，高低位都参与寻址运算    int hash = spread(key.hashCode());    // 表示当前 k-v 封装成 node 后插入到指定桶位后，在桶位中的所属链表的下标位置    int binCount = 0;    // tab 引用当前 map 的数组 table，开始自旋    for (Node&lt;K,V&gt;[] tab = table;;) &#123;        // f 表示桶位的头节点，n 表示哈希表数组的长度        // i 表示 key 通过寻址计算后得到的桶位下标，fh 表示桶位头结点的 hash 值        Node&lt;K,V&gt; f; int n, i, fh;                // 【CASE1】：表示当前 map 中的 table 尚未初始化        if (tab == null || (n = tab.length) == 0)            //【延迟初始化】            tab = initTable();                // 【CASE2】：i 表示 key 使用【寻址算法】得到 key 对应数组的下标位置，tabAt 获取指定桶位的头结点f        else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123;            // 对应的数组为 null 说明没有哈希冲突，直接新建节点添加到表中            if (casTabAt(tab, i, null,                         new Node&lt;K,V&gt;(hash, key, value, null)))                break;        &#125;        // 【CASE3】：逻辑说明数组已经被初始化，并且当前 key 对应的位置不为 null        // 条件成立表示当前桶位的头结点为 FWD 结点，表示目前 map 正处于扩容过程中        else if ((fh = f.hash) == MOVED)            // 当前线程【需要去帮助哈希表完成扩容】            tab = helpTransfer(tab, f);                // 【CASE4】：哈希表没有在扩容，当前桶位可能是链表也可能是红黑树        else &#123;            // 当插入 key 存在时，会将旧值赋值给 oldVal 返回            V oldVal = null;            // 【锁住当前 key 寻址的桶位的头节点】            synchronized (f) &#123;                // 这里重新获取一下桶的头节点有没有被修改，因为可能被其他线程修改过，这里是线程安全的获取                if (tabAt(tab, i) == f) &#123;                    // 头节点的哈希值大于 0 说明当前桶位是普通的链表节点                    if (fh &gt;= 0) &#123;                        // 当前的插入操作没出现重复的 key，追加到链表的末尾，binCount表示链表长度 -1                        // 插入的key与链表中的某个元素的 key 一致，变成替换操作，binCount 表示第几个节点冲突                        binCount = 1;                        // 迭代循环当前桶位的链表，e 是每次循环处理节点，e 初始是头节点                        for (Node&lt;K,V&gt; e = f;; ++binCount) &#123;                            // 当前循环节点 key                            K ek;                            // key 的哈希值与当前节点的哈希一致，并且 key 的值也相同                            if (e.hash == hash &amp;&amp;                                ((ek = e.key) == key ||                                 (ek != null &amp;&amp; key.equals(ek)))) &#123;                                // 把当前节点的 value 赋值给 oldVal                                oldVal = e.val;                                // 允许覆盖                                if (!onlyIfAbsent)                                    // 新数据覆盖旧数据                                    e.val = value;                                // 跳出循环                                break;                            &#125;                            Node&lt;K,V&gt; pred = e;                            // 如果下一个节点为空，把数据封装成节点插入链表尾部，【binCount 代表长度 - 1】                            if ((e = e.next) == null) &#123;                                pred.next = new Node&lt;K,V&gt;(hash, key,                                                          value, null);                                break;                            &#125;                        &#125;                    &#125;                    // 当前桶位头节点是红黑树                    else if (f instanceof TreeBin) &#123;                        Node&lt;K,V&gt; p;                        binCount = 2;                        if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,                                                              value)) != null) &#123;                            oldVal = p.val;                            if (!onlyIfAbsent)                                p.val = value;                        &#125;                    &#125;                &#125;            &#125;                        // 条件成立说明当前是链表或者红黑树            if (binCount != 0) &#123;                // 如果 binCount &gt;= 8 表示处理的桶位一定是链表，说明长度是 9                if (binCount &gt;= TREEIFY_THRESHOLD)                    // 树化                    treeifyBin(tab, i);                if (oldVal != null)                    return oldVal;                break;            &#125;        &#125;    &#125;    // 统计当前 table 一共有多少数据，判断是否达到扩容阈值标准，触发扩容    // binCount = 0 表示当前桶位为 null，node 可以直接放入，2 表示当前桶位已经是红黑树    addCount(1L, binCount);    return null;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>spread()：扰动函数</p><p>将 hashCode 无符号右移 16 位，高 16bit 和低 16bit 做异或，最后与 HASH_BITS 相与变成正数，<strong>与树化节点和转移节点区分</strong>，把高低位都利用起来减少哈希冲突，保证散列的均匀性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;    <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; HASH_BITS; <span class="comment">// 0111 1111 1111 1111 1111 1111 1111 1111&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>initTable()：初始化数组，延迟初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;    <span class="comment">// tab 引用 map.table，sc 引用 sizeCtl    Node&lt;K,V&gt;[] tab; int sc;    // table 尚未初始化，开始自旋    while ((tab = table) == null || tab.length == 0) &#123;        // sc &lt; 0 说明 table 正在初始化或者正在扩容，当前线程可以释放 CPU 资源        if ((sc = sizeCtl) &lt; 0)            Thread.yield();        // sizeCtl 设置为 -1，相当于加锁，【设置的是 SIZECTL 位置的数据】，        // 因为是 sizeCtl 是基本类型，不是引用类型，所以 sc 保存的是数据的副本        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123;            try &#123;                // 线程安全的逻辑，再进行一次判断                if ((tab = table) == null || tab.length == 0) &#123;                    // sc &gt; 0 创建 table 时使用 sc 为指定大小，否则使用 16 默认值                    int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY;                    // 创建哈希表数组                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];                    table = tab = nt;                    // 扩容阈值，n &gt;&gt;&gt; 2  =&gt; 等于 1/4 n ，n - (1/4)n = 3/4 n =&gt; 0.75 * n                    sc = n - (n &gt;&gt;&gt; 2);                &#125;            &#125; finally &#123;                // 解锁，把下一次扩容的阈值赋值给 sizeCtl                sizeCtl = sc;            &#125;            break;        &#125;    &#125;    return tab;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>treeifyBin()：树化方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index)</span> </span>&#123;    Node&lt;K,V&gt; b; <span class="keyword">int</span> n, sc;    <span class="keyword">if</span> (tab != <span class="keyword">null</span>) &#123;        <span class="comment">// 条件成立：【说明当前 table 数组长度未达到 64，此时不进行树化操作，进行扩容操作】        if ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)            // 当前容量的 2 倍            tryPresize(n &lt;&lt; 1);        // 条件成立：说明当前桶位有数据，且是普通 node 数据。        else if ((b = tabAt(tab, index)) != null &amp;&amp; b.hash &gt;= 0) &#123;            // 【树化加锁】            synchronized (b) &#123;                // 条件成立：表示加锁没问题。                if (tabAt(tab, index) == b) &#123;                    TreeNode&lt;K,V&gt; hd = null, tl = null;                    for (Node&lt;K,V&gt; e = b; e != null; e = e.next) &#123;                        TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,null, null);                        if ((p.prev = tl) == null)                            hd = p;                        else                            tl.next = p;                        tl = p;                    &#125;                    setTabAt(tab, index, new TreeBin&lt;K,V&gt;(hd));                &#125;            &#125;        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>addCount()：添加计数，<strong>代表哈希表中的数据总量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;    <span class="comment">// 【上面这部分的逻辑就是 LongAdder 的累加逻辑】    CounterCell[] as; long b, s;    // 判断累加数组 cells 是否初始化，没有就去累加 base 域，累加失败进入条件内逻辑    if ((as = counterCells) != null ||        !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)) &#123;        CounterCell a; long v; int m;        // true 未竞争，false 发生竞争        boolean uncontended = true;        // 判断 cells 是否被其他线程初始化        if (as == null || (m = as.length - 1) &lt; 0 ||            // 前面的条件为 fasle 说明 cells 被其他线程初始化，通过 hash 寻址对应的槽位            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == null ||            // 尝试去对应的槽位累加，累加失败进入 fullAddCount 进行重试或者扩容            !(uncontended = U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;            // 与 Striped64#longAccumulate 方法相同            fullAddCount(x, uncontended);            return;        &#125;        // 表示当前桶位是 null，或者一个链表节点        if (check &lt;= 1)            return;    // 【获取当前散列表元素个数】，这是一个期望值        s = sumCount();    &#125;        // 表示一定 【是一个 put 操作调用的 addCount】    if (check &gt;= 0) &#123;        Node&lt;K,V&gt;[] tab, nt; int n, sc;                // 条件一：true 说明当前 sizeCtl 可能为一个负数表示正在扩容中，或者 sizeCtl 是一个正数，表示扩容阈值        //        false 表示哈希表的数据的数量没达到扩容条件        // 然后判断当前 table 数组是否初始化了，当前 table 长度是否小于最大值限制，就可以进行扩容        while (s &gt;= (long)(sc = sizeCtl) &amp;&amp; (tab = table) != null &amp;&amp;               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;            // 16 -&gt; 32 扩容 标识为：1000 0000 0001 1011，【负数，扩容批次唯一标识戳】            int rs = resizeStamp(n);                        // 表示当前 table，【正在扩容】，sc 高 16 位是扩容标识戳，低 16 位是线程数 + 1            if (sc &lt; 0) &#123;                // 条件一：判断扩容标识戳是否一样，fasle 代表一样                // 勘误两个条件：                // 条件二是：sc == (rs &lt;&lt; 16 ) + 1，true 代表扩容完成，因为低16位是1代表没有线程扩容了                // 条件三是：sc == (rs &lt;&lt; 16) + MAX_RESIZERS，判断是否已经超过最大允许的并发扩容线程数                // 条件四：判断新表的引用是否是 null，代表扩容完成                // 条件五：【扩容是从高位到低位转移】，transferIndex &lt; 0 说明没有区间需要扩容了                if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||                    sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||                    transferIndex &lt;= 0)                    break;                                // 设置当前线程参与到扩容任务中，将 sc 低 16 位值加 1，表示多一个线程参与扩容                // 条设置失败其他线程或者 transfer 内部修改了 sizeCtl 值                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))                    //【协助扩容线程】，持有nextTable参数                    transfer(tab, nt);            &#125;            // 逻辑到这说明当前线程是触发扩容的第一个线程，线程数量 + 2            // 1000 0000 0001 1011 0000 0000 0000 0000 +2 =&gt; 1000 0000 0001 1011 0000 0000 0000 0010            else if (U.compareAndSwapInt(this, SIZECTL, sc,(rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))                //【触发扩容条件的线程】，不持有 nextTable，初始线程会新建 nextTable                transfer(tab, null);            s = sumCount();        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>resizeStamp()：扩容标识符，<strong>每次扩容都会产生一个，不是每个线程都产生</strong>，16 扩容到 32 产生一个，32 扩容到 64 产生一个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** * 扩容的标识符 * 16 -&gt; 32 从16扩容到32 * numberOfLeadingZeros(16) =&gt; 1 0000 =&gt; 32 - 5 = 27 =&gt; 0000 0000 0001 1011 * (1 &lt;&lt; (RESIZE_STAMP_BITS - 1)) =&gt; 1000 0000 0000 0000 =&gt; 32768 * --------------------------------------------------------------- * 0000 0000 0001 1011 * 1000 0000 0000 0000 * 1000 0000 0001 1011 * 永远是负数 */</span><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">resizeStamp</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;    <span class="comment">// 或运算    return Integer.numberOfLeadingZeros(n) | (1 &lt;&lt; (RESIZE_STAMP_BITS - 1)); // (16 -1 = 15)&#125;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="扩容方法"><a href="#扩容方法" class="headerlink" title="扩容方法"></a>扩容方法</h5><p>扩容机制：</p><ul><li>当链表中元素个数超过 8 个，数组的大小还未超过 64 时，此时进行数组的扩容，如果超过则将链表转化成红黑树</li><li>put 数据后调用 addCount() 方法，判断当前哈希表的容量超过阈值 sizeCtl，超过进行扩容</li><li>增删改线程发现其他线程正在扩容，帮其扩容</li></ul><p>常见方法：</p><ul><li><p>transfer()：数据转移到新表中，完成扩容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;    <span class="comment">// n 表示扩容之前 table 数组的长度    int n = tab.length, stride;    // stride 表示分配给线程任务的步长，默认就是 16     if ((stride = (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)        stride = MIN_TRANSFER_STRIDE;    // 如果当前线程为触发本次扩容的线程，需要做一些扩容准备工作，【协助线程不做这一步】    if (nextTab == null) &#123;        try &#123;            // 创建一个容量是之前【二倍的 table 数组】            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1];            nextTab = nt;        &#125; catch (Throwable ex) &#123;            sizeCtl = Integer.MAX_VALUE;            return;        &#125;        // 把新表赋值给对象属性 nextTable，方便其他线程获取新表        nextTable = nextTab;        // 记录迁移数据整体位置的一个标记，transferIndex 计数从1开始不是 0，所以这里是长度，不是长度-1        transferIndex = n;    &#125;    // 新数组的长度    int nextn = nextTab.length;    // 当某个桶位数据处理完毕后，将此桶位设置为 fwd 节点，其它写线程或读线程看到后，可以从中获取到新表    ForwardingNode&lt;K,V&gt; fwd = new ForwardingNode&lt;K,V&gt;(nextTab);    // 推进标记    boolean advance = true;    // 完成标记    boolean finishing = false;        // i 表示分配给当前线程任务，执行到的桶位    // bound 表示分配给当前线程任务的下界限制，因为是倒序迁移，16 迁移完 迁移 15，15完成去迁移14    for (int i = 0, bound = 0;;) &#123;        Node&lt;K,V&gt; f; int fh;                // 给当前线程【分配任务区间】        while (advance) &#123;            // 分配任务的开始下标，分配任务的结束下标            int nextIndex, nextBound;                     // --i 让当前线程处理下一个索引，true说明当前的迁移任务尚未完成，false说明线程已经完成或者还未分配            if (--i &gt;= bound || finishing)                advance = false;            // 迁移的开始下标，小于0说明没有区间需要迁移了，设置当前线程的 i 变量为 -1 跳出循环            else if ((nextIndex = transferIndex) &lt;= 0) &#123;                i = -1;                advance = false;            &#125;            // 逻辑到这说明还有区间需要分配，然后给当前线程分配任务，            else if (U.compareAndSwapInt(this, TRANSFERINDEX, nextIndex,                      // 判断区间是否还够一个步长，不够就全部分配                      nextBound = (nextIndex &gt; stride ? nextIndex - stride : 0))) &#123;                // 当前线程的结束下标                bound = nextBound;                // 当前线程的开始下标，上一个线程结束的下标的下一个索引就是这个线程开始的下标                i = nextIndex - 1;                // 任务分配结束，跳出循环执行迁移操作                advance = false;            &#125;        &#125;                // 【分配完成，开始数据迁移操作】        // 【CASE1】：i &lt; 0 成立表示当前线程未分配到任务，或者任务执行完了        if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn) &#123;            int sc;            // 如果迁移完成            if (finishing) &#123;                nextTable = null;// help GC                table = nextTab;// 新表赋值给当前对象                sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1);// 扩容阈值为 2n - n/2 = 3n/2 = 0.75*(2n)                return;            &#125;            // 当前线程完成了分配的任务区间，可以退出，先把 sizeCtl 赋值给 sc 保留            if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) &#123;                // 判断当前线程是不是最后一个线程，不是的话直接 return，                if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)                    return;                // 所以最后一个线程退出的时候，sizeCtl 的低 16 位为 1                finishing = advance = true;                // 【这里表示最后一个线程需要重新检查一遍是否有漏掉的区间】                i = n;            &#125;        &#125;                // 【CASE2】：当前桶位未存放数据，只需要将此处设置为 fwd 节点即可。        else if ((f = tabAt(tab, i)) == null)            advance = casTabAt(tab, i, null, fwd);        // 【CASE3】：说明当前桶位已经迁移过了，当前线程不用再处理了，直接处理下一个桶位即可        else if ((fh = f.hash) == MOVED)            advance = true;         // 【CASE4】：当前桶位有数据，而且 node 节点不是 fwd 节点，说明这些数据需要迁移        else &#123;            // 【锁住头节点】            synchronized (f) &#123;                // 二次检查，防止头节点已经被修改了，因为这里才是线程安全的访问                if (tabAt(tab, i) == f) &#123;                    // 【迁移数据的逻辑，和 HashMap 相似】                                            // ln 表示低位链表引用                    // hn 表示高位链表引用                    Node&lt;K,V&gt; ln, hn;                    // 哈希 &gt; 0 表示当前桶位是链表桶位                    if (fh &gt;= 0) &#123;                        // 和 HashMap 的处理方式一致，与老数组长度相与，16 是 10000                        // 判断对应的 1 的位置上是 0 或 1 分成高低位链表                        int runBit = fh &amp; n;                        Node&lt;K,V&gt; lastRun = f;                        // 遍历链表，寻找逆序看最长的对应位相同的链表，看下面的图更好的理解                        for (Node&lt;K,V&gt; p = f.next; p != null; p = p.next) &#123;                            // 将当前节点的哈希 与 n                            int b = p.hash &amp; n;                            // 如果当前值与前面节点的值 对应位 不同，则修改 runBit，把 lastRun 指向当前节点                            if (b != runBit) &#123;                                runBit = b;                                lastRun = p;                            &#125;                        &#125;                        // 判断筛选出的链表是低位的还是高位的                        if (runBit == 0) &#123;                            ln = lastRun;// ln 指向该链表                            hn = null;// hn 为 null                        &#125;                        // 说明 lastRun 引用的链表为高位链表，就让 hn 指向高位链表头节点                        else &#123;                            hn = lastRun;                            ln = null;                        &#125;                        // 从头开始遍历所有的链表节点，迭代到 p == lastRun 节点跳出循环                        for (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;                            int ph = p.hash; K pk = p.key; V pv = p.val;                            if ((ph &amp; n) == 0)                                // 【头插法】，从右往左看，首先 ln 指向的是上一个节点，                                // 所以这次新建的节点的 next 指向上一个节点，然后更新 ln 的引用                                ln = new Node&lt;K,V&gt;(ph, pk, pv, ln);                            else                                hn = new Node&lt;K,V&gt;(ph, pk, pv, hn);                        &#125;                        // 高低位链设置到新表中的指定位置                        setTabAt(nextTab, i, ln);                        setTabAt(nextTab, i + n, hn);                        // 老表中的该桶位设置为 fwd 节点                        setTabAt(tab, i, fwd);                        advance = true;                    &#125;                    // 条件成立：表示当前桶位是 红黑树结点                    else if (f instanceof TreeBin) &#123;                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;                        TreeNode&lt;K,V&gt; lo = null, loTail = null;                        TreeNode&lt;K,V&gt; hi = null, hiTail = null;                        int lc = 0, hc = 0;                        // 迭代 TreeBin 中的双向链表，从头结点至尾节点                        for (Node&lt;K,V&gt; e = t.first; e != null; e = e.next) &#123;                            // 迭代的当前元素的 hash                            int h = e.hash;                            TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt;                                (h, e.key, e.val, null, null);                            // 条件成立表示当前循环节点属于低位链节点                            if ((h &amp; n) == 0) &#123;                                if ((p.prev = loTail) == null)                                    lo = p;                                else                                    //【尾插法】                                    loTail.next = p;                                // loTail 指向尾节点                                loTail = p;                                ++lc;                            &#125;                            else &#123;                                if ((p.prev = hiTail) == null)                                    hi = p;                                else                                    hiTail.next = p;                                hiTail = p;                                ++hc;                            &#125;                        &#125;                        // 拆成的高位低位两个链，【判断是否需要需要转化为链表】，反之保持树化                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :                        (hc != 0) ? new TreeBin&lt;K,V&gt;(lo) : t;                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :                        (lc != 0) ? new TreeBin&lt;K,V&gt;(hi) : t;                        setTabAt(nextTab, i, ln);                        setTabAt(nextTab, i + n, hn);                        setTabAt(tab, i, fwd);                        advance = true;                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>链表处理的 LastRun 机制，<strong>可以减少节点的创建</strong></p><p><img src="https://gitee.com/seazean/images/raw/master/Java/JUC-ConcurrentHashMap-LastRun%E6%9C%BA%E5%88%B6.png"></p></li><li><p>helpTransfer()：帮助扩容机制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;    Node&lt;K,V&gt;[] nextTab; <span class="keyword">int</span> sc;    <span class="comment">// 数组不为空，节点是转发节点，获取转发节点指向的新表开始协助主线程扩容    if (tab != null &amp;&amp; (f instanceof ForwardingNode) &amp;&amp;        (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != null) &#123;        // 扩容标识戳        int rs = resizeStamp(tab.length);        // 判断数据迁移是否完成，迁移完成会把 新表赋值给 nextTable 属性        while (nextTab == nextTable &amp;&amp; table == tab &amp;&amp; (sc = sizeCtl) &lt; 0) &#123;            if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||                sc == rs + MAX_RESIZERS || transferIndex &lt;= 0)                break;            // 设置扩容线程数量 + 1            if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) &#123;                // 协助扩容                transfer(tab, nextTab);                break;            &#125;        &#125;        return nextTab;    &#125;    return table;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h5><p>ConcurrentHashMap 使用 get()  方法获取指定 key 的数据</p><ul><li><p>get()：获取指定数据的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;    <span class="comment">// 扰动运算，获取 key 的哈希值    int h = spread(key.hashCode());    // 判断当前哈希表的数组是否初始化    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;        // 如果 table 已经初始化，进行【哈希寻址】，映射到数组对应索引处，获取该索引处的头节点        (e = tabAt(tab, (n - 1) &amp; h)) != null) &#123;        // 对比头结点 hash 与查询 key 的 hash 是否一致        if ((eh = e.hash) == h) &#123;            // 进行值的判断，如果成功就说明当前节点就是要查询的节点，直接返回            if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))                return e.val;        &#125;        // 当前槽位的【哈希值小于0】说明是红黑树节点或者是正在扩容的 fwd 节点        else if (eh &lt; 0)            return (p = e.find(h, key)) != null ? p.val : null;        // 当前桶位是【链表】，循环遍历查找        while ((e = e.next) != null) &#123;            if (e.hash == h &amp;&amp;                ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))))                return e.val;        &#125;    &#125;    return null;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>ForwardingNode#find：转移节点的查找方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;    <span class="comment">// 获取新表的引用    outer: for (Node&lt;K,V&gt;[] tab = nextTable;;)  &#123;        // e 表示在扩容而创建新表使用寻址算法得到的桶位头结点，n 表示为扩容而创建的新表的长度        Node&lt;K,V&gt; e; int n;         if (k == null || tab == null || (n = tab.length) == 0 ||            // 在新表中重新定位 hash 对应的头结点，表示在 oldTable 中对应的桶位在迁移之前就是 null            (e = tabAt(tab, (n - 1) &amp; h)) == null)            return null;        for (;;) &#123;            int eh; K ek;            // 【哈希相同值也相同】，表示新表当前命中桶位中的数据，即为查询想要数据            if ((eh = e.hash) == h &amp;&amp; ((ek = e.key) == k || (ek != null &amp;&amp; k.equals(ek))))                return e;            // eh &lt; 0 说明当前新表中该索引的头节点是 TreeBin 类型，或者是 FWD 类型            if (eh &lt; 0) &#123;                // 在并发很大的情况下新扩容的表还没完成可能【再次扩容】，在此方法处再次拿到 FWD 类型                if (e instanceof ForwardingNode) &#123;                    // 继续获取新的 fwd 指向的新数组的地址，递归了                    tab = ((ForwardingNode&lt;K,V&gt;)e).nextTable;                    continue outer;                &#125;                else                    // 说明此桶位为 TreeBin 节点，使用TreeBin.find 查找红黑树中相应节点。                    return e.find(h, k);            &#125;            // 逻辑到这说明当前桶位是链表，将当前元素指向链表的下一个元素，判断当前元素的下一个位置是否为空            if ((e = e.next) == null)                // 条件成立说明迭代到链表末尾，【未找到对应的数据，返回 null】                return null;        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="删除方法"><a href="#删除方法" class="headerlink" title="删除方法"></a>删除方法</h5><ul><li><p>remove()：删除指定元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;    <span class="keyword">return</span> replaceNode(key, <span class="keyword">null</span>, <span class="keyword">null</span>);&#125;</span><br></pre></td></tr></table></figure></li><li><p>replaceNode()：替代指定的元素，会协助扩容，<strong>增删改（写）都会协助扩容，只有查询（读）操作不会</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">replaceNode</span><span class="params">(Object key, V value, Object cv)</span> </span>&#123;    <span class="comment">// 计算 key 扰动运算后的 hash    int hash = spread(key.hashCode());    // 开始自旋    for (Node&lt;K,V&gt;[] tab = table;;) &#123;        Node&lt;K,V&gt; f; int n, i, fh;                // 【CASE1】：table 还未初始化或者哈希寻址的数组索引处为 null，直接结束自旋，返回 null        if (tab == null || (n = tab.length) == 0 || (f = tabAt(tab, i = (n - 1) &amp; hash)) == null)            break;        // 【CASE2】：条件成立说明当前 table 正在扩容，【当前是个写操作，所以当前线程需要协助 table 完成扩容】        else if ((fh = f.hash) == MOVED)            tab = helpTransfer(tab, f);        // 【CASE3】：当前桶位可能是 链表 也可能是 红黑树         else &#123;            // 保留替换之前数据引用            V oldVal = null;            // 校验标记            boolean validated = false;            // 【加锁当前桶位头结点】，加锁成功之后会进入代码块            synchronized (f) &#123;                // 双重检查                if (tabAt(tab, i) == f) &#123;                    // 说明当前节点是链表节点                    if (fh &gt;= 0) &#123;                        validated = true;                        //遍历所有的节点                        for (Node&lt;K,V&gt; e = f, pred = null;;) &#123;                            K ek;                            // hash 和值都相同，定位到了具体的节点                            if (e.hash == hash &amp;&amp;                                ((ek = e.key) == key ||                                 (ek != null &amp;&amp; key.equals(ek)))) &#123;                                // 当前节点的value                                V ev = e.val;                                if (cv == null || cv == ev ||                                    (ev != null &amp;&amp; cv.equals(ev))) &#123;                                    // 将当前节点的值 赋值给 oldVal 后续返回会用到                                    oldVal = ev;                                    if (value != null)// 条件成立说明是替换操作                                        e.val = value;                                    else if (pred != null)// 非头节点删除操作，断开链表                                        pred.next = e.next;                                    else                                        // 说明当前节点即为头结点，将桶位头节点设置为以前头节点的下一个节点                                        setTabAt(tab, i, e.next);                                &#125;                                break;                            &#125;                            pred = e;                            if ((e = e.next) == null)                                break;                        &#125;                    &#125;                    // 说明是红黑树节点                    else if (f instanceof TreeBin) &#123;                        validated = true;                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;                        TreeNode&lt;K,V&gt; r, p;                        if ((r = t.root) != null &amp;&amp;                            (p = r.findTreeNode(hash, key, null)) != null) &#123;                            V pv = p.val;                            if (cv == null || cv == pv ||                                (pv != null &amp;&amp; cv.equals(pv))) &#123;                                oldVal = pv;                                // 条件成立说明替换操作                                if (value != null)                                    p.val = value;                                // 删除操作                                else if (t.removeTreeNode(p))                                    setTabAt(tab, i, untreeify(t.first));                            &#125;                        &#125;                    &#125;                &#125;            &#125;            // 其他线程修改过桶位头结点时，当前线程 sync 头结点锁错对象，validated 为 false，会进入下次 for 自旋            if (validated) &#123;                if (oldVal != null) &#123;                    // 替换的值为 null，【说明当前是一次删除操作，更新当前元素个数计数器】                    if (value == null)                        addCount(-1L, -1);                    return oldVal;                &#125;                break;            &#125;        &#125;    &#125;    return null;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><p>参考视频：<a href="https://space.bilibili.com/457326371/">https://space.bilibili.com/457326371/</a></p><hr><h4 id="JDK7原理"><a href="#JDK7原理" class="headerlink" title="JDK7原理"></a>JDK7原理</h4><p>ConcurrentHashMap 对锁粒度进行了优化，<strong>分段锁技术</strong>，将整张表分成了多个数组（Segment），每个数组又是一个类似 HashMap 数组的结构。允许多个修改操作并发进行，Segment 是一种可重入锁，继承 ReentrantLock，并发时锁住的是每个 Segment，其他 Segment 还是可以操作的，这样不同 Segment 之间就可以实现并发，大大提高效率。</p><p>底层结构： <strong>Segment 数组 + HashEntry 数组 + 链表</strong>（数组 + 链表是 HashMap 的结构）</p><ul><li><p>优点：如果多个线程访问不同的 segment，实际是没有冲突的，这与 JDK8 中是类似的</p></li><li><p>缺点：Segments 数组默认大小为16，这个容量初始化指定后就不能改变了，并且不是懒惰初始化</p><p>![](<a href="https://gitee.com/seazean/images/raw/master/Java/JUC-ConcurrentHashMap">https://gitee.com/seazean/images/raw/master/Java/JUC-ConcurrentHashMap</a> 1.7底层结构.png)</p></li></ul><hr><h3 id="CopyOnWrite"><a href="#CopyOnWrite" class="headerlink" title="CopyOnWrite"></a>CopyOnWrite</h3><h4 id="原理分析-1"><a href="#原理分析-1" class="headerlink" title="原理分析"></a>原理分析</h4><p>CopyOnWriteArrayList 采用了<strong>写入时拷贝</strong>的思想，增删改操作会将底层数组拷贝一份，在新数组上执行操作，不影响其它线程的<strong>并发读，读写分离</strong></p><p>CopyOnWriteArraySet 底层对 CopyOnWriteArrayList 进行了包装，装饰器模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArraySet</span><span class="params">()</span> </span>&#123;    al = <span class="keyword">new</span> CopyOnWriteArrayList&lt;E&gt;();&#125;</span><br></pre></td></tr></table></figure><ul><li><p>存储结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;<span class="comment">// 保证了读写线程之间的可见性</span></span><br></pre></td></tr></table></figure></li><li><p>全局锁：保证线程的执行安全</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br></pre></td></tr></table></figure></li><li><p>新增数据：需要加锁，<strong>创建新的数组操作</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;    <span class="comment">// 加锁，保证线程安全    lock.lock();    try &#123;        // 获取旧的数组        Object[] elements = getArray();        int len = elements.length;        // 【拷贝新的数组（这里是比较耗时的操作，但不影响其它读线程）】        Object[] newElements = Arrays.copyOf(elements, len + 1);        // 添加新元素        newElements[len] = e;        // 替换旧的数组，【这个操作以后，其他线程获取数组就是获取的新数组了】        setArray(newElements);        return true;    &#125; finally &#123;        lock.unlock();    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>读操作：不加锁，<strong>在原数组上操作</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;    <span class="keyword">return</span> get(getArray(), index);&#125;<span class="function"><span class="keyword">private</span> E <span class="title">get</span><span class="params">(Object[] a, <span class="keyword">int</span> index)</span> </span>&#123;    <span class="keyword">return</span> (E) a[index];&#125;</span><br></pre></td></tr></table></figure><p>适合读多写少的应用场景</p></li><li><p>迭代器：CopyOnWriteArrayList 在返回迭代器时，<strong>创建一个该内部数组当前的快照（引用）</strong>，即使其他线程替换了原始数组，迭代器遍历的快照依然引用的是创建快照时的数组，所以这种实现方式也存在一定的数据延迟性，对其他线程并行添加的数据不可见</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;    <span class="comment">// 获取到数组引用，整个遍历的过程该数组都不会变，一直引用的都是老数组，    return new COWIterator&lt;E&gt;(getArray(), 0);&#125;// 迭代器会创建一个底层array的快照，故主类的修改不影响该快照static final class COWIterator&lt;E&gt; implements ListIterator&lt;E&gt; &#123;    // 内部数组快照    private final Object[] snapshot;    private COWIterator(Object[] elements, int initialCursor) &#123;        cursor = initialCursor;        // 数组的引用在迭代过程不会改变        snapshot = elements;    &#125;    // 【不支持写操作】，因为是在快照上操作，无法同步回去    public void remove() &#123;        throw new UnsupportedOperationException();    &#125; &#125;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="弱一致性"><a href="#弱一致性" class="headerlink" title="弱一致性"></a>弱一致性</h4><p>数据一致性就是读到最新更新的数据：</p><ul><li><p>强一致性：当更新操作完成之后，任何多个后续进程或者线程的访问都会返回最新的更新过的值</p></li><li><p>弱一致性：系统并不保证进程或者线程的访问都会返回最新的更新过的值，也不会承诺多久之后可以读到</p></li></ul><img src="https://gitee.com/seazean/images/raw/master/Java/JUC-CopyOnWriteArrayList弱一致性.png" style="zoom:80%;"><table><thead><tr><th>时间点</th><th>操作</th></tr></thead><tbody><tr><td>1</td><td>Thread-0 getArray()</td></tr><tr><td>2</td><td>Thread-1 getArray()</td></tr><tr><td>3</td><td>Thread-1 setArray(arrayCopy)</td></tr><tr><td>4</td><td>Thread-0 array[index]</td></tr></tbody></table><p>Thread-0 读到了脏数据</p><p>不一定弱一致性就不好</p><ul><li>数据库的<strong>事务隔离级别</strong>就是弱一致性的表现</li><li>并发高和一致性是矛盾的，需要权衡</li></ul><hr><h4 id="安全失败"><a href="#安全失败" class="headerlink" title="安全失败"></a>安全失败</h4><p>在 java.util 包的集合类就都是快速失败的，而 java.util.concurrent 包下的类都是安全失败</p><ul><li><p>快速失败：在 A 线程使用<strong>迭代器</strong>对集合进行遍历的过程中，此时 B 线程对集合进行修改（增删改），或者 A 线程在遍历过程中对集合进行修改，都会导致 A 线程抛出 ConcurrentModificationException 异常</p><ul><li>AbstractList 类中的成员变量 modCount，用来记录 List 结构发生变化的次数，<strong>结构发生变化</strong>是指添加或者删除至少一个元素的操作，或者是调整内部数组的大小，仅仅设置元素的值不算结构发生变化</li><li>在进行序列化或者迭代等操作时，需要比较操作前后 modCount 是否改变，如果改变了抛出 CME 异常</li></ul></li><li><p>安全失败：采用安全失败机制的集合容器，在<strong>迭代器</strong>遍历时直接在原集合数组内容上访问，但其他线程的增删改都会新建数组进行修改，就算修改了集合底层的数组容器，迭代器依然引用着以前的数组（快照思想），所以不会出现异常</p><p>ConcurrentHashMap 不会出现并发时的迭代异常，因为在迭代过程中 CHM 的迭代器并没有判断结构的变化，迭代器还可以根据迭代的节点状态去寻找并发扩容时的新表进行迭代</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentHashMap map = <span class="keyword">new</span> ConcurrentHashMap();<span class="comment">// KeyIteratorIterator iterator = map.keySet().iterator();</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Traverser(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> size, <span class="keyword">int</span> index, <span class="keyword">int</span> limit) &#123;     <span class="comment">// 引用还是原来集合的 Node 数组，所以其他线程对数据的修改是可见的     this.tab = tab;     this.baseSize = size;     this.baseIndex = this.index = index;     this.baseLimit = limit;     this.next = null; &#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> next != <span class="keyword">null</span>; &#125;<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">next</span><span class="params">()</span> </span>&#123;    Node&lt;K,V&gt; p;    <span class="keyword">if</span> ((p = next) == <span class="keyword">null</span>)        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();    K k = p.key;    lastReturned = p;    <span class="comment">// 在方法中进行下一个节点的获取，会进行槽位头节点的状态判断    advance();    return k;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h3><p>Collections类是用来操作集合的工具类，提供了集合转换成线程安全的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Collection&lt;T&gt; <span class="title">synchronizedCollection</span><span class="params">(Collection&lt;T&gt; c)</span> </span>&#123;     <span class="keyword">return</span> <span class="keyword">new</span> SynchronizedCollection&lt;&gt;(c); &#125;<span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; <span class="function">Map&lt;K,V&gt; <span class="title">synchronizedMap</span><span class="params">(Map&lt;K,V&gt; m)</span> </span>&#123;    <span class="keyword">return</span> <span class="keyword">new</span> SynchronizedMap&lt;&gt;(m);&#125;</span><br></pre></td></tr></table></figure><p>源码：底层也是对方法进行加锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;    <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> c.add(e);&#125;&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="SkipListMap"><a href="#SkipListMap" class="headerlink" title="SkipListMap"></a>SkipListMap</h3><h4 id="底层结构-1"><a href="#底层结构-1" class="headerlink" title="底层结构"></a>底层结构</h4><p>跳表 SkipList 是一个<strong>有序的链表</strong>，默认升序，底层是链表加多级索引的结构。跳表可以对元素进行快速查询，类似于平衡树，是一种利用空间换时间的算法</p><p>对于单链表，即使链表是有序的，如果查找数据也只能从头到尾遍历链表，所以采用链表上建索引的方式提高效率，跳表的查询时间复杂度是 **O(logn)**，空间复杂度 O(n)</p><p>ConcurrentSkipListMap 提供了一种线程安全的并发访问的排序映射表，内部是跳表结构实现，通过 CAS + volatile 保证线程安全</p><p>平衡树和跳表的区别：</p><ul><li>对平衡树的插入和删除往往很可能导致平衡树进行一次全局的调整；而对跳表的插入和删除，<strong>只需要对整个结构的局部进行操作</strong></li><li>在高并发的情况下，保证整个平衡树的线程安全需要一个全局锁；对于跳表则只需要部分锁，拥有更好的性能</li></ul><p><img src="https://gitee.com/seazean/images/raw/master/Java/JUC-ConcurrentSkipListMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png"></p><p>BaseHeader 存储数据，headIndex 存储索引，纵向上<strong>所有索引都指向链表最下面的节点</strong></p><hr><h4 id="成员变量-2"><a href="#成员变量-2" class="headerlink" title="成员变量"></a>成员变量</h4><ul><li><p>标识索引头节点位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object BASE_HEADER = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure></li><li><p>跳表的顶层索引</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> HeadIndex&lt;K,V&gt; head;</span><br></pre></td></tr></table></figure></li><li><p>比较器，为 null 则使用自然排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> K&gt; comparator;</span><br></pre></td></tr></table></figure></li><li><p>Node 节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;</span>&#123;    <span class="keyword">final</span> K key;  <span class="comment">// key 是 final 的, 说明节点一旦定下来, 除了删除, 一般不会改动 key    volatile Object value; // 对应的 value    volatile Node&lt;K, V&gt; next; // 下一个节点，单向链表&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>索引节点 Index，只有向下和向右的指针</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Index</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;</span>&#123;    <span class="keyword">final</span> Node&lt;K, V&gt; node; <span class="comment">// 索引指向的节点，每个都会指向数据节点    final Index&lt;K, V&gt; down; // 下边level层的Index，分层索引    volatile Index&lt;K, V&gt; right; // 右边的Index    // 在 index 本身和 succ 之间插入一个新的节点 newSucc    final boolean link(Index&lt;K, V&gt; succ, Index&lt;K, V&gt; newSucc)&#123;        Node&lt;K, V&gt; n = node;        newSucc.right = succ;        // 把当前节点的右指针从 succ 改为 newSucc        return n.value != null &amp;&amp; casRight(succ, newSucc);    &#125;    // 断开当前节点和 succ 节点，将当前的节点 index 设置其的 right 为 succ.right，就是把 succ 删除    final boolean unlink(Index&lt;K, V&gt; succ)&#123;        return node.value != null &amp;&amp; casRight(succ, succ.right);    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>头索引节点 HeadIndex</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HeadIndex</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Index</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;    <span class="keyword">final</span> <span class="keyword">int</span> level;<span class="comment">// 表示索引层级，所有的 HeadIndex 都指向同一个 Base_header 节点    HeadIndex(Node&lt;K,V&gt; node, Index&lt;K,V&gt; down, Index&lt;K,V&gt; right, int level) &#123;        super(node, down, right);        this.level = level;    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="成员方法-7"><a href="#成员方法-7" class="headerlink" title="成员方法"></a>成员方法</h4><h5 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h5><ul><li><p>构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentSkipListMap</span><span class="params">()</span> </span>&#123;    <span class="keyword">this</span>.comparator = <span class="keyword">null</span>;<span class="comment">// comparator 为 null，使用 key 的自然序，如字典序    initialize();&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;    keySet = <span class="keyword">null</span>;    entrySet = <span class="keyword">null</span>;    values = <span class="keyword">null</span>;    descendingMap = <span class="keyword">null</span>;    <span class="comment">// 初始化索引头节点，Node 的 key 为 null，value 为 BASE_HEADER 对象，下一个节点为 null    // head 的分层索引 down 为 null，链表的后续索引 right 为 null，层级 level 为第 1 层    head = new HeadIndex&lt;K,V&gt;(new Node&lt;K,V&gt;(null, BASE_HEADER, null), null, null, 1);&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>cpr：排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//　x 是比较者，y 是被比较者，比较者大于被比较者 返回正数，小于返回负数，相等返回 0static final int cpr(Comparator c, Object x, Object y) &#123;    return (c != null) ? c.compare(x, y) : ((Comparable)x).compareTo(y);&#125;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="添加方法-1"><a href="#添加方法-1" class="headerlink" title="添加方法"></a>添加方法</h5><ul><li><p>findPredecessor()：寻找前置节点</p><p>从最上层的头索引开始向右查找（链表的后续索引），如果后续索引的节点的 key 大于要查找的 key，则头索引移到下层链表，在下层链表查找，以此反复，一直查找到没有下层的分层索引为止，返回该索引的节点。如果后续索引的节点的 key 小于要查找的 key，则在该层链表中向后查找。由于查找的 key 可能永远大于索引节点的 key，所以只能找到目标的前置索引节点。如果遇到空值索引的存在，通过 CAS 来断开索引</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;K,V&gt; <span class="title">findPredecessor</span><span class="params">(Object key, Comparator&lt;? <span class="keyword">super</span> K&gt; cmp)</span> </span>&#123;    <span class="keyword">if</span> (key == <span class="keyword">null</span>)        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(); <span class="comment">// don&#x27;t postpone errors    for (;;) &#123;        // 1.初始数据 q 是 head，r 是最顶层 h 的右 Index 节点        for (Index&lt;K,V&gt; q = head, r = q.right, d;;) &#123;            // 2.右索引节点不为空，则进行向下查找            if (r != null) &#123;                Node&lt;K,V&gt; n = r.node;                K k = n.key;                // 3.n.value 为 null 说明节点 n 正在删除的过程中，此时【当前线程帮其删除索引】                if (n.value == null) &#123;                    // 在 index 层直接删除 r 索引节点                    if (!q.unlink(r))                        // 删除失败重新从 head 节点开始查找，break 一个 for 到步骤 1，又从初始值开始                        break;                                        // 删除节点 r 成功，获取新的 r 节点,                    r = q.right;                    // 回到步骤 2，还是从这层索引开始向右遍历                    continue;                &#125;                // 4.若参数 key &gt; r.node.key，则继续向右遍历, continue 到步骤 2 处获取右节点                //   若参数 key &lt; r.node.key，说明需要进入下层索引，到步骤 5                if (cpr(cmp, key, k) &gt; 0) &#123;                    q = r;                    r = r.right;                    continue;                &#125;            &#125;            // 5.先让 d 指向 q 的下一层，判断是否是 null，是则说明已经到了数据层，也就是第一层            if ((d = q.down) == null)                 return q.node;            // 6.未到数据层, 进行重新赋值向下扫描            q = d;// q 指向 d            r = d.right;// r 指向 q 的后续索引节点，此时(q.key &lt; key &lt; r.key)        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/seazean/images/raw/master/Java/JUC-ConcurrentSkipListMap-Put%E6%B5%81%E7%A8%8B.png"></p></li><li><p>put()：添加数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;    <span class="comment">// 非空判断，value不能为空    if (value == null)        throw new NullPointerException();    return doPut(key, value, false);&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">doPut</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;    Node&lt;K,V&gt; z;    <span class="comment">// 非空判断，key 不能为空    if (key == null)        throw new NullPointerException();    Comparator&lt;? super K&gt; cmp = comparator;    // outer 循环，【把待插入数据插入到数据层的合适的位置，并在扫描过程中处理已删除(value = null)的数据】    outer: for (;;) &#123;        //0.for (;;)        //1.将 key 对应的前继节点找到, b 为前继节点，是数据层的, n 是前继节点的 next, //  若没发生条件竞争，最终 key 在 b 与 n 之间 (找到的 b 在 base_level 上)        for (Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) &#123;            // 2.n 不为 null 说明 b 不是链表的最后一个节点            if (n != null) &#123;                Object v; int c;                // 3.获取 n 的右节点                Node&lt;K,V&gt; f = n.next;                // 4.条件竞争，并发下其他线程在 b 之后插入节点或直接删除节点 n, break 到步骤 0                if (n != b.next)                                  break;                //  若节点 n 已经删除, 则调用 helpDelete 进行【帮助删除节点】                if ((v = n.value) == null) &#123;                    n.helpDelete(b, f);                    break;                &#125;                // 5.节点 b 被删除中，则 break 到步骤 0,//  【调用findPredecessor帮助删除index层的数据, node层的数据会通过helpDelete方法进行删除】                if (b.value == null || v == n)                     break;                // 6.若 key &gt; n.key，则进行向后扫描                //   若 key &lt; n.key，则证明 key 应该存储在 b 和 n 之间                if ((c = cpr(cmp, key, n.key)) &gt; 0) &#123;                    b = n;                    n = f;                    continue;                &#125;                // 7.key 的值和 n.key 相等，则可以直接覆盖赋值                if (c == 0) &#123;                    // onlyIfAbsent 默认 false，                    if (onlyIfAbsent || n.casValue(v, value)) &#123;                        @SuppressWarnings(&quot;unchecked&quot;) V vv = (V)v;                        // 返回被覆盖的值                        return vv;                    &#125;                    // cas失败，break 一层循环，返回 0 重试                    break;                &#125;                // else c &lt; 0; fall through            &#125;            // 8.此时的情况 n.key &gt; key &gt; b.key，对应流程图1中的7，创建z节点指向n            z = new Node&lt;K,V&gt;(key, value, n);            // 9.尝试把 b.next 从 n 设置成 z            if (!b.casNext(n, z))                // cas失败，返回到步骤0，重试                break;            // 10.break outer 后, 上面的 for 循环不会再执行, 而后执行下面的代码            break outer;        &#125;    &#125;// 【以上插入节点已经完成，剩下的任务要根据随机数的值来表示是否向上增加层数与上层索引】        // 随机数    int rnd = ThreadLocalRandom.nextSecondarySeed();        // 如果随机数的二进制与 10000000000000000000000000000001 进行与运算为 0    // 即随机数的二进制最高位与最末尾必须为 0，其他位无所谓，就进入该循环    // 如果随机数的二进制最高位与最末位不为 0，不增加新节点的层数        // 11.判断是否需要添加 level，32 位    if ((rnd &amp; 0x80000001) == 0) &#123;        // 索引层 level，从 1 开始，就是最底层        int level = 1, max;        // 12.判断最低位前面有几个 1，有几个leve就加几：0..0 0001 1110，这是4个，则1+4=5        //    【最大有30个就是 1 + 30 = 31        while (((rnd &gt;&gt;&gt;= 1) &amp; 1) != 0)            ++level;        // 最终会指向 z 节点，就是添加的节点         Index&lt;K,V&gt; idx = null;        // 指向头索引节点        HeadIndex&lt;K,V&gt; h = head;                // 13.判断level是否比当前最高索引小，图中 max 为 3        if (level &lt;= (max = h.level)) &#123;            for (int i = 1; i &lt;= level; ++i)                // 根据层数level不断创建新增节点的上层索引，索引的后继索引留空                // 第一次idx为null，也就是下层索引为空，第二次把上次的索引作为下层索引，【类似头插法】                idx = new Index&lt;K,V&gt;(z, idx, null);            // 循环以后的索引结构            // index-3← idx            //   ↓            // index-2            //   ↓            // index-1            //   ↓            //  z-node        &#125;        // 14.若 level &gt; max，则【只增加一层 index 索引层】，3 + 1 = 5        else &#123;             level = max + 1;            //创建一个 index 数组，长度是 level+1，假设 level 是 4，创建的数组长度为 5            Index&lt;K,V&gt;[] idxs = (Index&lt;K,V&gt;[])new Index&lt;?,?&gt;[level+1];            // index[0]的数组 slot 并没有使用，只使用 [1,level] 这些数组的 slot            for (int i = 1; i &lt;= level; ++i)                idxs[i] = idx = new Index&lt;K,V&gt;(z, idx, null);              // index-4   ← idx                    //   ↓                  // ......                    //   ↓                    // index-1                    //   ↓                    //  z-node                        for (;;) &#123;                h = head;                // 获取头索引的层数                int oldLevel = h.level;                // 如果 level &lt;= oldLevel，说明其他线程进行了 index 层增加操作，退出循环                if (level &lt;= oldLevel)                    break;                // 定义一个新的头索引节点                HeadIndex&lt;K,V&gt; newh = h;                // 获取头索引的节点，就是 BASE_HEADER                Node&lt;K,V&gt; oldbase = h.node;                // 升级 baseHeader 索引，升高一级，并发下可能升高多级                for (int j = oldLevel + 1; j &lt;= level; ++j)                    newh = new HeadIndex&lt;K,V&gt;(oldbase, newh, idxs[j], j);                // 执行完for循环之后，baseHeader 索引长这个样子，这里只升高一级                // index-4             →             index-4← idx                //   ↓                                  ↓                // index-3                           index-3                     //   ↓                                  ↓                // index-2                           index-2                //   ↓                                  ↓                // index-1                           index-1                //   ↓                                  ↓                // baseHeader    →    ....      →     z-node                                // cas 成功后，map.head 字段指向最新的 headIndex，baseHeader 的 index-4                if (casHead(h, newh)) &#123;                    // h 指向最新的 index-4 节点                    h = newh;                    // 让 idx 指向 z-node 的 index-3 节点，// 因为从 index-3 - index-1 的这些 z-node 索引节点 都没有插入到索引链表                    idx = idxs[level = oldLevel];                    break;                &#125;            &#125;        &#125;        // 15.【把新加的索引插入索引链表中】，有上述两种情况，一种索引高度不变，另一种是高度加 1        // 要插入的是第几层的索引        splice: for (int insertionLevel = level;;) &#123;            // 获取头索引的层数，情况 1 是 3，情况 2 是 4            int j = h.level;            // 【遍历 insertionLevel 层的索引，找到合适的插入位置】            for (Index&lt;K,V&gt; q = h, r = q.right, t = idx;;) &#123;                // 如果头索引为 null 或者新增节点索引为 null，退出插入索引的总循环                if (q == null || t == null)                    // 此处表示有其他线程删除了头索引或者新增节点的索引                    break splice;                // 头索引的链表后续索引存在，如果是新层则为新节点索引，如果是老层则为原索引                if (r != null) &#123;                    // 获取r的节点                    Node&lt;K,V&gt; n = r.node;                    // 插入的key和n.key的比较值                    int c = cpr(cmp, key, n.key);                    // 【删除空值索引】                    if (n.value == null) &#123;                        if (!q.unlink(r))                            break;                        r = q.right;                        continue;                    &#125;                    // key &gt; r.node.key，向右扫描                    if (c &gt; 0) &#123;                        q = r;                        r = r.right;                        continue;                    &#125;                &#125;                // 执行到这里，说明 key &lt; r.node.key，判断是否是第 j 层插入新增节点的前置索引                if (j == insertionLevel) &#123;                    // 【将新索引节点 t 插入 q r 之间】                    if (!q.link(r, t))                        break;                     // 如果新增节点的值为 null，表示该节点已经被其他线程删除                    if (t.node.value == null) &#123;                        // 找到该节点                        findNode(key);                        break splice;                    &#125;                    // 插入层逐层自减，当为最底层时退出循环                    if (--insertionLevel == 0)                        break splice;                &#125;// 其他节点随着插入节点的层数下移而下移                if (--j &gt;= insertionLevel &amp;&amp; j &lt; level)                    t = t.down;                q = q.down;                r = q.right;            &#125;        &#125;    &#125;    return null;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>findNode()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;K,V&gt; <span class="title">findNode</span><span class="params">(Object key)</span> </span>&#123;    <span class="comment">// 原理与doGet相同，无非是 findNode 返回节点，doGet 返回 value    if ((c = cpr(cmp, key, n.key)) == 0)        return n;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="获取方法-1"><a href="#获取方法-1" class="headerlink" title="获取方法"></a>获取方法</h5><ul><li><p>get(key)：获取对应的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;    <span class="keyword">return</span> doGet(key);&#125;</span><br></pre></td></tr></table></figure></li><li><p>doGet()：扫描过程会对已 value = null 的元素进行删除处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">doGet</span><span class="params">(Object key)</span> </span>&#123;    <span class="keyword">if</span> (key == <span class="keyword">null</span>)        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();    Comparator&lt;? <span class="keyword">super</span> K&gt; cmp = comparator;    outer: <span class="keyword">for</span> (;;) &#123;        <span class="comment">// 1.找到最底层节点的前置节点        for (Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) &#123;            Object v; int c;            // 2.【如果该前置节点的链表后续节点为 null，说明不存在该节点】            if (n == null)                break outer;            // b → n → f            Node&lt;K,V&gt; f = n.next;            // 3.如果n不为前置节点的后续节点，表示已经有其他线程删除了该节点            if (n != b.next)                 break;            // 4.如果后续节点的值为null，【需要帮助删除该节点】            if ((v = n.value) == null) &#123;                n.helpDelete(b, f);                break;            &#125;            // 5.如果前置节点已被其他线程删除，重新循环            if (b.value == null || v == n)                break;             // 6.如果要获取的key与后续节点的key相等，返回节点的value            if ((c = cpr(cmp, key, n.key)) == 0) &#123;                @SuppressWarnings(&quot;unchecked&quot;) V vv = (V)v;                return vv;            &#125;            // 7.key &lt; n.key，因位 key &gt; b.key，b 和 n 相连，说明不存在该节点或者被其他线程删除了            if (c &lt; 0)                break outer;            b = n;            n = f;        &#125;    &#125;    return null;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="删除方法-1"><a href="#删除方法-1" class="headerlink" title="删除方法"></a>删除方法</h5><ul><li><p>remove()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;    <span class="keyword">return</span> doRemove(key, <span class="keyword">null</span>);&#125;<span class="function"><span class="keyword">final</span> V <span class="title">doRemove</span><span class="params">(Object key, Object value)</span> </span>&#123;    <span class="keyword">if</span> (key == <span class="keyword">null</span>)        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();    Comparator&lt;? <span class="keyword">super</span> K&gt; cmp = comparator;    outer: <span class="keyword">for</span> (;;) &#123;        <span class="comment">// 1.找到最底层目标节点的前置节点，b.key &lt; key        for (Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) &#123;            Object v; int c;            // 2.如果该前置节点的链表后续节点为 null，退出循环，说明不存在这个元素            if (n == null)                break outer;            // b → n → f            Node&lt;K,V&gt; f = n.next;            if (n != b.next)                    // inconsistent read                break;            if ((v = n.value) == null) &#123;        // n is deleted                n.helpDelete(b, f);                break;            &#125;            if (b.value == null || v == n)      // b is deleted                break;            //3.key &lt; n.key，说明被其他线程删除了，或者不存在该节点            if ((c = cpr(cmp, key, n.key)) &lt; 0)                break outer;            //4.key &gt; n.key，继续向后扫描            if (c &gt; 0) &#123;                b = n;                n = f;                continue;            &#125;            //5.到这里是 key = n.key，value 不为空的情况下判断 value 和 n.value 是否相等            if (value != null &amp;&amp; !value.equals(v))                break outer;            //6.【把 n 节点的 value 置空】            if (!n.casValue(v, null))                break;            //7.【给 n 添加一个删除标志 mark】，mark.next = f，然后把 b.next 设置为 f，成功后n出队            if (!n.appendMarker(f) || !b.casNext(n, f))                // 对 key 对应的 index 进行删除，调用了 findPredecessor 方法                findNode(key);            else &#123;                // 进行操作失败后通过 findPredecessor 中进行 index 的删除                findPredecessor(key, cmp);                if (head.right == null)                    // 进行headIndex 对应的index 层的删除                    tryReduceLevel();            &#125;            @SuppressWarnings(&quot;unchecked&quot;) V vv = (V)v;            return vv;        &#125;    &#125;    return null;&#125;</span></span><br></pre></td></tr></table></figure><p>经过 findPredecessor() 中的 unlink() 后索引已经被删除</p><p><img src="https://gitee.com/seazean/images/raw/master/Java/JUC-ConcurrentSkipListMap-remove%E6%B5%81%E7%A8%8B.png"></p></li><li><p>appendMarker()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加删除标记节点boolean appendMarker(Node&lt;K,V&gt; f) &#123;    // 通过 CAS 让 n.next 指向一个 key 为 null，value 为 this，next 为 f 的标记节点    return casNext(f, new Node&lt;K,V&gt;(f));&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>helpDelete()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将添加了删除标记的节点清除，参数是该节点的前驱和后继节点void helpDelete(Node&lt;K,V&gt; b, Node&lt;K,V&gt; f) &#123;    // this 节点的后续节点为 f，且本身为 b 的后续节点，一般都是正确的，除非被别的线程删除    // b     if (f == next &amp;&amp; this == b.next) &#123;        // 如果 n 还还没有被标记        if (f == null || f.value != f)             casNext(f, new Node&lt;K,V&gt;(f));        else            // 通过 CAS，将 b 的下一个节点 n 变成 f.next，即成为图中的样式            b.casNext(this, f.next);    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>tryReduceLevel()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">tryReduceLevel</span><span class="params">()</span> </span>&#123;    HeadIndex&lt;K,V&gt; h = head;    HeadIndex&lt;K,V&gt; d;    HeadIndex&lt;K,V&gt; e;    <span class="keyword">if</span> (h.level &gt; <span class="number">3</span> &amp;&amp;        (d = (HeadIndex&lt;K,V&gt;)h.down) != <span class="keyword">null</span> &amp;&amp;        (e = (HeadIndex&lt;K,V&gt;)d.down) != <span class="keyword">null</span> &amp;&amp;        e.right == <span class="keyword">null</span> &amp;&amp;        d.right == <span class="keyword">null</span> &amp;&amp;        h.right == <span class="keyword">null</span> &amp;&amp;        <span class="comment">//设置头索引        casHead(h, d) &amp;&amp;         // 重新检查        h.right != null)         // 重新检查返回true，说明其他线程增加了索引层级，把索引头节点设置回来        casHead(d, h);   &#125;</span></span><br></pre></td></tr></table></figure></li></ul><p>参考文章：<a href="https://my.oschina.net/u/3768341/blog/3135659">https://my.oschina.net/u/3768341/blog/3135659</a></p><p>参考视频：<a href="https://www.bilibili.com/video/BV1Er4y1P7k1">https://www.bilibili.com/video/BV1Er4y1P7k1</a></p><hr><h3 id="NoBlocking"><a href="#NoBlocking" class="headerlink" title="NoBlocking"></a>NoBlocking</h3><h4 id="非阻塞队列"><a href="#非阻塞队列" class="headerlink" title="非阻塞队列"></a>非阻塞队列</h4><p>并发编程中，需要用到安全的队列，实现安全队列可以使用 2 种方式：</p><ul><li>加锁，这种实现方式是阻塞队列</li><li>使用循环 CAS 算法实现，这种方式是非阻塞队列</li></ul><p>ConcurrentLinkedQueue 是一个基于链接节点的无界线程安全队列，采用先进先出的规则对节点进行排序，当添加一个元素时，会添加到队列的尾部，当获取一个元素时，会返回队列头部的元素</p><p>补充：ConcurrentLinkedDeque 是双向链表结构的无界并发队列</p><p>ConcurrentLinkedQueue 使用约定：</p><ol><li>不允许 null 入列</li><li>队列中所有未删除的节点的 item 都不能为 null 且都能从 head 节点遍历到</li><li>删除节点是将 item 设置为 null，队列迭代时跳过 item 为 null 节点</li><li>head 节点跟 tail 不一定指向头节点或尾节点，可能<strong>存在滞后性</strong></li></ol><p>ConcurrentLinkedQueue 由 head 节点和 tail 节点组成，每个节点由节点元素和指向下一个节点的引用组成，组成一张链表结构的队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;E&gt; head;<span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;E&gt; tail;<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;    <span class="keyword">volatile</span> E item;    <span class="keyword">volatile</span> Node&lt;E&gt; next;    <span class="comment">//.....&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h4><ul><li><p>无参构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentLinkedQueue</span><span class="params">()</span> </span>&#123;    <span class="comment">// 默认情况下 head 节点存储的元素为空，dummy 节点，tail 节点等于 head 节点    head = tail = new Node&lt;E&gt;(null);&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>有参构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentLinkedQueue</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;    Node&lt;E&gt; h = <span class="keyword">null</span>, t = <span class="keyword">null</span>;    <span class="comment">// 遍历节点    for (E e : c) &#123;        checkNotNull(e);        Node&lt;E&gt; newNode = new Node&lt;E&gt;(e);        if (h == null)            h = t = newNode;        else &#123;            // 单向链表            t.lazySetNext(newNode);            t = newNode;        &#125;    &#125;    if (h == null)        h = t = new Node&lt;E&gt;(null);    head = h;    tail = t;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="入队方法"><a href="#入队方法" class="headerlink" title="入队方法"></a>入队方法</h4><p>与传统的链表不同，单线程入队的工作流程：</p><ul><li>将入队节点设置成当前队列尾节点的下一个节点</li><li>更新 tail 节点，如果 tail 节点的 next 节点不为空，则将入队节点设置成 tail 节点；如果 tail 节点的 next 节点为空，则将入队节点设置成 tail 的 next 节点，所以 tail 节点不总是尾节点，<strong>存在滞后性</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;    checkNotNull(e);    <span class="comment">// 创建入队节点    final Node&lt;E&gt; newNode = new Node&lt;E&gt;(e);    // 循环 CAS 直到入队成功    for (Node&lt;E&gt; t = tail, p = t;;) &#123;        // p 用来表示队列的尾节点，初始情况下等于 tail 节点，q 是 p 的 next 节点        Node&lt;E&gt; q = p.next;        // 条件成立说明 p 是尾节点        if (q == null) &#123;            // p 是尾节点，设置 p 节点的下一个节点为新节点            // 设置成功则 casNext 返回 true，否则返回 false，说明有其他线程更新过尾节点，继续寻找尾节点，继续 CAS            if (p.casNext(null, newNode)) &#123;                // 首次添加时，p 等于 t，不进行尾节点更新，所以尾节点存在滞后性                if (p != t)                    // 将 tail 设置成新入队的节点，设置失败表示其他线程更新了 tail 节点                    casTail(t, newNode);                 return true;            &#125;        &#125;        else if (p == q)            // 当 tail 不指向最后节点时，如果执行出列操作，可能将 tail 也移除，tail 不在链表中         // 此时需要对 tail 节点进行复位，复位到 head 节点            p = (t != (t = tail)) ? t : head;        else            // 推动 tail 尾节点往队尾移动            p = (p != t &amp;&amp; t != (t = tail)) ? t : q;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>图解入队：</p><p><img src="https://gitee.com/seazean/images/raw/master/Java/JUC-ConcurrentLinkedQueue%E5%85%A5%E9%98%9F%E6%93%8D%E4%BD%9C1.png"></p><p><img src="https://gitee.com/seazean/images/raw/master/Java/JUC-ConcurrentLinkedQueue%E5%85%A5%E9%98%9F%E6%93%8D%E4%BD%9C2.png"></p><p><img src="https://gitee.com/seazean/images/raw/master/Java/JUC-ConcurrentLinkedQueue%E5%85%A5%E9%98%9F%E6%93%8D%E4%BD%9C3.png"></p><p>当 tail 节点和尾节点的距离<strong>大于等于 1</strong> 时（每入队两次）更新 tail，可以减少 CAS 更新 tail 节点的次数，提高入队效率</p><p>线程安全问题：</p><ul><li>线程 1 线程 2 同时入队，无论从哪个位置开始并发入队，都可以循环 CAS，直到入队成功，线程安全</li><li>线程 1 遍历，线程 2 入队，所以造成 ConcurrentLinkedQueue 的 size 是变化，需要加锁保证安全</li><li>线程 1 线程 2 同时出列，线程也是安全的</li></ul><hr><h4 id="出队方法"><a href="#出队方法" class="headerlink" title="出队方法"></a>出队方法</h4><p>出队列的就是从队列里返回一个节点元素，并清空该节点对元素的引用，并不是每次出队都更新 head 节点</p><ul><li>当 head 节点里有元素时，直接弹出 head 节点里的元素，而不会更新 head 节点</li><li>当 head 节点里没有元素时，出队操作才会更新 head 节点</li></ul><p><strong>批处理方式</strong>可以减少使用 CAS 更新 head 节点的消耗，从而提高出队效率</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;    restartFromHead:    <span class="keyword">for</span> (;;) &#123;        <span class="comment">// p 节点表示首节点，即需要出队的节点，FIFO        for (Node&lt;E&gt; h = head, p = h, q;;) &#123;            E item = p.item;// 如果 p 节点的元素不为 null，则通过 CAS 来设置 p 节点引用元素为 null，成功返回 item            if (item != null &amp;&amp; p.casItem(item, null)) &#123;                if (p != h)                   // 对 head 进行移动                    updateHead(h, ((q = p.next) != null) ? q : p);                return item;            &#125;           // 逻辑到这说明头节点的元素为空或头节点发生了变化，头节点被另外一个线程修改了            // 那么获取 p 节点的下一个节点，如果 p 节点的下一节点也为 null，则表明队列已经空了            else if ((q = p.next) == null) &#123;                updateHead(h, p);                return null;            &#125;      // 第一轮操作失败，下一轮继续，调回到循环前            else if (p == q)                continue restartFromHead;            // 如果下一个元素不为空，则将头节点的下一个节点设置成头节点            else                p = q;        &#125;    &#125;&#125;final void updateHead(Node&lt;E&gt; h, Node&lt;E&gt; p) &#123;    if (h != p &amp;&amp; casHead(h, p))        // 将旧结点 h 的 next 域指向为 h，help gc        h.lazySetNext(h);&#125;</span></span><br></pre></td></tr></table></figure><p>在更新完 head 之后，会将旧的头结点 h 的 next 域指向为 h，图中所示的虚线也就表示这个节点的自引用，被移动的节点（item 为 null 的节点）会被 GC 回收</p><p><img src="https://gitee.com/seazean/images/raw/master/Java/JUC-ConcurrentLinkedQueue%E5%87%BA%E9%98%9F%E6%93%8D%E4%BD%9C1.png"></p><p><img src="https://gitee.com/seazean/images/raw/master/Java/JUC-ConcurrentLinkedQueue%E5%87%BA%E9%98%9F%E6%93%8D%E4%BD%9C2.png"></p><p><img src="https://gitee.com/seazean/images/raw/master/Java/JUC-ConcurrentLinkedQueue%E5%87%BA%E9%98%9F%E6%93%8D%E4%BD%9C3.png"></p><p>如果这时，有一个线程来添加元素，通过 tail 获取的 next 节点则仍然是它本身，这就出现了p == q 的情况，出现该种情况之后，则会触发执行 head 的更新，将 p 节点重新指向为 head</p><p>参考文章：<a href="https://www.jianshu.com/p/231caf90f30b">https://www.jianshu.com/p/231caf90f30b</a></p><hr><h4 id="成员方法-8"><a href="#成员方法-8" class="headerlink" title="成员方法"></a>成员方法</h4><ul><li><p>peek()：会改变 head 指向，执行 peek() 方法后 head 会指向第一个具有非空元素的节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取链表的首部元素，只读取而不移除public E peek() &#123;    restartFromHead:    for (;;) &#123;        for (Node&lt;E&gt; h = head, p = h, q;;) &#123;            E item = p.item;            if (item != null || (q = p.next) == null) &#123;                // 更改h的位置为非空元素节点                updateHead(h, p);                return item;            &#125;            else if (p == q)                continue restartFromHead;            else                p = q;        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>size()：用来获取当前队列的元素个数，因为整个过程都没有加锁，在并发环境中从调用 size 方法到返回结果期间有可能增删元素，导致统计的元素个数不精确</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;    <span class="keyword">int</span> count = <span class="number">0</span>;    <span class="comment">// first() 获取第一个具有非空元素的节点，若不存在，返回 null    // succ(p) 方法获取 p 的后继节点，若 p == p.next，则返回 head    // 类似遍历链表    for (Node&lt;E&gt; p = first(); p != null; p = succ(p))        if (p.item != null)            // 最大返回Integer.MAX_VALUE            if (++count == Integer.MAX_VALUE)                break;    return count;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>remove()：移除元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;    <span class="comment">// 删除的元素不能为null    if (o != null) &#123;        Node&lt;E&gt; next, pred = null;        for (Node&lt;E&gt; p = first(); p != null; pred = p, p = next) &#123;            boolean removed = false;            E item = p.item;            // 节点元素不为null            if (item != null) &#123;                // 若不匹配，则获取next节点继续匹配                if (!o.equals(item)) &#123;                    next = succ(p);                    continue;                &#125;                // 若匹配，则通过 CAS 操作将对应节点元素置为 null                removed = p.casItem(item, null);            &#125;            // 获取删除节点的后继节点            next = succ(p);            // 将被删除的节点移除队列            if (pred != null &amp;&amp; next != null) // unlink                pred.casNext(p, next);            if (removed)                return true;        &#125;    &#125;    return false;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础笔记4-SDP</title>
      <link href="./2021/09/16/java/java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B04-SDP/"/>
      <url>./2021/09/16/java/java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B04-SDP/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="assets\css\APlayer.min.css"><script src="assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="SDP"><a href="#SDP" class="headerlink" title="SDP"></a>SDP</h1><h2 id="软件设计"><a href="#软件设计" class="headerlink" title="软件设计"></a>软件设计</h2><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>软件设计模式（Software Design Pattern），本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性以及类的关联关系和组合关系的充分理解</p><ul><li>可以提高程序员的思维能力、编程能力和设计能力</li><li>使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期</li><li>使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强</li></ul><p>设计模式分类：</p><ul><li><strong>创建型模式</strong>：用于描述如何创建对象，主要特点是将对象的创建与使用分离。GoF 书中提供了单例、原型、工厂方法、抽象工厂、建造者等 5 种创建型模式</li><li><strong>结构型模式</strong>：用于描述如何将类或对象按某种布局组成更大的结构，GoF 书中提供了代理、适配器、桥接、装饰、外观、享元、组合等 7 种结构型模式</li><li><strong>行为型模式</strong>：用于描述类或对象之间怎样相互协作共同完成单个对象无法单独完成的任务，以及怎样分配职责。GoF 书中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式</li></ul><p>参考视频：<a href="https://www.bilibili.com/video/BV1Np4y1z7BU">https://www.bilibili.com/video/BV1Np4y1z7BU</a></p><hr><h3 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>统一建模语言（Unified Modeling Language，UML）是用来设计软件的可视化建模语言，特点是简单、统一、图形化、能表达软件设计中的动态与静态信息</p><p>UML 从目标系统的不同角度出发，定义了用例图、类图、对象图、状态图、活动图、时序图、协作图、构件图、部署图等 9 种图</p><p>类图（Class diagram）是显示了模型的静态结构，特别是模型中存在的类、类的内部结构以及它们与其他类的关系等，类图不显示暂时性的信息，类图是面向对象建模的主要组成部分</p><p>类图的作用：</p><ul><li>在软件工程中，类图是一种静态的结构图，描述了系统的类的集合，类的属性和类之间的关系，可以简化人们对系统的理解</li><li>类图是系统分析和设计阶段的重要产物，是系统编码和测试的重要模型</li></ul><hr><h4 id="表示方法"><a href="#表示方法" class="headerlink" title="表示方法"></a>表示方法</h4><p>在UML类图中，类使用包含类名、属性(field) 和方法(method) 且带有分割线的矩 形来表示，比如下图表示一个Employee 类，包含 name、age 和 address这3个属性，以及 work() 方法</p><p><img src="https://gitee.com/seazean/images/raw/master/Java/Design-%E7%B1%BB%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95.jpg"></p><p>属性/方法名称前加的+和-表示了这个属性/方法的可见性，UML类图中表示可见性的符号有三种：</p><ul><li><p>+：表示public</p></li><li><p>-：表示private</p></li><li><p>#：表示protected</p></li></ul><p>属性的完整表示方式是： <strong>可见性  名称 ：类型 [ = 缺省值]</strong>  </p><p>方法的完整表示方式是： <strong>可见性  名称(参数列表) [ : 返回类型]</strong></p><ul><li>中括号中的内容表示是可选的</li><li>也有将类型放在变量名前面，返回值类型放在方法名前面</li></ul><hr><h4 id="关联关系"><a href="#关联关系" class="headerlink" title="关联关系"></a>关联关系</h4><p>关联关系是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的联系，如老师和学生。关联关系是类与类之间最常用的一种关系，分为一般关联关系、聚合关系和组合关系</p><p>一般关联又可以分为单向关联，双向关联，自关联</p><ul><li><p>单向关联：在UML类图中单向关联用一个带箭头的实线表示，下图表示每个顾客都有一个地址，通过让 Customer 类持有一个类型为 Address 的成员变量类实现</p><img src="https://gitee.com/seazean/images/raw/master/Java/Design-类关系单向关联.jpg" style="zoom: 80%;"></li><li><p>双向关联：双方各自持有对方类型的成员变量</p><img src="https://gitee.com/seazean/images/raw/master/Java/Design-类关系双向关联.jpg" style="zoom:80%;"></li><li><p>自关联：在UML类图中用一个带有箭头且指向自身的线表示，下图的意思就是Node类包含类型为Node的成员变量，也就是自己包含自己</p><img src="https://gitee.com/seazean/images/raw/master/Java/Design-类关系自关联.jpg" style="zoom:80%;"></li></ul><hr><h4 id="聚合关系"><a href="#聚合关系" class="headerlink" title="聚合关系"></a>聚合关系</h4><p>聚合关系是关联关系的一种，是强关联关系，是整体和部分之间的关系。聚合关系通过成员对象来实现，其中成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立 存在</p><p>在 UML 类图中，聚合关系可以用带空心菱形的实线来表示，菱形指向整体，下图表示学校与老师的关系，学校包含老师，但如果学校倒闭了，老师依然存在</p><img src="https://gitee.com/seazean/images/raw/master/Java/Design-类关系聚合关系.jpg" style="zoom: 80%;"><hr><h4 id="组合关系"><a href="#组合关系" class="headerlink" title="组合关系"></a>组合关系</h4><p>组合关系表示类之间的整体与部分的关系，是一种更强烈的聚合关系。整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也将不存在，部分对象不能脱离整体对象而存在</p><p>在 UML 类图中，组合关系用带实心菱形的实线来表示，菱形指向整体，下图所示是头和嘴的关系图：</p><img src="https://gitee.com/seazean/images/raw/master/Java/Design-类关系组合关系.png" style="zoom:80%;"><hr><h4 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h4><p>依赖关系是一种使用关系，对象之间耦合度最弱的一种关联方式，是临时性的关联。在代码中，某个类的方法通过局部变量、方法的参数或者对静态方法的调用来访问另一个类（被依赖类）中的某些方法来完成一些职责</p><p>在 UML 类图中，依赖关系使用带箭头的虚线来表示，箭头从使用类指向被依赖的类</p><img src="https://gitee.com/seazean/images/raw/master/Java/Design-类关系依赖关系.jpg" style="zoom:80%;"><hr><h4 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h4><p>继承关系是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是父类与子类之间的关系，是一种继承关系</p><p>在 UML 类图中，泛化关系用带空心三角箭头的实线来表示，箭头从子类指向父类。在代码实现时，使用面向对象的继承机制来实现泛化关系。例如  Student 类和 Teacher 类都是 Person 类的子类，其类图如下图所示：</p><img src="https://gitee.com/seazean/images/raw/master/Java/Design-类关系继承关系.jpg" style="zoom:80%;"><hr><h4 id="实现关系"><a href="#实现关系" class="headerlink" title="实现关系"></a>实现关系</h4><p>实现关系是接口与实现类之间的关系，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作</p><p>在 UML 类图中，实现关系使用带空心三角箭头的虚线来表示，箭头从实现类指向接口，比如汽车和船实现了交通工具：</p><img src="https://gitee.com/seazean/images/raw/master/Java/Design-类关系实现关系.jpg" style="zoom:80%;"><hr><h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><h4 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h4><p><strong>对扩展开放，对修改关闭</strong>，在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果，简言之，是为了使程序的扩展性好，易于维护和升级，使用接口和抽象类</p><p>抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定，软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以。</p><hr><h4 id="里氏代换"><a href="#里氏代换" class="headerlink" title="里氏代换"></a>里氏代换</h4><p>里氏代换原则是面向对象设计的基本原则之一</p><p>里氏代换原则：任何基类可以出现的地方，子类一定可以出现，就是子类可以扩展父类的功能，但不能改变父类原有的功能，也就是子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法</p><p>如果通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的概率会非常大</p><hr><h4 id="依赖倒转"><a href="#依赖倒转" class="headerlink" title="依赖倒转"></a>依赖倒转</h4><p>高层模块不应该依赖实现模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合</p><p>比如说组装一台电脑，如果组装的电脑的cpu只能是Intel的，内存条只能是金士顿的，硬盘只能是希捷的，这对用户肯定是不友好的，所以需要把 CPU、内存、硬盘提取成接口类</p><hr><h4 id="接口隔离"><a href="#接口隔离" class="headerlink" title="接口隔离"></a>接口隔离</h4><p>客户端不应该被迫依赖于不使用的方法，一个类对另一个类的依赖应该建立在最小的接口上</p><p>比如说 Person 类有姓名、年龄、收入，但是子类 Teacher 类有收入，Student 没有，所以需要设置三个接口。</p><hr><h4 id="迪米特"><a href="#迪米特" class="headerlink" title="迪米特"></a>迪米特</h4><p>迪米特法则又叫最少知识原则，如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用，其目的是降低类之间的耦合度，提高模块的相对独立</p><p>比如明星与经纪人的关系：</p><p><img src="https://gitee.com/seazean/images/raw/master/Java/Design-%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99.png"></p><hr><h4 id="合成复用"><a href="#合成复用" class="headerlink" title="合成复用"></a>合成复用</h4><p>合成复用原则：尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现</p><p>类的复用分为继承复用和合成复用两种</p><ul><li><p>继承复用的缺点：</p><ol><li>继承复用破坏了类的封装性，继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱复用”</li><li>子类与父类的耦合度高，父类的实现的任何改变都会导致子类的实现发生变化，不利于类的扩展与维护</li><li>限制了复用的灵活性，从父类继承而来的实现是非虚方法，在编译时已经绑定，在运行时不能发生变化</li></ol></li><li><p>采用组合或聚合复用，将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能</p><ol><li>维持了类的封装性，因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用</li><li>对象间的耦合度低，可以在类的成员位置声明抽象</li><li>复用的灵活性高，这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象</li></ol></li></ul><p>比如：汽车按动力源分为汽油汽车、电动汽车等；按颜色划分可分为白色汽车、黑色汽车和红色汽车等</p><ul><li><p>类图：</p><img src="https://gitee.com/seazean/images/raw/master/Java/Design-合成复用原则1.png" style="zoom: 67%;"></li><li><p>将继承复用改为聚合复用，把颜色当作属性：</p><img src="https://gitee.com/seazean/images/raw/master/Java/Design-合成复用原则2.png" style="zoom: 80%;"></li></ul><hr><h2 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h2><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><h4 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>创建型模式的主要关注点是怎样创建对象，将对象的创建与使用分离，降低系统的耦合度，使用者不需要关注对象的创建细节</p><p>创建型模式分为：单例模式、工厂方法模式、抽象工程模式、原型模式、建造者模式</p><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一，提供了一种创建对象的最佳方式</p><p>单例设计模式分类两种：</p><ul><li><p>饿汉式：类加载就会导致该单实例对象被创建    </p></li><li><p>懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建</p></li></ul><hr><h4 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h4><p>饿汉式在类加载的过程导致该单实例对象被创建，<strong>虚拟机会保证类加载的线程安全</strong>，但是如果只是为了加载该类不需要实例，则会造成内存的浪费</p><ul><li><p>静态变量的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;    <span class="comment">// 私有构造方法    private Singleton() &#123;&#125;    // 在成员位置创建该类的对象    private static final Singleton instance = new Singleton();    // 对外提供静态方法获取该对象    public static Singleton getInstance() &#123;        return instance;    &#125;        // 解决序列化问题    protected Object readResolve() &#123;    return INSTANCE;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><ul><li><p>问题1：为什么类加 final 修饰？</p><ul><li>不被子类继承，防止子类中不适当的行为覆盖父类的方法，破坏了单例</li></ul></li><li><p>问题2：如果实现了序列化接口，怎么防止防止反序列化破坏单例？</p><ul><li><p>对单例声明 transient，然后实现 readObject(ObjectInputStream in) 方法，复用原来的单例</p><p>条件：访问权限为 private/protected、返回值必须是 Object、异常可以不抛</p></li><li><p>实现 readResolve() 方法，当 JVM 从内存中反序列化地”组装”一个新对象，就会自动调用 readResolve 方法返回原来单例</p></li></ul></li><li><p>问题3：为什么构造方法设置为私有? 是否能防止反射创建新的实例?</p><ul><li>防止其他类无限创建对象；不能防止反射破坏</li></ul></li><li><p>问题4：这种方式是否能保证单例对象创建时的线程安全?</p><ul><li>能，静态变量初始化在类加载时完成，由 JVM 保证线程安全</li></ul></li><li><p>问题5：为什么提供静态方法而不是直接将 INSTANCE 设置为 public？</p><ul><li>更好的封装性、提供泛型支持、可以改进成懒汉单例设计</li></ul></li></ul></li><li><p>静态代码块的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;    <span class="comment">//私有构造方法    private Singleton() &#123;&#125;        //在成员位置创建该类的对象    private static Singleton instance;    static &#123;        instance = new Singleton();    &#125;        //对外提供静态方法获取该对象    public static Singleton getInstance() &#123;        return instance;    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>枚举方式：枚举类型是所用单例实现中<strong>唯一一种</strong>不会被破坏的单例实现模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Singleton</span> </span>&#123;    INSTANCE;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;        System.out.println(<span class="string">&quot;doSomething&quot;</span>);    &#125;&#125;<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    Singleton.INSTANCE.doSomething();&#125;</span><br></pre></td></tr></table></figure><ul><li>问题1：枚举单例是如何限制实例个数的？每个枚举项都是一个实例，是一个静态成员变量</li><li>问题2：枚举单例在创建时是否有并发问题？否</li><li>问题3：枚举单例能否被反射破坏单例？否，反射创建对象时判断是枚举类型就直接抛出异常</li><li>问题4：枚举单例能否被反序列化破坏单例？否</li><li>问题5：枚举单例属于懒汉式还是饿汉式？<strong>饿汉式</strong></li><li>问题6：枚举单例如果希望加入一些单例创建时的初始化逻辑该如何做？添加构造方法</li></ul><p>反编译结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Enum</span>&lt;<span class="title">Singleton</span>&gt; </span>&#123;<span class="comment">//Enum实现序列化接口public static final Singleton INSTANCE = new Singleton();&#125;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h4><ul><li><p>线程不安全</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;    <span class="comment">//私有构造方法    private Singleton() &#123;&#125;    //在成员位置创建该类的对象    private static Singleton instance;    //对外提供静态方法获取该对象    public static Singleton getInstance() &#123;        if(instance == null) &#123;            //多线程环境，会出现线程安全问题，可能多个线程同时进入这里            instance = new Singleton();        &#125;        return instance;    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>双端检锁机制</p><p>在多线程的情况下，可能会出现空指针问题，出现问题的原因是 JVM 在实例化对象的时候会进行优化和指令重排序操作，所以需要使用 <code>volatile</code> 关键字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;     <span class="comment">// 私有构造方法    private Singleton() &#123;&#125;    private static volatile Singleton instance;    // 对外提供静态方法获取该对象    public static Singleton getInstance() &#123;        // 第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实例        if(instance == null) &#123;            synchronized (Singleton.class) &#123;                // 抢到锁之后再次判断是否为null                if(instance == null) &#123;                    instance = new Singleton();                &#125;            &#125;        &#125;        return instance;    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>静态内部类方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;    <span class="comment">// 私有构造方法    private Singleton() &#123;&#125;    private static class SingletonHolder &#123;        private static final Singleton INSTANCE = new Singleton();    &#125;    // 对外提供静态方法获取该对象    public static Singleton getInstance() &#123;        return SingletonHolder.INSTANCE;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><ul><li><p>内部类属于懒汉式，类加载本身就是懒惰的，首次调用时加载，然后对单例进行初始化</p><p>类加载的时候方法不会被调用，所以不会触发 getInstance 方法调用 invokestatic 指令对内部类进行加载；加载的时候字节码常量池会被加入类的运行时常量池，解析工作是将常量池中的符号引用解析成直接引用，但是解析过程不一定非得在类加载时完成，可以延迟到运行时进行，所以静态内部类实现单例会<strong>延迟加载</strong></p></li><li><p>没有线程安全问题，静态变量初始化在类加载时完成，由 JVM 保证线程安全</p></li></ul></li></ul><hr><h4 id="破坏单例"><a href="#破坏单例" class="headerlink" title="破坏单例"></a>破坏单例</h4><h5 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h5><p>将单例对象序列化再反序列化，对象从内存反序列化到程序中会重新创建一个对象，通过反序列化得到的对象是不同的对象，而且得到的对象不是通过构造器得到的，<strong>反序列化得到的对象不执行构造器</strong></p><ul><li><p>Singleton</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;<span class="comment">//实现序列化接口    // 私有构造方法    private Singleton() &#123;&#125;    private static class SingletonHolder &#123;        private static final Singleton INSTANCE = new Singleton();    &#125;    // 对外提供静态方法获取该对象    public static Singleton getInstance() &#123;        return SingletonHolder.INSTANCE;    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>序列化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;        <span class="comment">//往文件中写对象        //writeObject2File();        //从文件中读取对象        Singleton s1 = readObjectFromFile();        Singleton s2 = readObjectFromFile();        //判断两个反序列化后的对象是否是同一个对象        System.out.println(s1 == s2);    &#125;    private static Singleton readObjectFromFile() throws Exception &#123;        //创建对象输入流对象        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;C://a.txt&quot;));        //第一个读取Singleton对象        Singleton instance = (Singleton) ois.readObject();        return instance;    &#125;        public static void writeObject2File() throws Exception &#123;        //获取Singleton类的对象        Singleton instance = Singleton.getInstance();        //创建对象输出流        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;C://a.txt&quot;));        //将instance对象写出到文件中        oos.writeObject(instance);    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>解决方法：</p><p>在 Singleton 类中添加 <code>readResolve()</code> 方法，在反序列化时被反射调用，如果定义了这个方法，就返回这个方法的值，如果没有定义，则返回新创建的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;    <span class="keyword">return</span> SingletonHolder.INSTANCE;&#125;</span><br></pre></td></tr></table></figure><p>ObjectInputStream 类源码分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">readObject</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span>&#123;    <span class="comment">//...      Object obj = readObject0(false);//重点查看readObject0方法&#125;private Object readObject0(boolean unshared) throws IOException &#123;    try &#123;switch (tc) &#123;case TC_OBJECT:return checkResolve(readOrdinaryObject(unshared));        &#125;    &#125; &#125;private Object readOrdinaryObject(boolean unshared) throws IOException &#123;// isInstantiable 返回true，执行 desc.newInstance()，通过反射创建新的单例类    obj = desc.isInstantiable() ? desc.newInstance() : null;     // 添加 readResolve 方法后 desc.hasReadResolveMethod() 方法执行结果为true    if (obj != null &amp;&amp; handles.lookupException(passHandle) == null &amp;&amp; desc.hasReadResolveMethod()) &#123;    // 通过反射调用 Singleton 类中的 readResolve 方法，将返回值赋值给rep变量    // 多次调用ObjectInputStream类中的readObject方法，本质调用定义的readResolve方法，返回的是同一个对象。    Object rep = desc.invokeReadResolve(obj);    &#125;    return obj;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="反射破解"><a href="#反射破解" class="headerlink" title="反射破解"></a>反射破解</h5><ul><li><p>反射</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;        <span class="comment">//获取Singleton类的字节码对象        Class clazz = Singleton.class;        //获取Singleton类的私有无参构造方法对象        Constructor constructor = clazz.getDeclaredConstructor();        //取消访问检查        constructor.setAccessible(true);        //创建Singleton类的对象s1        Singleton s1 = (Singleton) constructor.newInstance();        //创建Singleton类的对象s2        Singleton s2 = (Singleton) constructor.newInstance();        //判断通过反射创建的两个Singleton对象是否是同一个对象        System.out.println(s1 == s2);//false    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>反射方式破解单例的解决方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;        <span class="comment">// 私有构造方法    private Singleton() &#123;        // 反射破解单例模式需要添加的代码        if(instance != null) &#123;            throw new RuntimeException();        &#125;    &#125;        // 对外提供静态方法获取该对象    public static Singleton getInstance() &#123;        if(instance != null) &#123;            return instance;        &#125;        synchronized (Singleton.class) &#123;            if(instance != null) &#123;                return instance;            &#125;            instance = new Singleton();            return instance;        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h4><p>Runtime 类就是使用的单例设计模式中的饿汉式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Runtime</span> </span>&#123;        <span class="keyword">private</span> <span class="keyword">static</span> Runtime currentRuntime = <span class="keyword">new</span> Runtime();        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Runtime <span class="title">getRuntime</span><span class="params">()</span> </span>&#123;                <span class="keyword">return</span> currentRuntime;        &#125;       <span class="function"><span class="keyword">private</span> <span class="title">Runtime</span><span class="params">()</span> </span>&#123;&#125;        ...&#125;</span><br></pre></td></tr></table></figure><p>使用 Runtime</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeDemo</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;        <span class="comment">//获取Runtime类对象        Runtime runtime = Runtime.getRuntime();        //返回 Java 虚拟机中的内存总量。        System.out.println(runtime.totalMemory());        //返回 Java 虚拟机试图使用的最大内存量。        System.out.println(runtime.maxMemory());        //创建一个新的进程执行指定的字符串命令，返回进程对象        Process process = runtime.exec(&quot;ipconfig&quot;);        //获取命令执行后的结果，通过输入流获取        InputStream inputStream = process.getInputStream();        byte[] arr = new byte[1024 * 1024* 100];        int b = inputStream.read(arr);        System.out.println(new String(arr,0,b,&quot;gbk&quot;));    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><h4 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>工厂模式：使用工厂来生产对象，彻底和对象解耦，如果要更换对象，直接在工厂里更换该对象即可</p><p>三种工厂：</p><ul><li>简单工厂模式（不属于 GOF 的23种经典设计模式）</li><li>工厂方法模式</li><li>抽象工厂模式</li></ul><hr><h4 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h4><p>简单工厂，也称为静态工厂模式，包含如下角色：</p><ul><li>抽象产品 ：定义了产品的规范，描述了产品的主要特性和功能</li><li>具体产品 ：实现或者继承抽象产品的子类</li><li>具体工厂 ：提供了创建产品的方法，调用者通过该方法来获取产品</li></ul><p>实现代码：</p><ul><li><p>抽象类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Coffee</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getName</span><span class="params">()</span></span>;&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AmericanCoffee</span> <span class="keyword">extends</span> <span class="title">Coffee</span> </span>&#123;    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> <span class="string">&quot;美式咖啡&quot;</span>;    &#125;&#125;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LatteCoffee</span> <span class="keyword">extends</span> <span class="title">Coffee</span> </span>&#123;    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> <span class="string">&quot;拿铁咖啡&quot;</span>;    &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>简单工厂类，在 createCoffee 方法加 static</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleCoffeeFactory</span> </span>&#123;    <span class="function"><span class="keyword">public</span> Coffee <span class="title">createCoffee</span><span class="params">(String type)</span> </span>&#123;        <span class="comment">//声明Coffee类型的变量，根据不同类型创建不同的coffee子类对象        Coffee coffee = null;        if(&quot;american&quot;.equals(type)) &#123;            coffee = new AmericanCoffee();        &#125; else if(&quot;latte&quot;.equals(type)) &#123;            coffee = new LatteCoffee();        &#125; else &#123;            throw new RuntimeException(&quot;对不起，您所点的咖啡没有&quot;);        &#125;        return coffee;    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        SimpleCoffeeFactory factory = <span class="keyword">new</span> SimpleCoffeeFactory();        Coffee coffee = factory.createCoffee(<span class="string">&quot;latte&quot;</span>);        System.out.println(coffee.getName());    &#125;&#125;</span><br></pre></td></tr></table></figure></li></ul><p>优点：</p><ul><li>封装了创建对象的过程，可以通过参数直接获取对象。</li><li>把对象的创建和业务逻辑层分开，如果要实现新产品直接修改工厂类，而不需要在原代码中修改，扩展性高</li></ul><p>缺点：实现新产品需要修改 SimpleCoffeeFactory 的代码，违反了开闭原则</p><hr><h4 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h4><p>定义一个用于创建对象的接口，让子类决定实例化哪个产品类对象，工厂方法使一个产品类的实例化延迟到其工厂的子类</p><p>工厂方法模式的主要角色：</p><ul><li>抽象工厂：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品</li><li>具体工厂：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。</li><li>抽象产品：定义了产品的规范，描述了产品的主要特性和功能。</li><li>具体产品：实现了抽象产品角色所定义的接口，由具体工厂来创建，同具体工厂之间一一对应</li></ul><p>代码实现：</p><ul><li><p>抽象工厂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CoffeeFactory</span> </span>&#123;        <span class="function">Coffee <span class="title">createCoffee</span><span class="params">()</span></span>;&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体工厂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LatteCoffeeFactory</span> <span class="keyword">implements</span> <span class="title">CoffeeFactory</span> </span>&#123;    <span class="function"><span class="keyword">public</span> Coffee <span class="title">createCoffee</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> <span class="keyword">new</span> LatteCoffee();    &#125;&#125;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AmericanCoffeeFactory</span> <span class="keyword">implements</span> <span class="title">CoffeeFactory</span> </span>&#123;    <span class="function"><span class="keyword">public</span> Coffee <span class="title">createCoffee</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> <span class="keyword">new</span> AmericanCoffee();    &#125;&#125;</span><br></pre></td></tr></table></figure></li></ul><p>优点：</p><ul><li>用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程</li><li>增加新的产品只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则</li></ul><p>缺点：</p><ul><li>每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度</li></ul><hr><h4 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h4><p>抽象工厂：是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构</p><p>抽象工厂是工厂方法的升级版，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品</p><p>工厂方法只能加咖啡，不能拓展其他业务，所以使用抽象工厂</p><ul><li><p>抽象工厂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DessertFactory</span> </span>&#123;        <span class="function">Coffee <span class="title">createCoffee</span><span class="params">()</span></span>;        <span class="function">Dessert <span class="title">createDessert</span><span class="params">()</span></span>;&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体工厂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//美式甜点工厂public class AmericanDessertFactory implements DessertFactory &#123;    public Coffee createCoffee() &#123;        return new AmericanCoffee();    &#125;    public Dessert createDessert() &#123;        return new MatchaMousse();    &#125;&#125;//意大利风味甜点工厂public class ItalyDessertFactory implements DessertFactory &#123;    public Coffee createCoffee() &#123;        return new LatteCoffee();    &#125;    public Dessert createDessert() &#123;        return new Tiramisu();    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><p>优点：当一个产品族中的多个对象被设计成一起工作时，能保证客户端始终只使用同一个产品族中的对象</p><p>缺点：当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改</p><hr><h4 id="模式拓展"><a href="#模式拓展" class="headerlink" title="模式拓展"></a>模式拓展</h4><p>通过工厂模式+配置文件的方式解除工厂对象和产品对象的耦合，在工厂类中加载配置文件中的全类名，并创建对象进行存储，客户端如果需要对象，直接进行获取即可</p><ul><li><p>定义配置文件 bean.properties：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">american</span>=<span class="string">pattern.factory.config_factory.AmericanCoffeelatte=pattern.factory.config_factory.LatteCoffee</span></span><br></pre></td></tr></table></figure></li><li><p>改进工厂类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoffeeFactory</span> </span>&#123;    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,Coffee&gt; map = <span class="keyword">new</span> HashMap();    <span class="keyword">static</span> &#123;        Properties p = <span class="keyword">new</span> Properties();        InputStream is = CoffeeFactory.class.getClassLoader().getResourceAsStream(<span class="string">&quot;bean.properties&quot;</span>);        <span class="keyword">try</span> &#123;            p.load(is);            <span class="comment">//遍历Properties集合对象            Set&lt;Object&gt; keys = p.keySet();            for (Object key : keys) &#123;                //根据键获取值（全类名）                String className = p.getProperty((String) key);                //获取字节码对象                Class clazz = Class.forName(className);                Coffee obj = (Coffee) clazz.newInstance();                map.put((String)key,obj);            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;    public static Coffee createCoffee(String name) &#123;        return map.get(name);    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>静态成员变量用来存储创建的对象（键存储的是名称，值存储的是对应的对象），而读取配置文件以及创建对象写在静态代码块中，目的就是只需要执行一次</p></li></ul><hr><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><p>使用场景：</p><ul><li>当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等</li><li>系统中有多个产品族，但每次只使用其中的某一族产品，如有人只喜欢穿某一个品牌的衣服和鞋</li><li>系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构</li></ul><h5 id="源码应用"><a href="#源码应用" class="headerlink" title="源码应用"></a>源码应用</h5><p>iterator</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();        list.add(<span class="string">&quot;令狐冲&quot;</span>);        list.add(<span class="string">&quot;风清扬&quot;</span>);        list.add(<span class="string">&quot;任我行&quot;</span>);        <span class="comment">//获取迭代器对象        Iterator&lt;String&gt; it = list.iterator();        //使用迭代器遍历        while(it.hasNext()) &#123;            String ele = it.next();            System.out.println(ele);        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>使用迭代器遍历集合，获取集合中的元素，而单列集合获取迭代器的方法就使用到了工厂方法模式</p><img src="https://gitee.com/seazean/images/raw/master/Java/Design-iterator源码解析.png" style="zoom:80%;"><p>Collection 接口是抽象工厂类，ArrayList 是具体的工厂类，Iterator 接口是抽象商品类，ArrayList 类中的 Iter 内部类是具体的商品类，在具体的工厂类中 iterator() 方法创建具体的商品类的对象</p><hr><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><h4 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型对象相同的新对象</p><p>原型模式包含如下角色：</p><ul><li>抽象原型类：规定了具体原型对象必须实现的的 clone() 方法。</li><li>具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。</li><li>访问类：使用具体原型类中的 clone() 方法来复制新的对象</li></ul><p>接口类图如下：</p><img src="https://gitee.com/seazean/images/raw/master/Java/Design-原型模式.png" style="zoom:80%;"><hr><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>原型模式的克隆分为浅克隆和深克隆，具体介绍参考 Object 类介绍部分的笔记</p><p>Java中 的 Object 类中提供了 <code>clone()</code> 方法来实现浅克隆，实现 Cloneable 接口的类才可以被克隆</p><ul><li><p>具体原型类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Citation</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;    <span class="keyword">private</span> String name;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;        <span class="keyword">this</span>.name = name;    &#125;    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> (<span class="keyword">this</span>.name);    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;        System.out.println(name + <span class="string">&quot;同学：第一学期被评为三好学生。特发此状！&quot;</span>);    &#125;    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> Citation <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;        <span class="keyword">return</span> (Citation) <span class="keyword">super</span>.clone();    &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CitationTest</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;        Citation c1 = <span class="keyword">new</span> Citation();        c1.setName(<span class="string">&quot;张三&quot;</span>);        <span class="comment">//复制奖状        Citation c2 = c1.clone();        c2.setName(&quot;李四&quot;);        c1.show();// 张三        c2.show();// 李四    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="模式拓展-1"><a href="#模式拓展-1" class="headerlink" title="模式拓展"></a>模式拓展</h4><p>深克隆案例：</p><ul><li><p>原代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Citation</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;    <span class="keyword">private</span> Student stu;<span class="comment">// get + set        public void show() &#123;        System.out.println(stu.getName() + &quot;同学：在第一学期被评为三好学生。特发此状！&quot;);    &#125;    @Override    public Citation clone() throws CloneNotSupportedException &#123;        return (Citation) super.clone();    &#125;&#125;//学生类public class Student &#123;    private String name;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;    Citation c1 = <span class="keyword">new</span> Citation();    Student stu1 = <span class="keyword">new</span> Student();    stu1.setName(<span class="string">&quot;张三&quot;</span>);    c1.setStu(stu);        Citation c2 = citation.clone();    Student stu2 = c2.getStu();    stu2.setName(<span class="string">&quot;李四&quot;</span>);    citation.show();<span class="comment">//李四...    citation1.show();//李四...&#125;</span></span><br></pre></td></tr></table></figure><p>stu1 对象和 stu2 对象是同一个对象，将 stu2 对象中 name 属性改为李四，两个Citation对象中都是李四，这就是浅克隆的效果</p></li><li><p>序列化实现深克隆，或者重写克隆方法：</p><p>序列化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CitationTest1</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;        Citation c1 = <span class="keyword">new</span> Citation();        Student stu = <span class="keyword">new</span> Student(<span class="string">&quot;张三&quot;</span>);        c1.setStu(stu);        <span class="comment">//创建对象输出流对象        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;C:\\b.txt&quot;));        //将c1对象写出到文件中        oos.writeObject(c1);        oos.close();        //创建对象输入流对象        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;C:\\b.txt&quot;));        //读取对象        Citation c2 = (Citation) ois.readObject();        //获取c2奖状所属学生对象        Student stu1 = c2.getStu();        stu1.setName(&quot;李四&quot;);        //判断stu对象和stu1对象是否是同一个对象        System.out.println(&quot;stu和stu1是同一个对象？&quot; + (stu == stu1));//false        c1.show();//张三        c2.show();//李四    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>重写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Overridepublic</span> <span class="function">Citation <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;    Citation clone = (Citation) <span class="keyword">super</span>.clone();    Student o = (Student) stu.clone();    clone.setStu(o);    <span class="keyword">return</span> clone;&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="建造者"><a href="#建造者" class="headerlink" title="建造者"></a>建造者</h3><h4 id="基本介绍-4"><a href="#基本介绍-4" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示</p><ul><li>分离了部件的构造（由Builder来负责）和装配（由Director负责），从而可以构造出复杂的对象，这个模式适用于某个对象的构建过程复杂的情况</li><li>由于实现了构建和装配的解耦。不同的构建器，相同的装配，也可以做出不同的对象；相同的构建器，不同的装配顺序也可以做出不同的对象，实现了更好的复用。</li><li>建造者模式可以将部件和其组装过程分开，一步一步创建一个复杂的对象。用户只需要指定复杂对象的类型就可以得到该对象，而无须知道其内部的具体构造细节</li></ul><p>建造者（Builder）模式包含如下角色：</p><ul><li><p>抽象建造者类 (Builder)：这个接口定义要实现复杂对象的哪些部分的创建，并不涉及具体的部件对象的创建</p></li><li><p>具体建造者类 (ConcreteBuilder)：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法，在构造过程完成后，提供产品的实例。 </p></li><li><p>产品类 (Product)：要创建的复杂对象</p></li><li><p>指挥者类 (Director)：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建</p></li></ul><img src="https://gitee.com/seazean/images/raw/master/Java/Design-建造者模式.png" style="zoom:80%;"><p>模式优点：</p><ul><li>建造者模式的封装性很好，使用建造者模式可以有效的封装变化，将主要的业务逻辑封装在指挥者类中对整体而言可以取得比较好的稳定性</li><li>在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象</li><li>可以更加精细地控制产品的创建过程 ，将复杂产品的创建步骤分解在不同的方法中，更方便使用程序来控制创建过程</li><li>建造者模式很容易进行扩展，如果有新的需求，通过实现一个新的建造者类就可以完成，基本上不用修改之前已经测试通过的代码，因此也就不会对原有功能引入风险，符合开闭原则</li></ul><p>模式缺点：造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制</p><p>应用场景：</p><ul><li>创建的对象较复杂，由多个部件构成，各部件面临着复杂的变化，但构件间的建造顺序是稳定的</li><li>创建复杂对象的算法独立于该对象的组成部分以及装配方式，即产品的构建过程和最终的表示是独立的</li></ul><hr><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><p>生产自行车是一个复杂的过程，它包含了车架，车座等组件的生产。而车架又有多种材质的，车座有多种材质，对于自行车的生产就可以使用建造者模式</p><ul><li><p>自行车类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bike</span> </span>&#123;       <span class="keyword">private</span> String frame;        <span class="keyword">private</span> String seat;    <span class="comment">// ...&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>抽象 builder 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;    <span class="keyword">protected</span> Bike bike = <span class="keyword">new</span> Bike();    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildFrame</span><span class="params">()</span></span>;    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildSeat</span><span class="params">()</span></span>;    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Bike <span class="title">createBike</span><span class="params">()</span></span>;&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体 builder 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//摩拜单车Builder类public class MobikeBuilder extends Builder &#123;    @Override    public void buildFrame() &#123;        bike.setFrame(&quot;铝合金车架&quot;);    &#125;    @Override    public void buildSeat() &#123;        bike.setSeat(&quot;真皮车座&quot;);    &#125;    @Override    public Bike createBike() &#123;        return bike;    &#125;&#125;//ofo单车Builder类public class OfoBuilder extends Builder &#123;    @Override    public void buildFrame() &#123;        bike.setFrame(&quot;碳纤维车架&quot;);    &#125;    @Override    public void buildSeat() &#123;        bike.setSeat(&quot;橡胶车座&quot;);    &#125;    @Override    public Bike createBike() &#123;        return bike;    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>指挥者类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;    <span class="keyword">private</span> Builder builder;    <span class="function"><span class="keyword">public</span> <span class="title">Director</span><span class="params">(Builder builder)</span> </span>&#123;        <span class="keyword">this</span>.builder = builder;    &#125;    <span class="function"><span class="keyword">public</span> Bike <span class="title">construct</span><span class="params">()</span> </span>&#123;        builder.buildFrame();        builder.buildSeat();        <span class="keyword">return</span> builder.createBike();    &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    Director director = <span class="keyword">new</span> Director(<span class="keyword">new</span> MobileBuilder());    <span class="comment">// 指挥者指挥装配自行车    Bike bike = director.construct();    System.out.println(bike.getFrame() + bike.getSeat());&#125;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="模式拓展-2"><a href="#模式拓展-2" class="headerlink" title="模式拓展"></a>模式拓展</h4><p>当一个类构造器需要传入很多参数时，如果创建这个类的实例，代码可读性会非常差，而且很容易引入错误，此时就可以利用建造者模式进行重构</p><ul><li><p>重构前代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;    <span class="keyword">private</span> String cpu;    <span class="keyword">private</span> String screen;    <span class="keyword">private</span> String memory;    <span class="keyword">private</span> String mainboard;&#125;<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    <span class="comment">//构建Phone对象    Phone phone = new Phone(&quot;intel&quot;,&quot;三星屏幕&quot;,&quot;金士顿&quot;,&quot;华硕&quot;);    System.out.println(phone);&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>重构后的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;    <span class="keyword">private</span> String cpu;    <span class="keyword">private</span> String screen;    <span class="keyword">private</span> String memory;    <span class="keyword">private</span> String mainboard;    <span class="function"><span class="keyword">private</span> <span class="title">Phone</span><span class="params">(Builder builder)</span> </span>&#123;        cpu = builder.cpu;        screen = builder.screen;        memory = builder.memory;        mainboard = builder.mainboard;    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;        <span class="keyword">private</span> String cpu;        <span class="keyword">private</span> String screen;        <span class="keyword">private</span> String memory;        <span class="keyword">private</span> String mainboard;        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;&#125;<span class="comment">//返回值为this 所以支持链式编程        public Builder cpu(String val) &#123;            cpu = val;            return this;        &#125;        public Builder screen(String val) &#123;            screen = val;            return this;        &#125;        public Builder memory(String val) &#123;            memory = val;            return this;        &#125;        public Builder mainboard(String val) &#123;            mainboard = val;            return this;        &#125;        public Phone build() &#123;            return new Phone(this);        &#125;    &#125;&#125;public static void main(String[] args) &#123;    Phone phone = new Phone.Builder()        .cpu(&quot;intel&quot;)        .mainboard(&quot;华硕&quot;)        .memory(&quot;金士顿&quot;)        .screen(&quot;三星&quot;)        .build();    System.out.println(phone);&#125;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="模式对比"><a href="#模式对比" class="headerlink" title="模式对比"></a>模式对比</h4><p>工厂方法模式对比建造者模式</p><ul><li>工厂方法模式注重的是整体对象的创建方式</li><li>建造者模式注重的是部件构建的过程，意在通过一步一步地精确构造创建出一个复杂的对象</li></ul><p>抽象工厂模式对比建造者模式</p><ul><li><p>抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品，不需要关心构建过程，只关心什么产品由什么工厂生产即可</p></li><li><p>建造者模式则是要求按照指定的蓝图建造产品，主要目的是通过组装零配件而产生一个新产品</p><p>如果将抽象工厂模式看成汽车配件生产工厂，生产一个产品族的产品，那么建造者模式就是一个汽车组装工厂，通过对部件的组装可以返回一辆完整的汽车</p></li></ul><hr><h2 id="结构型"><a href="#结构型" class="headerlink" title="结构型"></a>结构型</h2><h3 id="模式分类"><a href="#模式分类" class="headerlink" title="模式分类"></a>模式分类</h3><p>结构型模式描述如何将类或对象按某种布局组成更大的结构，分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合方式来组合对象。由于组合关系或聚合关系比继承关系耦合度低，满足合成复用原则，所以对象结构型模式比类结构型模式具有更大的灵活性</p><p>结构型模式分为 7 种：代理模式、适配器模式、装饰者模式、桥接模式、外观模式、组合模式、享元模式</p><hr><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><p>代理模式：由于某些原因需要给某对象提供一个代理以控制对该对象的访问，访问对象不适合或者不能直接引用为目标对象，代理对象作为访问对象和目标对象之间的中介</p><p>Java 中的代理按照代理类生成时机不同又分为静态代理和动态代理，静态代理代理类在编译期就生成，而动态代理代理类则是在 Java 运行时动态生成，动态代理又有 JDK 代理和 CGLib 代理两种</p><p>代理（Proxy）模式分为三种角色：</p><ul><li>抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法</li><li>真实主题（Real Subject）类： 实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象</li><li>代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，可以访问、控制或扩展真实主题的功能</li></ul><p>买票案例，火车站是目标对象，代售点是代理对象</p><ul><li><p>卖票接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SellTickets</span> </span>&#123;    <span class="function"><span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span></span>;&#125;</span><br></pre></td></tr></table></figure></li><li><p>火车站，具有卖票功能，需要实现SellTickets接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrainStation</span> <span class="keyword">implements</span> <span class="title">SellTickets</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span> </span>&#123;        System.out.println(<span class="string">&quot;火车站卖票&quot;</span>);    &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>代售点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyPoint</span> <span class="keyword">implements</span> <span class="title">SellTickets</span> </span>&#123;    <span class="keyword">private</span> TrainStation station = <span class="keyword">new</span> TrainStation();    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span> </span>&#123;        System.out.println(<span class="string">&quot;代理点收取一些服务费用&quot;</span>);        station.sell();    &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        ProxyPoint pp = <span class="keyword">new</span> ProxyPoint();        pp.sell();    &#125;&#125;</span><br></pre></td></tr></table></figure><p>测试类直接访问的是 ProxyPoint 类对象，也就是 ProxyPoint 作为访问对象和目标对象的中介</p></li></ul><hr><h4 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h4><h5 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h5><p>Java 中提供了一个动态代理类 Proxy，Proxy 并不是代理对象的类，而是提供了一个创建代理对象的静态方法 newProxyInstance() 来获取代理对象</p><p><code>static Object newProxyInstance(ClassLoader loader,Class[] interfaces,InvocationHandler h) </code></p><ul><li><p>参数一：类加载器，负责加载代理类。传入类加载器，代理和被代理对象要用一个类加载器才是父子关系，不同类加载器加载相同的类在 JVM 中都不是同一个类对象</p></li><li><p>参数二：被代理业务对象的<strong>全部实现的接口</strong>，代理对象与真实对象实现相同接口，知道为哪些方法做代理</p></li><li><p>参数三：代理真正的执行方法，也就是代理的处理逻辑</p></li></ul><p>代码实现：</p><ul><li><p>代理工厂：创建代理对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> </span>&#123;    <span class="keyword">private</span> TrainStation station = <span class="keyword">new</span> TrainStation();<span class="comment">//也可以在参数中提供 getProxyObject(TrainStation station)    public SellTickets getProxyObject() &#123;        //使用 Proxy 获取代理对象        SellTickets sellTickets = (SellTickets) Proxy.newProxyInstance(            station.getClass().getClassLoader(),                station.getClass().getInterfaces(),                new InvocationHandler() &#123;                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;                        System.out.println(&quot;代理点(JDK动态代理方式)&quot;);                        //执行真实对象                        Object result = method.invoke(station, args);                        return result;                    &#125;                &#125;);        return sellTickets;    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        <span class="comment">//获取代理对象        ProxyFactory factory = new ProxyFactory();        //必须时代理ji        SellTickets proxyObject = factory.getProxyObject();        proxyObject.sell();    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h5><p>JDK 动态代理方式的优缺点：</p><ul><li>优点：可以为任意的接口实现类对象做代理，也可以为被代理对象的所有接口的所有方法做代理，动态代理可以在不改变方法源码的情况下，实现对方法功能的增强，提高了软件的可扩展性，Java 反射机制可以生成任意类型的动态代理类</li><li>缺点：<strong>只能针对接口或者接口的实现类对象做代理对象</strong>，普通类是不能做代理对象的</li><li>原因：<strong>生成的代理类继承了 Proxy</strong>，Java 是单继承的，所以 JDK 动态代理只能代理接口</li></ul><p>ProxyFactory 不是代理模式中的代理类，而代理类是程序在运行过程中动态的在内存中生成的类，可以通过 Arthas 工具查看代理类结构：</p><ul><li>代理类（$Proxy0）实现了 SellTickets 接口，真实类和代理类实现同样的接口</li><li>代理类（$Proxy0）将提供了的匿名内部类对象传递给了父类</li><li>代理类（$Proxy0）的修饰符是 public final</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 程序运行过程中动态生成的代理类public final class $Proxy0 extends Proxy implements SellTickets &#123;    private static Method m3;    public $Proxy0(InvocationHandler invocationHandler) &#123;        super(invocationHandler);//InvocationHandler对象传递给父类    &#125;    static &#123;        m3 = Class.forName(&quot;proxy.dynamic.jdk.SellTickets&quot;).getMethod(&quot;sell&quot;, new Class[0]);    &#125;    public final void sell() &#123;        // 调用InvocationHandler的invoke方法        this.h.invoke(this, m3, null);    &#125;&#125;// Java提供的动态代理相关类public class Proxy implements java.io.Serializable &#123;protected InvocationHandler h; protected Proxy(InvocationHandler h) &#123;        this.h = h;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>执行流程如下：</p><ol><li>在测试类中通过代理对象调用 sell() 方法</li><li>根据多态的特性，执行的是代理类（$Proxy0）中的 sell() 方法</li><li>代理类（$Proxy0）中的 sell() 方法中又调用了 InvocationHandler 接口的子实现类对象的 invoke 方法</li><li>invoke 方法通过反射执行了真实对象所属类（TrainStation）中的 sell() 方法</li></ol><hr><h5 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,                                      Class&lt;?&gt;[] interfaces,                                      InvocationHandler h)</span></span>&#123;    <span class="comment">// InvocationHandler 为空则抛出异常    Objects.requireNonNull(h);    // 复制一份 interfaces    final Class&lt;?&gt;[] intfs = interfaces.clone();    final SecurityManager sm = System.getSecurityManager();    if (sm != null) &#123;        checkProxyAccess(Reflection.getCallerClass(), loader, intfs);    &#125;    // 从缓存中查找 class 类型的代理对象，会调用 ProxyClassFactory#apply 方法    Class&lt;?&gt; cl = getProxyClass0(loader, intfs);//proxyClassCache = new WeakCache&lt;&gt;(new KeyFactory(), new ProxyClassFactory())     try &#123;        if (sm != null) &#123;            checkNewProxyPermission(Reflection.getCallerClass(), cl);        &#125;        // 获取代理类的构造方法，根据参数 InvocationHandler 匹配获取某个构造器        final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);        final InvocationHandler ih = h;        // 构造方法不是 pubic 的需要启用权限        if (!Modifier.isPublic(cl.getModifiers())) &#123;            AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123;                public Void run() &#123;                    // 设置可访问的权限                    cons.setAccessible(true);                    return null;                &#125;            &#125;);        &#125;       // cons 是构造方法，并且内部持有 InvocationHandler，在 InvocationHandler 中持有 target 目标对象        return cons.newInstance(new Object[]&#123;h&#125;);    &#125; catch (IllegalAccessException|InstantiationException e) &#123;&#125;&#125;</span></span><br></pre></td></tr></table></figure><p>Proxy 的静态内部类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyClassFactory</span> </span>&#123;    <span class="comment">// 代理类型的名称前缀    private static final String proxyClassNamePrefix = &quot;$Proxy&quot;;    // 生成唯一数字使用，结合上面的代理类型名称前缀一起生成    private static final AtomicLong nextUniqueNumber = new AtomicLong();//参数一：Proxy.newInstance 时传递的    //参数二：Proxy.newInstance 时传递的接口集合    @Override    public Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;        Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = new IdentityHashMap&lt;&gt;(interfaces.length);        // 遍历接口集合        for (Class&lt;?&gt; intf : interfaces) &#123;            Class&lt;?&gt; interfaceClass = null;            try &#123;                // 加载接口类到 JVM                interfaceClass = Class.forName(intf.getName(), false, loader);            &#125; catch (ClassNotFoundException e) &#123;            &#125;            if (interfaceClass != intf) &#123;                throw new IllegalArgumentException(                    intf + &quot; is not visible from class loader&quot;);            &#125;            // 如果 interfaceClass 不是接口 直接报错，保证集合内都是接口            if (!interfaceClass.isInterface()) &#123;                throw new IllegalArgumentException(                    interfaceClass.getName() + &quot; is not an interface&quot;);            &#125;            // 保证接口 interfaces 集合中没有重复的接口            if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) &#123;                throw new IllegalArgumentException(                    &quot;repeated interface: &quot; + interfaceClass.getName());            &#125;        &#125;        // 生成的代理类的包名        String proxyPkg = null;           // 【生成的代理类访问修饰符 public final】         int accessFlags = Modifier.PUBLIC | Modifier.FINAL;        // 检查接口集合内的接口，看看有没有某个接口的访问修饰符不是 public 的  如果不是 public 的接口，        // 生成的代理类 class 就必须和它在一个包下，否则访问出现问题        for (Class&lt;?&gt; intf : interfaces) &#123;            // 获取访问修饰符            int flags = intf.getModifiers();            if (!Modifier.isPublic(flags)) &#123;                accessFlags = Modifier.FINAL;                // 获取当前接口的全限定名 包名.类名                String name = intf.getName();                int n = name.lastIndexOf(&#x27;.&#x27;);                // 获取包名                String pkg = ((n == -1) ? &quot;&quot; : name.substring(0, n + 1));                if (proxyPkg == null) &#123;                    proxyPkg = pkg;                &#125; else if (!pkg.equals(proxyPkg)) &#123;                    throw new IllegalArgumentException(                        &quot;non-public interfaces from different packages&quot;);                &#125;            &#125;        &#125;        if (proxyPkg == null) &#123;            // if no non-public proxy interfaces, use com.sun.proxy package            proxyPkg = ReflectUtil.PROXY_PACKAGE + &quot;.&quot;;        &#125;        // 获取唯一的编号        long num = nextUniqueNumber.getAndIncrement();        // 包名+ $proxy + 数字，比如 $proxy1        String proxyName = proxyPkg + proxyClassNamePrefix + num;        // 【生成二进制字节码，这个字节码写入到文件内】，就是编译好的 class 文件        byte[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags);        try &#123;            // 【使用加载器加载二进制到 jvm】，并且返回 class            return defineClass0(loader, proxyName,                                proxyClassFile, 0, proxyClassFile.length);        &#125; catch (ClassFormatError e) &#123; &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="CGLIB"><a href="#CGLIB" class="headerlink" title="CGLIB"></a>CGLIB</h4><p>CGLIB 是一个功能强大，高性能的代码生成包，为没有实现接口的类提供代理，为 JDK 动态代理提供了补充（$$Proxy）</p><ul><li><p>CGLIB 是第三方提供的包，所以需要引入 jar 包的坐标：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>代理工厂类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;    <span class="keyword">private</span> TrainStation target = <span class="keyword">new</span> TrainStation();    <span class="function"><span class="keyword">public</span> TrainStation <span class="title">getProxyObject</span><span class="params">()</span> </span>&#123;        <span class="comment">//创建Enhancer对象，类似于JDK动态代理的Proxy类，下一步就是设置几个参数        Enhancer enhancer = new Enhancer();        //设置父类的字节码对象        enhancer.setSuperclass(target.getClass());        //设置回调函数        enhancer.setCallback(new MethodInterceptor() &#123;            @Override            public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123;System.out.println(&quot;代理点收取一些服务费用(CGLIB动态代理方式)&quot;);        Object o = methodProxy.invokeSuper(obj, args);        return null;//因为返回值为void            &#125;        &#125;);        //创建代理对象        TrainStation obj = (TrainStation) enhancer.create();        return obj;    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><p>CGLIB 的优缺点</p><ul><li>优点：<ul><li>CGLIB 动态代理<strong>不限定</strong>是否具有接口，可以对任意操作进行增强</li><li>CGLIB 动态代理无需要原始被代理对象，动态创建出新的代理对象</li><li><strong>JDKProxy 仅对接口方法做增强，CGLIB 对所有方法做增强</strong>，包括 Object 类中的方法，toString、hashCode 等</li></ul></li><li>缺点：CGLIB 不能对声明为 final 的类或者方法进行代理，因为 CGLIB 原理是<strong>动态生成被代理类的子类，继承被代理类</strong></li></ul><hr><h4 id="方式对比"><a href="#方式对比" class="headerlink" title="方式对比"></a>方式对比</h4><p>三种方式对比：</p><ul><li><p>动态代理和静态代理：</p><ul><li><p>动态代理将接口中声明的所有方法都被转移到一个集中的方法中处理（InvocationHandler.invoke），在接口方法数量比较多的时候，可以进行灵活处理，不需要像静态代理那样每一个方法进行中转</p></li><li><p>静态代理是在编译时就已经将接口、代理类、被代理类的字节码文件确定下来</p></li><li><p>动态代理是程序<strong>在运行后通过反射创建字节码文件</strong>交由 JVM 加载</p></li></ul></li><li><p>JDK 代理和 CGLIB 代理：</p><p>JDK 动态代理采用 ProxyGenerator.generateProxyClass() 方法在运行时生成字节码；CGLIB 底层采用 ASM 字节码生成框架，使用字节码技术生成代理类。在 JDK1.6之前比使用 Java 反射效率要高，到 JDK1.8 的时候，JDK 代理效率高于 CGLIB 代理。所以如果有接口或者当前类就是接口使用 JDK 动态代理，如果没有接口使用 CGLIB 代理</p></li></ul><p>代理模式的优缺点：</p><ul><li><p>优点：</p><ul><li>代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用</li><li><strong>代理对象可以增强目标对象的功能，内部持有原始的目标对象</strong></li><li>代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度</li></ul></li><li><p>缺点：增加了系统的复杂度</p></li></ul><p>代理模式的使用场景：</p><ul><li><p>远程（Remote）代理：本地服务通过网络请求远程服务，需要实现网络通信，处理其中可能的异常。为了良好的代码设计和可维护性，将网络通信部分隐藏起来，只暴露给本地服务一个接口，通过该接口即可访问远程服务提供的功能</p></li><li><p>防火墙（Firewall）代理：当你将浏览器配置成使用代理功能时，防火墙就将你的浏览器的请求转给互联网，当互联网返回响应时，代理服务器再把它转给你的浏览器</p></li><li><p>保护（Protect or Access）代理：控制对一个对象的访问，如果需要，可以给不同的用户提供不同级别的使用权限</p></li></ul><hr><h3 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h3><h4 id="基本介绍-5"><a href="#基本介绍-5" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>适配器：将一个类的接口转换成另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作，比如 Type-C 转接头</p><p>适配器模式分为类适配器模式和对象适配器模式，前者类之间的耦合度比后者高，且要求了解现有组件库中的相关组件的内部结构，所以应用相对较少</p><p>还有一个适配器模式是接口适配器模式，当不希望实现一个接口中所有的方法时，可以创建一个抽象类Adapter 实现所有方法，而此时我们只需要继承该抽象类实现自己想实现的功能即可</p><p>适配器模式（Adapter）包含以下主要角色：</p><ul><li>目标（Target）接口：当前系统业务所期待的接口，可以是抽象类或接口</li><li>适配者（Adaptee）类：被访问和适配的现存组件库中的组件接口</li><li>适配器（Adapter）类：是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让开发人员按目标接口的格式访问适配者</li></ul><hr><h4 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a>类适配器</h4><p>实现方式：定义一个适配器类来实现当前系统的业务接口，同时又继承现有组件库中已经存在的组件</p><p>例如：现有一台电脑只能读取 SD 卡，而要读取 TF 卡中的内容的话就需要使用到适配器模式</p><ul><li><p>SD 卡：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口public interface SDCard &#123;    //读取SD卡方法    String readSD();    //写入SD卡功能    void writeSD(String msg);&#125;//实现类public class SDCardImpl implements SDCard &#123;    public String readSD() &#123;        String msg = &quot;sd card read a msg :hello word SD&quot;;        return msg;    &#125;    public void writeSD(String msg) &#123;        System.out.println(&quot;sd card write msg : &quot; + msg);    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>电脑类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;    <span class="function"><span class="keyword">public</span> String <span class="title">readSD</span><span class="params">(SDCard sdCard)</span> </span>&#123;        <span class="keyword">if</span>(sdCard == <span class="keyword">null</span>) &#123;            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;sd card null&quot;</span>);        &#125;        <span class="keyword">return</span> sdCard.readSD();    &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>TF卡：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口public interface TFCard &#123;    //读取TF卡方法    String readTF();    //写入TF卡功能    void writeTF(String msg);&#125;//实现类public class TFCardImpl implements TFCard &#123;    public String readTF() &#123;        String msg =&quot;tf card read msg : hello word tf card&quot;;        return msg;    &#125;    public void writeTF(String msg) &#123;        System.out.println(&quot;tf card write a msg : &quot; + msg);    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>定义适配器类（SD兼容TF）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SDAdapterTF</span> <span class="keyword">extends</span> <span class="title">TFCardImpl</span> <span class="keyword">implements</span> <span class="title">SDCard</span> </span>&#123;    <span class="function"><span class="keyword">public</span> String <span class="title">readSD</span><span class="params">()</span> </span>&#123;        System.out.println(<span class="string">&quot;adapter read tf card &quot;</span>);        <span class="keyword">return</span> readTF();    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeSD</span><span class="params">(String msg)</span> </span>&#123;        System.out.println(<span class="string">&quot;adapter write tf card&quot;</span>);        writeTF(msg);    &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试类，可以读取 TF 卡中的数据了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    Computer computer = <span class="keyword">new</span> Computer();    SDAdapterTF adapter = <span class="keyword">new</span> SDAdapterTF();    System.out.println(computer.readSD(adapter));&#125;</span><br></pre></td></tr></table></figure></li></ul><p>类适配器模式违背了合成复用原则，类适配器是客户类有一个接口规范的情况下可用，反之不可用</p><hr><h4 id="对象适配"><a href="#对象适配" class="headerlink" title="对象适配"></a>对象适配</h4><p>对象适配器模式可釆用将现有组件库中已经实现的组件引入适配器类中，该类同时实现当前系统的业务接口</p><p>使用对象适配器模式将读卡器的案例进行改写：</p><ul><li><p>适配器类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SDAdapterTF</span> <span class="keyword">implements</span> <span class="title">SDCard</span> </span>&#123;    <span class="keyword">private</span> TFCard tfCard;    <span class="function"><span class="keyword">public</span> <span class="title">SDAdapterTF</span><span class="params">(TFCard tfCard)</span> </span>&#123;        <span class="keyword">this</span>.tfCard = tfCard;    &#125;        <span class="function"><span class="keyword">public</span> String <span class="title">readSD</span><span class="params">()</span> </span>&#123;        System.out.println(<span class="string">&quot;adapter read tf card &quot;</span>);        <span class="keyword">return</span> tfCard.readTF();    &#125;        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeSD</span><span class="params">(String msg)</span> </span>&#123;        System.out.println(<span class="string">&quot;adapter write tf card&quot;</span>);        tfCard.writeTF(msg);    &#125;&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><h5 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h5><ul><li>开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致</li><li>使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同</li></ul><h5 id="源码应用-1"><a href="#源码应用-1" class="headerlink" title="源码应用"></a>源码应用</h5><p>Reader（字符流）、InputStream（字节流）的适配使用的是InputStreamReader</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;    <span class="keyword">return</span> sd.read();<span class="comment">// sd StreamDecoder&#125;</span></span><br></pre></td></tr></table></figure><p>StreamDecoder 用来编码解码，编码：字符转为字节；解码：字节转字符</p><img src="https://gitee.com/seazean/images/raw/master/Java/适配器模式-字符流与字节流源码解析.png" style="zoom:80%;"><hr><h3 id="装饰者"><a href="#装饰者" class="headerlink" title="装饰者"></a>装饰者</h3><h4 id="基本介绍-6"><a href="#基本介绍-6" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>装饰者模式：指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式</p><p>使用继承的方式存在的问题：扩展性不好、产生过多的子类</p><p>装饰（Decorator）模式中的角色：</p><ul><li>抽象构件（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象</li><li>具体构件（Concrete  Component）角色：实现抽象构件，通过装饰角色为其添加一些职责</li><li>抽象装饰（Decorator）角色：继承或实现抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能</li><li>具体装饰（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任</li></ul><hr><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><p>对快餐进行装饰，增加鸡蛋或者培根</p><ul><li><p>快餐类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FastFood</span> </span>&#123;    <span class="keyword">private</span> <span class="keyword">float</span> price;    <span class="keyword">private</span> String desc;<span class="comment">// set + get    public abstract float cost();  //获取价格&#125;//炒饭public class FriedRice extends FastFood &#123;    public FriedRice() &#123;        super(10, &quot;炒饭&quot;);    &#125;    public float cost() &#123;        return getPrice();    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>配料类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Garnish</span> <span class="keyword">extends</span> <span class="title">FastFood</span> </span>&#123;    <span class="keyword">private</span> FastFood fastFood;    <span class="comment">//get + set         public Garnish(FastFood fastFood, float price, String desc) &#123;        super(price,desc);        this.fastFood = fastFood;    &#125;&#125;//鸡蛋配料public class Egg extends Garnish &#123;    public Egg(FastFood fastFood) &#123;        super(fastFood, 1, &quot;鸡蛋&quot;);    &#125;    public float cost() &#123;        return getPrice() + getFastFood().getPrice();    &#125;    @Override    public String getDesc() &#123;        return super.getDesc() + getFastFood().getDesc();    &#125;&#125;//培根配料public class Bacon extends Garnish &#123;    public Bacon(FastFood fastFood) &#123;        super(fastFood, 2, &quot;培根&quot;);    &#125;    @Override    public float cost() &#123;        return getPrice() + getFastFood().getPrice();    &#125;    @Override    public String getDesc() &#123;        return super.getDesc() + getFastFood().getDesc();    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        <span class="comment">//点一份炒饭        FastFood food = new FriedRice();        //花费的价格        System.out.println(food.getDesc() + &quot; &quot; + food.cost() + &quot;元&quot;);        System.out.println(&quot;========&quot;);        //点一份加鸡蛋的炒饭        FastFood food1 = new FriedRice();        food1 = new Egg(food1);        //花费的价格        System.out.println(food1.getDesc() + &quot; &quot; + food1.cost() + &quot;元&quot;);    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h4><h5 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h5><ul><li><p>当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时</p><p>不能采用继承的情况主要有两类：</p><ul><li>第一类是系统中存在大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目增长很多</li><li>第二类是因为类定义不能继承（如final类）</li></ul></li><li><p>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责</p><p>当对象的功能要求可以动态地添加，也可以再动态地撤销时</p></li></ul><h5 id="源码应用-2"><a href="#源码应用-2" class="headerlink" title="源码应用"></a>源码应用</h5><p>IO流中的包装类使用到了装饰者模式，BufferedInputStream，BufferedOutputStream，BufferedReader，BufferedWriter</p><p>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;        <span class="comment">//创建FileWriter对象        FileWriter fw = new FileWriter(&quot;C:\\Users\\Think\\Desktop\\a.txt&quot;);        //创建BufferedWriter对象        BufferedWriter bw = new BufferedWriter(fw);        //写数据        bw.write(&quot;hello Buffered&quot;);        bw.close();    &#125;&#125;</span></span><br></pre></td></tr></table></figure><img src="https://gitee.com/seazean/images/raw/master/Java/装饰者模式-缓冲流源码.png" style="zoom:67%;"><p>​    BufferedWriter 使用装饰者模式对 Writer 子实现类进行了增强，添加了缓冲区，提高了读写数据的效率</p><hr><h4 id="模式对比-1"><a href="#模式对比-1" class="headerlink" title="模式对比"></a>模式对比</h4><p>静态代理和装饰者模式的区别：</p><ul><li>相同点：<ul><li>都要实现与目标类相同的业务接口</li><li>在两个类中都要声明目标对象</li><li>都可以在不修改目标类的前提下增强目标方法</li></ul></li><li>不同点：<ul><li>目的不同：装饰者是为了增强目标对象，静态代理是为了保护和隐藏目标对象</li><li>获取目标对象构建的地方不同：装饰者是由外界传递进来，可以通过构造方法传递；静态代理是在代理类内部创建，以此来隐藏目标对象</li></ul></li></ul><hr><h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><h4 id="基本介绍-7"><a href="#基本介绍-7" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>桥接模式：将抽象与实现分离，使它们可以独立变化，用组合关系代替继承关系实现，从而降低了抽象和实现这两个可变维度的耦合度</p><p>桥接（Bridge）模式包含以下主要角色：</p><ul><li>抽象化（Abstraction）角色 ：定义抽象类，并包含一个对实现化对象的引用</li><li>扩展抽象化（Refined  Abstraction）角色 ：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法</li><li>实现化（Implementor）角色 ：定义实现化角色的接口，供扩展抽象化角色调用</li><li>具体实现化（Concrete Implementor）角色 ：给出实现化角色接口的具体实现</li></ul><p>应用场景：</p><ul><li>当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时</li><li>当一个系统不希望使用继承或因为多层次继承导致系统类的数量增加时</li><li>当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系</li></ul><p>优点：桥接模式提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。如果现在还有一种视频文件类型 wmv，只需再定义一个类实现 VideoFile 接口即可，其他类不需要发生变化</p><hr><h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><p>开发一个跨平台视频播放器，可以在不同操作系统平台（如Windows、Mac、Linux等）上播放多种格式的视频文件，常见的视频格式包括RMVB、AVI、WMV等，该播放器包含了两个维度，适合使用桥接模式</p><ul><li><p>视频文件类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//视频文件public interface VideoFile &#123;    void decode(String fileName);&#125;//avi文件public class AVIFile implements VideoFile &#123;    public void decode(String fileName) &#123;        System.out.println(&quot;avi视频文件:&quot; + fileName);    &#125;&#125;//rmvb文件public class REVBBFile implements VideoFile &#123;    public void decode(String fileName) &#123;        System.out.println(&quot;rmvb文件:&quot; + fileName);    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>操作系统类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//操作系统版本public abstract class OperatingSystemVersion &#123;    protected VideoFile videoFile;    public OperatingSystemVersion(VideoFile videoFile) &#123;        this.videoFile = videoFile;    &#125;        public abstract void play(String fileName);&#125;//Windows版本public class Windows extends OperatingSystem &#123;    public Windows(VideoFile videoFile) &#123;        super(videoFile);    &#125;    public void play(String fileName) &#123;        videoFile.decode(fileName);    &#125;&#125;//mac版本public class Mac extends OperatingSystemVersion &#123;    public Mac(VideoFile videoFile) &#123;        super(videoFile);    &#125;    public void play(String fileName) &#123;videoFile.decode(fileName);    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        OperatingSystem os = <span class="keyword">new</span> Windows(<span class="keyword">new</span> AVIFile());        os.play(<span class="string">&quot;The Godfather&quot;</span>);    &#125;&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h3><h4 id="基本介绍-8"><a href="#基本介绍-8" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>外观模式：又名门面模式，是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性，是“迪米特法则”的典型应用</p><p>外观（Facade）模式包含以下主要角色：</p><ul><li>外观（Facade）角色：为多个子系统对外提供一个共同的接口</li><li>子系统（Sub System）角色：实现系统的部分功能，用户可以通过外观角色访问它</li></ul><p>模式优点：</p><ul><li>降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类</li><li>对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易</li></ul><p>模式缺点：不符合开闭原则，修改很麻烦</p><hr><h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><p>智能家电控制，一键关闭或者开启所有家电</p><ul><li><p>子系统角色：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//灯类public class Light &#123;    public void on() &#123;        System.out.println(&quot;打开了灯....&quot;);    &#125;    public void off() &#123;        System.out.println(&quot;关闭了灯....&quot;);    &#125;&#125;//电视类public class TV &#123;    public void on() &#123;        System.out.println(&quot;打开了电视....&quot;);    &#125;    public void off() &#123;        System.out.println(&quot;关闭了电视....&quot;);    &#125;&#125;//空调类public class AirCondition &#123;    public void on() &#123;        System.out.println(&quot;打开了空调....&quot;);    &#125;    public void off() &#123;        System.out.println(&quot;关闭了空调....&quot;);    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>外观角色：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//智能音箱public class SmartAppliancesFacade &#123;    private Light light;    private TV tv;    private AirCondition airCondition;    public SmartAppliancesFacade() &#123;        light = new Light();        tv = new TV();        airCondition = new AirCondition();    &#125;    public void say(String message) &#123;        if(message.contains(&quot;打开&quot;)) &#123;            on();        &#125; else if(message.contains(&quot;关闭&quot;)) &#123;            off();        &#125; else &#123;            System.out.println(&quot;我还听不懂你说的！！！&quot;);        &#125;    &#125;    //起床后一键开电器    private void on() &#123;        System.out.println(&quot;起床了&quot;);        light.on();        tv.on();        airCondition.on();    &#125;    //睡觉一键关电器    private void off() &#123;        System.out.println(&quot;睡觉了&quot;);        light.off();        tv.off();        airCondition.off();    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    <span class="comment">//创建外观对象    SmartAppliancesFacade facade = new SmartAppliancesFacade();    //客户端直接与外观对象进行交互    facade.say(&quot;打开家电&quot;);    facade.say(&quot;关闭家电&quot;);&#125;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h4><h5 id="使用场景-3"><a href="#使用场景-3" class="headerlink" title="使用场景"></a>使用场景</h5><ul><li>对分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系</li><li>当一个复杂系统的子系统很多时，外观模式可以为系统设计一个简单的接口供外界访问</li><li>当客户端与多个子系统之间存在很大的联系时，引入外观模式可将它们分离，从而提高子系统的独立性和可移植性</li></ul><h5 id="源码应用-3"><a href="#源码应用-3" class="headerlink" title="源码应用"></a>源码应用</h5><p>RequestFacade 类使用了外观模式</p><img src="https://gitee.com/seazean/images/raw/master/Java/外观模式-Servlet源码解析.png" style="zoom:67%;"><p>定义 RequestFacade 类，分别实现 ServletRequest ，同时定义私有成员变量 Request，并且方法的实现调用 Request  的实现。然后将 RequestFacade 上转为 ServletRequest  传给 servlet 的 service 方法，这样即使在 servlet 中被下转为 RequestFacade ，也不能访问私有成员变量对象中的方法。既用了 Request 又能防止其中方法被不合理的访问</p><hr><h3 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h3><h4 id="基本介绍-9"><a href="#基本介绍-9" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>组合模式：部分整体模式，用于把一组相似的对象当作一个单一的对象，组合模式依据树形结构来组合对象，用来表示部分以及整体层次，创建了对象组的树形结构，类比 Linux 树形文件图</p><p>组合模式主要包含三种角色：</p><ul><li>抽象根节点（Component）：定义系统各层次对象的共有方法和属性，可以预先定义一些默认行为和属性</li><li>树枝节点（Composite）：定义树枝节点的行为，存储子节点，组合树枝节点和叶子节点形成一个树形结构</li><li>叶子节点（Leaf）：叶子节点对象，其下再无分支，是系统层次遍历的最小单位</li></ul><p>应用场景：组合模式应树形结构而生，所以组合模式的使用场景就是出现树形结构的地方，比如文件目录显示，多级目录呈现等树形结构数据的操作</p><p>在使用组合模式时，根据抽象构件类的定义形式，可将组合模式分为透明组合模式和安全组合模式两种形式：</p><ul><li><p>透明组合模式</p><p>透明组合模式中，抽象根节点角色中声明了所有用于管理成员对象的方法，比如在示例中 <code>MenuComponent</code> 声明了 <code>add</code>、<code>remove</code> 、<code>getChild</code> 方法，这样做的好处是确保所有的构件类都有相同的接口，透明组合模式也是组合模式的标准形式</p><p>透明组合模式的缺点是不够安全，因为叶子对象和容器对象在本质上是有区别的，叶子对象不可能有下一个层次的对象，即不可能包含成员对象，因此为其提供 add()、remove() 等方法是没有意义的，这在编译阶段不会出错，但在运行阶段如果调用这些方法可能会出错（如果没有提供相应的错误处理代码）</p></li><li><p>安全组合模式</p><p>在安全组合模式中，在抽象构件角色中没有声明任何用于管理成员对象的方法，而是在树枝节点 <code>Menu</code> 类中声明并实现这些方法。安全组合模式的缺点是不够透明，因为叶子构件和容器构件具有不同的方法，且容器构件中那些用于管理成员对象的方法没有在抽象构件类中定义，因此客户端不能完全针对抽象编程，必须有区别地对待叶子构件和容器构件</p></li></ul><p>组合模式的优点：</p><ul><li>组合模式可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，让客户端忽略了层次的差异，方便对整个层次结构进行控制</li><li>客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码</li><li>在组合模式中增加新的树枝节点和叶子节点都很方便，无须对现有类库进行任何修改，符合“开闭原则”</li><li>组合模式为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子节点和树枝节点的递归组合，可以形成复杂的树形结构，但对树形结构的控制却非常简单</li></ul><hr><h4 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h4><p>不管是菜单还是菜单项，都应该继承自统一的接口，将这个统一的接口称为菜单组件</p><ul><li><p>菜单组件：</p><p>MenuComponent 定义为抽象类，有一些共有的属性和行为要在该类中实现，其他类就可以只覆盖自己需要的方法。这里给出的默认实现是抛出异常，可以根据自己的需要改写默认实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MenuComponent</span> </span>&#123;    <span class="keyword">protected</span> String name;    <span class="keyword">protected</span> <span class="keyword">int</span> level;<span class="comment">//层级 几级菜单    //添加菜单    public void add(MenuComponent menuComponent)&#123;        throw new UnsupportedOperationException();    &#125;    //移除菜单    public void remove(MenuComponent menuComponent)&#123;        throw new UnsupportedOperationException();    &#125;    //获取指定的子菜单    public MenuComponent getChild(int i)&#123;        throw new UnsupportedOperationException();    &#125;    //获取菜单名称    public String getName()&#123;        return name;    &#125;    public void print()&#123;        throw new UnsupportedOperationException();    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>菜单：</p><p>Menu 类具有添加菜单，移除菜单和获取子菜单的功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Menu</span> <span class="keyword">extends</span> <span class="title">MenuComponent</span> </span>&#123;    <span class="keyword">private</span> List&lt;MenuComponent&gt; menuComponentList;    <span class="function"><span class="keyword">public</span> <span class="title">Menu</span><span class="params">(String name,<span class="keyword">int</span> level)</span></span>&#123;        <span class="keyword">this</span>.level = level;        <span class="keyword">this</span>.name = name;        menuComponentList = <span class="keyword">new</span> ArrayList&lt;MenuComponent&gt;();    &#125;    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(MenuComponent menuComponent)</span> </span>&#123;        menuComponentList.add(menuComponent);    &#125;    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(MenuComponent menuComponent)</span> </span>&#123;        menuComponentList.remove(menuComponent);    &#125;    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> MenuComponent <span class="title">getChild</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;        <span class="keyword">return</span> menuComponentList.get(i);    &#125;    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; level; i++) &#123;            System.out.print(<span class="string">&quot;--&quot;</span>);        &#125;        System.out.println(name);        <span class="keyword">for</span> (MenuComponent menuComponent : menuComponentList) &#123;            menuComponent.print();        &#125;    &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>菜单项：</p><p>MenuItem 是菜单项，不能再有子菜单，所以添加菜单，移除菜单和获取子菜单的功能并不能实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MenuItem</span> <span class="keyword">extends</span> <span class="title">MenuComponent</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="title">MenuItem</span><span class="params">(String name, <span class="keyword">int</span> level)</span> </span>&#123;        <span class="keyword">this</span>.name = name;        <span class="keyword">this</span>.level = level;    &#125;    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; level; i++) &#123;            System.out.print(<span class="string">&quot;--&quot;</span>);        &#125;        System.out.println(name);    &#125;&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><h4 id="基本介绍-10"><a href="#基本介绍-10" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>享元模式：运用共享技术来有效地支持大量细粒度对象的复用，共享已经存在的对象来大幅度减少大量相似对象的开销，从而提高系统资源的利用率</p><p>享元（Flyweight ）模式中存在以下两种状态：</p><ul><li>内部状态，不会随着环境的改变而改变的可共享部分</li><li>外部状态，随着环境改变而改变的不可以共享的部分，享元模式的实现要领就是区分应用中的这两种状态，并将外部状态外部化</li></ul><p>享元模式的主要有以下角色：</p><ul><li>抽象享元角色（Flyweight）：通常是一个接口或抽象类，在抽象享元类中声明具体享元类公共的方法，这些方法可以向外界提供享元对象的内部数据（内部状态），也可以通过这些方法来设置外部数据（外部状态）</li><li>具体享元（Concrete Flyweight）角色 ：实现了抽象享元类，称为享元对象，在具体享元类中为内部状态提供了存储空间。通常结合单例模式来设计具体享元类，为每一个具体享元类提供唯一的享元对象</li><li>非享元（Unsharable Flyweight）角色 ：并不是所有的抽象享元类的子类都需要被共享，不能被共享的子类可设计为非共享具体享元类，当需要一个非共享具体享元类的对象时可以直接通过实例化创建</li><li>享元工厂（Flyweight Factory）角色 ：负责创建和管理享元角色。当用户请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象，如果存在则提供给用户；如果不存在则创建一个新的享元对象</li></ul><p>模式优点：</p><ul><li>极大减少内存中相似或相同对象数量，节约系统资源，提供系统性能</li><li>享元模式中的外部状态相对独立，且不影响内部状态</li></ul><p>模式缺点：为了使对象可以共享，需要将享元对象的部分状态外部化，分离内部状态和外部状态，使程序逻辑复杂</p><hr><h4 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h4><p>俄罗斯方块，类图：</p><img src="https://gitee.com/seazean/images/raw/master/Java/Design-享元模式俄罗斯方块.png" style="zoom:67%;"><ul><li><p>抽象享元角色：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBox</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getShape</span><span class="params">()</span></span>;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(String color)</span> </span>&#123;        System.out.println(<span class="string">&quot;方块形状：&quot;</span> + <span class="keyword">this</span>.getShape() + <span class="string">&quot; 颜色：&quot;</span> + color);    &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体享元角色：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IBox</span> <span class="keyword">extends</span> <span class="title">AbstractBox</span> </span>&#123;    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> String <span class="title">getShape</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> <span class="string">&quot;I&quot;</span>;    &#125;&#125;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LBox</span> <span class="keyword">extends</span> <span class="title">AbstractBox</span> </span>&#123;    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> String <span class="title">getShape</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> <span class="string">&quot;L&quot;</span>;    &#125;&#125;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OBox</span> <span class="keyword">extends</span> <span class="title">AbstractBox</span> </span>&#123;    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> String <span class="title">getShape</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> <span class="string">&quot;O&quot;</span>;    &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>享元工厂角色：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoxFactory</span> </span>&#123;    <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;String, AbstractBox&gt; map;    <span class="function"><span class="keyword">private</span> <span class="title">BoxFactory</span><span class="params">()</span> </span>&#123;        map = <span class="keyword">new</span> HashMap&lt;String, AbstractBox&gt;();        AbstractBox iBox = <span class="keyword">new</span> IBox();        AbstractBox lBox = <span class="keyword">new</span> LBox();        AbstractBox oBox = <span class="keyword">new</span> OBox();        map.put(<span class="string">&quot;I&quot;</span>, iBox);        map.put(<span class="string">&quot;L&quot;</span>, lBox);        map.put(<span class="string">&quot;O&quot;</span>, oBox);    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> BoxFactory <span class="title">getInstance</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> SingletonHolder.INSTANCE;    &#125;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BoxFactory INSTANCE = <span class="keyword">new</span> BoxFactory();    &#125;    <span class="function"><span class="keyword">public</span> AbstractBox <span class="title">getBox</span><span class="params">(String key)</span> </span>&#123;        <span class="keyword">return</span> map.get(key);    &#125;&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h4><h5 id="使用场景-4"><a href="#使用场景-4" class="headerlink" title="使用场景"></a>使用场景</h5><ul><li>一个系统有大量相同或者相似的对象，造成内存的大量耗费</li><li>对象的大部分状态都可以外部化，可以将这些外部状态传入对象中</li><li>在使用享元模式时需要维护一个存储享元对象的享元池，而这需要耗费一定的系统资源，应当在需要多次重复使用享元对象时才值得使用享元模式</li></ul><h5 id="源码应用-4"><a href="#源码应用-4" class="headerlink" title="源码应用"></a>源码应用</h5><p>Integer类使用了享元模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        Integer i1 = <span class="number">127</span>;        Integer i2 = <span class="number">127</span>;        System.out.println(<span class="string">&quot;i1和i2对象是否是同一个对象？&quot;</span> + (i1 == i2));<span class="comment">//true        Integer i3 = 128;        Integer i4 = 128;        System.out.println(&quot;i3和i4对象是否是同一个对象？&quot; + (i3 == i4));//false    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>反编译后发现直接给 Integer 类型的变量赋值基本数据类型数据的操作底层使用的是 <code>valueOf()</code></p><p><code>Integer</code> 默认先创建并缓存 <code>-128 ~ 127</code> 之间数的 <code>Integer</code> 对象，当调用 <code>valueOf</code> 时如果参数在 <code>-128 ~ 127</code> 之间则计算下标并从缓存中返回，否则创建一个新的 <code>Integer</code> 对象</p><hr><h2 id="行为型"><a href="#行为型" class="headerlink" title="行为型"></a>行为型</h2><h3 id="模式分类-1"><a href="#模式分类-1" class="headerlink" title="模式分类"></a>模式分类</h3><p>行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，涉及算法与对象间职责的分配</p><p>行为型模式分为类行为模式和对象行为模式，前者采用继承机制来在类间分派行为，后者采用组合或聚合在对象间分配行为，由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象行为模式比类行为模式具有更大的灵活性</p><p>除了模板方法模式和解释器模式是类行为型模式，其他的全部属于对象行为型模式</p><hr><h3 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h3><h4 id="基本介绍-11"><a href="#基本介绍-11" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>模板方法模式：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤</p><p>模板方法（Template Method）模式包含以下主要角色：</p><ul><li><p>抽象类（Abstract Class）：负责给出一个算法的轮廓和骨架，由一个模板方法和若干个基本方法构成</p><ul><li><p>模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法</p></li><li><p>基本方法：是实现算法各个步骤的方法，是模板方法的组成部分，基本方法又可以分为三种：</p><ul><li><p>抽象方法(Abstract Method)：一个抽象方法由抽象类声明，由其具体子类实现</p></li><li><p>具体方法(Concrete Method)：一个具体方法由一个抽象类或具体类声明并实现，其子类可以进行覆盖也可以直接继承</p></li><li><p>钩子方法(Hook Method)：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法</p><p>一般钩子方法是用于判断的逻辑方法，这类方法名一般为isXxx，返回值类型为boolean类型</p></li></ul></li></ul></li><li><p>具体子类（Concrete Class）：实现抽象类中所定义的抽象方法和钩子方法，是一个顶级逻辑的组成步骤</p></li></ul><p>模式优点：</p><ul><li>提高代码复用性，将相同部分的代码放在抽象的父类中，而将不同的代码放入不同的子类中</li><li>实现反向控制，通过一个父类调用其子类的操作，通过对子类的具体实现扩展不同的行为，实现了反向控制，并符合开闭原则</li></ul><p>模式缺点：</p><ul><li>对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象</li><li>父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，提高了代码阅读的难度</li></ul><hr><h4 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h4><p>炒菜步骤是固定的，现通过模板方法模式来用代码模拟</p><ul><li><p>抽象类：</p><p>注意：为防止恶意操作，一般模板方法都加上 final 关键词</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClass</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">cookProcess</span><span class="params">()</span> </span>&#123;        <span class="comment">//第一步：倒油        this.pourOil();        //第二步：热油        this.heatOil();        //第三步：倒蔬菜        this.pourVegetable();        //第四步：倒调味料        this.pourSauce();        //第五步：翻炒        this.fry();    &#125;//第一步：倒油    public void pourOil() &#123;        System.out.println(&quot;倒油&quot;);    &#125;    //第二步：热油是一样的，所以直接实现    public void heatOil() &#123;        System.out.println(&quot;热油&quot;);    &#125;    //第三步：倒蔬菜是不一样的    public abstract void pourVegetable();    //第四步：倒调味料是不一样    public abstract void pourSauce();    //第五步：翻炒是一样的，所以直接实现    public void fry()&#123;        System.out.println(&quot;炒啊炒啊炒到熟啊&quot;);    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>具体子类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteClass_BaoCai</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span> </span>&#123;    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pourVegetable</span><span class="params">()</span> </span>&#123;        System.out.println(<span class="string">&quot;下锅的蔬菜是包菜&quot;</span>);    &#125;    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pourSauce</span><span class="params">()</span> </span>&#123;        System.out.println(<span class="string">&quot;下锅的酱料是辣椒&quot;</span>);    &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    <span class="comment">//炒手撕包菜    ConcreteClass_BaoCai baoCai = new ConcreteClass_BaoCai();    baoCai.cookProcess();&#125;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="应用场景-5"><a href="#应用场景-5" class="headerlink" title="应用场景"></a>应用场景</h4><h5 id="使用场景-5"><a href="#使用场景-5" class="headerlink" title="使用场景"></a>使用场景</h5><ul><li>算法的整体步骤很固定，但其中个别部分易变时，这时使用模板方法模式将易变的部分抽象出来，供子类实现</li><li>需要通过子类来决定父类算法中某个步骤是否执行，实现子类对父类的反向控制</li></ul><h5 id="源码应用-5"><a href="#源码应用-5" class="headerlink" title="源码应用"></a>源码应用</h5><p>InputStream类就使用了模板方法模式，在InputStream类中定义了多个 read() 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">InputStream</span> <span class="keyword">implements</span> <span class="title">Closeable</span> </span>&#123;    <span class="comment">//抽象方法，要求子类必须重写    public abstract int read() throws IOException;    public int read(byte b[]) throws IOException &#123;...&#125;    public int read(byte b[], int off, int len) throws IOException &#123;        //...        int c = read(); //调用了无参的read方法，该方法是每次读取一个字节数据        //...    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>在 InputStream 父类中已经定义好了读取一个字节数组数据的方法是每次读取一个字节，并将其存储到数组的第一个索引位置，读取 len 个字节数据，具体如何读取一个字节数据由子类实现</p><hr><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><h4 id="基本介绍-12"><a href="#基本介绍-12" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>策略模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的用户。策略模式属于对象行为模式，通过对算法进行封装，把使用算法和算法的实现分割开来，并委派给不同的对象对这些算法进行管理</p><p>策略模式的主要角色如下：</p><ul><li>抽象策略（Strategy）类：一个抽象角色，通常由一个接口或抽象类实现，给出所有的具体策略类所需的接口</li><li>具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现或行为</li><li>环境（Context）类：持有一个策略类的引用，最终给客户端调用</li></ul><p>模式优点：</p><ul><li>策略类之间可以自由切换，由于策略类都实现同一个接口，所以使它们之间可以自由切换</li><li>易于扩展，增加一个新的策略只需要添加一个具体的策略类，基本不需要改变原有的代码，符合开闭原则</li><li>避免使用多重条件选择语句（if else），充分体现面向对象设计思想</li></ul><p>缺点：</p><ul><li>客户端必须知道所有的策略类，并自行决定使用哪一个策略类</li><li>策略模式将造成产生很多策略类，可以通过使用享元模式在一定程度上减少对象的数量</li></ul><hr><h4 id="代码实现-8"><a href="#代码实现-8" class="headerlink" title="代码实现"></a>代码实现</h4><p>促销活动，针对不同的节日推出不同的促销活动，由促销员将促销活动展示给客户</p><ul><li><p>抽象策略类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;        <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体策略类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为春节准备的促销活动Apublic class StrategyA implements Strategy &#123;    public void show() &#123;        System.out.println(&quot;买一送一&quot;);    &#125;&#125;//为中秋准备的促销活动Bpublic class StrategyB implements Strategy &#123;    public void show() &#123;        System.out.println(&quot;满200元减50元&quot;);    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>环境类：用于连接上下文，即把促销活动推销给客户，这里可以理解为促销员</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SalesMan</span> </span>&#123;                            <span class="comment">//持有抽象策略角色的引用                                  private Strategy strategy;                                                      public SalesMan(Strategy strategy) &#123;               this.strategy = strategy;                  &#125;                                                                        //向客户展示促销活动                                    public void salesManShow()&#123;                        strategy.show();                           &#125;                                          &#125;                                              </span></span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="应用场景-6"><a href="#应用场景-6" class="headerlink" title="应用场景"></a>应用场景</h4><h5 id="使用场景-6"><a href="#使用场景-6" class="headerlink" title="使用场景"></a>使用场景</h5><ul><li>一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中</li><li>一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入各自的策略类中以代替这些条件语句</li><li>系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时</li><li>系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关的数据结构</li><li>多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为</li></ul><hr><h5 id="源码应用-6"><a href="#源码应用-6" class="headerlink" title="源码应用"></a>源码应用</h5><p>Comparator 中的策略模式，在 Arrays 类中有一个 sort() 方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] a, Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span> </span>&#123;    <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;        sort(a);    &#125; <span class="keyword">else</span> &#123;        <span class="keyword">if</span> (LegacyMergeSort.userRequested)            legacyMergeSort(a, c);        <span class="keyword">else</span>            TimSort.sort(a, <span class="number">0</span>, a.length, c, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);    &#125;&#125;</span><br></pre></td></tr></table></figure><p>Arrays 就是一个环境角色类，这个 sort 方法可以传一个新策略让Arrays根据这个策略来进行排序，Comparator充当的是抽象策略角色，而具体的子实现类充当的是具体策略角色</p><p>通过 TimSort 类的 sort() 方法，最终会跑到 <code>countRunAndMakeAscending()</code> 这个方法中，只用了 compare 方法，所以在调用 Arrays.sort 方法只传具体 compare 重写方法的类对象就可以，这也是 Comparator 接口中必须要子类实现的一个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">int</span> <span class="title">countRunAndMakeAscending</span><span class="params">(T[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi,Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span> </span>&#123;    <span class="keyword">assert</span> lo &lt; hi;    <span class="keyword">int</span> runHi = lo + <span class="number">1</span>;    <span class="keyword">if</span> (runHi == hi)        <span class="keyword">return</span> <span class="number">1</span>;    <span class="comment">// Find end of run, and reverse range if descending    if (c.compare(a[runHi++], a[lo]) &lt; 0) &#123; // Descending        while (runHi &lt; hi &amp;&amp; c.compare(a[runHi], a[runHi - 1]) &lt; 0)            runHi++;        reverseRange(a, lo, runHi);    &#125; else &#123;                              // Ascending        while (runHi &lt; hi &amp;&amp; c.compare(a[runHi], a[runHi - 1]) &gt;= 0)            runHi++;    &#125;    return runHi - lo;&#125;</span></span><br></pre></td></tr></table></figure><hr><h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><h4 id="基本介绍-13"><a href="#基本介绍-13" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>命令模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开，这样两者之间通过命令对象进行沟通，方便将命令对象进行存储、传递、调用、增加与管理</p><p>命令模式包含以下主要角色：</p><ul><li>抽象命令类（Command）角色：定义命令的接口，声明执行的方法。</li><li>具体命令（Concrete  Command）角色：具体的命令，实现命令接口，通常会持有接收者，并调用接收者的功能来完成命令要执行的操作</li><li>实现者/接收者（Receiver）角色：接收者，真正执行命令的对象，任何类都可能成为一个接收者，只要能够实现命令要求实现的相应功能</li><li>调用者/请求者（Invoker）角色：要求命令对象执行请求，通常会持有命令对象，可以持有很多的命令对象。这个是客户端真正触发命令并要求命令执行相应操作的地方，也就是说相当于使用命令对象的入口</li></ul><p>模式优点：</p><ul><li>降低系统的耦合度，命令模式能将调用操作的对象与实现该操作的对象解耦</li><li>增加或删除命令非常方便，采用命令模式增加与删除命令不会影响其他类，满足“开闭原则”，对扩展比较灵活</li><li>可以实现宏命令，命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令</li><li>方便实现 Undo 和 Redo 操作，命令模式可以与备忘录模式结合，实现命令的撤销与恢复</li></ul><p>模式缺点：</p><ul><li>使用命令模式可能会导致某些系统有过多的具体命令类。</li><li>系统结构更加复杂</li></ul><hr><h4 id="代码实现-9"><a href="#代码实现-9" class="headerlink" title="代码实现"></a>代码实现</h4><p>饭店案例</p><ul><li><p>抽象命令类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;        <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;<span class="comment">//只需要定义一个统一的执行方法&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>具体命令角色：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;    <span class="comment">// 餐桌号码    private int diningTable;    //set + get    // 用来存储餐名并记录份数    private Map&lt;String, Integer&gt; foodDic = new HashMap&lt;String, Integer&gt;();    public Map&lt;String, Integer&gt; getFoodDic() &#123;        return foodDic;    &#125;    public void setFoodDic(String name, int num) &#123;        foodDic.put(name,num);    &#125;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;    <span class="comment">//持有接受者对象    private SeniorChef receiver;    private Order order;    public OrderCommand(SeniorChef receiver, Order order)&#123;        this.receiver = receiver;        this.order = order;    &#125;    public void execute()  &#123;        System.out.println(order.getDiningTable() + &quot;桌的订单：&quot;);        Set&lt;String&gt; keys = order.getFoodDic().keySet();        for (String key : keys) &#123;            receiver.makeFood(order.getFoodDic().get(key),key);        &#125;        try &#123;            Thread.sleep(100);//停顿一下 模拟做饭的过程        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.out.println(order.getDiningTable() + &quot;桌的饭弄好了&quot;);    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>接收者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 厨师类public class SeniorChef &#123;    public void makeFood(int num, String foodName) &#123;        System.out.println(num + &quot;份&quot; + foodName);    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>请求者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务员类public class Waitor &#123;    private ArrayList&lt;Command&gt; commands;//可以持有很多的命令对象    public Waitor() &#123;        commands = new ArrayList();    &#125;        public void setCommand(Command cmd)&#123;        //存储d        commands.add(cmd);    &#125;    // 发出命令 喊 订单来了，厨师开始执行    public void orderUp() &#123;        System.out.println(&quot;服务员：大厨，新订单来了.......&quot;);        for (int i = 0; i &lt; commands.size(); i++) &#123;            Command cmd = commands.get(i);            if (cmd != null) &#123;                cmd.execute();            &#125;        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    <span class="comment">//创建1个order    Order order = new Order();    order.setDiningTable(1);    order.getFoodDic().put(&quot;西红柿鸡蛋面&quot;,1);    order.getFoodDic().put(&quot;小杯可乐&quot;,2);    //创建接收者    SeniorChef receiver=new SeniorChef();    //将订单和接收者封装成命令对象    OrderCommand cmd = new OrderCommand(receiver, order1);    //创建调用者 waitor    Waitor invoker = new Waitor();    invoker.setCommand(cmd);    //将订单带到柜台 并向厨师喊 订单来了    invoker.orderUp();&#125;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="应用场景-7"><a href="#应用场景-7" class="headerlink" title="应用场景"></a>应用场景</h4><h5 id="使用场景-7"><a href="#使用场景-7" class="headerlink" title="使用场景"></a>使用场景</h5><ul><li>系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互</li><li>系统需要在不同的时间指定请求、将请求排队和执行请求</li><li>系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作</li></ul><h5 id="源码应用-7"><a href="#源码应用-7" class="headerlink" title="源码应用"></a>源码应用</h5><p>Runable 是一个典型命令模式，Runnable 担当命令的角色，Thread 充当的是调用者，start 方法就是其执行方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//命令接口(抽象命令角色)public interface Runnable &#123;public abstract void run();&#125;//调用者public class Thread implements Runnable &#123;    private Runnable target;    public synchronized void start() &#123;        //...        start0();       //....    &#125;    private native void start0();&#125;</span></span><br></pre></td></tr></table></figure><p>调用一个 native 方法 start0()，调用系统方法，开启一个线程。而接收者是对程序员开放的，可以自定义接收者</p><hr><h3 id="责任链"><a href="#责任链" class="headerlink" title="责任链"></a>责任链</h3><h4 id="基本介绍-14"><a href="#基本介绍-14" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>责任链模式：为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链，当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止</p><p>职责链模式主要包含以下角色：</p><ul><li>抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接</li><li>具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给后继者</li><li>客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，不关心处理细节和请求的传递过程</li></ul><p>模式优点：</p><ul><li><p>降低了对象之间的耦合度，降低了请求发送者和接收者的耦合度</p></li><li><p>增强了系统的可扩展性，可以根据需要增加新的请求处理类，满足开闭原则</p></li><li><p>增强了给对象指派职责的灵活性，当工作流程发生变化，可以动态地改变链内的成员或者修改它们的次序，也可动态地新增或者删除责任</p></li><li><p>责任链简化了对象之间的连接，一个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if···else 语句。</p></li><li><p>责任分担，每个类只需要处理自己该处理的工作，不能处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则</p></li></ul><p>模式缺点：</p><ul><li>不能保证每个请求一定被处理，由于一个请求没有明确的接收者，所以不能保证一定会被处理，该请求可能一直传到链的末端都得不到处理</li><li>对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响</li><li>职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用</li></ul><hr><h4 id="代码实现-10"><a href="#代码实现-10" class="headerlink" title="代码实现"></a>代码实现</h4><p>开发一个请假流程控制系统，请假一天以下的假只需要小组长同意即可，请假1天到3天的假还需要部门经理同意，请求3天到7天还需要总经理同意才行</p><ul><li><p>请假类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeaveRequest</span> </span>&#123;    <span class="keyword">private</span> String name;<span class="comment">//姓名    private int num;//请假天数    private String content;//请假内容// constructor + set + get&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>抽象处理者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//处理者抽象类public abstract class Handler &#123;    protected final static int NUM_ONE = 1;    protected final static int NUM_THREE = 3;    protected final static int NUM_SEVEN = 7;    //该领导处理的请假天数区间    private int numStart;    private int numEnd;    //领导上面还有领导    private Handler nextHandler;    //设置请假天数范围 上不封顶    public Handler(int numStart) &#123;        this.numStart = numStart;    &#125;    //设置请假天数范围    public Handler(int numStart, int numEnd) &#123;        this.numStart = numStart;        this.numEnd = numEnd;    &#125;    //设置上级领导    public void setNextHandler(Handler nextHandler)&#123;        this.nextHandler = nextHandler;    &#125;    //提交请假条    public final void submit(LeaveRequest leave)&#123;        if(0 == this.numStart)&#123;            return;        &#125;        //如果请假天数达到该领导者的处理要求        if(leave.getNum() &gt;= this.numStart)&#123;            this.handleLeave(leave);            //如果还有上级 并且请假天数超过了当前领导的处理范围            if(null != this.nextHandler &amp;&amp; leave.getNum() &gt; numEnd)&#123;                this.nextHandler.submit(leave);//继续提交            &#125; else &#123;                System.out.println(&quot;流程结束&quot;);            &#125;        &#125;    &#125;    //各级领导处理请假条方法    protected abstract void handleLeave(LeaveRequest leave);&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>具体处理者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupLeader</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="title">GroupLeader</span><span class="params">()</span> </span>&#123;        <span class="comment">//小组长处理1-3天的请假        super(Handler.NUM_ONE, Handler.NUM_THREE);    &#125;    @Override    protected void handleLeave(LeaveRequest leave) &#123;        System.out.println(leave.getName() + &quot;请假&quot; + leave.getNum() + &quot;天,&quot; + leave.getContent() + &quot;。&quot;);        System.out.println(&quot;小组长审批：同意。&quot;);    &#125;&#125;//部门经理public class Manager extends Handler &#123;    public Manager() &#123;        //部门经理处理3-7天的请假        super(Handler.NUM_THREE, Handler.NUM_SEVEN);    &#125;    @Override    protected void handleLeave(LeaveRequest leave) &#123;        System.out.println(leave.getName() + &quot;请假&quot; + leave.getNum() + &quot;天,&quot; + leave.getContent() + &quot;。&quot;);        System.out.println(&quot;部门经理审批：同意。&quot;);    &#125;&#125;//总经理public class GeneralManager extends Handler &#123;    public GeneralManager() &#123;        //部门经理处理7天以上的请假        super(Handler.NUM_SEVEN);    &#125;    @Override    protected void handleLeave(LeaveRequest leave) &#123;        System.out.println(leave.getName() + &quot;请假&quot; + leave.getNum() + &quot;天,&quot; + leave.getContent() + &quot;。&quot;);        System.out.println(&quot;总经理审批：同意。&quot;);    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    <span class="comment">//请假条来一张    LeaveRequest leave = new LeaveRequest(&quot;小花&quot;,5,&quot;身体不适&quot;);    //各位领导    GroupLeader groupLeader = new GroupLeader();    Manager manager = new Manager();    GeneralManager generalManager = new GeneralManager();    groupLeader.setNextHandler(manager);//小组长的领导是部门经理    manager.setNextHandler(generalManager);//部门经理的领导是总经理    //之所以在这里设置上级领导，是因为可以根据实际需求来更改设置，如果实战中上级领导人都是固定的，则可以移到领导实现类中。    //提交申请    groupLeader.submit(leave);&#125;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="应用场景-8"><a href="#应用场景-8" class="headerlink" title="应用场景"></a>应用场景</h4><p>在 JavaWeb 应用开发中，FilterChain是职责链（过滤器）模式的典型应用，以下是 Filter 的模拟实现：</p><p>类似于栈的执行流程，先进先出</p><ul><li><p>模拟 web 请求 Request 以及 web 响应 Response：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Request</span></span>&#123;&#125;<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Response</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>模拟 web 过滤器 Filter：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Filter</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(Request req, Response res, FilterChain c)</span></span>;&#125;</span><br></pre></td></tr></table></figure></li><li><p>模拟实现具体过滤器  ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(Request request, Response response, FilterChain chain)</span> </span>&#123;        System.out.println(<span class="string">&quot;过滤器1 前置处理&quot;</span>);        <span class="comment">// 先执行所有request再倒序执行所有response        chain.doFilter(request, response);        System.out.println(&quot;过滤器1 后置处理&quot;);    &#125;&#125;public class SecondFilter implements Filter &#123;    @Override    public void doFilter(Request request, Response response, FilterChain chain) &#123;        System.out.println(&quot;过滤器2 前置处理&quot;);        // 先执行所有request再倒序执行所有response        chain.doFilter(request, response);        System.out.println(&quot;过滤器2 后置处理&quot;);    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>模拟实现过滤器链FilterChain  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterChain</span> </span>&#123;    <span class="keyword">private</span> List&lt;Filter&gt; filters = <span class="keyword">new</span> ArrayList&lt;Filter&gt;();    <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;    <span class="comment">// 链式调用    public FilterChain addFilter(Filter filter) &#123;        this.filters.add(filter);        return this;    &#125;    public void doFilter(Request request, Response response) &#123;        if (index == filters.size()) &#123;            return;        &#125;        Filter filter = filters.get(index);        index++;        filter.doFilter(request, response, this);    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        Request  req = <span class="keyword">null</span>;        Response res = <span class="keyword">null</span> ;        FilterChain filterChain = <span class="keyword">new</span> FilterChain();        filterChain.addFilter(<span class="keyword">new</span> FirstFilter()).addFilter(<span class="keyword">new</span> SecondFilter());        filterChain.doFilter(req,res);    &#125;&#125;<span class="comment">/*过滤器1 前置处理过滤器2 前置处理过滤器2 后置处理过滤器1 后置处理*/</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h3><h4 id="基本介绍-15"><a href="#基本介绍-15" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>在状态模式（State Pattern）中，类的行为是基于它的状态改变的</p><p>状态模式包含以下主要角色。</p><ul><li>环境（Context）角色：也称为上下文，它定义了客户程序需要的接口，维护一个当前状态，并将与状态相关的操作委托给当前状态对象来处理</li><li>抽象状态（State）角色：定义一个接口，用以封装环境对象中的特定状态所对应的行为</li><li>具体状态（Concrete  State）角色：实现抽象状态所对应的行为</li></ul><p>模式优点：</p><ul><li>将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为</li><li>允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块</li></ul><p>模式缺点：</p><ul><li>状态模式的使用必然会增加系统类和对象的个数。 </li><li>状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱</li><li>状态模式对开闭原则的支持并不太好</li></ul><p>使用场景：</p><ul><li>当一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为时，可以使用状态模式</li><li>一个操作中含有庞大的分支结构，并且这些分支决定于对象的状态时</li></ul><hr><h4 id="代码实现-11"><a href="#代码实现-11" class="headerlink" title="代码实现"></a>代码实现</h4><p>通过按钮来控制一个电梯的状态，一个电梯有开门状态，关门状态，停止状态，运行状态，每一种状态改变，都有可能要根据其他状态来更新处理</p><ul><li><p>抽象状态角色：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LiftState</span> </span>&#123;        <span class="comment">//定义一个环境角色，也就是封装状态的变化引起的功能变化        protected Context context;        public void setContext(Context context) &#123;                this.context = context;        &#125;        //电梯开门动作        public abstract void open();        //电梯关门动作        public abstract void close();        //电梯运行动作        public abstract void run();        //电梯停止动作        public abstract void stop();&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>电梯门开启状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OpenningState</span> <span class="keyword">extends</span> <span class="title">LiftState</span> </span>&#123;            <span class="meta">@Override</span>        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;                System.out.println(<span class="string">&quot;电梯门开启...&quot;</span>);        &#125;    <span class="comment">//开启了就可以关闭了        @Override        public void close() &#123;                //状态修改                super.context.setLiftState(Context.closeingState);                //动作委托为CloseState来执行，也就是委托给了ClosingState子类执行这个动作                super.context.getLiftState().close();        &#125;        //电梯门不能开着就跑，这里什么也不做        @Override    public void run() &#123;               //do nothing        &#125;        //开门状态已经是停止的了        @Override        public void stop() &#123;                //do nothing        &#125;&#125;//电梯门关闭状态 省略</span></span><br></pre></td></tr></table></figure></li><li><p>电梯运行状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunningState</span> <span class="keyword">extends</span> <span class="title">LiftState</span> </span>&#123;        <span class="comment">//运行的时候不能开电梯门        @Override        public void open() &#123;                //do nothing        &#125;        //电梯门关闭？这是肯定了        @Override        public void close() &#123;        //虽然可以关门，但这个动作不归我执行                //do nothing        &#125;        //这是在运行状态下要实现的方法        @Override        public void run() &#123;                System.out.println(&quot;电梯正在运行...&quot;);        &#125;        //这个事是合理的        @Override        public void stop() &#123;                super.context.setLiftState(Context.stoppingState);                super.context.stop();        &#125;&#125;//电梯停止状态 省略</span></span><br></pre></td></tr></table></figure></li><li><p>环境角色类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;        <span class="comment">//定义出所有的电梯状态，开门状态，这时候电梯只能关闭        public final static OpenningState openningState = new OpenningState();        //关闭状态，这时候电梯可以运行、停止和开门        public final static ClosingState closeingState = new ClosingState();        //运行状态，这时候电梯只能停止        public final static RunningState runningState = new RunningState();        //停止状态，这时候电梯可以开门、运行        public final static StoppingState stoppingState = new StoppingState();        //定义一个当前电梯状态        private LiftState liftState;        public LiftState getLiftState() &#123;                return this.liftState;        &#125;       public void setLiftState(LiftState liftState) &#123;                //当前环境改变                this.liftState = liftState;                //把当前的环境通知到各个实现类中                this.liftState.setContext(this);        &#125;        public void open() &#123;                this.liftState.open();        &#125;        public void close() &#123;                this.liftState.close();        &#125;        public void run() &#123;                this.liftState.run();        &#125;        public void stop() &#123;                this.liftState.stop();        &#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        Context context = <span class="keyword">new</span> Context();        context.setLiftState(<span class="keyword">new</span> ClosingState());        context.open();        context.close();        context.run();        context.stop();&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="观察者"><a href="#观察者" class="headerlink" title="观察者"></a>观察者</h3><h4 id="基本介绍-16"><a href="#基本介绍-16" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>观察者模式：又称为发布-订阅（Publish/Subscribe）模式，定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态变化时，会通知所有的观察者对象，使他们能够自动更新自己</p><p>在观察者模式中有如下角色：</p><ul><li>Subject：抽象主题（抽象被观察者），抽象主题角色把所有观察者对象保存在一个集合里，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象</li><li>ConcreteSubject：具体主题（具体被观察者），该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知</li><li>Observer：抽象观察者，是观察者的抽象类，定义了一个更新接口，在得到主题更改通知时更新自己</li><li>ConcrereObserver：具体观察者，实现抽象观察者定义的更新接口，在得到主题更改通知时更新自身状态</li></ul><p>模式优点：</p><ul><li>降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系</li><li>被观察者发送通知，所有注册的观察者都会收到信息，可以实现<strong>广播</strong>机制</li></ul><p>模式缺点：</p><ul><li>如果观察者非常多的话，那么所有的观察者收到被观察者发送的通知会比较耗时</li><li>如果被观察者有循环依赖的话，那么被观察者发送通知会使观察者循环调用，会导致系统崩溃</li></ul><hr><h4 id="代码实现-12"><a href="#代码实现-12" class="headerlink" title="代码实现"></a>代码实现</h4><p>微信公众号订阅，微信用户就是观察者，微信公众号是被观察者</p><img src="https://gitee.com/seazean/images/raw/master/Java/Design-观察者模式.png" style="zoom: 80%;"><ul><li><p>抽象观察者类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;        <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(String message)</span></span>;&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体观察者类，微信用户是观察者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeixinUser</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;        <span class="comment">// 微信用户名        private String name;        public WeixinUser(String name) &#123;                this.name = name;        &#125;        @Override        public void update(String message) &#123;                System.out.println(name + &quot;-&quot; + message);        &#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>抽象主题类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;        <span class="comment">//增加订阅者        public void attach(Observer observer);        //删除订阅者        public void detach(Observer observer);        //通知订阅者更新消息        public void notify(String message);&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>微信公众号是具体主题（具体被观察者）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubscriptionSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;        <span class="comment">//储存订阅公众号的微信用户        private List&lt;Observer&gt; weixinUserlist = new ArrayList&lt;Observer&gt;();        @Override        public void attach(Observer observer) &#123;                weixinUserlist.add(observer);        &#125;        @Override        public void detach(Observer observer) &#123;                weixinUserlist.remove(observer);        &#125;        @Override        public void notify(String message) &#123;                for (Observer observer : weixinUserlist) &#123;                        observer.update(message);                &#125;        &#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        SubscriptionSubject mSubscriptionSubject = <span class="keyword">new</span> SubscriptionSubject();        <span class="comment">//创建微信用户        WeixinUser user1 = new WeixinUser(&quot;孙悟空&quot;);        WeixinUser user2 = new WeixinUser(&quot;猪悟能&quot;);        WeixinUser user3 = new WeixinUser(&quot;沙悟净&quot;);        //订阅公众号        mSubscriptionSubject.attach(user1);        mSubscriptionSubject.attach(user2);        mSubscriptionSubject.attach(user3);        //公众号更新发出消息给订阅的微信用户        mSubscriptionSubject.notify(&quot;唐僧的专栏更新了&quot;);&#125;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="应用场景-9"><a href="#应用场景-9" class="headerlink" title="应用场景"></a>应用场景</h4><h5 id="使用场景-8"><a href="#使用场景-8" class="headerlink" title="使用场景"></a>使用场景</h5><ul><li>对象间存在一对多关系，一个对象的状态发生改变会影响其他对象</li><li>当一个抽象模型有两个方面，其中一个方面依赖于另一方面时</li></ul><h5 id="源码应用-8"><a href="#源码应用-8" class="headerlink" title="源码应用"></a>源码应用</h5><p>在 Java 中，通过 java.util.Observable 类和 java.util.Observer 接口定义了观察者模式，只要实现它们的子类就可以编写观察者模式实例</p><ul><li><p>Observable类是抽象目标类（被观察者），有一个 Vector 集合成员变量，保存所有要通知的观察者对象</p><ul><li><p><code>void addObserver(Observer o)</code>：用于将新的观察者对象添加到集合中</p></li><li><p><code>void notifyObservers(Object arg)</code>：调用集合中的所有观察者对象的 update 方法，通知它们数据发生改变，通常越晚加入集合的观察者越先得到通知（从后向前遍历）</p></li><li><p><code>void setChange()</code>：用来设置一个 boolean 类型的内部标志，注明目标对象发生了变化，当它为true时，notifyObservers() 就会通知观察者</p></li></ul></li><li><p>Observer 接口是抽象观察者，监视目标对象的变化，当目标对象发生变化时，观察者得到通知，并调用 update 方法，进行相应的工作</p></li></ul><p>实例：警察抓小偷使用观察者模式来实现，代码如下：</p><ul><li><p>小偷是一个被观察者，需要继承Observable类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thief</span> <span class="keyword">extends</span> <span class="title">Observable</span> </span>&#123;    <span class="keyword">private</span> String name;<span class="comment">// construct + set + get    public void steal() &#123;        System.out.println(&quot;小偷：我偷东西了，有没有人来抓我！！！&quot;);        super.setChanged(); //changed  = true        super.notifyObservers();    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>警察是一个观察者，需要实现Observer接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Policemen</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;    <span class="keyword">private</span> String name;<span class="comment">// construct + set + get    @Override    public void update(Observable o, Object arg) &#123;        System.out.println(&quot;警察：&quot; + ((Thief) o).getName() + &quot;，我盯你很久了&quot;);    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    <span class="comment">//创建小偷对象    Thief t = new Thief(&quot;12&quot;);    //创建警察对象    Policemen p = new Policemen(&quot;66&quot;);    //让警察盯着小偷    t.addObserver(p);    //小偷偷东西    t.steal();&#125;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="中介者"><a href="#中介者" class="headerlink" title="中介者"></a>中介者</h3><h4 id="基本介绍-17"><a href="#基本介绍-17" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>中介者模式：又叫调停模式，定义一个中介角色来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互<br><img src="https://gitee.com/seazean/images/raw/master/Java/Design-中介者模式.png" style="zoom:67%;"></p><p>中介者模式包含以下主要角色：</p><ul><li>抽象中介者（Mediator）角色：中介者的接口，提供了同事对象注册与转发同事对象信息的抽象方法</li><li>具体中介者（ConcreteMediator）角色：实现中介者接口，定义一个 List 来管理同事对象，协调各个同事角色之间的交互关系，因此依赖于同事角色</li><li>抽象同事类（Colleague）角色：定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能</li><li>具体同事类（Concrete Colleague）角色：是抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互</li></ul><p>模式优点：</p><ul><li><p>松散耦合：中介者模式通过把多个同事对象之间的交互封装到中介者对象里面，从而使得同事对象之间松散耦合，基本上可以做到互补依赖，同事对象就可以独立地变化和复用</p></li><li><p>集中控制交互：多个同事对象的交互，被封装在中介者对象里面集中管理，使得这些交互行为发生变化时，只需要修改中介者对象就可以，如果是已经做好的系统，那么就扩展中介者对象，而各个同事类不需要做修改</p></li><li><p>一对多关联转变为一对一的关联：没有使用中介者模式的时候，同事对象之间的关系通常是一对多的，引入中介者对象以后，中介者对象和同事对象的关系通常变成双向的一对一，这会让对象的关系更容易理解和实现</p></li></ul><p>模式缺点：当同事类太多时，中介者的职责将很大，会变得复杂而庞大，以至于系统难以维护</p><p>应用场景：</p><ul><li>系统中对象之间存在复杂的引用关系，系统结构混乱且难以理解。</li><li>当想创建一个运行于多个类之间的对象，又不想生成新的子类时</li></ul><hr><h4 id="代码实现-13"><a href="#代码实现-13" class="headerlink" title="代码实现"></a>代码实现</h4><p>案例：通过房屋中介租房</p><ul><li><p>抽象中介者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Mediator</span> </span>&#123;    <span class="comment">//申明一个联络方法    public abstract void constact(String message,Person person);&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>抽象同事类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;    <span class="keyword">protected</span> String name;    <span class="keyword">protected</span> Mediator mediator;    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, Mediator mediator)</span></span>&#123;        <span class="keyword">this</span>.name = name;        <span class="keyword">this</span>.mediator = mediator;    &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体同事类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 房屋拥有者public class HouseOwner extends Person &#123;    public HouseOwner(String name, Mediator mediator) &#123;        super(name, mediator);    &#125;    //与中介者联系    public void constact(String message)&#123;        mediator.constact(message, this);    &#125;    //获取信息    public void getMessage(String message)&#123;        System.out.println(&quot;房主&quot; + name +&quot;获取到的信息：&quot; + message);    &#125;&#125;//承租人public class Tenant extends Person &#123;    public Tenant(String name, Mediator mediator) &#123;        super(name, mediator);    &#125;    //与中介者联系    public void constact(String message)&#123;        mediator.constact(message, this);    &#125;    //获取信息    public void getMessage(String message)&#123;        System.out.println(&quot;租房者&quot; + name +&quot;获取到的信息：&quot; + message);    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>具体中介者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MediatorStructure</span> <span class="keyword">extends</span> <span class="title">Mediator</span> </span>&#123;    <span class="comment">//首先中介结构必须知道所有房主和租房者的信息    private HouseOwner houseOwner;    private Tenant tenant;//set + get        public void constact(String message, Person person) &#123;        if (person == houseOwner) &#123;//如果是房主，则租房者获得信息            tenant.getMessage(message);        &#125; else &#123;       //反正则是房主获得信息            houseOwner.getMessage(message);        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    <span class="comment">//一个房主、一个租房者、一个中介机构    MediatorStructure mediator = new MediatorStructure();    //房主和租房者只需要知道中介机构即可    HouseOwner houseOwner = new HouseOwner(&quot;张三&quot;, mediator);    Tenant tenant = new Tenant(&quot;李四&quot;, mediator);    //中介结构要知道房主和租房者    mediator.setHouseOwner(houseOwner);    mediator.setTenant(tenant);    tenant.constact(&quot;需要租三室的房子&quot;);    houseOwner.constact(&quot;我这有三室的房子，你需要租吗？&quot;);&#125;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><h4 id="基本介绍-18"><a href="#基本介绍-18" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>迭代器模式：提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示</p><p>迭代器模式主要包含以下角色：</p><ul><li><p>抽象聚合（Aggregate）角色：定义存储、添加、删除聚合元素以及创建迭代器对象的接口</p></li><li><p>具体聚合（ConcreteAggregate）角色：实现抽象聚合类，返回一个具体迭代器的实例</p></li><li><p>抽象迭代器（Iterator）角色：定义访问和遍历聚合元素的接口，通常包含 hasNext()、next() 等方法</p></li><li><p>具体迭代器（Concretelterator）角色：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置</p></li></ul><p>模式优点：</p><ul><li>支持以不同的方式遍历一个聚合对象，在迭代器模式中只要用一个不同的迭代器来替换原有迭代器即可改变遍历算法，也可以自定义迭代器的子类以支持新的遍历方式</li><li>迭代器简化了聚合类，在原有的聚合对象中不需要再自行提供数据遍历等方法，这样可以简化聚合类的设计</li><li>在迭代器模式中，由于引入了抽象层，增加新的聚合类和迭代器类都很方便，无须修改原有代码，满足开闭原则的要求</li></ul><p>模式缺点：增加了类的个数，这在一定程度上增加了系统的复杂</p><hr><h4 id="代码实现-14"><a href="#代码实现-14" class="headerlink" title="代码实现"></a>代码实现</h4><p>定义一个可以存储学生对象的容器对象，将遍历该容器的功能交由迭代器实现</p><ul><li><p>迭代器接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentIterator</span> </span>&#123;    <span class="comment">//判断是否还有元素    boolean hasNext();    //获取下一个元素    Student next();&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>具体的迭代器类，重写所有的抽象方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentIteratorImpl</span> <span class="keyword">implements</span> <span class="title">StudentIterator</span> </span>&#123;    <span class="keyword">private</span> List&lt;Student&gt; list;    <span class="keyword">private</span> <span class="keyword">int</span> position = <span class="number">0</span>;<span class="comment">//用来记录遍历时的位置    public StudentIteratorImpl(List&lt;Student&gt; list) &#123;        this.list = list;    &#125;    @Override    public boolean hasNext() &#123;        return position &lt; list.size();    &#125;    @Override    public Student next() &#123;        Student currentStudent = list.get(position);        position ++;        return currentStudent;    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>抽象容器类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentAggregate</span> </span>&#123;    <span class="function"><span class="keyword">void</span> <span class="title">addStudent</span><span class="params">(Student student)</span></span>;    <span class="function"><span class="keyword">void</span> <span class="title">removeStudent</span><span class="params">(Student student)</span></span>;    <span class="function">StudentIterator <span class="title">getStudentIterator</span><span class="params">()</span></span>;&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体容器类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentAggregateImpl</span> <span class="keyword">implements</span> <span class="title">StudentAggregate</span> </span>&#123;    <span class="keyword">private</span> List&lt;Student&gt; list = <span class="keyword">new</span> ArrayList&lt;Student&gt;();  <span class="comment">// 学生列表    @Override    public void addStudent(Student student) &#123;        this.list.add(student);    &#125;    @Override    public void removeStudent(Student student) &#123;        this.list.remove(student);    &#125;    @Override    public StudentIterator getStudentIterator() &#123;        return new StudentIteratorImpl(list);    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="应用场景-10"><a href="#应用场景-10" class="headerlink" title="应用场景"></a>应用场景</h4><p>使用场景：</p><ul><li>需要为聚合对象提供多种遍历方式</li><li>需要为遍历不同的聚合结构提供一个统一的接口</li><li>访问一个聚合对象的内容而无须暴露其内部细节的表示</li></ul><p>使用 JAVA 开发的时候，想使用迭代器模式，只要让自定义的容器类实现 <code>java.util.Iterable</code> 并实现其中的iterator() 方法使其返回一个 <code>java.util.Iterator</code> 的实现类就可以</p><hr><h3 id="访问者"><a href="#访问者" class="headerlink" title="访问者"></a>访问者</h3><h4 id="基本介绍-19"><a href="#基本介绍-19" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>访问者模式：封装一些作用于某种数据结构中的各元素的操作，可以在不改变这个数据结构的前提下定义作用于这些元素的新操作</p><p>访问者模式包含以下主要角色:</p><ul><li>抽象访问者（Visitor）角色：定义了对每一个元素（Element）访问的行为，它的参数就是可以访问的元素，它的方法个数理论上来讲与元素类个数（Element 的实现类个数）是一样的，从这点不难看出，访问者模式要求元素类的个数不能改变</li><li>具体访问者（ConcreteVisitor）角色：给出对每一个元素类访问时所产生的具体行为</li><li>抽象元素（Element）角色：定义了一个接受访问者的方法（accept），每一个元素都可以被访问者访问</li><li>具体元素（ConcreteElement）角色： 提供接受访问方法的具体实现，而这个具体的实现，通常情况下是使用访问者提供的访问该元素类的方法</li><li>对象结构（Object Structure）角色：定义当中所提到的对象结构，对象结构是一个抽象表述，可以理解为一个具有容器性质或者复合对象特性的类，它含有一组元素并且可以迭代这些元素，供访问者访问</li></ul><p>模式优点：</p><ul><li><p>扩展性好，在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能</p></li><li><p>复用性好，通过访问者来定义整个对象结构通用的功能，从而提高复用程度</p></li><li><p>分离无关行为，通过访问者来分离无关的行为，把相关的行为封装在一起构成一个访问者，这样每一个访问者的功能都比较单一</p></li></ul><p>模式缺点：</p><ul><li>对象结构变化很困难，在访问者模式中，每增加一个新的元素类，都要在每一个具体访问者类中增加相应的具体操作，这违背了开闭原则</li><li>违反了依赖倒置原则，访问者模式依赖了具体类，而没有依赖抽象类</li></ul><p>应用场景：</p><ul><li><p>对象结构相对稳定，但其操作算法经常变化的程序</p></li><li><p>对象结构中的对象需要提供多种不同且不相关的操作，而且要避免让这些操作的变化影响对象的结构</p></li></ul><hr><h4 id="代码实现-15"><a href="#代码实现-15" class="headerlink" title="代码实现"></a>代码实现</h4><p>以给宠物喂食为例，当然宠物还分为狗，猫等，要给宠物喂食的话，主人可以喂，其他人也可以喂食</p><ul><li>访问者角色：给宠物喂食的人</li><li>具体访问者角色：主人、其他人</li><li>抽象元素角色：动物抽象类</li><li>具体元素角色：宠物狗、宠物猫</li><li>结构对象角色：主人家</li></ul><p><img src="https://gitee.com/seazean/images/raw/master/Java/Design-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F.png"></p><ul><li><p>抽象访问者接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;    <span class="function"><span class="keyword">void</span> <span class="title">feed</span><span class="params">(Cat cat)</span></span>;    <span class="function"><span class="keyword">void</span> <span class="title">feed</span><span class="params">(Dog dog)</span></span>;&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体访问者角色，需要实现 Person 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Owner</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">feed</span><span class="params">(Cat cat)</span> </span>&#123;        System.out.println(<span class="string">&quot;主人喂食猫&quot;</span>);    &#125;    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">feed</span><span class="params">(Dog dog)</span> </span>&#123;        System.out.println(<span class="string">&quot;主人喂食狗&quot;</span>);    &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>抽象元素接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Animal</span> </span>&#123;    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(Person person)</span></span>;&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体元素角色：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">implements</span> <span class="title">Animal</span> </span>&#123;    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Person person)</span> </span>&#123;        person.feed(<span class="keyword">this</span>);        System.out.println(<span class="string">&quot;汪汪汪！！！&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">implements</span> <span class="title">Animal</span> </span>&#123;    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Person person)</span> </span>&#123;        person.feed(<span class="keyword">this</span>);        System.out.println(<span class="string">&quot;喵喵喵！！！&quot;</span>);    &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>对象结构，此案例中是主人的家：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Home</span> </span>&#123;    <span class="keyword">private</span> List&lt;Animal&gt; nodeList = <span class="keyword">new</span> ArrayList&lt;Animal&gt;();        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">(Person person)</span> </span>&#123;        <span class="keyword">for</span> (Animal node : nodeList) &#123;            node.accept(person);        &#125;    &#125;    <span class="comment">//添加操作    public void add(Animal animal) &#123;        nodeList.add(animal);    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    Home home = <span class="keyword">new</span> Home();    home.add(<span class="keyword">new</span> Dog());    home.add(<span class="keyword">new</span> Cat());    Owner owner = <span class="keyword">new</span> Owner();    home.action(owner);&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="分派机制"><a href="#分派机制" class="headerlink" title="分派机制"></a>分派机制</h4><p>访问者模式用到了一种双分派的技术</p><p>变量被声明时的类型叫做变量的静态类型，也叫做明显类型；而变量所引用的对象的真实类型又叫做变量的实际类型。比如 <code>Map map = new HashMap()</code> ，map变量的静态类型是 <code>Map</code> ，实际类型是 <code>HashMap</code> 。根据对象的类型而对方法进行的选择，就是分派(Dispatch)，分派(Dispatch)又分为两种，即静态分派和动态分派</p><ul><li>静态分派(Static Dispatch)：发生在编译时期，根据静态类型信息分派，方法重载就是静态分派</li><li>动态分派(Dynamic Dispatch)：发生在运行时期，动态地置换掉某个方法，通过方法重写支持动态分派</li></ul><p>双分派技术是在选择一个方法时，不仅要根据消息接收者的运行时区别，还要根据参数的运行时区别。双分派实现动态绑定的本质，就是在重载方法委派的前加上继承体系中覆盖的环节，由于覆盖是动态的，所以重载是动态的</p><hr><h3 id="备忘录"><a href="#备忘录" class="headerlink" title="备忘录"></a>备忘录</h3><h4 id="基本介绍-20"><a href="#基本介绍-20" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>备忘录模式：又叫快照模式，在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态</p><p>备忘录模式提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史步骤，当新的状态无效或者存在问题时，可以使用暂时存储起来的备忘录将状态复原。很多软件都提供了撤销（Undo）操作，使文档恢复到之前的状态；比如数据库事务管理中的回滚操作、玩游戏时的存档功能、棋类游戏中的悔棋功能等都属于这类</p><p>备忘录模式的主要角色如下：</p><ul><li>发起人（Originator）角色：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务功能，它可以访问备忘录里的所有信息</li><li>备忘录（Memento）角色：负责存储发起人的内部状态，在需要的时候提供这些内部状态给发起人</li><li>管理者（Caretaker）角色：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内容进行访问与修改</li></ul><p>备忘录有两个等效的接口：</p><ul><li>窄接口：管理者对象看到的是备忘录的窄接口(narror Interface)，只允许他把备忘录对象传给其他的对象</li><li>宽接口：与管理者看到的窄接口相反，发起人对象可以看到一个宽接口(wide Interface)，这个宽接口允许它读取所有的数据，以便根据这些数据恢复这个发起人对象的内部状态</li></ul><p>模式优点：</p><ul><li>提供了一种可以恢复状态的机制，当用户需要时能够比较方便地将数据恢复到某个历史的状态</li><li>实现了内部状态的封装，除了创建它的发起人之外，其他对象都不能够访问这些状态信息</li><li>简化了发起人类，发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，这符合单一职责原则</li></ul><p>模式缺点：资源消耗大，如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源</p><p>使用场景：</p><ul><li><p>需要保存与恢复数据的场景，如玩游戏时的中间结果的存档功能</p></li><li><p>需要提供一个可回滚操作的场景，如按 Ctrl+Z 组合键</p></li></ul><hr><h4 id="代码实现-16"><a href="#代码实现-16" class="headerlink" title="代码实现"></a>代码实现</h4><h5 id="白箱模式"><a href="#白箱模式" class="headerlink" title="白箱模式"></a>白箱模式</h5><p>备忘录角色对任何对象都提供一个接口，即宽接口，备忘录角色的内部所存储的状态就对所有对象公开</p><img src="https://gitee.com/seazean/images/raw/master/Java/Design-白箱备忘录模式.png" style="zoom: 67%;"><ul><li><p>发起人类，游戏角色类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GameRole</span> </span>&#123;    <span class="keyword">private</span> <span class="keyword">int</span> vit; <span class="comment">//生命力    private int atk; //攻击力    private int def; //防御力    // set + get     //初始化状态    public void initState() &#123;        this.vit = 100;        this.atk = 100;        this.def = 100;    &#125;    //战斗后的状态    public void fight() &#123;        this.vit = 0;        this.atk = 0;        this.def = 0;    &#125;    //保存角色状态    public RoleStateMemento saveState() &#123;        return new RoleStateMemento(vit, atk, def);    &#125;    //恢复角色状态    public void recoverState(RoleStateMemento roleStateMemento) &#123;        this.vit = roleStateMemento.getVit();        this.atk = roleStateMemento.getAtk();        this.def = roleStateMemento.getDef();    &#125;//展示角色状态    public void stateDisplay() &#123;        System.out.println(&quot;角色生命力：&quot; + vit);        System.out.println(&quot;角色攻击力：&quot; + atk);        System.out.println(&quot;角色防御力：&quot; + def);    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>备忘录类，游戏状态存储类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoleStateMemento</span> </span>&#123;    <span class="keyword">private</span> <span class="keyword">int</span> vit;    <span class="keyword">private</span> <span class="keyword">int</span> atk;    <span class="keyword">private</span> <span class="keyword">int</span> def;    <span class="comment">// construct +set + get &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>角色状态管理者类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoleStateCaretaker</span> </span>&#123;    <span class="keyword">private</span> RoleStateMemento roleStateMemento;    <span class="comment">// get + set&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    <span class="comment">//大战Boss前    GameRole gameRole = new GameRole();    gameRole.initState();    //保存进度    RoleStateCaretaker roleStateCaretaker = new RoleStateCaretaker();    roleStateCaretaker.setRoleStateMemento(gameRole.saveState());        //大战Boss时    gameRole.fight();    //恢复之前状态    gameRole.recoverState(roleStateCaretaker.getRoleStateMemento());    gameRole.stateDisplay();&#125;</span></span><br></pre></td></tr></table></figure></li></ul><p>白箱备忘录模式是破坏封装性的，但是通过程序员自律，同样可以在一定程度上实现模式的大部分目的</p><hr><h5 id="黑箱模式"><a href="#黑箱模式" class="headerlink" title="黑箱模式"></a>黑箱模式</h5><p>备忘录角色对发起人对象提供一个宽接口，而为其他对象提供一个窄接口。在Java语言中，实现双重接口的办法就是将备忘录类设计成发起人类的内部成员类</p><img src="https://gitee.com/seazean/images/raw/master/Java/Design-黑箱备忘录模式.png" style="zoom: 67%;"><ul><li><p>窄接口 Memento，这是一个标识接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Memento</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>发起人类 GameRole，并在内部定义备忘录内部类 RoleStateMemento（该内部类设置为私有的）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GameRole</span> </span>&#123;    <span class="comment">//.......    private class RoleStateMemento implements Memento &#123;        private int vit;        private int atk;        private int def;        // set + get    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>负责人角色类 RoleStateCaretaker 得到的备忘录对象是以 Memento 为接口的，由于这个接口仅仅是一个标识接口，负责人角色不可能改变这个备忘录对象的内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoleStateCaretaker</span> </span>&#123;    <span class="keyword">private</span> Memento memento;<span class="comment">// set + get&#125;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h3><h4 id="基本介绍-21"><a href="#基本介绍-21" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式，使用该表示来解释语言中的句子</p><p>解释器模式包含以下主要角色。</p><ul><li><p>抽象表达式（Abstract Expression）角色：定义解释器的接口，约定解释器的解释操作，主要包含解释方法 interpret()</p></li><li><p>终结符表达式（Terminal  Expression）角色：是抽象表达式的子类，用来实现文法中与终结符相关的操作，文法中的每一个终结符都有一个具体终结表达式与之相对应</p></li><li><p>非终结符表达式（Nonterminal Expression）角色：抽象表达式的子类，用来实现文法中与非终结符相关的操作，文法中的每条规则都对应于一个非终结符表达式</p></li><li><p>环境（Context）角色：通常包含各个解释器需要的数据或是公共的功能，一般用来传递被所有解释器共享的数据，后面的解释器可以从这里获取这些值</p></li><li><p>客户端（Client）：主要任务是将需要分析的句子或表达式转换成使用解释器对象描述的抽象语法树，然后调用解释器的解释方法，也可以通过环境角色间接访问解释器的解释方法</p></li></ul><p>抽象语法树（AbstractSyntaxTree，AST），或简称语法树（Syntax tree），是源代码语法结构的一种抽象表示，以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构</p><p>用树形来表示符合文法规则的句子：</p><img src="https://gitee.com/seazean/images/raw/master/Java/Design-解释器模式语法树.png" style="zoom:33%;"><p>模式优点：</p><ul><li><p>易于改变和扩展文法，由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法，每一条文法规则都可以表示为一个类，因此可以方便地实现一个简单的语言</p></li><li><p>实现文法较为容易，在抽象语法树中每一个表达式节点类的实现方式都是相似的，代码编写不会特别复杂</p></li><li><p>增加新的解释表达式较为方便，如果用户需要增加新的解释表达式只需要对应增加一个新的终结符表达式或非终结符表达式类，原有表达式类代码无须修改，符合开闭原则</p></li></ul><p>模式缺点：</p><ul><li>对于复杂文法难以维护，在解释器模式中，每一条规则至少需要定义一个类，因此如果一个语言包含太多文法规则，类的个数将会急剧增加，导致系统难以管理和维护</li><li>执行效率较低，在解释器模式中使用了大量的循环和递归调用，因此在解释较为复杂的句子时其速度很慢，而且代码的调试过程也比较麻烦</li></ul><p>使用场景：</p><ul><li>当语言的文法较为简单，且执行效率不是关键问题时</li><li>当问题重复出现，且可以用一种简单的语言来进行表达时</li><li>当一个语言需要解释执行，并且语言中的句子可以表示为一个抽象语法树的时候</li></ul><hr><h4 id="代码实现-17"><a href="#代码实现-17" class="headerlink" title="代码实现"></a>代码实现</h4><p>设计实现加减法的软件</p><ul><li><p>抽象角色类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractExpression</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">interpret</span><span class="params">(Context context)</span></span>;&#125;</span><br></pre></td></tr></table></figure></li><li><p>终结符表达式角色，变量表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Variable</span> <span class="keyword">extends</span> <span class="title">AbstractExpression</span> </span>&#123;    <span class="keyword">private</span> String name;    <span class="function"><span class="keyword">public</span> <span class="title">Variable</span><span class="params">(String name)</span> </span>&#123;        <span class="keyword">this</span>.name = name;    &#125;    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">interpret</span><span class="params">(Context ctx)</span> </span>&#123;        <span class="keyword">return</span> ctx.getValue(<span class="keyword">this</span>);    &#125;    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> name;    &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>非终结符表达式角色：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加法表达式public class Plus extends AbstractExpression &#123;    private AbstractExpression left;// + 左边的表达式    private AbstractExpression right;// + 右边的表达式    public Plus(AbstractExpression left, AbstractExpression right) &#123;        this.left = left;        this.right = right;    &#125;    @Override    public int interpret(Context context) &#123;        return left.interpret(context) + right.interpret(context);    &#125;    @Override    public String toString() &#123;        return &quot;(&quot; + left.toString() + &quot; + &quot; + right.toString() + &quot;)&quot;;    &#125;&#125;// 剑法仿照加法public class Minus extends AbstractExpression &#123;...&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>环境类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;    <span class="keyword">private</span> Map&lt;Variable, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Variable, Integer&gt;();    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">assign</span><span class="params">(Variable <span class="keyword">var</span>, Integer value)</span> </span>&#123;        map.put(<span class="keyword">var</span>, value);    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">(Variable <span class="keyword">var</span>)</span> </span>&#123;        Integer value = map.get(<span class="keyword">var</span>);        <span class="keyword">return</span> value;    &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;     Context context = <span class="keyword">new</span> Context();     Variable a = <span class="keyword">new</span> Variable(<span class="string">&quot;a&quot;</span>);     Variable b = <span class="keyword">new</span> Variable(<span class="string">&quot;b&quot;</span>);     Variable c = <span class="keyword">new</span> Variable(<span class="string">&quot;c&quot;</span>);     Variable d = <span class="keyword">new</span> Variable(<span class="string">&quot;d&quot;</span>);     Variable e = <span class="keyword">new</span> Variable(<span class="string">&quot;e&quot;</span>);     context.assign(a, <span class="number">1</span>);     context.assign(b, <span class="number">2</span>);     context.assign(c, <span class="number">3</span>);     context.assign(d, <span class="number">4</span>);     context.assign(e, <span class="number">5</span>);     AbstractExpression expression = <span class="keyword">new</span> Minus(<span class="keyword">new</span> Plus(<span class="keyword">new</span> Plus(<span class="keyword">new</span> Plus(a, b), c), d), e);     System.out.println(expression + <span class="string">&quot;= &quot;</span> + expression.interpret(context)); &#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础笔记2-JVM</title>
      <link href="./2021/09/16/java/java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B02-JVM/"/>
      <url>./2021/09/16/java/java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B02-JVM/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="assets\css\APlayer.min.css"><script src="assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="JVM概述"><a href="#JVM概述" class="headerlink" title="JVM概述"></a>JVM概述</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>JVM：全称 Java Virtual Machine，即 Java 虚拟机，一种规范，本身是一个虚拟计算机，直接和操作系统进行交互，与硬件不直接交互，而操作系统可以帮我们完成和硬件进行交互的工作</p><p>特点：</p><ul><li>Java 虚拟机基于<strong>二进制字节码</strong>执行，由一套字节码指令集、一组寄存器、一个栈、一个垃圾回收堆、一个方法区等组成</li><li>JVM 屏蔽了与操作系统平台相关的信息，从而能够让 Java 程序只需要生成能够在 JVM 上运行的字节码文件，通过该机制实现的<strong>跨平台性</strong></li></ul><p>Java 代码执行流程：java程序 –（编译）–&gt; 字节码文件 –（解释执行）–&gt; 操作系统（Win，Linux）</p><p>JVM 结构：</p><img src="https://gitee.com/seazean/images/raw/master/Java/JVM-概述图.png" style="zoom: 80%;"><p>JVM、JRE、JDK对比：</p><img src="https://gitee.com/seazean/images/raw/master/Java/JVM-JRE关系.png" style="zoom: 80%;"><p>参考书籍：<a href="https://book.douban.com/subject/34907497/">https://book.douban.com/subject/34907497/</a></p><p>参考视频：<a href="https://www.bilibili.com/video/BV1PJ411n7xZ">https://www.bilibili.com/video/BV1PJ411n7xZ</a></p><p>参考视频：<a href="https://www.bilibili.com/video/BV1yE411Z7AP">https://www.bilibili.com/video/BV1yE411Z7AP</a></p><hr><h3 id="架构模型"><a href="#架构模型" class="headerlink" title="架构模型"></a>架构模型</h3><p>Java 编译器输入的指令流是一种基于栈的指令集架构。因为跨平台的设计，Java 的指令都是根据栈来设计的，不同平台 CPU 架构不同，所以不能设计为基于寄存器架构</p><ul><li>基于栈式架构的特点：<ul><li>设计和实现简单，适用于资源受限的系统</li><li>使用零地址指令方式分配，执行过程依赖操作栈，指令集更小，编译器容易实现<ul><li>零地址指令：机器指令的一种，是指令系统中的一种不设地址字段的指令，只有操作码而没有地址码。这种指令有两种情况：一是无需操作数，另一种是操作数为默认的（隐含的），默认为操作数在寄存器（ACC）中，指令可直接访问寄存器</li><li>一地址指令：一个操作码对应一个地址码，通过地址码寻找操作数</li></ul></li><li>不需要硬件的支持，可移植性更好，更好实现跨平台</li></ul></li><li>基于寄存器架构的特点：<ul><li>需要硬件的支持，可移植性差</li><li>性能更好，执行更高效，寄存器比内存快</li><li>以一地址指令、二地址指令、三地址指令为主</li></ul></li></ul><hr><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>JVM 的生命周期分为三个阶段，分别为：启动、运行、死亡。</p><ul><li><p><strong>启动</strong>：当启动一个 Java 程序时，通过引导类加载器（bootstrap class loader）创建一个初始类（initial class），对于拥有 main 函数的类就是 JVM 实例运行的起点</p></li><li><p><strong>运行</strong>：</p><ul><li><p>main() 方法是一个程序的初始起点，任何线程均可由在此处启动</p></li><li><p>在 JVM 内部有两种线程类型，分别为：用户线程和守护线程，<strong>JVM 使用的是守护线程，main() 和其他线程使用的是用户线程</strong>，守护线程会随着用户线程的结束而结束</p></li><li><p>执行一个 Java 程序时，真真正正在执行的是一个 Java 虚拟机的进程</p></li><li><p>JVM 有两种运行模式 Server 与 Client，两种模式的区别在于：Client 模式启动速度较快，Server 模式启动较慢；但是启动进入稳定期长期运行之后 Server 模式的程序运行速度比 Client 要快很多</p><p>Server 模式启动的 JVM 采用的是重量级的虚拟机，对程序采用了更多的优化；Client 模式启动的 JVM 采用的是轻量级的虚拟机</p></li></ul></li><li><p><strong>死亡</strong>：</p><ul><li>当程序中的用户线程都中止，JVM 才会退出</li><li>程序正常执行结束、程序异常或错误而异常终止、操作系统错误导致终止</li><li>线程调用 Runtime 类 halt 方法或 System 类 exit 方法，并且 java 安全管理器允许这次 exit 或 halt 操作</li></ul></li></ul><hr><h2 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h2><h3 id="内存概述"><a href="#内存概述" class="headerlink" title="内存概述"></a>内存概述</h3><p>内存结构是 JVM 中非常重要的一部分，是非常重要的系统资源，是硬盘和 CPU 的中间仓库及桥梁，承载着操作系统和应用程序的实时运行，又叫运行时数据区</p><p>JVM 内存结构规定了 Java 在运行过程中内存申请、分配、管理的策略，保证了 JVM 的高效稳定运行</p><ul><li><p>Java1.8 以前的内存结构图：<br><img src="https://gitee.com/seazean/images/raw/master/Java/JVM-Java7%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p></li><li><p>Java1.8 之后的内存结果图：</p><p><img src="https://gitee.com/seazean/images/raw/master/Java/JVM-Java8%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p></li></ul><p>线程运行诊断：</p><ul><li>定位：jps 定位进程 id</li><li>jstack 进程 id：用于打印出给定的 java 进程 ID 或 core file 或远程调试服务的 Java 堆栈信息</li></ul><p>常见OOM错误：</p><ul><li>java.lang.StackOverflowError</li><li>java.lang.OutOfMemoryError：java heap space</li><li>java.lang.OutOfMemoryError：GC overhead limit exceeded</li><li>java.lang.OutOfMemoryError：Direct buffer memory</li><li>java.lang.OutOfMemoryError：unable to create new native thread</li><li>java.lang.OutOfMemoryError：Metaspace</li></ul><hr><h3 id="JVM内存"><a href="#JVM内存" class="headerlink" title="JVM内存"></a>JVM内存</h3><h4 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h4><h5 id="Java栈"><a href="#Java栈" class="headerlink" title="Java栈"></a>Java栈</h5><p>Java 虚拟机栈：Java Virtual Machine Stacks，<strong>每个线程</strong>运行时所需要的内存</p><ul><li><p>每个方法被执行时，都会在虚拟机栈中创建一个栈帧 stack frame（<strong>一个方法一个栈帧</strong>）</p></li><li><p>Java 虚拟机规范允许 <strong>Java 栈的大小是动态的或者是固定不变的</strong></p></li><li><p>虚拟机栈是<strong>每个线程私有的</strong>，每个线程只能有一个活动栈帧，对应方法调用到执行完成的整个过程</p></li><li><p>每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存，每个栈帧中存储着：</p><ul><li>局部变量表：存储方法里的java基本数据类型以及对象的引用</li><li>动态链接：也叫指向运行时常量池的方法引用</li><li>方法返回地址：方法正常退出或者异常退出的定义</li><li>操作数栈或表达式栈和其他一些附加信息</li></ul><img src="https://gitee.com/seazean/images/raw/master/Java/JVM-虚拟机栈.png" style="zoom:50%;"></li></ul><p>设置栈内存大小：<code>-Xss size</code>   <code>-Xss 1024k</code></p><ul><li>在 JDK 1.4 中默认为 256K，而在 JDK 1.5+ 默认为 1M</li></ul><p>虚拟机栈特点：</p><ul><li><p>栈内存<strong>不需要进行GC</strong>，方法开始执行的时候会进栈，方法调用后自动弹栈，相当于清空了数据</p></li><li><p>栈内存分配越大越大，可用的线程数越少（内存越大，每个线程拥有的内存越大）</p></li><li><p>方法内的局部变量是否<strong>线程安全</strong>：</p><ul><li>如果方法内局部变量没有逃离方法的作用访问，它是线程安全的（逃逸分析）</li><li>如果是局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全</li></ul></li></ul><p>异常：</p><ul><li>栈帧过多导致栈内存溢出 （超过了栈的容量），会抛出 OutOfMemoryError 异常</li><li>当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常</li></ul><hr><h5 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h5><p>局部变量表也被称之为局部变量数组或本地变量表，本质上定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量</p><ul><li>表是建立在线程的栈上，是线程私有的数据，因此不存在数据安全问题</li><li>表的容量大小是在编译期确定的，保存在方法的 Code 属性的 maximum local variables 数据项中</li><li>表中的变量只在当前方法调用中有效，方法结束栈帧销毁，局部变量表也会随之销毁</li><li>表中的变量也是重要的垃圾回收根节点，只要被表中数据直接或间接引用的对象都不会被回收</li></ul><p>局部变量表最基本的存储单元是 <strong>slot（变量槽）</strong>：</p><ul><li>参数值的存放总是在局部变量数组的 index0 开始，到数组长度 -1 的索引结束，JVM 为每一个 slot 都分配一个访问索引，通过索引即可访问到槽中的数据</li><li>存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress 类型的变量</li><li>32 位以内的类型只占一个 slot（包括 returnAddress 类型），64 位的类型（long 和 double）占两个 slot</li><li>局部变量表中的槽位是可以<strong>重复利用</strong>的，如果一个局部变量过了其作用域，那么之后申明的新的局部变量就可能会复用过期局部变量的槽位，从而达到节省资源的目的</li></ul><hr><h5 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h5><p>栈：可以使用数组或者链表来实现</p><p>操作数栈：在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）或出栈（pop）</p><ul><li><p>保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间，是执行引擎的一个工作区</p></li><li><p>Java 虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈</p></li><li><p>如果被调用的方法带有返回值的话，其<strong>返回值将会被压入当前栈帧的操作数栈中</strong></p></li></ul><p>栈顶缓存技术 ToS（Top-of-Stack Cashing）：将栈顶元素全部缓存在 CPU 的寄存器中，以此降低对内存的读/写次数，提升执行的效率</p><p>基于栈式架构的虚拟机使用的零地址指令更加紧凑，完成一项操作需要使用很多入栈和出栈指令，所以需要更多的指令分派（instruction dispatch）次数和内存读/写次数，由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度，所以需要栈顶缓存技术</p><hr><h5 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h5><p>动态链接是指向运行时常量池的方法引用，涉及到栈操作已经是类加载完成，这个阶段的解析是<strong>动态绑定</strong></p><ul><li><p>为了支持当前方法的代码能够实现动态链接，每一个栈帧内部都包含一个指向运行时常量池或该栈帧所属方法的引用</p><p><img src="https://gitee.com/seazean/images/raw/master/Java/JVM-%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E7%AC%A6%E5%8F%B7%E5%BC%95%E7%94%A8.png"></p></li><li><p>在 Java 源文件被编译成字节码文件中，所有的变量和方法引用都作为符号引用保存在 class 的常量池中</p><p>常量池的作用：提供一些符号和常量，便于指令的识别</p><p><img src="https://gitee.com/seazean/images/raw/master/Java/JVM-%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0.png"></p></li></ul><hr><h5 id="返回地址"><a href="#返回地址" class="headerlink" title="返回地址"></a>返回地址</h5><p>Return Address：存放调用该方法的 PC 寄存器的值</p><p>方法的结束有两种方式：正常执行完成、出现未处理的异常，在方法退出后都返回到该方法被调用的位置</p><ul><li>正常：调用者的 pc 计数器的值作为返回地址，即调用该方法的指令的<strong>下一条指令的地址</strong></li><li>异常：返回地址是要通过异常表来确定</li></ul><p>正常完成出口：执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者</p><p>异常完成出口：方法执行的过程中遇到了异常（Exception），并且这个异常没有在方法内进行处理，本方法的异常表中没有搜素到匹配的异常处理器，导致方法退出</p><p>两者区别：通过异常完成出口退出的不会给上层调用者产生任何的返回值</p><h5 id="附加信息"><a href="#附加信息" class="headerlink" title="附加信息"></a>附加信息</h5><p>栈帧中还允许携带与 Java 虚拟机实现相关的一些附加信息，例如对程序调试提供支持的信息</p><hr><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>本地方法栈是为虚拟机执行本地方法时提供服务的</p><p>JNI：Java Native Interface，通过使用 Java 本地接口书写程序，可以确保代码在不同的平台上方便移植</p><ul><li><p>不需要进行GC，与虚拟机栈类似，也是线程私有的，有 StackOverFlowError 和 OutOfMemoryError 异常</p></li><li><p>虚拟机栈执行的是 Java 方法，在 HotSpot JVM 中，直接将本地方法栈和虚拟机栈合二为一</p></li><li><p>本地方法一般是由其他语言编写，并且被编译为基于本机硬件和操作系统的程序</p></li><li><p>当某个线程调用一个本地方法时，就进入了不再受虚拟机限制的世界，和虚拟机拥有同样的权限</p><ul><li>本地方法可以通过本地方法接口来<strong>访问虚拟机内部的运行时数据区</strong></li><li>直接从本地内存的堆中分配任意数量的内存</li><li>可以直接使用本地处理器中的寄存器</li></ul><img src="https://gitee.com/seazean/images/raw/master/Java/JVM-本地方法栈.png" style="zoom:67%;"></li></ul><p>图片来源：<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md">https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md</a></p><hr><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>Program Counter Register 程序计数器（寄存器）</p><p>作用：内部保存字节码的行号，用于记录正在执行的字节码指令地址（如果正在执行的是本地方法则为空）</p><p>原理：</p><ul><li>JVM 对于多线程是通过线程轮流切换并且分配线程执行时间，一个处理器只会处理执行一个线程</li><li>切换线程需要从程序计数器中来回去到当前的线程上一次执行的行号</li></ul><p>特点：</p><ul><li>是线程私有的</li><li><strong>不会存在内存溢出</strong>，是 JVM 规范中唯一一个不出现 OOM 的区域，所以这个空间不会进行 GC</li></ul><p>Java 反编译指令：<code>javap -v Test.class</code></p><p>#20：代表去 Constant pool 查看该地址的指令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: getstatic #<span class="number">20</span> <span class="comment">// PrintStream out = System.out;3: astore_1 // --4: aload_1 // out.println(1);5: iconst_1 // --6: invokevirtual #26 // --9: aload_1 // out.println(2);10: iconst_2 // --11: invokevirtual #26 // --</span></span><br></pre></td></tr></table></figure><hr><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>Heap 堆：是 JVM 内存中最大的一块，由所有线程共享，由垃圾回收器管理的主要区域，堆中对象大部分都需要考虑线程安全的问题</p><p>存放哪些资源：</p><ul><li>对象实例：类初始化生成的对象，<strong>基本数据类型的数组也是对象实例</strong>，new 创建对象都使用堆内存</li><li>字符串常量池：<ul><li>字符串常量池原本存放于方法区，jdk7 开始放置于堆中</li><li>字符串常量池<strong>存储的是 String 对象的直接引用或者对象</strong>，是一张 string table</li></ul></li><li>静态变量：静态变量是有 static 修饰的变量，jdk7 时从方法区迁移至堆中</li><li>线程分配缓冲区 Thread Local Allocation Buffer：线程私有但不影响堆的共性，可以提升对象分配的效率</li></ul><p>设置堆内存指令：<code>-Xmx Size</code></p><p>内存溢出：new 出对象，循环添加字符数据，当堆中没有内存空间可分配给实例，也无法再扩展时，就会抛出 OutOfMemoryError 异常</p><p>堆内存诊断工具：（控制台命令）</p><ol><li>jps：查看当前系统中有哪些 java 进程</li><li>jmap：查看堆内存占用情况 <code>jhsdb jmap --heap --pid 进程id</code></li><li>jconsole：图形界面的，多功能的监测工具，可以连续监测</li></ol><p>在 Java7 中堆内会存在<strong>年轻代、老年代和方法区（永久代）</strong>：</p><ul><li>Young 区被划分为三部分，Eden 区和两个大小严格相同的 Survivor 区。Survivor 区某一时刻只有其中一个是被使用的，另外一个留做垃圾回收时复制对象。在 Eden 区变满的时候， GC 就会将存活的对象移到空闲的 Survivor 区间中，根据 JVM 的策略，在经过几次垃圾回收后，仍然存活于 Survivor 的对象将被移动到 Tenured 区间</li><li>Tenured 区主要保存生命周期长的对象，一般是一些老的对象，当一些对象在 Young 复制转移一定的次数以后，对象就会被转移到 Tenured 区</li><li>Perm 代主要保存 Class、ClassLoader、静态变量、常量、编译后的代码，在 Java7 中堆内方法区会受到 GC 的管理</li></ul><p>分代原因：不同对象的生命周期不同，70%-99% 的对象都是临时对象，优化 GC 性能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    <span class="comment">//返回Java虚拟机中的堆内存总量    long initialMemory = Runtime.getRuntime().totalMemory() / 1024 / 1024;    //返回Java虚拟机使用的最大堆内存量    long maxMemory = Runtime.getRuntime().maxMemory() / 1024 / 1024;        System.out.println(&quot;-Xms : &quot; + initialMemory + &quot;M&quot;);//-Xms : 245M    System.out.println(&quot;-Xmx : &quot; + maxMemory + &quot;M&quot;);//-Xmx : 3641M&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>方法区：是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、即时编译器编译后的代码等数据，虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是也叫 Non-Heap（非堆）</p><p>方法区是一个 JVM 规范，<strong>永久代与元空间都是其一种实现方式</strong></p><p>方法区的大小不必是固定的，可以动态扩展，加载的类太多，可能导致永久代内存溢出 (OutOfMemoryError)</p><p>方法区的 GC：针对常量池的回收及对类型的卸载，比较难实现</p><p>为了<strong>避免方法区出现 OOM</strong>，在 JDK8 中将堆内的方法区（永久代）移动到了本地内存上，重新开辟了一块空间，叫做元空间，元空间存储类的元信息，<strong>静态变量和字符串常量池等放入堆中</strong></p><p>类元信息：在类编译期间放入方法区，存放了类的基本信息，包括类的方法、参数、接口以及常量池表</p><p>常量池表（Constant Pool Table）是 Class 文件的一部分，存储了<strong>类在编译期间生成的字面量、符号引用</strong>，JVM 为每个已加载的类维护一个常量池</p><ul><li>字面量：基本数据类型、字符串类型常量、声明为 final 的常量值等</li><li>符号引用：类、字段、方法、接口等的符号引用</li></ul><p>运行时常量池是方法区的一部分</p><ul><li>常量池（编译器生成的字面量和符号引用）中的数据会在类加载的加载阶段放入运行时常量池</li><li>类在解析阶段将这些符号引用替换成直接引用</li><li>除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()</li></ul><hr><h3 id="本地内存"><a href="#本地内存" class="headerlink" title="本地内存"></a>本地内存</h3><h4 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>虚拟机内存：Java 虚拟机在执行的时候会把管理的内存分配成不同的区域，受虚拟机内存大小的参数控制，当大小超过参数设置的大小时就会报 OOM</p><p>本地内存：又叫做<strong>堆外内存</strong>，线程共享的区域，本地内存这块区域是不会受到 JVM 的控制的，不会发生 GC；因此对于整个 java 的执行效率是提升非常大，但是如果内存的占用超出物理内存的大小，同样也会报 OOM</p><p>本地内存概述图：</p><img src="https://gitee.com/seazean/images/raw/master/Java/JVM-内存图对比.png" style="zoom: 67%;"><hr><h4 id="元空间"><a href="#元空间" class="headerlink" title="元空间"></a>元空间</h4><p>PermGen 被元空间代替，永久代的<strong>类信息、方法、常量池</strong>等都移动到元空间区</p><p>元空间与永久代区别：元空间不在虚拟机中，使用的本地内存，默认情况下，元空间的大小仅受本地内存限制</p><p>方法区内存溢出：</p><ul><li><p>JDK1.8 以前会导致永久代内存溢出：java.lang.OutOfMemoryError: PerGen space</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:MaxPermSize=8m<span class="comment">#参数设置</span></span><br></pre></td></tr></table></figure></li><li><p>JDK1.8 以后会导致元空间内存溢出：java.lang.OutOfMemoryError: Metaspace</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:MaxMetaspaceSize=8m<span class="comment">#参数设置</span></span><br></pre></td></tr></table></figure></li></ul><p>元空间内存溢出演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1_8</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123; <span class="comment">// 可以用来加载类的二进制字节码    public static void main(String[] args) &#123;        int j = 0;        try &#123;            Demo1_8 test = new Demo1_8();            for (int i = 0; i &lt; 10000; i++, j++) &#123;                // ClassWriter 作用是生成类的二进制字节码                ClassWriter cw = new ClassWriter(0);                // 版本号， public， 类名, 包名, 父类， 接口                cw.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, &quot;Class&quot; + i, null, &quot;java/lang/Object&quot;, null);                // 返回 byte[]                byte[] code = cw.toByteArray();                // 执行了类的加载                test.defineClass(&quot;Class&quot; + i, code, 0, code.length); // Class 对象            &#125;        &#125; finally &#123;            System.out.println(j);        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4><p>直接内存是 Java 堆外、直接向系统申请的内存区间，不是虚拟机运行时数据区的一部分，也不是《Java 虚拟机规范》中定义的内存区域</p><p>直接内存详解参考：NET → NIO → 直接内存</p><hr><h3 id="变量位置"><a href="#变量位置" class="headerlink" title="变量位置"></a>变量位置</h3><p>变量的位置不取决于它是基本数据类型还是引用数据类型，取决于它的<strong>声明位置</strong></p><p>静态内部类和其他内部类：</p><ul><li><p><strong>一个 class 文件只能对应一个 public 类型的类</strong>，这个类可以有内部类，但不会生成新的 class 文件</p></li><li><p>静态内部类属于类本身，加载到方法区，其他内部类属于内部类的属性，加载到堆（待考证）</p></li></ul><p>类变量：</p><ul><li>类变量是用 static 修饰符修饰，定义在方法外的变量，随着 java 进程产生和销毁</li><li>在 java8 之前把静态变量存放于方法区，在 java8 时存放在堆中的静态变量区</li></ul><p>实例变量：</p><ul><li>实例（成员）变量是定义在类中，没有 static 修饰的变量，随着类的实例产生和销毁，是类实例的一部分</li><li>在类初始化的时候，从运行时常量池取出直接引用或者值，<strong>与初始化的对象一起放入堆中</strong></li></ul><p>局部变量：</p><ul><li>局部变量是定义在类的方法中的变量</li><li>在所在方法被调用时<strong>放入虚拟机栈的栈帧</strong>中，方法执行结束后从虚拟机栈中弹出，</li></ul><p>类常量池、运行时常量池、字符串常量池有什么关系？有什么区别？</p><ul><li>类常量池与运行时常量池都存储在方法区，而字符串常量池在 jdk7 时就已经从方法区迁移到了 java 堆中</li><li>在类编译过程中，会把类元信息放到方法区，类元信息的其中一部分便是类常量池，主要存放字面量和符号引用，而字面量的一部分便是文本字符</li><li><strong>在类加载时将字面量和符号引用解析为直接引用存储在运行时常量池</strong></li><li>对于文本字符，会在解析时查找字符串常量池，查出这个文本字符对应的字符串对象的直接引用，将直接引用存储在运行时常量池</li></ul><p>什么是字面量？什么是符号引用？</p><ul><li><p>字面量：java 代码在编译过程中是无法构建引用的，字面量就是在编译时对于数据的一种表示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;<span class="comment">//这个1便是字面量String b = &quot;iloveu&quot;;//iloveu便是字面量</span></span><br></pre></td></tr></table></figure></li><li><p>符号引用：在编译过程中并不知道每个类的地址，因为可能这个类还没有加载，如果在一个类中引用了另一个类，无法知道它的内存地址，只能用他的类名作为符号引用，在类加载完后用这个符号引用去获取内存地址</p></li></ul><hr><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><h4 id="两种方式"><a href="#两种方式" class="headerlink" title="两种方式"></a>两种方式</h4><p>为对象分配内存：首先计算对象占用空间大小，接着在堆中划分一块内存给新对象</p><ul><li>如果内存规整，使用指针碰撞（BumpThePointer）。所有用过的内存在一边，空闲的内存在另外一边，中间有一个指针作为分界点的指示器，分配内存就仅仅是把指针向空闲那边挪动一段与对象大小相等的距离</li><li>如果内存不规整，虚拟机需要维护一个空闲列表（Free List）分配。已使用的内存和未使用的内存相互交错，虚拟机维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容</li></ul><hr><h4 id="分代思想"><a href="#分代思想" class="headerlink" title="分代思想"></a>分代思想</h4><h5 id="分代介绍"><a href="#分代介绍" class="headerlink" title="分代介绍"></a>分代介绍</h5><p>Java8 时，堆被分为了两份：新生代和老年代（1：2），在 Java7 时，还存在一个永久代</p><ul><li>新生代使用：复制算法</li><li>老年代使用：标记 - 清除 或者 标记 - 整理 算法</li></ul><p><strong>Minor GC 和 Full GC</strong>：</p><ul><li>Minor GC：回收新生代，新生代对象存活时间很短，所以 Minor GC 会频繁执行，执行的速度比较快</li><li>Full GC：回收老年代和新生代，老年代对象其存活时间长，所以 Full GC 很少执行，执行速度会比 Minor GC 慢很多</li></ul><p> Eden 和 Survivor 大小比例默认为 8:1:1</p><img src="https://gitee.com/seazean/images/raw/master/Java/JVM-分代收集算法.png" style="zoom: 67%;"><hr><h5 id="分代分配"><a href="#分代分配" class="headerlink" title="分代分配"></a>分代分配</h5><p>工作机制：</p><ul><li><strong>对象优先在 Eden 分配</strong>：当创建一个对象的时候，对象会被分配在新生代的 Eden 区，当Eden 区要满了时候，触发 YoungGC</li><li>当进行 YoungGC 后，此时在 Eden 区存活的对象被移动到 to 区，并且当前对象的年龄会加 1，清空 Eden 区</li><li>当再一次触发 YoungGC 的时候，会把 Eden 区中存活下来的对象和 to 中的对象，移动到 from 区中，这些对象的年龄会加 1，清空 Eden 区和 to 区</li><li>To 区永远是空 Survivor 区，From 区是有数据的，每次 MinorGC 后两个区域互换</li><li>From 区和 To 区 也可以叫做 S0 区和 S1 区</li></ul><p>晋升到老年代：</p><ul><li><p><strong>长期存活的对象进入老年代</strong>：为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中</p><p><code>-XX:MaxTenuringThreshold</code>：定义年龄的阈值，对象头中用 4 个 bit 存储，所以最大值是 15，默认也是 15</p></li><li><p><strong>大对象直接进入老年代</strong>：需要连续内存空间的对象，最典型的大对象是很长的字符串以及数组；避免在 Eden 和 Survivor 之间的大量复制；经常出现大对象会提前触发 GC 以获取足够的连续空间分配给大对象</p><p><code>-XX:PretenureSizeThreshold</code>：大于此值的对象直接在老年代分配</p></li><li><p><strong>动态对象年龄判定</strong>：如果在 Survivor 区中相同年龄的对象的所有大小之和超过 Survivor 空间的一半，年龄大于等于该年龄的对象就可以直接进入老年代</p></li></ul><p>空间分配担保：</p><ul><li>在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的</li><li>如果不成立，虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于将尝试着进行一次 Minor GC；如果小于或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。</li></ul><hr><h4 id="TLAB"><a href="#TLAB" class="headerlink" title="TLAB"></a>TLAB</h4><p>TLAB：Thread Local Allocation Buffer，为每个线程在堆内单独分配了一个缓冲区，多线程分配内存时，使用 TLAB 可以避免线程安全问题，同时还能够提升内存分配的吞吐量，这种内存分配方式叫做<strong>快速分配策略</strong></p><ul><li>栈上分配使用的是栈来进行对象内存的分配</li><li>TLAB 分配使用的是 Eden 区域进行内存分配，属于堆内存</li></ul><p>堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据，由于对象实例的创建在 JVM 中非常频繁，因此在并发环境下为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度</p><p>问题：堆空间都是共享的么？ 不一定，因为还有 TLAB，在堆中划分出一块区域，为每个线程所独占</p><p><img src="https://gitee.com/seazean/images/raw/master/Java/JVM-TLAB%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5.jpg"></p><p>JVM 是将 TLAB 作为内存分配的首选，但不是所有的对象实例都能够在 TLAB 中成功分配内存，一旦对象在 TLAB 空间分配内存失败时，JVM 就会通过<strong>使用加锁机制确保数据操作的原子性</strong>，从而直接在堆中分配内存</p><p>栈上分配优先于 TLAB 分配进行，逃逸分析中若可进行栈上分配优化，会优先进行对象栈上直接分配内存</p><p>参数设置：</p><ul><li><p><code>-XX:UseTLAB</code>：设置是否开启 TLAB 空间</p></li><li><p><code>-XX:TLABWasteTargetPercent</code>：设置 TLAB 空间所占用 Eden 空间的百分比大小，默认情况下 TLAB 空间的内存非常小，仅占有整个 Eden 空间的1%</p></li><li><p><code>-XX:TLABRefillWasteFraction</code>：指当 TLAB 空间不足，请求分配的对象内存大小超过此阈值时不会进行 TLAB 分配，直接进行堆内存分配，否则还是会优先进行 TLAB 分配</p></li></ul><p><img src="https://gitee.com/seazean/images/raw/master/Java/JVM-TLAB%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B.jpg"></p><hr><h4 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h4><p>即时编译（Just-in-time Compilation，JIT）是一种通过在运行时将字节码翻译为机器码，从而改善性能的技术，在 HotSpot 实现中有多种选择：C1、C2 和 C1+C2，分别对应 client、server 和分层编译</p><ul><li>C1 编译速度快，优化方式比较保守；C2 编译速度慢，优化方式比较激进</li><li>C1+C2 在开始阶段采用 C1 编译，当代码运行到一定热度之后采用 C2 重新编译</li></ul><p>逃逸分析并不是直接的优化手段，而是一个代码分析方式，通过动态分析对象的作用域，为其它优化手段如栈上分配、标量替换和同步消除等提供依据，发生逃逸行为的情况有两种：方法逃逸和线程逃逸</p><ul><li>方法逃逸：当一个对象在方法中定义之后，被外部方法引用<ul><li>全局逃逸：一个对象的作用范围逃出了当前方法或者当前线程，比如对象是一个静态变量、全局变量赋值、已经发生逃逸的对象、作为当前方法的返回值</li><li>参数逃逸：一个对象被作为方法参数传递或者被参数引用</li></ul></li><li>线程逃逸：如类变量或实例变量，可能被其它线程访问到</li></ul><p>如果不存在逃逸行为，则可以对该对象进行如下优化：同步消除、标量替换和栈上分配</p><ul><li><p>同步消除</p><p>线程同步本身比较耗时，如果确定一个对象不会逃逸出线程，不被其它线程访问到，那对象的读写就不会存在竞争，则可以消除对该对象的<strong>同步锁</strong>，通过 <code>-XX:+EliminateLocks</code> 可以开启同步消除 ( - 号关闭)</p></li><li><p>标量替换</p><ul><li><p>标量替换：如果把一个对象拆散，将其成员变量恢复到基本类型来访问</p></li><li><p>标量 (scalar) ：不可分割的量，如基本数据类型和 reference 类型</p><p>聚合量 (Aggregate)：一个数据可以继续分解，对象一般是聚合量</p></li><li><p>如果逃逸分析发现一个对象不会被外部访问，并且该对象可以被拆散，那么经过优化之后，并不直接生成该对象，而是将该对象成员变量分解若干个被这个方法使用的成员变量所代替</p></li><li><p>参数设置：</p><ul><li><code>-XX:+EliminateAllocations</code>：开启标量替换</li><li><code>-XX:+PrintEliminateAllocations</code>：查看标量替换情况</li></ul></li></ul></li><li><p>栈上分配</p><p>JIT 编译器在编译期间根据逃逸分析的结果，如果一个对象没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收，这样就无需 GC</p><p>User 对象的作用域局限在方法 fn 中，可以使用标量替换的优化手段在栈上分配对象的成员变量，这样就不会生成 User 对象，大大减轻 GC 的压力</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JVM</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;        <span class="keyword">int</span> sum = <span class="number">0</span>;        <span class="keyword">int</span> count = <span class="number">1000000</span>;        <span class="comment">//warm up        for (int i = 0; i &lt; count ; i++) &#123;            sum += fn(i);        &#125;        System.out.println(sum);        System.in.read();    &#125;    private static int fn(int age) &#123;        User user = new User(age);        int i = user.getAge();        return i;    &#125;&#125;class User &#123;    private final int age;    public User(int age) &#123;        this.age = age;    &#125;    public int getAge() &#123;        return age;    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="回收策略"><a href="#回收策略" class="headerlink" title="回收策略"></a>回收策略</h3><h4 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件"></a>触发条件</h4><p>内存垃圾回收机制主要集中的区域就是线程共享区域：<strong>堆和方法区</strong></p><p>Minor GC 触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC</p><p>FullGC 同时回收新生代、老年代和方法区，只会存在一个 FullGC 的线程进行执行，其他的线程全部会被<strong>挂起</strong>，有以下触发条件：</p><ul><li><p>调用 System.gc()：</p><ul><li>在默认情况下，通过 System.gc() 或 Runtime.getRuntime().gc() 的调用，会显式触发 FullGC，同时对老年代和新生代进行回收，但是虚拟机不一定真正去执行，无法保证对垃圾收集器的调用</li><li>不建议使用这种方式，应该让虚拟机管理内存。一般情况下，垃圾回收应该是自动进行的，无须手动触发；在一些特殊情况下，如正在编写一个性能基准，可以在运行之间调用 System.gc() </li></ul></li><li><p>老年代空间不足：</p><ul><li>为了避免引起的 Full GC，应当尽量不要创建过大的对象以及数组</li><li>通过 -Xmn 参数调整新生代的大小，让对象尽量在新生代被回收掉不进入老年代，可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间</li></ul></li><li><p>空间分配担保失败</p></li><li><p>JDK 1.7 及以前的永久代（方法区）空间不足</p></li><li><p>Concurrent Mode Failure：执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC</p></li></ul><p>手动 GC 测试，VM参数：<code>-XX:+PrintGcDetails</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localvarGC1</span><span class="params">()</span> </span>&#123;    <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];<span class="comment">//10MB    System.gc();//输出: 不会被回收, FullGC时被放入老年代&#125;public void localvarGC2() &#123;    byte[] buffer = new byte[10 * 1024 * 1024];    buffer = null;    System.gc();//输出: 正常被回收&#125; public void localvarGC3() &#123;     &#123;         byte[] buffer = new byte[10 * 1024 * 1024];     &#125;     System.gc();//输出: 不会被回收, FullGC时被放入老年代 &#125;public void localvarGC4() &#123;    &#123;        byte[] buffer = new byte[10 * 1024 * 1024];    &#125;    int value = 10;    System.gc();//输出: 正常被回收，slot复用，局部变量过了其作用域 buffer置空&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h4><p>安全点 (Safepoint)：程序执行时并非在所有地方都能停顿下来开始 GC，只有在安全点才能停下</p><ul><li>Safe Point 的选择很重要，如果太少可能导致 GC 等待的时间太长，如果太多可能导致运行时的性能问题</li><li>大部分指令的执行时间都非常短，通常会根据是否具有让程序长时间执行的特征为标准，选择些执行时间较长的指令作为 Safe Point， 如方法调用、循环跳转和异常跳转等</li></ul><p>在 GC 发生时，让所有线程都在最近的安全点停顿下来的方法：</p><ul><li>抢先式中断：没有虚拟机采用，首先中断所有线程，如果有线程不在安全点，就恢复线程让线程运行到安全点</li><li>主动式中断：设置一个中断标志，各个线程运行到各个 Safe Point 时就轮询这个标志，如果中断标志为真，则将自己进行中断挂起</li></ul><p>问题：Safepoint 保证程序执行时，在不太长的时间内就会遇到可进入 GC 的 Safepoint，但是当线程处于 Waiting 状态或 Blocked 状态，线程无法响应 JVM 的中断请求，运行到安全点去中断挂起，JVM 也不可能等待线程被唤醒，对于这种情况，需要安全区域来解决</p><p>安全区域 (Safe Region)：指在一段代码片段中，<strong>对象的引用关系不会发生变化</strong>，在这个区域中的任何位置开始 GC 都是安全的</p><p>运行流程：</p><ul><li><p>当线程运行到 Safe Region 的代码时，首先标识已经进入了 Safe Region，如果这段时间内发生GC，JVM 会忽略标识为 Safe Region 状态的线程</p></li><li><p>当线程即将离开 Safe Region 时，会检查 JVM 是否已经完成 GC，如果完成了则继续运行，否则线程必须等待 GC 完成，收到可以安全离开 SafeRegion 的信号</p></li></ul><hr><h3 id="垃圾判断"><a href="#垃圾判断" class="headerlink" title="垃圾判断"></a>垃圾判断</h3><h4 id="垃圾介绍"><a href="#垃圾介绍" class="headerlink" title="垃圾介绍"></a>垃圾介绍</h4><p>垃圾：<strong>如果一个或多个对象没有任何的引用指向它了，那么这个对象现在就是垃圾</strong></p><p>作用：释放没用的对象，清除内存里的记录碎片，碎片整理将所占用的堆内存移到堆的一端，以便 JVM 将整理出的内存分配给新的对象</p><p>垃圾收集主要是针对堆和方法区进行，程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后就会消失，因此不需要对这三个区域进行垃圾回收</p><p>在堆里存放着几乎所有的 Java 对象实例，在 GC 执行垃圾回收之前，首先需要区分出内存中哪些是存活对象，哪些是已经死亡的对象。只有被标记为己经死亡的对象，GC 才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程可以称为垃圾标记阶段，判断对象存活一般有两种方式：<strong>引用计数算法</strong>和<strong>可达性分析算法</strong></p><hr><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>引用计数算法（Reference Counting）：对每个对象保存一个整型的引用计数器属性，用于记录对象被引用的情况。对于一个对象 A，只要有任何一个对象引用了 A，则 A 的引用计数器就加 1；当引用失效时，引用计数器就减 1；当对象 A 的引用计数器的值为 0，即表示对象A不可能再被使用，可进行回收（Java 没有采用）</p><p>优点：</p><ul><li>回收没有延迟性，无需等到内存不够的时候才开始回收，运行时根据对象计数器是否为 0，可以直接回收</li><li>在垃圾回收过程中，应用无需挂起；如果申请内存时，内存不足，则立刻报 OOM 错误</li><li>区域性，更新对象的计数器时，只是影响到该对象，不会扫描全部对象</li></ul><p>缺点：</p><ul><li><p>每次对象被引用时，都需要去更新计数器，有一点时间开销</p></li><li><p>浪费 CPU 资源，即使内存够用，仍然在运行时进行计数器的统计。</p></li><li><p><strong>无法解决循环引用问题，会引发内存泄露</strong>（最大的缺点）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;    <span class="keyword">public</span> Object instance = <span class="keyword">null</span>;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        Test a = <span class="keyword">new</span> Test();<span class="comment">// a = 1        Test b = new Test();// b = 1        a.instance = b;// b = 2        b.instance = a;// a = 2        a = null;// a = 1        b = null;// b = 1    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><p><img src="https://gitee.com/seazean/images/raw/master/Java/JVM-%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8.png"></p><hr><h4 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h4><h5 id="GC-Roots"><a href="#GC-Roots" class="headerlink" title="GC Roots"></a>GC Roots</h5><p>可达性分析算法：也可以称为根搜索算法、追踪性垃圾收集</p><p>GC Roots 对象：</p><ul><li>虚拟机栈中局部变量表中引用的对象：各个线程被调用的方法中使用到的参数、局部变量等</li><li>本地方法栈中引用的对象</li><li>堆中类静态属性引用的对象</li><li>方法区中的常量引用的对象</li><li>字符串常量池（string Table）里的引用</li><li>同步锁 synchronized 持有的对象</li></ul><p><strong>GC Roots 是一组活跃的引用，不是对象</strong>，放在 GC Roots Set 集合</p><hr><h5 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h5><p>可达性分析算法以根对象集合（GCRoots）为起始点，从上至下的方式搜索被根对象集合所连接的目标对象</p><p>分析工作必须在一个保障<strong>一致性的快照</strong>中进行，否则结果的准确性无法保证，这也是导致 GC 进行时必须 Stop The World 的一个原因</p><p>基本原理：</p><ul><li><p>可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索走过的路径称为引用链</p></li><li><p>如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象</p></li><li><p>在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象</p><img src="https://gitee.com/seazean/images/raw/master/Java/JVM-可达性分析算法.png" style="zoom: 50%;"></li></ul><hr><h5 id="三色标记"><a href="#三色标记" class="headerlink" title="三色标记"></a>三色标记</h5><h6 id="标记算法"><a href="#标记算法" class="headerlink" title="标记算法"></a>标记算法</h6><p>三色标记法把遍历对象图过程中遇到的对象，标记成以下三种颜色：</p><ul><li>白色：尚未访问过</li><li>灰色：本对象已访问过，但是本对象引用到的其他对象尚未全部访问</li><li>黑色：本对象已访问过，而且本对象引用到的其他对象也全部访问完成</li></ul><p>当 Stop The World (STW) 时，对象间的引用是不会发生变化的，可以轻松完成标记，遍历访问过程为：</p><ol><li>初始时，所有对象都在白色集合</li><li>将 GC Roots 直接引用到的对象挪到灰色集合</li><li>从灰色集合中获取对象：<ul><li>将本对象引用到的其他对象全部挪到灰色集合中</li><li>将本对象挪到黑色集合里面</li></ul></li><li>重复步骤 3，直至灰色集合为空时结束</li><li>结束后，仍在白色集合的对象即为 GC Roots 不可达，可以进行回收</li></ol><img src="https://gitee.com/seazean/images/raw/master/Java/JVM-三色标记法过程.gif" style="zoom: 67%;"><p>参考文章：<a href="https://www.jianshu.com/p/12544c0ad5c1">https://www.jianshu.com/p/12544c0ad5c1</a></p><hr><h6 id="并发标记"><a href="#并发标记" class="headerlink" title="并发标记"></a>并发标记</h6><p>并发标记时，对象间的引用可能发生变化<strong>，</strong>多标和漏标的情况就有可能发生</p><p><strong>多标情况：</strong>当 E 变为灰色或黑色时，其他线程断开的 D 对 E 的引用，导致这部分对象仍会被标记为存活，本轮 GC 不会回收这部分内存，这部分本应该回收但是没有回收到的内存，被称之为<strong>浮动垃圾</strong></p><ul><li>针对并发标记开始后的<strong>新对象</strong>，通常的做法是直接全部当成黑色，也算浮动垃圾</li><li>浮动垃圾并不会影响应用程序的正确性，只是需要等到下一轮垃圾回收中才被清除</li></ul><img src="https://gitee.com/seazean/images/raw/master/Java/JVM-三色标记法多标情况.png" style="zoom: 50%;"><p><strong>漏标情况：</strong></p><ul><li>条件一：灰色对象断开了对一个白色对象的引用（直接或间接），即灰色对象原成员变量的引用发生了变化</li><li>条件二：其他线程中修改了黑色对象，插入了一条或多条对该白色对象的新引用</li><li>结果：导致该白色对象当作垃圾被 GC，影响到了应用程序的正确性</li></ul><img src="https://gitee.com/seazean/images/raw/master/Java/JVM-三色标记法漏标情况.png" style="zoom:50%;"><p>代码角度解释漏标：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object G = objE.fieldG; <span class="comment">// 读objE.fieldG = null;  // 写objD.fieldG = G;     // 写</span></span><br></pre></td></tr></table></figure><p>为了解决问题，可以操作上面三步，<strong>将对象 G 记录起来，然后作为灰色对象再进行遍历</strong>，比如放到一个特定的集合，等初始的 GC Roots 遍历完（并发标记），再遍历该集合（重新标记）</p><blockquote><p>所以<strong>重新标记需要 STW</strong>，应用程序一直在运行，该集合可能会一直增加新的对象，导致永远都运行不完</p></blockquote><p>解决方法：添加读写屏障，读屏障拦截第一步，写屏障拦截第二三步，在读写前后进行一些后置处理：</p><ul><li><p><strong>写屏障 + 增量更新</strong>：黑色对象新增引用，会将黑色对象变成灰色对象，最后对该节节点重新扫描</p><p>增量更新 (Incremental Update) 破坏了条件二，从而保证了不会漏标</p><p>缺点：对黑色变灰的对象重新扫描所有引用，比较耗费时间</p></li><li><p><strong>写屏障 (Store Barrier) + SATB</strong>：当原来成员变量的引用发生变化之前，记录下原来的引用对象</p><p>保留 GC 开始时的对象图，即原始快照 SATB，当 GC Roots 确定后，对象图就已经确定，那后续的标记也应该是按照这个时刻的对象图走，如果期间对白色对象有了新的引用会记录下来，并且将白色对象变灰（说明可达了），重新扫描该对象的引用关系</p><p>SATB (Snapshot At The Beginning) 破坏了条件一，从而保证了不会漏标</p></li><li><p>**读屏障 (Load Barrier)**：破坏条件二，黑色对象引用白色对象的前提是获取到该对象，此时读屏障发挥作用</p></li></ul><p>以 Java HotSpot VM 为例，其并发标记时对漏标的处理方案如下：</p><ul><li>CMS：写屏障 + 增量更新</li><li>G1：写屏障 + SATB</li><li>ZGC：读屏障</li></ul><hr><h4 id="finalization"><a href="#finalization" class="headerlink" title="finalization"></a>finalization</h4><p>Java 语言提供了对象终止（finalization）机制来允许开发人员提供对象被销毁之前的自定义处理逻辑</p><p>垃圾回收此对象之前，会先调用这个对象的 finalize() 方法，finalize() 方法允许在子类中被重写，用于在对象被回收时进行后置处理，通常在这个方法中进行一些资源释放和清理，比如关闭文件、套接字和数据库连接等</p><p>生存 OR 死亡：如果从所有的根节点都无法访问到某个对象，说明对象己经不再使用，此对象需要被回收。但事实上这时候它们暂时处于缓刑阶段。<strong>一个无法触及的对象有可能在某个条件下复活自己</strong>，这样对它的回收就是不合理的，所以虚拟机中的对象可能的三种状态：</p><ul><li>可触及的：从根节点开始，可以到达这个对象。</li><li>可复活的：对象的所有引用都被释放，但是对象有可能在finalize() 中复活</li><li>不可触及的：对象的 finalize() 被调用并且没有复活，那么就会进入不可触及状态，不可触及的对象不可能被复活，因为 <strong>finalize() 只会被调用一次</strong>，等到这个对象再被标记为可回收时就必须回收</li></ul><p>永远不要主动调用某个对象的 finalize() 方法，应该交给垃圾回收机制调用，原因：</p><ul><li>finalize() 时可能会导致对象复活</li><li>finalize() 方法的执行时间是没有保障的，完全由 GC 线程决定，极端情况下，若不发生 GC，则 finalize() 方法将没有执行机会，因为优先级比较低，即使主动调用该方法，也不会因此就直接进行回收</li><li>一个糟糕的 finalize() 会严重影响 GC 的性能</li></ul><hr><h4 id="引用分析"><a href="#引用分析" class="headerlink" title="引用分析"></a>引用分析</h4><p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关，Java 提供了四种强度不同的引用类型</p><ol><li><p>强引用：被强引用关联的对象不会被回收，只有所有 GCRoots 都不通过强引用引用该对象，才能被垃圾回收</p><ul><li>强引用可以直接访问目标对象</li><li>虚拟机宁愿抛出 OOM 异常，也不会回收强引用所指向对象</li><li>强引用可能导致<strong>内存泄漏</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();<span class="comment">//使用 new 一个新对象的方式来创建强引用</span></span><br></pre></td></tr></table></figure></li><li><p>软引用（SoftReference）：被软引用关联的对象只有在内存不够的情况下才会被回收</p><ul><li><strong>仅（可能有强引用，一个对象可以被多个引用）</strong>有软引用引用该对象时，在垃圾回收后，内存仍不足时会再次出发垃圾回收，回收软引用对象</li><li>配合<strong>引用队列来释放软引用自身</strong>，在构造软引用时，可以指定一个引用队列，当软引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况</li><li>软引用通常用来实现内存敏感的缓存，比如高速缓存就有用到软引用；如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时不会耗尽内存</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> SoftReference&lt;Object&gt;(obj);obj = <span class="keyword">null</span>;  <span class="comment">// 使对象只被软引用关联</span></span><br></pre></td></tr></table></figure></li><li><p>弱引用（WeakReference）：被弱引用关联的对象一定会被回收，只能存活到下一次垃圾回收发生之前</p><ul><li>仅有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象</li><li>配合引用队列来释放弱引用自身</li><li>WeakHashMap 用来存储图片信息，可以在内存不足的时候及时回收，避免了 OOM</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();WeakReference&lt;Object&gt; wf = <span class="keyword">new</span> WeakReference&lt;Object&gt;(obj);obj = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure></li><li><p>虚引用（PhantomReference）：也称为幽灵引用或者幻影引用，是所有引用类型中最弱的一个</p><ul><li>一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象</li><li>为对象设置虚引用的唯一目的是在于跟踪垃圾回收过程，能在这个对象被回收时收到一个系统通知</li><li>必须配合引用队列使用，主要配合 ByteBuffer 使用，被引用对象回收时会将虚引用入队，由 Reference Handler 线程调用虚引用相关方法释放直接内存</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();PhantomReference&lt;Object&gt; pf = <span class="keyword">new</span> PhantomReference&lt;Object&gt;(obj, <span class="keyword">null</span>);obj = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure></li><li><p>终结器引用（finalization）</p></li></ol><hr><h4 id="无用类"><a href="#无用类" class="headerlink" title="无用类"></a>无用类</h4><p>方法区主要回收的是无用的类</p><p>判定一个类是否是无用的类，需要同时满足下面 3 个条件：</p><ul><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例</li><li>加载该类的 <code>ClassLoader</code> 已经被回收</li><li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</li></ul><p>虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的<strong>仅仅是可以</strong>，而并不是和对象一样不使用了就会必然被回收</p><hr><h3 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h3><h4 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h4><p>当成功区分出内存中存活对象和死亡对象后，GC 接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。目前在 JVM 中比较常见的三种垃圾收集算法是</p><ul><li>标记清除算法（Mark-Sweep）</li><li>复制算法（copying）</li><li>标记压缩算法（Mark-Compact）</li></ul><p>标记清除算法，是将垃圾回收分为两个个阶段，分别是<strong>标记和清除</strong></p><ul><li><p><strong>标记</strong>：Collector 从引用根节点开始遍历，标记所有被引用的对象，一般是在对象的 Header 中记录为可达对象，<strong>标记的是引用的对象，不是垃圾</strong></p></li><li><p><strong>清除</strong>：Collector 对堆内存从头到尾进行线性的遍历，如果发现某个对象在其 Header 中没有标记为可达对象，则将其回收，把分块连接到 <strong>空闲列表</strong>”的单向链表，判断回收后的分块与前一个空闲分块是否连续，若连续会合并这两个分块，之后进行分配时只需要遍历这个空闲列表，就可以找到分块</p></li><li><p><strong>分配阶段</strong>：程序会搜索空闲链表寻找空间大于等于新对象大小 size 的块 block，如果找到的块等于 size，会直接返回这个分块；如果找到的块大于 size，会将块分割成大小为 size 与 block - size 的两部分，返回大小为 size 的分块，并把大小为 block - size 的块返回给空闲列表</p></li></ul><p>算法缺点：</p><ul><li>标记和清除过程效率都不高</li><li>会产生大量不连续的内存碎片，导致无法给大对象分配内存，需要维护一个空闲链表</li></ul><img src="https://gitee.com/seazean/images/raw/master/Java/JVM-标记清除算法.png" style="zoom: 67%;"><hr><h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>复制算法的核心就是，<strong>将原有的内存空间一分为二，每次只用其中的一块</strong>，在垃圾回收时，将正在使用的对象复制到另一个内存空间中，然后将该内存空间清理，交换两个内存的角色，完成垃圾的回收</p><p>应用场景：如果内存中的垃圾对象较多，需要复制的对象就较少，这种情况下适合使用该方式并且效率比较高，反之则不适合</p><p><img src="https://gitee.com/seazean/images/raw/master/Java/JVM-%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png"></p><p>算法优点：</p><ul><li>没有标记和清除过程，实现简单，运行高效</li><li>复制过去以后保证空间的连续性，不会出现“碎片”问题。</li></ul><p>算法缺点：</p><ul><li>主要不足是<strong>只使用了内存的一半</strong></li><li>对于 G1 这种分拆成为大量 region 的 GC，复制而不是移动，意味着 GC 需要维护 region 之间对象引用关系，不管是内存占用或者时间开销都不小</li></ul><p>现在的商业虚拟机都采用这种收集算法回收新生代，但是并不是划分为大小相等的两块，而是一块较大的 Eden 空间和两块较小的 Survivor 空间</p><hr><h4 id="标记整理"><a href="#标记整理" class="headerlink" title="标记整理"></a>标记整理</h4><p>标记整理（压缩）算法是在标记清除算法的基础之上，做了优化改进的算法</p><p>标记阶段和标记清除算法一样，也是从根节点开始，对对象的引用进行标记，在清理阶段，并不是简单的直接清理可回收对象，而是将存活对象都向内存另一端移动，然后清理边界以外的垃圾，从而<strong>解决了碎片化</strong>的问题</p><p>优点：不会产生内存碎片</p><p>缺点：需要移动大量对象，处理效率比较低</p><img src="https://gitee.com/seazean/images/raw/master/Java/JVM-标记整理算法.png" style="zoom:67%;"><table><thead><tr><th></th><th>Mark-Sweep</th><th>Mark-Compact</th><th>Copying</th></tr></thead><tbody><tr><td>速度</td><td>中等</td><td>最慢</td><td>最快</td></tr><tr><td>空间开销</td><td>少(但会堆积碎片)</td><td>少(不堆积碎片)</td><td>通常需要活对象的2倍大小(不堆积碎片)</td></tr><tr><td>移动对象</td><td>否</td><td>是</td><td>是</td></tr></tbody></table><ul><li>效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存。</li><li>为了尽量兼顾三个指标，标记一整理算法相对来说更平滑一些</li></ul><hr><h4 id="增量收集"><a href="#增量收集" class="headerlink" title="增量收集"></a>增量收集</h4><p>增量收集算法：通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作，基础仍是标记-清除和复制算法，用于多线程并发环境</p><p>工作原理：如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，影响系统的交互性，所以让垃圾收集线程和应用程序线程交替执行，每次垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程，依次反复直到垃圾收集完成</p><p>缺点：线程切换和上下文转换消耗资源，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降</p><hr><h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>垃圾收集器分类：</p><ul><li>按线程数分（垃圾回收线程数），可以分为串行垃圾回收器和并行垃圾回收器<ul><li>除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行</li></ul></li><li>按照工作模式分，可以分为并发式垃圾回收器和独占式垃圾回收器<ul><li>并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间</li><li>独占式垃圾回收器（Stop the world）一旦运行，就停止应用程序中的所有用户线程，直到垃圾回收过程完全结束</li></ul></li><li>按碎片处理方式分，可分为压缩式垃圾回收器和非压缩式垃圾回收器<ul><li>压缩式垃圾回收器在回收完成后进行压缩整理，消除回收后的碎片，再分配对象空间使用指针碰撞</li><li>非压缩式的垃圾回收器不进行这步操作，再分配对象空间使用空闲列表</li></ul></li><li>按工作的内存区间分，又可分为年轻代垃圾回收器和老年代垃圾回收器</li></ul><p>GC 性能指标：</p><ul><li><strong>吞吐量</strong>：程序的运行时间占总运行时间的比例（总运行时间 = 程序的运行时间 + 内存回收的时间）</li><li>垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例</li><li>暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间</li><li>收集频率：相对于应用程序的执行，收集操作发生的频率</li><li>内存占用：Java 堆区所占的内存大小</li><li>快速：一个对象从诞生到被回收所经历的时间</li></ul><p><strong>垃圾收集器的组合关系</strong>：</p><p><img src="https://gitee.com/seazean/images/raw/master/Java/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%85%B3%E7%B3%BB%E5%9B%BE.png"></p><p>新生代收集器：Serial、ParNew、Paralle1 Scavenge；</p><p>老年代收集器：Serial old、Parallel old、CMS；</p><p>整堆收集器：G1</p><ul><li>红色虚线在 JDK9 移除、绿色虚线在 JDK14 弃用该组合、青色虚线在 JDK14 删除 CMS 垃圾回收器</li></ul><p>查看默认的垃圾收回收器：</p><ul><li><p><code>-XX:+PrintcommandLineFlags</code>：查看命令行相关参数（包含使用的垃圾收集器）</p></li><li><p>使用命令行指令：jinfo -flag 相关垃圾回收器参数  进程 ID</p></li></ul><hr><h4 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h4><p>Serial：串行垃圾收集器，作用于新生代，是指使用单线程进行垃圾回收，采用<strong>复制算法</strong></p><p><strong>STW（Stop-The-World）</strong>：垃圾回收时，只有一个线程在工作，并且 java 应用中的所有线程都要暂停，等待垃圾回收的完成</p><p><strong>Serial old</strong>：执行老年代垃圾回收的串行收集器，内存回收算法使用的是<strong>标记-整理算法</strong>，同样也采用了串行回收和 STW 机制</p><ul><li>Serial old 是 Client 模式下默认的老年代的垃圾回收器</li><li>Serial old 在 Server 模式下主要有两个用途：<ul><li>在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用</li><li>作为老年代 CMS 收集器的<strong>后备垃圾回收方案</strong>，在并发收集发生 Concurrent Mode Failure 时使用</li></ul></li></ul><p>开启参数：<code>-XX:+UseSerialGC</code> 等价于新生代用 Serial GC 且老年代用 Serial old GC</p><p><img src="https://gitee.com/seazean/images/raw/master/Java/JVM-Serial%E6%94%B6%E9%9B%86%E5%99%A8.png"></p><p>优点：简单而高效（与其他收集器的单线程比），对于限定单个 CPU 的环境来说，Serial 收集器由于没有线程交互的开销，可以获得最高的单线程收集效率</p><p>缺点：对于交互性较强的应用而言，这种垃圾收集器是不能够接受的，比如 JavaWeb 应用</p><hr><h4 id="Parallel"><a href="#Parallel" class="headerlink" title="Parallel"></a>Parallel</h4><p>Parallel Scavenge 收集器是应用于新生代的并行垃圾回收器，<strong>采用复制算法</strong>、并行回收和 Stop the World 机制</p><p>Parallel Old 收集器：是一个应用于老年代的并行垃圾回收器，<strong>采用标记-整理算法</strong></p><p>对比其他回收器：</p><ul><li>其它收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间</li><li>Parallel 目标是达到一个可控制的吞吐量，被称为<strong>吞吐量优先</strong>收集器</li><li>Parallel Scavenge 对比 ParNew 拥有<strong>自适应调节策略</strong>，可以通过一个开关参数打开 GC Ergonomics</li></ul><p>应用场景：</p><ul><li>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验</li><li>高吞吐量可以高效率地利用 CPU 时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互</li></ul><p>停顿时间和吞吐量的关系：新生代空间变小 → 缩短停顿时间 → 垃圾回收变得频繁 → 导致吞吐量下降</p><p>在注重吞吐量及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge + Parallel Old 收集器，在 Server 模式下的内存回收性能很好，<strong>Java8 默认是此垃圾收集器组合</strong></p><p><img src="https://gitee.com/seazean/images/raw/master/Java/JVM-ParallelScavenge%E6%94%B6%E9%9B%86%E5%99%A8.png"></p><p>参数配置：</p><ul><li><code>-XX：+UseParallelGC</code>：手动指定年轻代使用Paralle并行收集器执行内存回收任务</li><li><code>-XX：+UseParalleloldcc</code>：手动指定老年代使用并行回收收集器执行内存回收任务<ul><li>上面两个参数，默认开启一个，另一个也会被开启（互相激活），默认 jdk8 是开启的</li></ul></li><li><code>-XX:+UseAdaptivesizepplicy</code>：设置 Parallel scavenge 收集器具有<strong>自适应调节策略</strong>，在这种模式下，年轻代的大小、Eden 和 Survivor 的比例、晋升老年代的对象年龄等参数会被自动调整，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量</li><li><code>-XX:ParallelGcrhreads</code>：设置年轻代并行收集器的线程数，一般最好与 CPU 数量相等，以避免过多的线程数影响垃圾收集性能<ul><li>在默认情况下，当 CPU 数量小于 8 个，ParallelGcThreads 的值等于 CPU 数量</li><li>当 CPU 数量大于 8 个，ParallelGCThreads 的值等于 3+[5*CPU Count]/8]</li></ul></li><li><code>-XX:MaxGCPauseMillis</code>：设置垃圾收集器最大停顿时间（即 STW 的时间），单位是毫秒<ul><li>对于用户来讲，停顿时间越短体验越好；在服务器端，注重高并发，整体的吞吐量</li><li>为了把停顿时间控制在 MaxGCPauseMillis 以内，收集器在工作时会调整 Java 堆大小或其他一些参数</li></ul></li><li><code>-XX:GCTimeRatio</code>：垃圾收集时间占总时间的比例 =1/(N+1)，用于衡量吞吐量的大小<ul><li>取值范围（0，100）。默认值 99，也就是垃圾回收时间不超过1</li><li>与 <code>-xx:MaxGCPauseMillis</code> 参数有一定矛盾性，暂停时间越长，Radio 参数就容易超过设定的比例</li></ul></li></ul><hr><h4 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a>ParNew</h4><p>Par 是 Parallel 并行的缩写，New 是只能处理的是新生代</p><p>并行垃圾收集器在串行垃圾收集器的基础之上做了改进，<strong>采用复制算法</strong>，将单线程改为了多线程进行垃圾回收，可以缩短垃圾回收的时间</p><p>对于其他的行为（收集算法、stop the world、对象分配规则、回收策略等）同 Serial 收集器一样，应用在年轻代，除 Serial 外，只有<strong>ParNew GC 能与 CMS 收集器配合工作</strong></p><p>相关参数：</p><ul><li><p><code>-XX：+UseParNewGC</code>：表示年轻代使用并行收集器，不影响老年代</p></li><li><p><code>-XX:ParallelGCThreads</code>：默认开启和 CPU 数量相同的线程数</p></li></ul><p><img src="https://gitee.com/seazean/images/raw/master/Java/JVM-ParNew%E6%94%B6%E9%9B%86%E5%99%A8.png"></p><p>ParNew 是很多 JVM 运行在 Server 模式下新生代的默认垃圾收集器</p><ul><li>对于新生代，回收次数频繁，使用并行方式高效</li><li>对于老年代，回收次数少，使用串行方式节省资源（CPU 并行需要切换线程，串行可以省去切换线程的资源）</li></ul><hr><h4 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h4><p>CMS 全称 Concurrent Mark Sweep，是一款<strong>并发的、使用标记-清除</strong>算法、针对老年代的垃圾回收器，其最大特点是<strong>让垃圾收集线程与用户线程同时工作</strong></p><p>CMS 收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间，停顿时间越短（<strong>低延迟</strong>）越适合与用户交互的程序，良好的响应速度能提升用户体验</p><p>分为以下四个流程：</p><ul><li>初始标记：使用 STW 出现短暂停顿，仅标记一下 GC Roots 能直接关联到的对象，速度很快</li><li>并发标记：进行 GC Roots 开始遍历整个对象图，在整个回收过程中耗时最长，不需要 STW，可以与用户线程并发运行</li><li>重新标记：修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，比初始标记时间长但远比并发标记时间短，需要 STW（不停顿就会一直变化，采用写屏障 + 增量更新来避免漏标情况）</li><li>并发清除：清除标记为可以回收对象，不需要移动存活对象，所以这个阶段可以与用户线程同时并发的</li></ul><p>Mark Sweep 会造成内存碎片，不把算法换成 Mark Compact 的原因：</p><ul><li><p>Mark Compact 算法会整理内存，导致用户线程使用的对象的地址改变，影响用户线程继续执行</p></li><li><p>Mark Compact 更适合 Stop The World 场景</p></li></ul><p>在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿</p><p><img src="https://gitee.com/seazean/images/raw/master/Java/JVM-CMS%E6%94%B6%E9%9B%86%E5%99%A8.png"></p><p>优点：并发收集、低延迟</p><p>缺点：</p><ul><li><p>吞吐量降低：在并发阶段虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，CPU 利用率不够高</p></li><li><p>CMS 收集器<strong>无法处理浮动垃圾</strong>，可能出现 Concurrent Mode Failure 导致另一次 Full GC 的产生</p><p>浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾（产生了新对象），这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，CMS 收集需要预留出一部分内存，不能等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS，导致很长的停顿时间</p></li><li><p>标记 - 清除算法导致的空间碎片，往往出现老年代空间无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC；为新对象分配内存空间时，将无法使用指针碰撞（Bump the Pointer）技术，而只能够选择空闲列表（Free List）执行内存分配</p></li></ul><p>参数设置：</p><ul><li><p><code>-XX：+UseConcMarkSweepGC</code>：手动指定使用 CMS 收集器执行内存回收任务</p><p>开启该参数后会自动将 <code>-XX:+UseParNewGC</code> 打开，即：ParNew + CMS + Serial old的组合</p></li><li><p><code>-XX:CMSInitiatingoccupanyFraction</code>：设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收</p><ul><li>JDK5 及以前版本的默认值为 68，即当老年代的空间使用率达到 68% 时，会执行一次CMS回收</li><li>JDK6 及以上版本默认值为 92%</li></ul></li><li><p><code>-XX:+UseCMSCompactAtFullCollection</code>：用于指定在执行完 Full GC 后对内存空间进行压缩整理，以此避免内存碎片的产生，由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长</p></li><li><p><code>-XX:CMSFullGCsBeforecompaction</code>：<strong>设置在执行多少次 Full GC 后对内存空间进行压缩整理</strong></p></li><li><p><code>-XX:ParallelCMSThreads</code>：<strong>设置CMS的线程数量</strong></p><ul><li>CMS 默认启动的线程数是(ParallelGCThreads+3)/4，ParallelGCThreads 是年轻代并行收集器的线程数</li><li>收集线程占用的 CPU 资源多于25%，对用户程序影响可能较大；当 CPU 资源比较紧张时，受到 CMS 收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕</li></ul></li></ul><hr><h4 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h4><h5 id="G1特点"><a href="#G1特点" class="headerlink" title="G1特点"></a>G1特点</h5><p>G1（Garbage-First）是一款面向服务端应用的垃圾收集器，<strong>应用于新生代和老年代</strong>、采用标记-整理算法、软实时、低延迟、可设定目标（最大STW停顿时间）的垃圾回收器，用于代替 CMS，适用于较大的堆（&gt;4 ~ 6G），在 JDK9 之后默认使用 G1</p><p>G1 对比其他处理器的优点：</p><ul><li><p>并发与并行：</p><ul><li>并行性：G1 在回收期间，可以有多个 GC 线程同时工作，有效利用多核计算能力，此时用户线程 STW</li><li>并发性：G1 拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此不会在整个回收阶段发生完全阻塞应用程序的情况</li><li>其他的垃圾收集器使用内置的 JVM 线程执行 GC 的多线程操作，而 G1 GC 可以采用应用线程承担后台运行的 GC 工作，JVM 的 GC 线程处理速度慢时，系统会<strong>调用应用程序线程加速垃圾回收</strong>过程</li></ul></li><li><p><strong>分区算法</strong>：</p><ul><li><p>从分代上看，G1  属于分代型垃圾回收器，区分年轻代和老年代，年轻代依然有 Eden 区和 Survivor 区。从堆结构上看，<strong>新生代和老年代不再物理隔离</strong>，不用担心每个代内存是否足够，这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次 GC</p></li><li><p>将整个堆划分成约 2048 个大小相同的独立 Region 块，每个 Region 块大小根据堆空间的实际大小而定，整体被控制在 1MB 到 32 MB之间且为 2 的 N 次幂，所有 Region 大小相同，在 JVM 生命周期内不会被改变。G1 把堆划分成多个大小相等的独立区域，使得每个小空间可以单独进行垃圾回收</p></li><li><p><strong>新的区域 Humongous</strong>：本身属于老年代区，当出现了一个巨型对象超出了分区容量的一半，该对象就会进入到该区域。如果一个 H 区装不下一个巨型对象，那么 G1 会寻找连续的 H 分区来存储，为了能找到连续的H区，有时候不得不启动 Full GC</p></li><li><p>G1 不会对巨型对象进行拷贝，回收时被优先考虑，G1 会跟踪老年代所有 incoming 引用，这样老年代 incoming 引用为 0 的巨型对象就可以在新生代垃圾回收时处理掉</p></li><li><p>Region 结构图：</p></li></ul></li></ul><p><img src="https://gitee.com/seazean/images/raw/master/Java/JVM-G1-Region%E5%8C%BA%E5%9F%9F.png"></p><ul><li><p>空间整合：</p><ul><li>CMS：标记-清除算法、内存碎片、若干次 GC 后进行一次碎片整理</li><li>G1：整体来看是基于标记 - 整理算法实现的收集器，从局部（Region 之间）上来看是基于复制算法实现的，两种算法都可以避免内存碎片</li></ul></li><li><p><strong>可预测的停顿时间模型（软实时 soft real-time）</strong>：可以指定在 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒</p><ul><li>由于分块的原因，G1 可以只选取部分区域进行内存回收，这样缩小了回收的范围，对于全局停顿情况也能得到较好的控制</li><li>G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间，通过过去回收的经验获得），在后台维护一个<strong>优先列表</strong>，每次根据允许的收集时间优先回收价值最大的 Region，保证了 G1 收集器在有限的时间内可以获取尽可能高的收集效率</li></ul><ul><li>相比于 CMS GC，G1 未必能做到 CMS 在最好情况下的延时停顿，但是最差情况要好很多</li></ul></li></ul><p>G1垃圾收集器的缺点：</p><ul><li>相较于 CMS，G1 还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1 无论是为了垃圾收集产生的内存占用还是程序运行时的额外执行负载都要比 CMS 要高</li><li>从经验上来说，在小内存应用上 CMS 的表现大概率会优于 G1，而 G1 在大内存应用上则发挥其优势。平衡点在 6-8GB 之间</li></ul><p>应用场景：</p><ul><li>面向服务端应用，针对具有大内存、多处理器的机器</li><li>需要低 GC 延迟，并具有大堆的应用程序提供解决方案</li></ul><hr><h5 id="记忆集"><a href="#记忆集" class="headerlink" title="记忆集"></a>记忆集</h5><p>记忆集 Remembered Set 在新生代中，每个 Region 都有一个 Remembered Set，用来被哪些其他 Region 里的对象引用（谁引用了我就记录谁）</p><img src="https://gitee.com/seazean/images/raw/master/Java/JUC-G1记忆集.png" style="zoom:67%;"><ul><li>程序对 Reference 类型数据写操作时，产生一个 Write Barrier 暂时中断操作，检查该对象和 Reference 类型数据是否在不同的 Region（跨代引用），不同就将相关引用信息记录到 Reference 类型所属的 Region 的 Remembered Set 之中</li><li>进行内存回收时，在 GC 根节点的枚举范围中加入 Remembered Set 即可保证不对全堆扫描也不会有遗漏</li></ul><p>垃圾收集器在新生代中建立了记忆集这样的数据结构，可以理解为它是一个抽象类，具体实现记忆集的三种方式：</p><ul><li>字长精度</li><li>对象精度</li><li>卡精度(卡表)</li></ul><p>卡表（Card Table）在老年代中，是一种对记忆集的具体实现，主要定义了记忆集的记录精度、与堆内存的映射关系等，卡表中的每一个元素都对应着一块特定大小的内存块，这个内存块称之为卡页（card page），当存在跨代引用时，会将卡页标记为 dirty，JVM 对于卡页的维护也是通过写屏障的方式</p><p>收集集合 CSet 代表每次 GC 暂停时回收的一系列目标分区，在任意一次收集暂停中，CSet 所有分区都会被释放，内部存活的对象都会被转移到分配的空闲分区中。年轻代收集 CSet 只容纳年轻代分区，而混合收集会通过启发式算法，在老年代候选回收分区中，筛选出回收收益最高的分区添加到 CSet 中</p><ul><li>CSet of Young Collection</li><li>CSet of Mix Collection</li></ul><hr><h5 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h5><p>G1 中提供了三种垃圾回收模式：YoungGC、Mixed GC 和 FullGC，在不同的条件下被触发</p><ul><li>当堆内存使用达到一定值（默认 45%）时，开始老年代并发标记过程</li><li>标记完成马上开始混合回收过程</li></ul><img src="https://gitee.com/seazean/images/raw/master/Java/JVM-G1回收过程.png" style="zoom: 50%;"><p>顺时针：Young GC → Young GC + Concurrent Mark → Mixed GC 顺序，进行垃圾回收</p><ul><li><p><strong>Young GC</strong>：发生在年轻代的 GC 算法，一般对象（除了巨型对象）都是在 eden region 中分配内存，当所有 eden region 被耗尽无法申请内存时，就会触发一次 young gc，G1 停止应用程序的执行 STW，把活跃对象放入老年代，垃圾对象回收</p><p><strong>回收过程</strong>：</p><ol><li>扫描根：根引用连同 RSet 记录的外部引用作为扫描存活对象的入口</li><li>更新 RSet：处理 dirty card queue 更新 RS，此后 RSet 准确的反映对象的引用关系<ul><li>dirty card queue：类似缓存，产生了引用先记录在这里，然后更新到 RSet</li><li>作用：产生引用直接更新 RSet 需要线程同步开销很大，使用队列性能好</li></ul></li><li>处理 RSet：识别被老年代对象指向的 Eden 中的对象，这些被指向的对象被认为是存活的对象，把需要回收的分区放入 Young CSet 中进行回收</li><li>复制对象：Eden 区内存段中存活的对象会被复制到 survivor 区，survivor 区内存段中存活的对象如果年龄未达阈值，年龄会加1，达到阀值会被会被复制到 old 区中空的内存分段，如果 survivor 空间不够，Eden 空间的部分数据会直接晋升到老年代空间</li><li>处理引用：处理 Soft，Weak，Phantom，JNI Weak  等引用，最终 Eden 空间的数据为空，GC 停止工作</li></ol></li><li><p>**Concurrent Mark **：</p><ul><li>初始标记：标记从根节点直接可达的对象，这个阶段是 STW 的，并且会触发一次年轻代 GC</li><li>根区域扫描 (Root Region Scanning)：扫描 Survivor 区中指向老年代的，被初始标记标记了的引用及引用的对象，这一个过程是并发进行的，但是必须在 Young GC 之前完成</li><li>并发标记 (Concurrent Marking)：在整个堆中进行并发标记（应用程序并发执行），可能被 YoungGC 中断。会计算每个区域的对象活性，即区域中存活对象的比例，若区域中的所有对象都是垃圾，则这个区域会被立即回收（实时回收），给浮动垃圾准备出更多的空间，把需要收集的 Region 放入 CSet 当中</li><li>最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中，这阶段需要停顿线程，但是可并行执行（<strong>防止漏标</strong>）</li><li>筛选回收：并发清理阶段，首先对 CSet 中各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率</li></ul><p><img src="https://gitee.com/seazean/images/raw/master/Java/JVM-G1%E6%94%B6%E9%9B%86%E5%99%A8.jpg"></p></li><li><p><strong>Mixed GC</strong>：当很多对象晋升到老年代时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即 Mixed GC，除了回收整个 young region，还会<strong>回收一部分</strong>的 old region，过程同 YGC</p><p>注意：<strong>是一部分老年代，而不是全部老年代</strong>，可以选择哪些老年代 region 收集，对垃圾回收的时间进行控制</p><p>在 G1 中，Mixed GC 可以通过 <code>-XX:InitiatingHeapOccupancyPercent</code> 设置阈值</p></li><li><p><strong>Full GC</strong>：对象内存分配速度过快，Mixed GC 来不及回收，导致老年代被填满，就会触发一次 Full GC，G1 的 Full GC 算法就是单线程执行的垃圾回收，会导致异常长时间的暂停时间，需要进行不断的调优，尽可能的避免 Full GC</p><p>产生 Full GC 的原因：</p><ul><li>晋升时没有足够的空间存放晋升的对象</li><li>并发处理过程完成之前空间耗尽，浮动垃圾</li></ul></li></ul><hr><h5 id="相关参数"><a href="#相关参数" class="headerlink" title="相关参数"></a>相关参数</h5><ul><li><code>-XX:+UseG1GC</code>：手动指定使用 G1 垃圾收集器执行内存回收任务</li><li><code>-XX:G1HeapRegionSize</code>：设置每个 Region 的大小。值是 2 的幂，范围是 1MB 到 32MB 之间，目标是根据最小的 Java 堆大小划分出约 2048 个区域，默认是堆内存的 1/2000</li><li><code>-XX:MaxGCPauseMillis</code>：设置期望达到的最大 GC 停顿时间指标，JVM会尽力实现，但不保证达到，默认值是 200ms</li><li><code>-XX:+ParallelGcThread</code>：设置 STW 时 GC 线程数的值，最多设置为 8</li><li><code>-XX:ConcGCThreads</code>：设置并发标记线程数，设置为并行垃圾回收线程数 ParallelGcThreads 的1/4左右</li><li><code>-XX:InitiatingHeapoccupancyPercent</code>：设置触发并发 Mixed GC 周期的 Java 堆占用率阈值，超过此值，就触发 GC，默认值是 45</li><li><code>-XX:+ClassUnloadingWithConcurrentMark</code>：并发标记类卸载，默认启用，所有对象都经过并发标记后，就可以知道哪些类不再被使用，当一个类加载器的所有类都不再使用，则卸载它所加载的所有类</li><li><code>-XX:G1NewSizePercent</code>：新生代占用整个堆内存的最小百分比（默认5％） </li><li><code>-XX:G1MaxNewSizePercent</code>：新生代占用整个堆内存的最大百分比（默认60％） </li><li><code>-XX:G1ReservePercent=10</code>：保留内存区域，防止 to space（Survivor中的 to 区）溢出</li></ul><hr><h5 id="调优"><a href="#调优" class="headerlink" title="调优"></a>调优</h5><p>G1 的设计原则就是简化 JVM 性能调优，只需要简单的三步即可完成调优：</p><ol><li>开启 G1 垃圾收集器</li><li>设置堆的最大内存</li><li>设置最大的停顿时间（STW）</li></ol><p>不断调优暂停时间指标：</p><ul><li><code>XX:MaxGCPauseMillis=x</code> 可以设置启动应用程序暂停的时间，G1会根据这个参数选择 CSet 来满足响应时间的设置</li><li>设置到 100ms 或者 200ms 都可以（不同情况下会不一样），但设置成50ms就不太合理</li><li>暂停时间设置的太短，就会导致出现 G1 跟不上垃圾产生的速度，最终退化成 Full GC</li><li>对这个参数的调优是一个持续的过程，逐步调整到最佳状态</li></ul><p>不要设置新生代和老年代的大小：</p><ul><li>避免使用 -Xmn 或 -XX:NewRatio 等相关选项显式设置年轻代大小，G1 收集器在运行的时候会调整新生代和老年代的大小，从而达到我们为收集器设置的暂停时间目标</li><li>设置了新生代大小相当于放弃了 G1 为我们做的自动调优，我们需要做的只是设置整个堆内存的大小，剩下的交给 G1 自己去分配各个代的大小</li></ul><hr><h4 id="ZGC"><a href="#ZGC" class="headerlink" title="ZGC"></a>ZGC</h4><p>ZGC 收集器是一个可伸缩的、低延迟的垃圾收集器，基于 Region 内存布局的，不设分代，使用了读屏障、染色指针和内存多重映射等技术来实现<strong>可并发的标记压缩算法</strong></p><ul><li>在 CMS 和 G1 中都用到了写屏障，而 ZGC 用到了读屏障</li><li>染色指针：直接<strong>将少量额外的信息存储在指针上的技术</strong>，从 64 位的指针中拿高 4 位来标识对象此时的状态<ul><li>染色指针可以使某个 Region 的存活对象被移走之后，这个 Region 立即就能够被释放和重用</li><li>可以直接从指针中看到引用对象的三色标记状态（Marked0、Marked1）、是否进入了重分配集、是否被移动过（Remapped）、是否只能通过 finalize() 方法才能被访问到（Finalizable）</li><li>可以大幅减少在垃圾收集过程中内存屏障的使用数量，写屏障的目的通常是为了记录对象引用的变动情况，如果将这些信息直接维护在指针中，显然就可以省去一些专门的记录操作</li><li>可以作为一种可扩展的存储结构用来记录更多与对象标记、重定位过程相关的数据</li></ul></li><li>内存多重映射：多个虚拟地址指向同一个物理地址</li></ul><p>可并发的标记压缩算法：染色指针标识对象是否被标记或移动，读屏障保证在每次应用程序或 GC 程序访问对象时先根据染色指针的标识判断是否被移动，如果被移动就根据转发表访问新的移动对象，并更新引用，不会像 G1 一样必须等待垃圾回收完成才能访问</p><p>ZGC 目标：</p><ul><li>停顿时间不会超过 10ms</li><li>停顿时间不会随着堆的增大而增大（不管多大的堆都能保持在 10ms 以下）</li><li>可支持几百 M，甚至几 T 的堆大小（最大支持4T）</li></ul><p>ZGC 的工作过程可以分为 4 个阶段：</p><ul><li>并发标记（Concurrent Mark）： 遍历对象图做可达性分析的阶段，也要经过初始标记和最终标记，需要短暂停顿</li><li>并发预备重分配（ Concurrent Prepare for Relocate）：根据特定的查询条件统计得出本次收集过程要清理哪些 Region，将这些 Region 组成重分配集（Relocation Set）</li><li>并发重分配（Concurrent Relocate）： 重分配是 ZGC 执行过程中的核心阶段，这个过程要把重分配集中的存活对象复制到新的 Region 上，并为重分配集中的<strong>每个 Region 维护一个转发表</strong>（Forward Table），记录从旧地址到新地址的转向关系</li><li>并发重映射（Concurrent Remap）：修正整个堆中指向重分配集中旧对象的所有引用，ZGC 的并发映射并不是一个必须要立即完成的任务，ZGC 很巧妙地把并发重映射阶段要做的工作，合并到下一次垃圾收集循环中的并发标记阶段里去完成，因为都是要遍历所有对象，这样合并节省了一次遍历的开销</li></ul><p>ZGC 几乎在所有地方并发执行的，除了初始标记的是 STW 的，但这部分的实际时间是非常少的，所以响应速度快，在尽可能对吞吐量影响不大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的低延迟</p><p>优点：高吞吐量、低延迟</p><p>缺点：浮动垃圾，当 ZGC 准备要对一个很大的堆做一次完整的并发收集，其全过程要持续十分钟以上，由于应用的对象分配速率很高，将创造大量的新对象产生浮动垃圾</p><p>参考文章：<a href="https://www.cnblogs.com/jimoer/p/13170249.html">https://www.cnblogs.com/jimoer/p/13170249.html</a></p><hr><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Serial GC、Parallel GC、Concurrent Mark Sweep GC 这三个 GC  不同：</p><ul><li>最小化地使用内存和并行开销，选 Serial GC</li><li>最大化应用程序的吞吐量，选 Parallel GC</li><li>最小化 GC 的中断或停顿时间，选 CMS GC</li></ul><p><img src="https://gitee.com/seazean/images/raw/master/Java/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E6%80%BB%E7%BB%93.png"></p><hr><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><h4 id="泄露溢出"><a href="#泄露溢出" class="headerlink" title="泄露溢出"></a>泄露溢出</h4><p>内存泄漏（Memory Leak）：是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果</p><p>可达性分析算法来判断对象是否是不再使用的对象，本质都是判断一个对象是否还被引用。由于代码的实现不同就会出现很多种内存泄漏问题，让 JVM 误以为此对象还在引用中，无法回收，造成内存泄漏</p><p>内存溢出（out of memory）指的是申请内存时，没有足够的内存可以使用</p><p>内存泄漏和内存溢出的关系：内存泄漏的越来越多，最终会导致内存溢出</p><hr><h4 id="几种情况"><a href="#几种情况" class="headerlink" title="几种情况"></a>几种情况</h4><h5 id="静态集合"><a href="#静态集合" class="headerlink" title="静态集合"></a>静态集合</h5><p>静态集合类的生命周期与 JVM 程序一致，则容器中的对象在程序结束之前将不能被释放，从而造成内存泄漏。原因是<strong>长生命周期的对象持有短生命周期对象的引用</strong>，尽管短生命周期的对象不再使用，但是因为长生命周期对象持有它的引用而导致不能被回收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryLeak</span> </span>&#123;    <span class="keyword">static</span> List list = <span class="keyword">new</span> ArrayList();    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">oomTest</span><span class="params">()</span></span>&#123;        Object obj = <span class="keyword">new</span> Object();<span class="comment">//局部变量        list.add(obj);    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h5 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h5><p>单例模式和静态集合导致内存泄露的原因类似，因为单例的静态特性，它的生命周期和 JVM 的生命周期一样长，所以如果单例对象持有外部对象的引用，那么这个外部对象也不会被回收，那么就会造成内存泄漏</p><hr><h5 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h5><p>内部类持有外部类的情况，如果一个外部类的实例对象调用方法返回了一个内部类的实例对象，即使那个外部类实例对象不再被使用，但由于内部类持有外部类的实例对象，这个外部类对象也不会被回收，造成内存泄漏</p><hr><h5 id="连接相关"><a href="#连接相关" class="headerlink" title="连接相关"></a>连接相关</h5><p>数据库连接、网络连接和 IO 连接等，当不再使用时，需要显式调用 close 方法来释放与连接，垃圾回收器才会回收对应的对象，否则将会造成大量的对象无法被回收，从而引起内存泄漏</p><hr><h5 id="不合理域"><a href="#不合理域" class="headerlink" title="不合理域"></a>不合理域</h5><p>变量不合理的作用域，一个变量的定义的作用范围大于其使用范围，很有可能会造成内存泄漏；如果没有及时地把对象设置为 null，也有可能导致内存泄漏的发生</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsingRandom</span> </span>&#123;    <span class="keyword">private</span> String msg;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveMsg</span><span class="params">()</span></span>&#123;        msg = readFromNet();<span class="comment">// 从网络中接受数据保存到 msg 中        saveDB(msg);// 把 msg 保存到数据库中    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>通过 readFromNet 方法把接收消息保存在 msg 中，然后调用 saveDB 方法把内容保存到数据库中，此时 msg 已经可以被回收，但是 msg 的生命周期与对象的生命周期相同，造成 msg 不能回收，产生内存泄漏</p><p>解决：</p><ul><li>msg 变量可以放在 receiveMsg 方法内部，当方法使用完，msg 的生命周期也就结束，就可以被回收了</li><li>在使用完 msg 后，把 msg 设置为 null，这样垃圾回收器也会回收 msg 的内存空间。</li></ul><hr><h5 id="改变哈希"><a href="#改变哈希" class="headerlink" title="改变哈希"></a>改变哈希</h5><p>当一个对象被存储进 HashSet 集合中以后，就<strong>不能修改这个对象中的那些参与计算哈希值的字段</strong>，否则对象修改后的哈希值与最初存储进 HashSet 集合中时的哈希值不同，这种情况下使用该对象的当前引用作为的参数去 HashSet 集合中检索对象返回 false，导致无法从 HashSet 集合中单独删除当前对象，造成内存泄漏</p><hr><h5 id="缓存泄露"><a href="#缓存泄露" class="headerlink" title="缓存泄露"></a>缓存泄露</h5><p>内存泄漏的一个常见来源是缓存，一旦把对象引用放入到缓存中，就会很容易被遗忘</p><p>使用 WeakHashMap 代表缓存，当除了自身有对 key 的引用外没有其他引用，map 会自动丢弃此值</p><hr><h5 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h5><p>监听器和其他回调情况，假如客户端在实现的 API 中注册回调，却没有显式的取消，那么就会一直积聚下去，所以确保回调立即被当作垃圾回收的最佳方法是只保存它的弱引用，比如保存为 WeakHashMap 中的键</p><hr><h4 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;    <span class="keyword">private</span> Object[] elements;    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;    <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span> </span>&#123;        elements = <span class="keyword">new</span> Object[DEFAULT_INITIAL_CAPACITY];    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Object e)</span> </span>&#123; <span class="comment">//入栈        ensureCapacity();        elements[size++] = e;    &#125;    public Object pop() &#123; //出栈        if (size == 0)            throw new EmptyStackException();        return elements[--size];    &#125;    private void ensureCapacity() &#123;        if (elements.length == size)            elements = Arrays.copyOf(elements, 2 * size + 1);    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>程序并没有明显错误，但 pop 函数存在内存泄漏问题，因为 pop 函数只是把栈顶索引下移一位，并没有把上一个出栈索引处的引用置空，导致栈数组一直强引用着已经出栈的对象</p><p>解决方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span> </span>&#123;    <span class="keyword">if</span> (size == <span class="number">0</span>)        <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();    Object result = elements[--size];    elements[size] = <span class="keyword">null</span>;    <span class="keyword">return</span> result;&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><h3 id="对象访存"><a href="#对象访存" class="headerlink" title="对象访存"></a>对象访存</h3><h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><p>一个 Java 对象内存中存储为三部分：对象头（Header）、实例数据（Instance Data）和对齐填充 （Padding）</p><p>对象头：</p><ul><li><p>普通对象：分为两部分</p><ul><li><p><strong>Mark Word</strong>：用于存储对象自身的运行时数据， 如哈希码（HashCode）、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash(<span class="number">25</span>) + age(<span class="number">4</span>) + lock(<span class="number">3</span>) = 32bit<span class="comment">#32位系统unused(25+1) + hash(31) + age(4) + lock(3) = 64bit#64位系统</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Klass Word</strong>：类型指针，<strong>指向该对象的 Class 类对象的指针</strong>，虚拟机通过这个指针来确定这个对象是哪个类的实例；在 64 位系统中，开启指针压缩（-XX:+UseCompressedOops）或者 JVM 堆的最大值小于 32G，这个指针也是 4byte，否则是 8byte（就是 <strong>Java 中的一个引用的大小</strong>）</p></li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">|-----------------------------------------------------|</span><span class="params">|   Object Header (64 bits)   |</span><span class="params">|---------------------------|</span>-------------------------<span class="params">||</span>  Mark Word (<span class="number">32</span> bits)<span class="params">|  Klass Word (32 bits)   |</span><span class="params">|---------------------------|</span>-------------------------<span class="params">|</span></span><br></pre></td></tr></table></figure></li><li><p>数组对象：如果对象是一个数组，那在对象头中还有一块数据用于记录数组长度（12 字节）</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">|-------------------------------------------------------------------------------|</span><span class="params">|   Object Header (96 bits)     |</span><span class="params">|-----------------------|</span>-----------------------------<span class="params">|-------------------------|</span><span class="params">|  Mark Word(32bits)    |</span>   Klass Word(32bits)   <span class="params">|   array length(32bits)  |</span><span class="params">|-----------------------|</span>-----------------------------<span class="params">|-------------------------|</span></span><br></pre></td></tr></table></figure></li></ul><p>实例数据：实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的，都需要记录起来</p><p>对齐填充：Padding 起占位符的作用。64 位系统，由于 HotSpot VM 的自动内存管理系统要求<strong>对象起始地址必须是 8 字节的整数倍</strong>，就是对象的大小必须是 8 字节的整数倍，而对象头部分正好是 8 字节的倍数（1 倍或者 2 倍），因此当对象实例数据部分没有对齐时，就需要通过对齐填充来补全</p><p>32 位系统：</p><ul><li><p>一个 int 在 java 中占据 4byte，所以 Integer 的大小为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需要补位4byte4(Mark Word) + 4(Klass Word) + 4(data) + 4(Padding) = 16byte</span></span><br></pre></td></tr></table></figure></li><li><p><code>int[] arr = new int[10]</code></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 由于需要8位对齐，所以最终大小为`56byte`。4(Mark Word) + 4(Klass Word) + 4(length) + 4*10(10个int大小) + 4(Padding) = 56sbyte</span></span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="实际大小"><a href="#实际大小" class="headerlink" title="实际大小"></a>实际大小</h4><p>浅堆（Shallow Heap）：<strong>对象本身占用的内存，不包括内部引用对象的大小</strong>，32 位系统中一个对象引用占 4 个字节，每个对象头占用 8 个字节，根据堆快照格式不同，对象的大小会同 8 字节进行对齐</p><p>JDK7 中的 String：2个 int 值共占 8 字节，value 对象引用占用 4 字节，对象头 8 字节，对齐后占 24 字节，为 String 对象的浅堆大小，与 value 实际取值无关，无论字符串长度如何，浅堆大小始终是 24 字节</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];<span class="keyword">private</span> <span class="keyword">int</span> hash;<span class="keyword">private</span> <span class="keyword">int</span> hash32;</span><br></pre></td></tr></table></figure><p>保留集（Retained Set）：对象 A 的保留集指当对象 A 被垃圾回收后，可以被释放的所有的对象集合（包括 A 本身），所以对象 A 的保留集就是只能通过对象 A 被直接或间接访问到的所有对象的集合，就是仅被对象 A 所持有的对象的集合</p><p>深堆（Retained Heap）：指对象的保留集中所有的对象的浅堆大小之和，一个对象的深堆指只能通过该对象访问到的（直接或间接）所有对象的浅堆之和，即对象被回收后，可以释放的真实空间</p><p>对象的实际大小：一个对象所能触及的所有对象的浅堆大小之和，也就是通常意义上我们说的对象大小</p><p>下图显示了一个简单的对象引用关系图，对象 A 引用了 C 和 D，对象 B 引用了 C 和 E。那么对象 A 的浅堆大小只是 A 本身，<strong>A 的实际大小为 A、C、D 三者之和</strong>，A 的深堆大小为 A 与 D 之和，由于对象 C 还可以通过对象 B 访问到 C，因此 C 不在对象 A 的深堆范围内</p><img src="https://gitee.com/seazean/images/raw/master/Java/JVM-对象的实际大小.png" style="zoom: 67%;"><p>内存分析工具 MAT 提供了一种叫支配树的对象图，体现了对象实例间的支配关系</p><p>基本性质：</p><ul><li><p>对象 A 的子树（所有被对象 A 支配的对象集合）表示对象 A 的保留集（retained set），即深堆</p></li><li><p>如果对象 A 支配对象 B，那么对象 A 的直接支配者也支配对象 B</p></li><li><p>支配树的边与对象引用图的边不直接对应</p></li></ul><p>左图表示对象引用图，右图表示左图所对应的支配树：</p><p><img src="https://gitee.com/seazean/images/raw/master/Java/JVM-%E6%94%AF%E9%85%8D%E6%A0%91.png"></p><p>比如：对象 F 与对象 D 相互引用，因为到对象 F 的所有路径必然经过对象 D，因此对象 D 是对象 F 的直接支配者</p><hr><h4 id="节约内存"><a href="#节约内存" class="headerlink" title="节约内存"></a>节约内存</h4><ul><li><p>尽量使用基本数据类型</p></li><li><p>满足容量前提下，尽量用小字段</p></li><li><p>尽量用数组，少用集合，数组中是可以使用基本类型的，但是集合中只能放包装类型，如果需要使用集合，推荐比较节约内存的集合工具：fastutil</p><p>一个 ArrayList 集合，如果里面放了 10 个数字，占用多少内存：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] elementData;<span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure><p>Mark Word 占 4byte，Klass Word 占 4byte，一个 int 字段占 4byte，elementData 数组占 12byte，数组中 10 个 Integer 对象占 10×16，所以整个集合空间大小为 184byte（深堆）</p></li><li><p>时间用 long/int 表示，不用 Date 或者 String</p></li></ul><hr><h4 id="对象访问"><a href="#对象访问" class="headerlink" title="对象访问"></a>对象访问</h4><p>JVM 是通过<strong>栈帧中的对象引用</strong>访问到其内部的对象实例：</p><ul><li><p>句柄访问：Java 堆中会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息</p><p>优点：reference 中存储的是稳定的句柄地址，在对象被移动（垃圾收集）时只会改变句柄中的实例数据指针，而 reference 本身不需要被修改</p><p><img src="https://gitee.com/seazean/images/raw/master/Java/JVM-%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE-%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE.png"></p></li><li><p>直接指针（HotSpot 采用）：Java 堆对象的布局必须考虑如何放置访问类型数据的相关信息，reference 中直接存储的对象地址</p><p>优点：速度更快，<strong>节省了一次指针定位的时间开销</strong></p><p>缺点：对象被移动时（如进行GC后的内存重新排列），对象的 reference 也需要同步更新</p><p><img src="https://gitee.com/seazean/images/raw/master/Java/JVM-%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE-%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88.png"></p></li></ul><p>参考文章：<a href="https://www.cnblogs.com/afraidToForget/p/12584866.html">https://www.cnblogs.com/afraidToForget/p/12584866.html</a></p><hr><h3 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h3><h4 id="生命周期-1"><a href="#生命周期-1" class="headerlink" title="生命周期"></a>生命周期</h4><p>在 Java 中，对象的生命周期包括以下几个阶段：</p><ol><li><pre><code> 创建阶段 (Created)：</code></pre></li><li><pre><code> 应用阶段 (In Use)：对象至少被一个强引用持有着</code></pre></li><li><pre><code> 不可见阶段 (Invisible)：程序的执行已经超出了该对象的作用域，不再持有该对象的任何强引用</code></pre></li><li><pre><code> 不可达阶段 (Unreachable)：该对象不再被任何强引用所持有，包括 GC Root 的强引用</code></pre></li><li><pre><code> 收集阶段 (Collected)：垃圾回收器对该对象的内存空间重新分配做好准备，该对象如果重写了 finalize() 方法，则会去执行该方法</code></pre></li><li><pre><code> 终结阶段 (Finalized)：等待垃圾回收器对该对象空间进行回收，当对象执行完 finalize()方 法后仍然处于不可达状态时进入该阶段</code></pre></li><li><pre><code> 对象空间重分配阶段 (De-allocated)：垃圾回收器对该对象的所占用的内存空间进行回收或者再分配</code></pre></li></ol><p>参考文章：<a href="https://blog.csdn.net/sodino/article/details/38387049">https://blog.csdn.net/sodino/article/details/38387049</a></p><hr><h4 id="创建时机"><a href="#创建时机" class="headerlink" title="创建时机"></a>创建时机</h4><p>类在第一次实例化加载一次，后续实例化不再加载，引用第一次加载的类</p><p>Java 对象创建时机：</p><ol><li><p>使用 new 关键字创建对象：由执行类实例创建表达式而引起的对象创建</p></li><li><p>使用 Class 类的 newInstance 方法（反射机制）</p></li><li><p>使用 Constructor 类的 newInstance 方法（反射机制）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;    <span class="keyword">private</span> <span class="keyword">int</span> id;    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(Integer id)</span> </span>&#123;        <span class="keyword">this</span>.id = id;    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;        Constructor&lt;Student&gt; c = Student.class.getConstructor(Integer.class);        Student stu = c.newInstance(<span class="number">123</span>);    &#125;&#125;</span><br></pre></td></tr></table></figure><p>使用 newInstance 方法的这两种方式创建对象使用的就是 Java 的反射机制，事实上 Class 的 newInstance 方法内部调用的也是 Constructor 的 newInstance 方法</p></li><li><p>使用 Clone 方法创建对象：用 clone 方法创建对象的过程中并不会调用任何构造函数，要想使用 clone 方法，我们就必须先实现 Cloneable 接口并实现其定义的 clone 方法</p></li><li><p>使用（反）序列化机制创建对象：当反序列化一个对象时，JVM 会创建一个<strong>单独的对象</strong>，在此过程中，JVM 并不会调用任何构造函数，为了反序列化一个对象，需要让类实现 Serializable 接口</p></li></ol><p>从 Java 虚拟机层面看，除了使用 new 关键字创建对象的方式外，其他方式全部都是通过转变为 invokevirtual 指令直接创建对象的</p><hr><h4 id="创建过程"><a href="#创建过程" class="headerlink" title="创建过程"></a>创建过程</h4><p>创建对象的过程：</p><ol><li><p>判断对象对应的类是否加载、链接、初始化</p></li><li><p>为对象分配内存：指针碰撞、空闲链表。当一个对象被创建时，虚拟机就会为其分配内存来存放对象的实例变量及其从父类继承过来的实例变量，即使从<strong>隐藏变量</strong>也会被分配空间（继承部分解释了为什么会隐藏）</p></li><li><p>处理并发安全问题：</p><ul><li>采用 CAS 配上自旋保证更新的原子性</li><li>每个线程预先分配一块 TLAB</li></ul></li><li><p>初始化分配的空间：虚拟机将分配到的内存空间都初始化为零值（不包括对象头），保证对象实例字段在不赋值时可以直接使用，程序能访问到这些字段的数据类型所对应的零值</p></li><li><p>设置对象的对象头：将对象的所属类（类的元数据信息）、对象的 HashCode、对象的 GC 信息、锁信息等数据存储在对象头中</p></li><li><p>执行 init 方法进行实例化：实例变量初始化、实例代码块初始化 、构造函数初始化</p><ul><li><p>实例变量初始化与实例代码块初始化：</p><p>对实例变量直接赋值或者使用实例代码块赋值，<strong>编译器会将其中的代码放到类的构造函数中去</strong>，并且这些代码会被放在对超类构造函数的调用语句之后 (Java 要求构造函数的第一条语句必须是超类构造函数的调用语句)，构造函数本身的代码之前</p></li><li><p>构造函数初始化：</p><p><strong>Java 要求在实例化类之前，必须先实例化其超类，以保证所创建实例的完整性</strong>，在准备实例化一个类的对象前，首先准备实例化该类的父类，如果该类的父类还有父类，那么准备实例化该类的父类的父类，依次递归直到递归到 Object 类。然后从 Object 类依次对以下各类进行实例化，初始化父类中的变量和执行构造函数</p></li></ul></li></ol><hr><h4 id="承上启下"><a href="#承上启下" class="headerlink" title="承上启下"></a>承上启下</h4><ol><li><p>一个实例变量在对象初始化的过程中会被赋值几次？</p><p>JVM 在为一个对象分配完内存之后，会给每一个实例变量赋予默认值，这个实例变量被第一次赋值<br>在声明实例变量的同时对其进行了赋值操作，那么这个实例变量就被第二次赋值<br>在实例代码块中又对变量做了初始化操作，那么这个实例变量就被第三次赋值<br>在构造函数中也对变量做了初始化操作，那么这个实例变量就被第四次赋值<br>在 Java 的对象初始化过程中，一个实例变量最多可以被初始化 4 次</p></li><li><p>类的初始化过程与类的实例化过程的异同？</p><p>类的初始化是指类加载过程中的初始化阶段对类变量按照代码进行赋值的过程<br>类的实例化是指在类完全加载到内存中后创建对象的过程（类的实例化触发了类的初始化，先初始化才能实例化）</p></li><li><p>假如一个类还未加载到内存中，那么在创建一个该类的实例时，具体过程是怎样的？（<strong>经典案例</strong>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticTest</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        staticFunction();<span class="comment">//调用静态方法，触发初始化    &#125;    static StaticTest st = new StaticTest();    static &#123;   //静态代码块        System.out.println(&quot;1&quot;);    &#125;    &#123;       // 实例代码块        System.out.println(&quot;2&quot;);    &#125;    StaticTest() &#123;    // 实例构造器        System.out.println(&quot;3&quot;);        System.out.println(&quot;a=&quot; + a + &quot;,b=&quot; + b);    &#125;    public static void staticFunction() &#123;   // 静态方法        System.out.println(&quot;4&quot;);    &#125;    int a = 110;    // 实例变量    static int b = 112;     // 静态变量&#125;/* Output:         2        3        a=110,b=0        1        4 *///:~</span></span><br></pre></td></tr></table></figure><p><code>static StaticTest st = new StaticTest();</code>：</p><ul><li><p>实例实例化不一定要在类初始化结束之后才开始</p></li><li><p>在同一个类加载器下，一个类型只会被初始化一次。所以一旦开始初始化一个类，无论是否完成后续都不会再重新触发该类型的初始化阶段了（只考虑在同一个类加载器下的情形）。因此在实例化上述程序中的 st 变量时，<strong>实际上是把实例化嵌入到了静态初始化流程中，并且在上面的程序中，嵌入到了静态初始化的起始位置</strong>，这就导致了实例初始化完全发生在静态初始化之前，这也是导致 a 为 110，b 为 0 的原因</p></li></ul><p>代码等价于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticTest</span> </span>&#123;    &lt;clinit&gt;()&#123;        a = <span class="number">110</span>;    <span class="comment">// 实例变量        System.out.println(&quot;2&quot;);        // 实例代码块        System.out.println(&quot;3&quot;);     // 实例构造器中代码的执行        System.out.println(&quot;a=&quot; + a + &quot;,b=&quot; + b);  // 实例构造器中代码的执行        类变量st被初始化        System.out.println(&quot;1&quot;);        //静态代码块        类变量b被初始化为112    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="加载过程"><a href="#加载过程" class="headerlink" title="加载过程"></a>加载过程</h3><h4 id="生命周期-2"><a href="#生命周期-2" class="headerlink" title="生命周期"></a>生命周期</h4><p>类是在运行期间<strong>第一次使用时动态加载</strong>的（不使用不加载），而不是一次性加载所有类，因为一次性加载会占用很多的内存，加载的类信息存放于一块成为方法区的内存空间</p><p><img src="https://gitee.com/seazean/images/raw/master/Java/JVM-%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png"></p><p>包括 7 个阶段：</p><ul><li>加载（Loading）</li><li>链接：验证（Verification）、准备（Preparation）、解析（Resolution）</li><li>初始化（Initialization）</li><li>使用（Using）</li><li>卸载（Unloading）</li></ul><hr><h4 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h4><p>加载是类加载的其中一个阶段，注意不要混淆</p><p>加载过程完成以下三件事：</p><ul><li>通过类的完全限定名称获取定义该类的二进制字节流（二进制字节码）</li><li>将该字节流表示的<strong>静态存储结构转换为方法区的运行时存储结构</strong>（Java 类模型）</li><li>在内存中生成一个代表该类的 Class 对象，作为该类在方法区中的各种数据的访问入口</li></ul><p>其中二进制字节流可以从以下方式中获取：</p><ul><li>从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础</li><li>从网络中获取，最典型的应用是 Applet</li><li>由其他文件生成，例如由 JSP 文件生成对应的 Class 类</li><li>运行时计算生成，例如动态代理技术，在 java.lang.reflect.Proxy 使用 ProxyGenerator.generateProxyClass 生成字节码</li></ul><p>将字节码文件加载至方法区后，会<strong>在堆中</strong>创建一个 java.lang.Class 对象，用来引用位于方法区内的数据结构，该 Class 对象是在加载类的过程中创建的，每个类都对应有一个 Class 类型的对象</p><p>方法区内部采用 C++ 的 instanceKlass 描述 Java 类的数据结构：</p><ul><li><code>_java_mirror</code> 即 java 的类镜像，例如对 String 来说就是 String.class，作用是把 class 暴露给 java 使用</li><li><code>_super</code> 即父类、<code>_fields</code> 即成员变量、<code>_methods</code> 即方法、<code>_constants</code> 即常量池、<code>_class_loader</code> 即类加载器、<code>_vtable</code> <strong>虚方法表</strong>、<code>_itable</code> 接口方法表</li></ul><p>加载过程：</p><ul><li>如果这个类还有父类没有加载，先加载父类</li><li>加载和链接可能是交替运行的</li><li>Class 对象和 _java_mirror 相互持有对方的地址，堆中对象通过 instanceKlass 和元空间进行交互</li></ul><img src="https://gitee.com/seazean/images/raw/master/Java/JVM-类的生命周期-加载.png" style="zoom:80%;"><p>创建数组类有些特殊，因为数组类本身并不是由类加载器负责创建，而是由 JVM 在运行时根据需要而直接创建的，但数组的元素类型仍然需要依靠类加载器去创建，创建数组类的过程：</p><ul><li>如果数组的元素类型是引用类型，那么遵循定义的加载过程递归加载和创建数组的元素类型</li><li>JVM 使用指定的元素类型和数组维度来创建新的数组类</li><li>基本数据类型由启动类加载器加载</li></ul><hr><h4 id="链接阶段"><a href="#链接阶段" class="headerlink" title="链接阶段"></a>链接阶段</h4><h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><p>确保 Class 文件的字节流中包含的信息是否符合 JVM 规范，保证被加载类的正确性，不会危害虚拟机自身的安全</p><p>主要包括<strong>四种验证</strong>：</p><ul><li><p>文件格式验证</p></li><li><p>语义检查，但凡在语义上不符合规范的，虚拟机不会给予验证通过</p><ul><li><p>是否所有的类都有父类的存在（除了 Object 外，其他类都应该有父类）</p></li><li><p>是否一些被定义为 final 的方法或者类被重写或继承了</p></li><li><p>非抽象类是否实现了所有抽象方法或者接口方法</p></li><li><p>是否存在不兼容的方法</p></li></ul></li><li><p>字节码验证，试图通过对字节码流的分析，判断字节码是否可以被正确地执行</p><ul><li>在字节码的执行过程中，是否会跳转到一条不存在的指令</li><li>函数的调用是否传递了正确类型的参数</li><li>变量的赋值是不是给了正确的数据类型</li><li>栈映射帧（StackMapTable）在这个阶段用于检测在特定的字节码处，其局部变量表和操作数栈是否有着正确的数据类型</li></ul></li><li><p>符号引用验证，Class 文件在其常量池会通过字符串记录将要使用的其他类或者方法</p></li></ul><hr><h5 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h5><p>准备阶段为<strong>静态变量分配内存并设置初始值</strong>，使用的是方法区的内存：</p><ul><li>类变量也叫静态变量，就是是被 static 修饰的变量</li><li>实例变量也叫对象变量，即没加 static 的变量</li></ul><p>说明：实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次</p><p>类变量初始化：</p><ul><li>static 变量分配空间和赋值是两个步骤：<strong>分配空间在准备阶段完成，赋值在初始化阶段完成</strong></li><li>如果 static 变量是 final 的基本类型以及字符串常量，那么编译阶段值（方法区）就确定了，准备阶段会显式初始化</li><li>如果 static 变量是 final 的，但属于引用类型或者构造器方法的字符串，赋值在初始化阶段完成</li></ul><p>实例：</p><ul><li><p>初始值一般为 0 值，例如下面的类变量 value 被初始化为 0 而不是 123：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></table></figure></li><li><p>常量 value 被初始化为 123 而不是 0：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></table></figure></li><li><p>Java 并不支持 boolean 类型，对于 boolean 类型，内部实现是 int，由于 int 的默认值是0，故 boolean 的默认值就是 false</p></li></ul><hr><h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><p>将常量池中类、接口、字段、方法的<strong>符号引用替换为直接引用</strong>（内存地址）的过程：</p><ul><li>符号引用：一组符号来描述目标，可以是任何字面量，属于编译原理方面的概念，如：包括类和接口的全限名、字段的名称和描述符、方法的名称和<strong>方法描述符</strong></li><li>直接引用：直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄，如果有了直接引用，那说明引用的目标必定已经存在于内存之中</li></ul><p>例如：在 <code>com.demo.Solution</code> 类中引用了 <code>com.test.Quest</code>，把 <code>com.test.Quest</code> 作为符号引用存进类常量池，在类加载完后，<strong>用这个符号引用去方法区找这个类的内存地址</strong></p><p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等</p><ul><li>在类加载阶段解析的是非虚方法，静态绑定</li><li>也可以在初始化阶段之后再开始解析，这是为了支持 Java 的<strong>动态绑定</strong></li><li>通过解析操作，符号引用就可以转变为目标方法在类的虚方法表中的位置，从而使得方法被成功调用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Load2</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;    ClassLoader classloader = Load2.class.getClassLoader();    <span class="comment">// cloadClass 加载类方法不会导致类的解析和初始化，也不会加载D    Class&lt;?&gt; c = classloader.loadClass(&quot;cn.jvm.t3.load.C&quot;);            // new C();会导致类的解析和初始化，从而解析初始化D    System.in.read();    &#125;&#125;class C &#123;D d = new D();&#125;class D &#123;&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><p>初始化阶段才真正开始执行类中定义的 Java 程序代码，在准备阶段，类变量已经赋过一次系统要求的初始值；在初始化阶段，通过程序制定的计划去初始化类变量和其它资源，执行 <clinit></clinit></p><p>在编译生成 class 文件时，编译器会产生两个方法加于 class 文件中，一个是类的初始化方法 clinit，另一个是实例的初始化方法 init</p><p>类构造器 <clinit>() 与实例构造器 <init>() 不同，它不需要程序员进行显式调用，在一个类的生命周期中，类构造器最多被虚拟机<strong>调用一次</strong>，而实例构造器则会被虚拟机调用多次，只要程序员创建对象</init></clinit></p><p>类在第一次实例化加载一次，把 class 读入内存，后续实例化不再加载，引用第一次加载的类</p><hr><h5 id="clinit"><a href="#clinit" class="headerlink" title="clinit"></a>clinit</h5><p><clinit>()：类构造器，由编译器自动收集类中<strong>所有类变量的赋值动作和静态语句块</strong>中的语句合并产生的</clinit></p><p>作用：是在类加载过程中的初始化阶段进行静态变量初始化和执行静态代码块</p><ul><li>如果类中没有静态变量或静态代码块，那么 clinit 方法将不会被生成</li><li>clinit 方法只执行一次，在执行 clinit 方法时，必须先执行父类的clinit方法</li><li>static 变量的赋值操作和静态代码块的合并顺序由源文件中出现的顺序决定</li><li>static 不加 final 的变量都在初始化环节赋值</li></ul><p><strong>线程安全</strong>问题：</p><ul><li>虚拟机会保证一个类的 <clinit>() 方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的 <clinit>() 方法，其它线程都阻塞等待，直到活动线程执行 <clinit>() 方法完毕</clinit></clinit></clinit></li><li>如果在一个类的 <clinit>() 方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽</clinit></li></ul><p>特别注意：静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;    <span class="keyword">static</span> &#123;        <span class="comment">//i = 0;                // 给变量赋值可以正常编译通过        System.out.print(i);  // 这句编译器会提示“非法向前引用”    &#125;    static int i = 1;&#125;</span></span><br></pre></td></tr></table></figure><p>接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成 <clinit>() 方法，两者不同的是：</clinit></p><ul><li>在初始化一个接口时，并不会先初始化它的父接口，所以执行接口的 <clinit>() 方法不需要先执行父接口的 <clinit>() 方法</clinit></clinit></li><li>在初始化一个类时，不会先初始化所实现的接口，所以接口的实现类在初始化时不会执行接口的 <clinit>() 方法</clinit></li><li>只有当父接口中定义的变量使用时，父接口才会初始化</li></ul><hr><h5 id="时机"><a href="#时机" class="headerlink" title="时机"></a>时机</h5><p>类的初始化是懒惰的，只有在首次使用时才会被装载，JVM 不会无条件地装载 Class 类型，Java 虚拟机规定，一个类或接口在初次使用前，必须要进行初始化</p><p><strong>主动引用</strong>：虚拟机规范中并没有强制约束何时进行加载，但是规范严格规定了有且只有下列情况必须对类进行初始化（加载、验证、准备都会发生）：</p><ul><li>当创建一个类的实例时，使用 new 关键字，或者通过反射、克隆、反序列化（前文讲述的对象的创建时机）</li><li>当调用类的静态方法或访问静态字段时，遇到 getstatic、putstatic、invokestatic 这三条字节码指令，如果类没有进行过初始化，则必须先触发其初始化<ul><li>getstatic：程序访问类的静态变量（不是静态常量，常量会被加载到运行时常量池）</li><li>putstatic：程序给类的静态变量赋值</li><li>invokestatic ：调用一个类的静态方法</li></ul></li><li>使用 java.lang.reflect 包的方法对类进行反射调用时，如果类没有进行初始化，则需要先触发其初始化</li><li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化，但这条规则并<strong>不适用于接口</strong></li><li>当虚拟机启动时，需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类</li><li>MethodHandle 和 VarHandle 可以看作是轻量级的反射调用机制，而要想使用这两个调用， 就必须先使用 findStaticVarHandle 来初始化要调用的类</li><li>补充：当一个接口中定义了 JDK8 新加入的默认方法（被 default 关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化</li></ul><p><strong>被动引用</strong>：所有引用类的方式都不会触发初始化，称为被动引用</p><ul><li>通过子类引用父类的静态字段，不会导致子类初始化，只会触发父类的初始化</li><li>通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法</li><li>常量（final 修饰）在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化</li><li>调用 ClassLoader 类的 loadClass() 方法加载一个类，并不是对类的主动使用，不会导致类的初始化</li></ul><hr><h5 id="init"><a href="#init" class="headerlink" title="init"></a>init</h5><p>init 指的是实例构造器，主要作用是在类实例化过程中执行，执行内容包括成员变量初始化和代码块的执行</p><p>实例化即调用 <init>()V ，虚拟机会保证这个类的构造方法的线程安全，先为实例变量分配内存空间，再执行赋默认值，然后根据源码中的顺序执行赋初值或代码块，没有成员变量初始化和代码块则不会执行</init></p><p>类实例化过程：<strong>父类的类构造器<clinit>() -&gt; 子类的类构造器<clinit>() -&gt; 父类的成员变量和实例代码块 -&gt; 父类的构造函数 -&gt; 子类的成员变量和实例代码块 -&gt; 子类的构造函数</clinit></clinit></strong></p><hr><h4 id="卸载阶段"><a href="#卸载阶段" class="headerlink" title="卸载阶段"></a>卸载阶段</h4><p>时机：执行了 System.exit() 方法，程序正常执行结束，程序在执行过程中遇到了异常或错误而异常终止，由于操作系统出现错误而导致Java虚拟机进程终止</p><p>卸载类即该类的 <strong>Class 对象被 GC</strong>，卸载类需要满足3个要求:</p><ol><li>该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象</li><li>该类没有在其他任何地方被引用</li><li>该类的类加载器的实例已被 GC，一般是可替换类加载器的场景，如 OSGi、JSP 的重加载等，很难达成</li></ol><p>在 JVM 生命周期类，由 JVM 自带的类加载器加载的类是不会被卸载的，自定义的类加载器加载的类是可能被卸载。因为 JVM 会始终引用启动、扩展、系统类加载器，这些类加载器始终引用它们所加载的类，这些类始终是可及的</p><hr><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><h4 id="类加载-1"><a href="#类加载-1" class="headerlink" title="类加载"></a>类加载</h4><p>类加载方式：</p><ul><li>隐式加载：不直接在代码中调用 ClassLoader 的方法加载类对象<ul><li>创建类对象、使用类的静态域、创建子类对象、使用子类的静态域</li><li>在 JVM 启动时，通过三大类加载器加载 class</li></ul></li><li>显式加载：<ul><li>ClassLoader.loadClass(className)：只加载和连接，<strong>不会进行初始化</strong></li><li>Class.forName(String name, boolean initialize, ClassLoader loader)：使用 loader 进行加载和连接，根据参数 initialize 决定是否初始化</li></ul></li></ul><p>类的唯一性：</p><ul><li>在 JVM 中表示两个 class 对象判断为同一个类存在的两个必要条件：<ul><li>类的完整类名必须一致，包括包名</li><li>加载这个类的 ClassLoader（指 ClassLoader 实例对象）必须相同</li></ul></li><li>这里的相等，包括类的 Class 对象的 equals() 方法、isAssignableFrom() 方法、isInstance() 方法的返回结果为 true，也包括使用 instanceof 关键字做对象所属关系判定结果为 true</li></ul><p>命名空间：</p><ul><li>每个类加载器都有自己的命名空间，命名空间由该加载器及所有的父加载器所加载的类组成</li><li>在同一命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类</li></ul><p>基本特征：</p><ul><li><strong>可见性</strong>，子类加载器可以访问父加载器加载的类型，但是反过来是不允许的</li><li><strong>单一性</strong>，由于父加载器的类型对于子加载器是可见的，所以父加载器中加载过的类型，不会在子加载器中重复加载</li></ul><hr><h4 id="加载器"><a href="#加载器" class="headerlink" title="加载器"></a>加载器</h4><p>类加载器是 Java 的核心组件，用于加载字节码到 JVM 内存，得到 Class 类的对象</p><p>从 Java 虚拟机规范来讲，只存在以下两种不同的类加载器：</p><ul><li>启动类加载器（Bootstrap ClassLoader）：使用 C++ 实现，是虚拟机自身的一部分</li><li>自定义类加载器（User-Defined ClassLoader）：Java 虚拟机规范<strong>将所有派生于抽象类 ClassLoader 的类加载器都划分为自定义类加载器</strong>，使用 Java 语言实现，独立于虚拟机</li></ul><p>从 Java 开发人员的角度看：</p><ul><li>启动类加载器（Bootstrap ClassLoader）：<ul><li>处于安全考虑，Bootstrap 启动类加载器只加载包名为 java、javax、sun 等开头的类</li><li>类加载器负责加载在 <code>JAVA_HOME/jre/lib  </code>或 <code>sun.boot.class.path</code> 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的类，并且是虚拟机识别的类库加载到虚拟机内存中</li><li>仅按照文件名识别，如 rt.jar 名字不符合的类库即使放在 lib 目录中也不会被加载</li><li>启动类加载器无法被 Java 程序直接引用，编写自定义类加载器时，如果要把加载请求委派给启动类加载器，直接使用 null 代替</li></ul></li><li>扩展类加载器（Extension ClassLoader）：<ul><li>由 ExtClassLoader (sun.misc.Launcher$ExtClassLoader)  实现，上级为 Bootstrap，显示为 null</li><li>将 <code>JAVA_HOME/jre/lib/ext </code>或者被 <code>java.ext.dir</code> 系统变量所指定路径中的所有类库加载到内存中</li><li>开发者可以使用扩展类加载器，创建的 JAR 放在此目录下，会由扩展类加载器自动加载</li></ul></li><li>应用程序类加载器（Application ClassLoader）：<ul><li>由 AppClassLoader(sun.misc.Launcher$AppClassLoader) 实现，上级为 Extension</li><li>负责加载环境变量 classpath 或系统属性 <code>java.class.path</code> 指定路径下的类库</li><li>这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，因此称为系统类加载器</li><li>可以直接使用这个类加载器，如果应用程序中没有自定义类加载器，这个就是程序中默认的类加载器</li></ul></li><li>自定义类加载器：由开发人员自定义的类加载器，上级是 Application</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    <span class="comment">//获取系统类加载器    ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();    System.out.println(systemClassLoader);//sun.misc.Launcher$AppClassLoader@18b4aac2    //获取其上层  扩展类加载器    ClassLoader extClassLoader = systemClassLoader.getParent();    System.out.println(extClassLoader);//sun.misc.Launcher$ExtClassLoader@610455d6    //获取其上层 获取不到引导类加载器    ClassLoader bootStrapClassLoader = extClassLoader.getParent();    System.out.println(bootStrapClassLoader);//null    //对于用户自定义类来说：使用系统类加载器进行加载    ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();    System.out.println(classLoader);//sun.misc.Launcher$AppClassLoader@18b4aac2    //String 类使用引导类加载器进行加载的 --&gt; java核心类库都是使用启动类加载器加载的    ClassLoader classLoader1 = String.class.getClassLoader();    System.out.println(classLoader1);//null&#125;</span></span><br></pre></td></tr></table></figure><p>补充两个类加载器：</p><ul><li>SecureClassLoader 扩展了 ClassLoader，新增了几个与使用相关的代码源和权限定义类验证（对 class 源码的访问权限）的方法，一般不会直接跟这个类打交道，更多是与它的子类 URLClassLoader 有所关联</li><li>ClassLoader 是一个抽象类，很多方法是空的没有实现，而 URLClassLoader 这个实现类为这些方法提供了具体的实现，并新增了 URLClassPath 类协助取得 Class 字节流等功能。在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承 URLClassLoader 类，这样就可以避免去编写 findClass() 方法及其获取字节码流的方式，使自定义类加载器编写更加简洁</li></ul><hr><h4 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h4><p>ClassLoader 类，是一个抽象类，其后所有的类加载器都继承自 ClassLoader（不包括启动类加载器）</p><p>获取 ClassLoader 的途径：</p><ul><li>获取当前类的 ClassLoader：<code>clazz.getClassLoader()</code></li><li>获取当前线程上下文的 ClassLoader：<code>Thread.currentThread.getContextClassLoader()</code></li><li>获取系统的 ClassLoader：<code>ClassLoader.getSystemClassLoader()</code></li><li>获取调用者的 ClassLoader：<code>DriverManager.getCallerClassLoader()</code></li></ul><p>ClassLoader 类常用方法：</p><ul><li><code>getParent()</code>：返回该类加载器的超类加载器  </li><li><code>loadclass(String name)</code>：加载名为 name 的类，返回结果为 Class 类的实例，<strong>该方法就是双亲委派模式</strong></li><li><code>findclass(String name)</code>：查找二进制名称为 name 的类，返回结果为 Class 类的实例，该方法会在检查完父类加载器之后被 loadClass() 方法调用</li><li><code>findLoadedClass(String name)</code>：查找名称为 name 的已经被加载过的类，final 修饰无法重写</li><li><code>defineClass(String name, byte[] b, int off, int len)</code>：将<strong>字节流</strong>解析成 JVM 能够识别的类对象</li><li><code>resolveclass(Class&lt;?&gt; c)</code>：链接指定的 Java 类，可以使类的 Class 对象创建完成的同时也被解析</li><li><code>InputStream getResourceAsStream(String name)</code>：指定资源名称获取输入流</li></ul><hr><h4 id="加载模型"><a href="#加载模型" class="headerlink" title="加载模型"></a>加载模型</h4><h5 id="加载机制"><a href="#加载机制" class="headerlink" title="加载机制"></a>加载机制</h5><p>在 JVM 中，对于类加载模型提供了三种，分别为全盘加载、双亲委派、缓存机制</p><ul><li><p><strong>全盘加载：</strong>当一个类加载器负责加载某个 Class 时，该 Class 所依赖和引用的其他 Class 也将由该类加载器负责载入，除非显示指定使用另外一个类加载器来载入</p></li><li><p><strong>双亲委派：</strong>先让父类加载器加载该 Class，在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。简单来说就是，某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，<strong>依次递归</strong>，如果父加载器可以完成类加载任务，就成功返回；只有当父加载器无法完成此加载任务时，才自己去加载</p></li><li><p><strong>缓存机制：</strong>会保证所有加载过的 Class 都会被缓存，当程序中需要使用某个 Class 时，类加载器先从缓存区中搜寻该 Class，只有当缓存区中不存在该 Class 对象时，系统才会读取该类对应的二进制数据，并将其转换成 Class 对象存入缓冲区中</p><ul><li>这就是修改了 Class 后，必须重新启动 JVM，程序所做的修改才会生效的原因</li></ul></li></ul><hr><h5 id="双亲委派"><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h5><p>双亲委派模型（Parents Delegation Model）：该模型要求除了顶层的启动类加载器外，其它类加载器都要有父类加载器，这里的父子关系一般通过组合关系（Composition）来实现，而不是继承关系（Inheritance）</p><p>工作过程：一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成时才尝试自己加载</p><p>双亲委派机制的优点：</p><ul><li><p>可以避免某一个类被重复加载，当父类已经加载后则无需重复加载，保证全局唯一性</p></li><li><p>Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一</p></li><li><p>保护程序安全，防止类库的核心 API 被随意篡改</p><p>例如：在工程中新建 java.lang 包，接着在该包下新建 String 类，并定义 main 函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        System.out.println(<span class="string">&quot;demo info&quot;</span>);    &#125;&#125;</span><br></pre></td></tr></table></figure><p>此时执行 main 函数，会出现异常，在类 java.lang.String 中找不到 main 方法，防止恶意篡改核心 API 库。出现该信息是因为双亲委派的机制，java.lang.String 的在启动类加载器（Bootstrap）得到加载，启动类加载器优先级更高，在核心 jre 库中有其相同名字的类文件，但该类中并没有 main 方法</p></li></ul><p>双亲委派机制的缺点：检查类是否加载的委托过程是单向的，这个方式虽然从结构上看比较清晰，使各个 ClassLoader 的职责非常明确，但<strong>顶层的 ClassLoader 无法访问底层的 ClassLoader 所加载的类</strong>（可见性）</p><img src="https://gitee.com/seazean/images/raw/master/Java/JVM-双亲委派模型.png" style="zoom: 50%;"><hr><h5 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)    <span class="keyword">throws</span> ClassNotFoundException &#123;    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;       <span class="comment">// 调用当前类加载器的 findLoadedClass(name)，检查当前类加载器是否已加载过指定 name 的类        Class c = findLoadedClass(name);                // 当前类加载器如果没有加载过        if (c == null) &#123;            long t0 = System.nanoTime();            try &#123;                // 判断当前类加载器是否有父类加载器                if (parent != null) &#123;                    // 如果当前类加载器有父类加载器，则调用父类加载器的 loadClass(name,false)         // 父类加载器的 loadClass 方法，又会检查自己是否已经加载过                    c = parent.loadClass(name, false);                &#125; else &#123;                    // 当前类加载器没有父类加载器，说明当前类加载器是 BootStrapClassLoader          // 则调用 BootStrap ClassLoader 的方法加载类                    c = findBootstrapClassOrNull(name);                &#125;            &#125; catch (ClassNotFoundException e) &#123; &#125;            if (c == null) &#123;                // 如果调用父类的类加载器无法对类进行加载，则用自己的 findClass() 方法进行加载                // 可以自定义 findClass() 方法                long t1 = System.nanoTime();                c = findClass(name);                // this is the defining class loader; record the stats                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);                sun.misc.PerfCounter.getFindClasses().increment();            &#125;        &#125;        if (resolve) &#123;            // 链接指定的 Java 类，可以使类的 Class 对象创建完成的同时也被解析            resolveClass(c);        &#125;        return c;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h5 id="破坏委派"><a href="#破坏委派" class="headerlink" title="破坏委派"></a>破坏委派</h5><p>双亲委派模型并不是一个具有强制性约束的模型，而是 Java 设计者推荐给开发者的类加载器实现方式</p><p>破坏双亲委派模型的方式：</p><ul><li><p>自定义 ClassLoader</p><ul><li>如果不想破坏双亲委派模型，只需要重写 findClass 方法</li><li>如果想要去破坏双亲委派模型，需要去**重写 loadClass **方法</li></ul></li><li><p>引入线程<strong>上下文类加载器</strong></p><p>Java 提供了很多服务提供者接口（Service Provider Interface，SPI），允许第三方为这些接口提供实现。常见的 SPI 有 JDBC、JCE、JNDI 等。这些 SPI 接口由 Java 核心库来提供，而 SPI 的实现代码则是作为 Java 应用所依赖的 jar 包被包含进类路径 classpath 里，SPI 接口中的代码需要加载具体的实现类：</p><ul><li>SPI 的接口是 Java 核心库的一部分，是由引导类加载器来加载的</li><li>SPI 的实现类是由系统类加载器来加载的，引导类加载器是无法找到 SPI 的实现类的，因为依照双亲委派模型，BootstrapClassloader 无法委派 AppClassLoader 来加载类</li></ul><p>JDK 开发人员引入了线程上下文类加载器（Thread Context ClassLoader），这种类加载器可以通过 Thread  类的 setContextClassLoader 方法进行设置线程上下文类加载器，在执行线程中抛弃双亲委派加载模式，使程序可以逆向使用类加载器，使 Bootstrap 加载器拿到了 Application 加载器加载的类，破坏了双亲委派模型</p></li><li><p>实现程序的动态性，如代码热替换（Hot Swap）、模块热部署（Hot Deployment）</p><p>IBM 公司主导的 JSR一291（OSGiR4.2）实现模块化热部署的关键是它自定义的类加载器机制的实现，每一个程序模块（OSGi 中称为 Bundle）都有一个自己的类加载器，当更换一个 Bundle 时，就把 Bundle 连同类加载器一起换掉以实现代码的热替换，在 OSGi 环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的网状结构</p><p>当收到类加载请求时，OSGi 将按照下面的顺序进行类搜索:</p><ol><li>将以 java.* 开头的类，委派给父类加载器加载</li><li>否则，将委派列表名单内的类，委派给父类加载器加载</li><li>否则，将 Import 列表中的类，委派给 Export 这个类的 Bundle 的类加载器加载</li><li>否则，查找当前 Bundle 的 ClassPath，使用自己的类加载器加载</li><li>否则，查找类是否在自己的 Fragment Bundle 中，如果在就委派给 Fragment Bundle 类加载器加载</li><li>否则，查找 Dynamic Import 列表的 Bundle，委派给对应 Bundle 的类加载器加载</li><li>否则，类查找失败</li></ol><p>热替换是指在程序的运行过程中，不停止服务，只通过替换程序文件来修改程序的行为，<strong>热替换的关键需求在于服务不能中断</strong>，修改必须立即表现正在运行的系统之中</p></li></ul><img src="https://gitee.com/seazean/images/raw/master/Java/JVM-热替换.png" style="zoom: 33%;"><hr><h4 id="沙箱机制"><a href="#沙箱机制" class="headerlink" title="沙箱机制"></a>沙箱机制</h4><p>沙箱机制（Sandbox）：将 Java 代码限定在虚拟机特定的运行范围中，并且严格限制代码对本地系统资源访问，来保证对代码的有效隔离，防止对本地系统造成破坏</p><p>沙箱<strong>限制系统资源访问</strong>，包括 CPU、内存、文件系统、网络，不同级别的沙箱对资源访问的限制也不一样</p><ul><li>JDK1.0：Java 中将执行程序分成本地代码和远程代码两种，本地代码默认视为可信任的，而远程代码被看作是不受信的。对于授信的本地代码，可以访问一切本地资源，而对于非授信的远程代码不可以访问本地资源，其实依赖于沙箱机制。如此严格的安全机制也给程序的功能扩展带来障碍，比如当用户希望远程代码访问本地系统的文件时候，就无法实现</li><li>JDK1.1：针对安全机制做了改进，增加了安全策略。允许用户指定代码对本地资源的访问权限</li><li>JDK1.2：改进了安全机制，增加了代码签名，不论本地代码或是远程代码都会按照用户的安全策略设定，由类加载器加载到虚拟机中权限不同的运行空间，来实现差异化的代码执行权限控制</li><li>JDK1.6：当前最新的安全机制，引入了域（Domain）的概念。虚拟机会把所有代码加载到不同的系统域和应用域，不同的保护域对应不一样的权限。系统域部分专门负责与关键资源进行交互，而各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问</li></ul><img src="https://gitee.com/seazean/images/raw/master/Java/JVM-沙箱机制.png" style="zoom:67%;"><hr><h4 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h4><p>对于自定义类加载器的实现，只需要继承 ClassLoader 类，覆写 findClass 方法即可</p><p>作用：隔离加载类、修改类加载的方式、拓展加载源、防止源码泄漏</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义类加载器，读取指定的类路径classPath下的class文件public class MyClassLoader extends ClassLoader&#123;    private String classPath;    public MyClassLoader(String classPath) &#123;        this.classPath = classPath;    &#125;         public MyClassLoader(ClassLoader parent, String byteCodePath) &#123;        super(parent);        this.classPath = classPath;    &#125;    @Override    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;       BufferedInputStream bis = null;        ByteArrayOutputStream baos = null;        try &#123;            // 获取字节码文件的完整路径            String fileName = classPath + className + &quot;.class&quot;;            // 获取一个输入流            bis = new BufferedInputStream(new FileInputStream(fileName));            // 获取一个输出流            baos = new ByteArrayOutputStream();            // 具体读入数据并写出的过程            int len;            byte[] data = new byte[1024];            while ((len = bis.read(data)) != -1) &#123;                baos.write(data, 0, len);            &#125;            // 获取内存中的完整的字节数组的数据            byte[] byteCodes = baos.toByteArray();            // 调用 defineClass()，将字节数组的数据转换为 Class 的实例。            Class clazz = defineClass(null, byteCodes, 0, byteCodes.length);            return clazz;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally &#123;            try &#123;                if (baos != null)                    baos.close();            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;            try &#123;                if (bis != null)                    bis.close();            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;        return null;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    MyClassLoader loader = <span class="keyword">new</span> MyClassLoader(<span class="string">&quot;D:\Workspace\Project\JVM_study\src\java1\&quot;);    try &#123;        Class clazz = loader.loadClass(&quot;</span>Demo1<span class="string">&quot;);        System.out.println(&quot;</span>加载此类的类的加载器为：<span class="string">&quot; + clazz.getClassLoader().getClass().getName());//MyClassLoader        System.out.println(&quot;</span>加载当前类的类的加载器的父类加载器为：<span class="string">&quot; + clazz.getClassLoader().getParent().getClass().getName());//sun.misc.Launcher$AppClassLoader    &#125; catch (ClassNotFoundException e) &#123;        e.printStackTrace();    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="JDK9"><a href="#JDK9" class="headerlink" title="JDK9"></a>JDK9</h4><p>为了保证兼容性，JDK9 没有改变三层类加载器架构和双亲委派模型，但为了模块化系统的顺利运行做了一些变动：</p><ul><li><p>扩展机制被移除，扩展类加载器由于<strong>向后兼容性</strong>的原因被保留，不过被重命名为平台类加载器（platform classloader），可以通过 ClassLoader 的新方法 getPlatformClassLoader() 来获取</p></li><li><p>JDK9 基于模块化进行构建（原来的 rt.jar 和 tools.jar 被拆分成数个 JMOD 文件），其中 Java 类库就满足了可扩展的需求，那就无须再保留 <code>&lt;JAVA_HOME&gt;\lib\ext</code> 目录，此前使用这个目录或者 <code>java.ext.dirs</code> 系统变量来扩展 JDK 功能的机制就不需要再存在</p></li><li><p>启动类加载器、平台类加载器、应用程序类加载器全都继承于 <code>jdk.internal.loader.BuiltinClassLoader</code></p></li></ul><hr><h2 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h2><h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><p> Java 文件编译执行的过程：</p><p><img src="https://gitee.com/seazean/images/raw/master/Java/JVM-Java%E6%96%87%E4%BB%B6%E7%BC%96%E8%AF%91%E6%89%A7%E8%A1%8C%E7%9A%84%E8%BF%87%E7%A8%8B.png"></p><ul><li>类加载器：用于装载字节码文件(.class文件)</li><li>运行时数据区：用于分配存储空间</li><li>执行引擎：执行字节码文件或本地方法</li><li>垃圾回收器：用于对 JVM 中的垃圾内容进行回收</li></ul><hr><h3 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h3><h4 id="跨平台性"><a href="#跨平台性" class="headerlink" title="跨平台性"></a>跨平台性</h4><p>Java 语言：跨平台的语言（write once ，run anywhere）</p><ul><li>当 Java 源代码成功编译成字节码后，在不同的平台上面运行<strong>无须再次编译</strong></li><li>让一个 Java 程序正确地运行在 JVM 中，Java 源码就必须要被编译为符合 JVM 规范的字节码</li></ul><p>编译过程中的编译器：</p><ul><li><p>前端编译器： Sun 的全量式编译器 javac、 Eclipse 的增量式编译器 ECJ，把源代码编译为字节码文件.class</p><ul><li>IntelliJ IDEA 使用 javac 编译器</li><li>Eclipse 中，当开发人员编写完代码后保存时，ECJ 编译器就会把未编译部分的源码逐行进行编译，而非每次都全量编译，因此 ECJ 的编译效率会比 javac 更加迅速和高效</li><li>前端编译器并不会直接涉及编译优化等方面的技术，具体优化细节移交给 HotSpot 的 JIT 编译器负责</li></ul></li><li><p>后端运行期编译器：HotSpot VM 的 C1、C2 编译器，也就是 JIT 编译器，Graal 编译器</p><ul><li>JIT编译器：执行引擎部分详解</li><li>Graal 编译器：JDK10 HotSpot 加入的一个全新的即时编译器，编译效果短短几年时间就追平了 C2</li></ul></li><li><p>静态提前编译器：AOT  (Ahead Of Time Compiler)编译器，直接把源代码编译成本地机器代码，</p><ul><li><p>JDK 9 引入，是与即时编译相对立的一个概念，即时编译指的是在程序的运行过程中将字节码转换为机器码，AOT 是程序运行之前便将字节码转换为机器码</p></li><li><p>优点：JVM 加载已经预编译成二进制库，可以直接执行，不必等待即时编译器的预热，减少 Java 应用第一次运行慢的现象</p></li><li><p>缺点：</p><ul><li>破坏了 Java <strong>一次编译，到处运行</strong>，必须为每个不同硬件编译对应的发行包</li><li>降低了 Java 链接过程的动态性，加载的代码在编译期就必须全部已知</li></ul></li></ul></li></ul><hr><h4 id="语言发展"><a href="#语言发展" class="headerlink" title="语言发展"></a>语言发展</h4><p>机器码：各种用二进制编码方式表示的指令，与 CPU 紧密相关，所以不同种类的 CPU 对应的机器指令不同</p><p>指令：指令就是把机器码中特定的 0 和 1 序列，简化成对应的指令，例如 mov，inc 等，可读性稍好，但是不同的硬件平台的同一种指令（比如 mov），对应的机器码也可能不同</p><p>指令集：不同的硬件平台支持的指令是有区别的，每个平台所支持的指令，称之为对应平台的指令集</p><ul><li>x86 指令集，对应的是 x86 架构的平台</li><li>ARM 指令集，对应的是 ARM 架构的平台</li></ul><p>汇编语言：用助记符代替机器指令的操作码，用地址符号或标号代替指令或操作数的地址</p><ul><li>在不同的硬件平台，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令</li><li>计算机只认识指令码，汇编语言编写的程序也必须翻译成机器指令码，计算机才能识别和执行</li></ul><p>高级语言：为了使计算机用户编程序更容易些，后来就出现了各种高级计算机语言</p><p>字节码：是一种中间状态（中间码）的二进制代码，比机器码更抽象，需要直译器转译后才能成为机器码</p><ul><li>字节码为了实现特定软件运行和软件环境，与硬件环境无关</li><li>通过编译器和虚拟机器实现，编译器将源码编译成字节码，虚拟机器将字节码转译为可以直接执行的指令</li></ul><img src="https://gitee.com/seazean/images/raw/master/Java/JVM-高级语言执行过程.png" style="zoom:50%;"><hr><h4 id="类结构"><a href="#类结构" class="headerlink" title="类结构"></a>类结构</h4><h5 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h5><p>字节码是一种二进制的类文件，是编译之后供虚拟机解释执行的二进制字节码文件，<strong>一个 class 文件对应一个 public 类型的类或接口</strong></p><p>字节码内容是 <strong>JVM 的字节码指令</strong>，不是机器码，C、C++ 经由编译器直接生成机器码，所以 C 执行效率比 Java 高</p><p>JVM 官方文档：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html">https://docs.oracle.com/javase/specs/jvms/se8/html/index.html</a></p><p>根据 JVM 规范，类文件结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;u4 magic;    u2 minor_version;    u2 major_version;    u2 constant_pool_count;    cp_infoconstant_pool[constant_pool_count-<span class="number">1</span>];    u2 access_flags;    u2 this_class;    u2 super_class;    u2 interfaces_count;    u2 interfaces[interfaces_count];    u2 fields_count;    field_info fields[fields_count];    u2 methods_count;    method_info methods[methods_count];    u2 attributes_count;    attribute_info attributes[attributes_count];&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>类型</th><th>名称</th><th>说明</th><th>长度</th><th>数量</th></tr></thead><tbody><tr><td>u4</td><td>magic</td><td>魔数，识别类文件格式</td><td>4个字节</td><td>1</td></tr><tr><td>u2</td><td>minor_version</td><td>副版本号(小版本)</td><td>2个字节</td><td>1</td></tr><tr><td>u2</td><td>major_version</td><td>主版本号(大版本)</td><td>2个字节</td><td>1</td></tr><tr><td>u2</td><td>constant_pool_count</td><td>常量池计数器</td><td>2个字节</td><td>1</td></tr><tr><td>cp_info</td><td>constant_pool</td><td>常量池表</td><td>n个字节</td><td>constant_pool_count-1</td></tr><tr><td>u2</td><td>access_flags</td><td>访问标识</td><td>2个字节</td><td>1</td></tr><tr><td>u2</td><td>this_class</td><td>类索引</td><td>2个字节</td><td>1</td></tr><tr><td>u2</td><td>super_class</td><td>父类索引</td><td>2个字节</td><td>1</td></tr><tr><td>u2</td><td>interfaces_count</td><td>接口计数</td><td>2个字节</td><td>1</td></tr><tr><td>u2</td><td>interfaces</td><td>接口索引集合</td><td>2个字节</td><td>interfaces_count</td></tr><tr><td>u2</td><td>fields_count</td><td>字段计数器</td><td>2个字节</td><td>1</td></tr><tr><td>field_info</td><td>fields</td><td>字段表</td><td>n个字节</td><td>fields_count</td></tr><tr><td>u2</td><td>methods_count</td><td>方法计数器</td><td>2个字节</td><td>1</td></tr><tr><td>method_info</td><td>methods</td><td>方法表</td><td>n个字节</td><td>methods_count</td></tr><tr><td>u2</td><td>attributes_count</td><td>属性计数器</td><td>2个字节</td><td>1</td></tr><tr><td>attribute_info</td><td>attributes</td><td>属性表</td><td>n个字节</td><td>attributes_count</td></tr></tbody></table><p>Class 文件格式采用一种类似于 C 语言结构体的方式进行数据存储，这种结构中只有两种数据类型：无符号数和表</p><ul><li>无符号数属于基本的数据类型，以 u1、u2、u4、u8 来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照 UTF-8 编码构成字符串</li><li>表是由多个无符号数或者其他表作为数据项构成的复合数据类型，表都以 <code>_info</code> 结尾，用于描述有层次关系的数据，整个 Class 文件本质上就是一张表，由于表没有固定长度，所以通常会在其前面加上个数说明</li></ul><p>获取方式：</p><ul><li>HelloWorld.java 执行 <code>javac -parameters -d . HellowWorld.java</code>指令</li><li>写入文件指令 <code>javap -v xxx.class &gt;xxx.txt</code></li><li>IDEA 插件 jclasslib </li></ul><hr><h5 id="魔数版本"><a href="#魔数版本" class="headerlink" title="魔数版本"></a>魔数版本</h5><p>魔数：每个 Class 文件开头的 4 个字节的无符号整数称为魔数（Magic Number），是 Class 文件的标识符，代表这是一个能被虚拟机接受的有效合法的 Class 文件，</p><ul><li><p>魔数值固定为 0xCAFEBABE，不符合则会抛出错误</p></li><li><p>使用魔数而不是扩展名来进行识别主要是基于安全方面的考虑，因为文件扩展名可以随意地改动</p></li></ul><p>版本：4 个 字节，5 6两个字节代表的是编译的副版本号 minor_version，而 7 8 两个字节是编译的主版本号 major_version</p><ul><li>不同版本的 Java 编译器编译的 Class 文件对应的版本是不一样的，高版本的 Java 虚拟机可以执行由低版本编译器生成的 Class 文件，反之 JVM 会抛出异常 <code>java.lang.UnsupportedClassVersionError</code></li></ul><table><thead><tr><th>主版本（十进制）</th><th>副版本（十进制）</th><th>编译器版本</th></tr></thead><tbody><tr><td>45</td><td>3</td><td>1.1</td></tr><tr><td>46</td><td>0</td><td>1.2</td></tr><tr><td>47</td><td>0</td><td>1.3</td></tr><tr><td>48</td><td>0</td><td>1.4</td></tr><tr><td>49</td><td>0</td><td>1.5</td></tr><tr><td>50</td><td>0</td><td>1.6</td></tr><tr><td>51</td><td>0</td><td>1.7</td></tr><tr><td>52</td><td>0</td><td>1.8</td></tr><tr><td>53</td><td>0</td><td>1.9</td></tr><tr><td>54</td><td>0</td><td>1.10</td></tr><tr><td>55</td><td>0</td><td>1.11</td></tr></tbody></table><p><img src="https://gitee.com/seazean/images/raw/master/Java/JVM-%E7%B1%BB%E7%BB%93%E6%9E%84.png"></p><p>图片来源：<a href="https://www.bilibili.com/video/BV1PJ411n7xZ">https://www.bilibili.com/video/BV1PJ411n7xZ</a></p><hr><h5 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h5><p>常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项 u2 类型的无符号数，代表常量池计数器（constant_pool_count），这个容量计数是从 1 而不是 0 开始，是为了满足后面某些指向常量池的索引值的数据在特定情况下需要表达不引用任何一个常量池项目，这种情况可用索引值 0 来表示</p><p>constant_pool 是一种表结构，以1 ~ constant_pool_count - 1为索引，表明有多少个常量池表项。表项中存放编译时期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池</p><ul><li><p>字面量（Literal） ：基本数据类型、字符串类型常量、声明为 final 的常量值等</p></li><li><p>符号引用（Symbolic References）：类和接口的全限定名、字段的名称和描述符、方法的名称和描述符</p><ul><li><p>全限定名：com/test/Demo 这个就是类的全限定名，仅仅是把包名的 <code>.</code> 替换成 <code>/</code>，为了使连续的多个全限定名之间不产生混淆，在使用时最后一般会加入一个 <code>;</code> 表示全限定名结束</p></li><li><p>简单名称：指没有类型和参数修饰的方法或者字段名称，比如字段 x 的简单名称就是 x</p></li><li><p>描述符：用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值</p><table><thead><tr><th>标志符</th><th>含义</th></tr></thead><tbody><tr><td>B</td><td>基本数据类型 byte</td></tr><tr><td>C</td><td>基本数据类型 char</td></tr><tr><td>D</td><td>基本数据类型 double</td></tr><tr><td>F</td><td>基本数据类型 float</td></tr><tr><td>I</td><td>基本数据类型 int</td></tr><tr><td>J</td><td>基本数据类型 long</td></tr><tr><td>S</td><td>基本数据类型 short</td></tr><tr><td>Z</td><td>基本数据类型 boolean</td></tr><tr><td>V</td><td>代表 void 类型</td></tr><tr><td>L</td><td>对象类型，比如：<code>Ljava/lang/Object;</code>，不同方法间用<code>;</code>隔开</td></tr><tr><td>[</td><td>数组类型，代表一维数组。比如：<code>double[][][] is [[[D</code></td></tr></tbody></table></li></ul></li></ul><p>常量类型和结构：</p><table><thead><tr><th>类型</th><th>标志(或标识)</th><th>描述</th></tr></thead><tbody><tr><td>CONSTANT_utf8_info</td><td>1</td><td>UTF-8编码的字符串</td></tr><tr><td>CONSTANT_Integer_info</td><td>3</td><td>整型字面量</td></tr><tr><td>CONSTANT_Float_info</td><td>4</td><td>浮点型字面量</td></tr><tr><td>CONSTANT_Long_info</td><td>5</td><td>长整型字面量</td></tr><tr><td>CONSTANT_Double_info</td><td>6</td><td>双精度浮点型字面量</td></tr><tr><td>CONSTANT_Class_info</td><td>7</td><td>类或接口的符号引用</td></tr><tr><td>CONSTANT_String_info</td><td>8</td><td>字符串类型字面量</td></tr><tr><td>CONSTANT_Fieldref_info</td><td>9</td><td>字段的符号引用</td></tr><tr><td>CONSTANT_Methodref_info</td><td>10</td><td>类中方法的符号引用</td></tr><tr><td>CONSTANT_InterfaceMethodref_info</td><td>11</td><td>接口中方法的符号引用</td></tr><tr><td>CONSTANT_NameAndType_info</td><td>12</td><td>字段或方法的符号引用</td></tr><tr><td>CONSTANT_MethodHandle_info</td><td>15</td><td>表示方法句柄</td></tr><tr><td>CONSTANT_MethodType_info</td><td>16</td><td>标志方法类型</td></tr><tr><td>CONSTANT_InvokeDynamic_info</td><td>18</td><td>表示一个动态方法调用点</td></tr></tbody></table><p>18 种常量没有出现 byte、short、char，boolean 的原因：编译之后都可以理解为 Integer</p><hr><h5 id="访问标识"><a href="#访问标识" class="headerlink" title="访问标识"></a>访问标识</h5><p>访问标识（access_flag），又叫访问标志、访问标记，该标识用两个字节表示，用于识别一些类或者接口层次的访问信息，包括这个 Class 是类还是接口，是否定义为 public类型，是否定义为 abstract类型等</p><ul><li>类的访问权限通常为 ACC_ 开头的常量</li><li>每一种类型的表示都是通过设置访问标记的 32 位中的特定位来实现的，比如若是 public final 的类，则该标记为 <code>ACC_PUBLIC | ACC_FINAL</code></li><li>使用 <code>ACC_SUPER</code> 可以让类更准确地定位到父类的方法，确定类或接口里面的 invokespecial 指令使用的是哪一种执行语义，现代编译器都会设置并且使用这个标记</li></ul><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>标志为 public 类型</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>标志被声明为 final，只有类可以设置</td></tr><tr><td>ACC_SUPER</td><td>0x0020</td><td>标志允许使用 invokespecial 字节码指令的新语义，JDK1.0.2之后编译出来的类的这个标志默认为真，使用增强的方法调用父类方法</td></tr><tr><td>ACC_INTERFACE</td><td>0x0200</td><td>标志这是一个接口</td></tr><tr><td>ACC_ABSTRACT</td><td>0x0400</td><td>是否为 abstract 类型，对于接口或者抽象类来说，次标志值为真，其他类型为假</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x1000</td><td>标志此类并非由用户代码产生（由编译器产生的类，没有源码对应）</td></tr><tr><td>ACC_ANNOTATION</td><td>0x2000</td><td>标志这是一个注解</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>标志这是一个枚举</td></tr></tbody></table><hr><h5 id="索引集合"><a href="#索引集合" class="headerlink" title="索引集合"></a>索引集合</h5><p>类索引、父类索引、接口索引集合</p><ul><li><p>类索引用于确定这个类的全限定名</p></li><li><p>父类索引用于确定这个类的父类的全限定名，Java 语言不允许多重继承，所以父类索引只有一个，除了Object 之外，所有的 Java 类都有父类，因此除了 java.lang.Object 外，所有 Java 类的父类索引都不为0</p></li><li><p>接口索引集合就用来描述这个类实现了哪些接口</p><ul><li>interfaces_count 项的值表示当前类或接口的直接超接口数量</li><li>interfaces[] 接口索引集合，被实现的接口将按 implements 语句后的接口顺序从左到右排列在接口索引集合中</li></ul></li></ul><table><thead><tr><th>长度</th><th>含义</th></tr></thead><tbody><tr><td>u2</td><td>this_class</td></tr><tr><td>u2</td><td>super_class</td></tr><tr><td>u2</td><td>interfaces_count</td></tr><tr><td>u2</td><td>interfaces[interfaces_count]</td></tr></tbody></table><hr><h5 id="字段表"><a href="#字段表" class="headerlink" title="字段表"></a>字段表</h5><p>字段 fields 用于描述接口或类中声明的变量，包括类变量以及实例变量，但不包括方法内部、代码块内部声明的局部变量以及从父类或父接口继承。字段叫什么名字、被定义为什么数据类型，都是无法固定的，只能引用常量池中的常量来描述</p><p>fields_count（字段计数器），表示当前 class 文件 fields 表的成员个数，用两个字节来表示</p><p>fields[]（字段表）：</p><ul><li><p>表中的每个成员都是一个 fields_info 结构的数据项，用于表示当前类或接口中某个字段的完整描述</p></li><li><p>字段访问标识：</p><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>字段是否为public</td></tr><tr><td>ACC_PRIVATE</td><td>0x0002</td><td>字段是否为private</td></tr><tr><td>ACC_PROTECTED</td><td>0x0004</td><td>字段是否为protected</td></tr><tr><td>ACC_STATIC</td><td>0x0008</td><td>字段是否为static</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>字段是否为final</td></tr><tr><td>ACC_VOLATILE</td><td>0x0040</td><td>字段是否为volatile</td></tr><tr><td>ACC_TRANSTENT</td><td>0x0080</td><td>字段是否为transient</td></tr><tr><td>ACC_SYNCHETIC</td><td>0x1000</td><td>字段是否为由编译器自动产生</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>字段是否为enum</td></tr></tbody></table></li><li><p>字段名索引：根据该值查询常量池中的指定索引项即可</p></li><li><p>描述符索引：用来描述字段的数据类型、方法的参数列表和返回值</p><table><thead><tr><th>字符</th><th>类型</th><th>含义</th></tr></thead><tbody><tr><td>B</td><td>byte</td><td>有符号字节型树</td></tr><tr><td>C</td><td>char</td><td>Unicode字符，UTF-16编码</td></tr><tr><td>D</td><td>double</td><td>双精度浮点数</td></tr><tr><td>F</td><td>float</td><td>单精度浮点数</td></tr><tr><td>I</td><td>int</td><td>整型数</td></tr><tr><td>J</td><td>long</td><td>长整数</td></tr><tr><td>S</td><td>short</td><td>有符号短整数</td></tr><tr><td>Z</td><td>boolean</td><td>布尔值true/false</td></tr><tr><td>V</td><td>void</td><td>代表void类型</td></tr><tr><td>L Classname</td><td>reference</td><td>一个名为Classname的实例</td></tr><tr><td>[</td><td>reference</td><td>一个一维数组</td></tr></tbody></table></li><li><p>属性表集合：属性个数存放在 attribute_count 中，属性具体内容存放在 attribute 数组中，一个字段还可能拥有一些属性，用于存储更多的额外信息，比如初始化值、一些注释信息等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConstantValue_attribute&#123;    u2 attribute_name_index;    u4 attribute_length;    u2 constantvalue_index;&#125;</span><br></pre></td></tr></table></figure><p>对于常量属性而言，attribute_length 值恒为2</p></li></ul><hr><h5 id="方法表"><a href="#方法表" class="headerlink" title="方法表"></a>方法表</h5><p>方法表是 methods 指向常量池索引集合，其中每一个 method_info 项都对应着一个类或者接口中的方法信息，完整描述了每个方法的签名</p><ul><li>如果这个方法不是抽象的或者不是 native 的，字节码中就会体现出来</li><li>methods 表只描述当前类或接口中声明的方法，不包括从父类或父接口继承的方法</li><li>methods 表可能会出现由编译器自动添加的方法，比如初始化方法 <cinit> 和实例化方法 <init></init></cinit></li></ul><p><strong>重载（Overload）</strong>一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名，特征签名就是一个方法中各个参数在常量池中的字段符号引用的集合，因为返回值不会包含在特征签名之中，因此 Java 语言里无法仅仅依靠返回值的不同来对一个已有方法进行重载。但在 Class 文件格式中，特征签名的范围更大一些，只要描述符不是完全一致的两个方法就可以共存</p><p>methods_count（方法计数器）：表示 class 文件 methods 表的成员个数，使用两个字节来表示</p><p>methods[]（方法表）：每个表项都是一个 method_info 结构，表示当前类或接口中某个方法的完整描述</p><ul><li><p>方法表结构如下：</p><table><thead><tr><th>类型</th><th>名称</th><th>含义</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>access_flags</td><td>访问标志</td><td>1</td></tr><tr><td>u2</td><td>name_index</td><td>字段名索引</td><td>1</td></tr><tr><td>u2</td><td>descriptor_index</td><td>描述符索引</td><td>1</td></tr><tr><td>u2</td><td>attrubutes_count</td><td>属性计数器</td><td>1</td></tr><tr><td>attribute_info</td><td>attributes</td><td>属性集合</td><td>attributes_count</td></tr></tbody></table></li><li><p>方法表访问标志：</p><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>字段是否为 public</td></tr><tr><td>ACC_PRIVATE</td><td>0x0002</td><td>字段是否为 private</td></tr><tr><td>ACC_PROTECTED</td><td>0x0004</td><td>字段是否为 protected</td></tr><tr><td>ACC_STATIC</td><td>0x0008</td><td>字段是否为 static</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>字段是否为 final</td></tr><tr><td>ACC_VOLATILE</td><td>0x0040</td><td>字段是否为 volatile</td></tr><tr><td>ACC_TRANSTENT</td><td>0x0080</td><td>字段是否为 transient</td></tr><tr><td>ACC_SYNCHETIC</td><td>0x1000</td><td>字段是否为由编译器自动产生</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>字段是否为 enum</td></tr></tbody></table></li></ul><hr><h5 id="属性表"><a href="#属性表" class="headerlink" title="属性表"></a>属性表</h5><p>属性表集合，指的是 Class 文件所携带的辅助信息，比如该 Class 文件的源文件的名称，以及任何带有 <code>RetentionPolicy.CLASS</code> 或者 <code>RetentionPolicy.RUNTIME</code> 的注解，这类信息通常被用于 Java 虚拟机的验证和运行，以及 Java 程序的调试。字段表、方法表都可以有自己的属性表，用于描述某些场景专有的信息</p><p>attributes_ count（属性计数器）：表示当前文件属性表的成员个数</p><p>attributes[]（属性表）：属性表的每个项的值必须是 attribute_info 结构</p><ul><li><p>属性的通用格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConstantValue_attribute&#123;    u2 attribute_name_index;<span class="comment">//属性名索引    u4 attribute_length;//属性长度    u2 attribute_info;//属性表&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>属性类型：</p><table><thead><tr><th>属性名称</th><th>使用位置</th><th>含义</th></tr></thead><tbody><tr><td>Code</td><td>方法表</td><td>Java 代码编译成的字节码指令</td></tr><tr><td>ConstantValue</td><td>字段表</td><td>final 关键字定义的常量池</td></tr><tr><td>Deprecated</td><td>类、方法、字段表</td><td>被声明为 deprecated 的方法和字段</td></tr><tr><td>Exceptions</td><td>方法表</td><td>方法抛出的异常</td></tr><tr><td>EnclosingMethod</td><td>类文件</td><td>仅当一个类为局部类或者匿名类是才能拥有这个属性，这个属性用于标识这个类所在的外围方法</td></tr><tr><td>InnerClass</td><td>类文件</td><td>内部类列表</td></tr><tr><td>LineNumberTable</td><td>Code属性</td><td>Java 源码的行号与字节码指令的对应关系</td></tr><tr><td>LocalVariableTable</td><td>Code属性</td><td>方法的局部变量描述</td></tr><tr><td>StackMapTable</td><td>Code属性</td><td>JDK1.6中新增的属性，供新的类型检查检验器检查和处理目标方法的局部变量和操作数有所需要的类是否匹配</td></tr><tr><td>Signature</td><td>类，方法表，字段表</td><td>用于支持泛型情况下的方法签名</td></tr><tr><td>SourceFile</td><td>类文件</td><td>记录源文件名称</td></tr><tr><td>SourceDebugExtension</td><td>类文件</td><td>用于存储额外的调试信息</td></tr><tr><td>Syothetic</td><td>类，方法表，字段表</td><td>标志方法或字段为编泽器自动生成的</td></tr><tr><td>LocalVariableTypeTable</td><td>类</td><td>使用特征签名代替描述符，是为了引入泛型语法之后能描述泛型参数化类型而添加</td></tr><tr><td>RuntimeVisibleAnnotations</td><td>类，方法表，字段表</td><td>为动态注解提供支持</td></tr><tr><td>RuntimelnvisibleAnnotations</td><td>类，方法表，字段表</td><td>用于指明哪些注解是运行时不可见的</td></tr><tr><td>RuntimeVisibleParameterAnnotation</td><td>方法表</td><td>作用与 RuntimeVisibleAnnotations 属性类似，只不过作用对象为方法</td></tr><tr><td>RuntirmelnvisibleParameterAnniotation</td><td>方法表</td><td>作用与 RuntimelnvisibleAnnotations 属性类似，作用对象哪个为方法参数</td></tr><tr><td>AnnotationDefauit</td><td>方法表</td><td>用于记录注解类元素的默认值</td></tr><tr><td>BootstrapMethods</td><td>类文件</td><td>用于保存 invokeddynanic 指令引用的引导方式限定符</td></tr></tbody></table></li></ul><hr><h4 id="编译指令"><a href="#编译指令" class="headerlink" title="编译指令"></a>编译指令</h4><h5 id="javac"><a href="#javac" class="headerlink" title="javac"></a>javac</h5><p>javac：编译命令，将 java 源文件编译成 class 字节码文件</p><p><code>javac xx.java</code> 不会在生成对应的局部变量表等信息，使用 <code>javac -g xx.java</code> 可以生成所有相关信息</p><hr><h5 id="javap"><a href="#javap" class="headerlink" title="javap"></a>javap</h5><p>javap 反编译生成的字节码文件，根据 class 字节码文件，反解析出当前类对应的 code 区 （字节码指令）、局部变量表、异常表和代码行偏移量映射表、常量池等信息</p><p>用法：javap <options> <classes></classes></options></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="built_in">help</span>  --<span class="built_in">help</span>  -?        输出此用法消息-version                 版本信息-public                  仅显示公共类和成员-protected               显示受保护的/公共类和成员-package                 显示程序包/受保护的/公共类和成员 (默认)-p  -private             显示所有类和成员 <span class="comment">#常用的以下三个-v  -verbose             输出附加信息-l                       输出行号和本地变量表-c                       对代码进行反汇编#反编译-s                       输出内部类型签名-sysinfo                 显示正在处理的类的系统信息 (路径, 大小, 日期, MD5 散列)-constants               显示最终常量-classpath &lt;path&gt;        指定查找用户类文件的位置-cp &lt;path&gt;               指定查找用户类文件的位置-bootclasspath &lt;path&gt;    覆盖引导类文件的位置</span></span><br></pre></td></tr></table></figure><hr><h4 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h4><h5 id="执行指令"><a href="#执行指令" class="headerlink" title="执行指令"></a>执行指令</h5><p>Java 字节码属于 JVM 基本执行指令。由一个字节长度的代表某种操作的操作码（opcode）以及零至多个代表此操作所需参数的操作数（operand）所构成，虚拟机中许多指令并不包含操作数，只有一个操作码（零地址指令）</p><p>由于限制了 Java 虚拟机操作码的长度为一个字节（0~255），所以指令集的操作码总数不可能超过 256 条</p><p>在 JVM 的指令集中，大多数的指令都包含了其操作所对应的数据类型信息。例如 iload 指令用于从局部变量表中加载 int 型的数据到操作数栈中，而 fload 指令加载的则是 float 类型的数据</p><ul><li>i 代表对 int 类型的数据操作</li><li>l 代表 long </li><li>s 代表 short</li><li>b 代表 byte</li><li>c 代表 char</li><li>f 代表 float</li><li>d 代表 double</li></ul><p>大部分的指令都没有支持 byte、char、short、boolean 类型，编译器会在编译期或运行期将 byte 和 short 类型的数据带符号扩展（Sign-Extend-）为相应的 int 类型数据，将 boolean 和 char 类型数据零位扩展（Zero-Extend-）为相应的 int 类型数据</p><p>在做值相关操作时:</p><ul><li>一个指令，可以从局部变量表、常量池、堆中对象、方法调用、系统调用中等取得数据，这些数据（可能是值，也可能是对象的引用）被压入操作数栈</li><li>一个指令，也可以从操作数栈中取出一到多个值（pop 多次），完成赋值、加减乘除、方法传参、系统调用等等操作</li></ul><hr><h5 id="加载存储"><a href="#加载存储" class="headerlink" title="加载存储"></a>加载存储</h5><p>加载和存储指令用于将数据从栈帧的局部变量表和操作数栈之间来回传递</p><p>局部变量压栈指令：将给定的局部变量表中的数据压入操作数栈</p><ul><li>xload、xload_n，x 表示取值数据类型，为 i、l、f、d、a， n 为 0 到 3</li><li>指令 xload_n 表示将第 n 个局部变量压入操作数栈，aload_n 表示将一个对象引用压栈</li><li>指令 xload n 通过指定参数的形式，把局部变量压入操作数栈，局部变量数量超过 4 个时使用这个命令</li></ul><p>常量入栈指令：将常数压入操作数栈，根据数据类型和入栈内容的不同，又分为 const、push、ldc指令</p><ul><li>push：包括 bipush 和 sipush，区别在于接收数据类型的不同，bipush 接收 8 位整数作为参数，sipush 接收 16 位整数</li><li>ldc：如果以上指令不能满足需求，可以使用 ldc 指令，接收一个 8 位的参数，该参数指向常量池中的 int、 float 或者 String 的索引，将指定的内容压入堆栈。ldc_w 接收两个 8 位参数，能支持的索引范围更大，如果要压入的元素是 long 或 double 类型的，则使用 ldc2_w 指令</li><li>aconst_null 将 null 对象引用压入栈，iconst_m1 将 int 类型常量 -1 压入栈，iconst_0 将 int 类型常量 0 压入栈</li></ul><p>出栈装入局部变量表指令：将操作数栈中栈顶元素弹出后，装入局部变量表的指定位置，用于给局部变量赋值</p><ul><li>xstore、xstore_n，x 表示取值类型为 i、l、f、d、a， n 为 0 到 3</li><li>xastore 表示存入数组，x 取值为 i、l、f、d、a、b、c、s</li></ul><p>扩充局部变量表的访问索引的指令：wide</p><hr><h5 id="算术指令"><a href="#算术指令" class="headerlink" title="算术指令"></a>算术指令</h5><p>算术指令用于对两个操作数栈上的值进行某种特定运算，并把计算结果重新压入操作数栈</p><p>没有直接支持 byte、 short、 char 和 boolean类型的算术指令，对于这些数据的运算，都使用 int 类型的指令来处理，数组类型也是转换成 int 数组</p><ul><li><p>加法指令：iadd、ladd、fadd、dadd</p></li><li><p>减法指令：isub、lsub、fsub、dsub</p></li><li><p>乘法指令：imu、lmu、fmul、dmul</p></li><li><p>除法指令：idiv、ldiv、fdiv、ddiv</p></li><li><p>求余指令：irem、lrem、frem、drem（remainder 余数）</p></li><li><p>取反指令：ineg、lneg、fneg、dneg （negation 取反）</p></li><li><p>自增指令：iinc（直接<strong>在局部变量 slot 上进行运算</strong>，不用放入操作数栈）</p></li><li><p>位运算指令，又可分为：</p><ul><li>位移指令：ishl、ishr、 iushr、lshl、lshr、 lushr</li><li>按位或指令：ior、lor</li><li>按位与指令：iand、land</li><li>按位异或指令：ixor、lxor</li></ul></li><li><p>比较指令：dcmpg、dcmpl、 fcmpg、fcmpl、lcmp</p></li></ul><p>运算模式：</p><ul><li>向最接近数舍入模式，JVM 在进行浮点数计算时，所有的运算结果都必须舍入到适当的精度，非精确结果必须舍入为可被表示的最接近的精确值，如果有两种可表示形式与该值一样接近，将优先选择最低有效位为零的</li><li>向零舍入模式：将浮点数转换为整数时，该模式将在目标数值类型中选择一个最接近但是不大于原值的数字作为最精确的舍入结果</li></ul><p>NaN 值：当一个操作产生溢出时，将会使用有符号的无穷大表示，如果某个操作结果没有明确的数学定义，将使用 NaN 值来表示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> j = i / <span class="number">0.0</span>;System.out.println(j);<span class="comment">//无穷大，NaN: not a number</span></span><br></pre></td></tr></table></figure><p>**分析 i++**：从字节码角度分析：a++ 和 ++a 的区别是先执行 iload 还是 先执行 iinc</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> iload_1<span class="comment">//存入操作数栈 5 iinc 1 by 1//自增i++ 8 istore_3//把操作数栈没有自增的数据的存入局部变量表 9 iinc 2 by 1//++i12 iload_2//加载到操作数栈13 istore 4//存入局部变量表，这个存入没有 _ 符号，_只能到3</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        <span class="keyword">int</span> a = <span class="number">10</span>;        <span class="keyword">int</span> b = a++ + ++a + a--;        System.out.println(a);<span class="comment">//11        System.out.println(b);//34    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>判断结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        <span class="keyword">int</span> i = <span class="number">0</span>;        <span class="keyword">int</span> x = <span class="number">0</span>;        <span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;            x = x++;            i++;        &#125;        System.out.println(x); <span class="comment">// 结果是 0    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h5 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h5><p>类型转换指令可以将两种不同的数值类型进行相互转换，除了 boolean 之外的七种类型</p><p>宽化类型转换：</p><ul><li><p>JVM 支持以下数值的宽化类型转换（widening numeric conversion），小范围类型到大范围类型的安全转换</p><ul><li>从 int 类型到 long、float 或者 double 类型，对应的指令为 i2l、i2f、i2d</li><li>从 long 类型到 float、 double 类型，对应的指令为 l2f、l2d</li><li>从 float 类型到 double 类型，对应的指令为 f2d</li></ul></li><li><p>精度损失问题</p><ul><li>宽化类型转换是不会因为超过目标类型最大值而丢失信息</li><li>从 int 转换到 float 或者 long 类型转换到 double 时，将可能发生精度丢失</li></ul></li><li><p>从 byte、char 和 short 类型到 int 类型的宽化类型转换实际上是不存在的，JVM 把它们当作 int 处理</p></li></ul><p>窄化类型转换：</p><ul><li><p>Java 虚拟机直接支持以下窄化类型转换：</p><ul><li>从 int 类型至 byte、 short 或者 char 类型，对应的指令有 i2b、i2c、i2s</li><li>从 long 类型到 int 类型，对应的指令有 l2i</li><li>从 float 类型到 int 或者 long 类型，对应的指令有:f2i、f2l</li><li>从 double 类型到 int、long 或 float 者类型，对应的指令有 d2i、d2、d2f</li></ul></li><li><p>精度损失问题：</p><ul><li>窄化类型转换可能会导致转换结果具备不同的正负号、不同的数量级，转换过程可能会导致数值丢失精度</li><li>将一个浮点值窄化转换为整数类型 T（T 限于 int 或 long 类型之一）时，将遵循以下转换规则：<ul><li>如果浮点值是 NaN，那转换结果就是 int 或 long 类型的 0</li><li>如果浮点值不是无穷大的话，浮点值使用 IEEE 754 的向零舍入模式取整，获得整数值 v，如果 v 在目标类型 T 的表示范围之内，那转换结果就是 v，否则将根据 v 的符号，转换为 T 所能表示的最大或者最小正数</li></ul></li></ul></li></ul><hr><h5 id="创建访问"><a href="#创建访问" class="headerlink" title="创建访问"></a>创建访问</h5><p>创建指令：</p><ul><li><p>创建类实例指令：new，接收一个操作数指向常量池的索引，表示要创建的类型，执行完成后将对象的引用压入栈</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:  <span class="keyword">new</span>             #<span class="number">2</span> <span class="comment">// class com/jvm/bytecode/Demo3:  dup4:  invokespecial   #3 // Method &quot;&lt;init&gt;&quot;:()V</span></span><br></pre></td></tr></table></figure><p><strong>dup 是复制操作数栈栈顶的内容</strong>，需要两份引用原因：</p><ul><li>一个要配合 invokespecial 调用该对象的构造方法 <init>:()V （会消耗掉栈顶一个引用）</init></li><li>一个要配合 astore_1 赋值给局部变量</li></ul></li><li><p>创建数组的指令：newarray、anewarray、multianewarray</p><ul><li>newarray：创建基本类型数组</li><li>anewarray：创建引用类型数组</li><li>multianewarray：创建多维数组</li></ul></li></ul><p>字段访问指令：对象创建后可以通过对象访问指令获取对象实例或数组实例中的字段或者数组元素</p><ul><li>访问类字段（static字段，或者称为类变量）的指令：getstatic、putstatic</li><li>访问类实例字段（非static字段，或者称为实例变量）的指令：getfield、 putfield</li></ul><p>类型检查指令：检查类实例或数组类型的指令</p><ul><li><p>checkcast：用于检查类型强制转换是否可以进行，如果可以进行 checkcast 指令不会改变操作数栈，否则它会抛出 ClassCastException 异常</p></li><li><p>instanceof：判断给定对象是否是某一个类的实例，会将判断结果压入操作数栈</p></li></ul><hr><h5 id="方法指令"><a href="#方法指令" class="headerlink" title="方法指令"></a>方法指令</h5><p>方法调用指令：invokevirtual、 invokeinterface、invokespecial、invokestatic、invokedynamic</p><p><strong>方法调用章节详解</strong></p><hr><h5 id="操作数栈-1"><a href="#操作数栈-1" class="headerlink" title="操作数栈"></a>操作数栈</h5><p>JVM 提供的操作数栈管理指令，可以用于直接操作操作数栈的指令</p><ul><li><p>pop、pop2：将一个或两个元素从栈顶弹出，并且直接废弃</p></li><li><p>dup、dup2，dup_x1、dup2_x1，dup_x2、dup2_x2：复制栈顶一个或两个数值并重新压入栈顶</p></li><li><p>swap：将栈最顶端的两个 slot 数值位置交换，JVM 没有提供交换两个 64 位数据类型数值的指令</p></li><li><p>nop：一个非常特殊的指令，字节码为 0x00，和汇编语言中的 nop 一样，表示什么都不做，一般可用于调试、占位等</p></li></ul><hr><h5 id="控制转移"><a href="#控制转移" class="headerlink" title="控制转移"></a>控制转移</h5><p>比较指令：比较栈顶两个元素的大小，并将比较结果入栈</p><ul><li>lcmp：比较两个 long 类型值</li><li>fcmpl：比较两个 float 类型值（当遇到NaN时，返回-1）</li><li>fcmpg：比较两个 float 类型值（当遇到NaN时，返回1）</li><li>dcmpl：比较两个 double 类型值（当遇到NaN时，返回-1）</li><li>dcmpg：比较两个 double 类型值（当遇到NaN时，返回1）</li></ul><p>条件跳转指令：</p><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>ifeq</td><td>equals，当栈顶int类型数值等于0时跳转</td></tr><tr><td>ifne</td><td>not equals，当栈顶in类型数值不等于0时跳转</td></tr><tr><td>iflt</td><td>lower than，当栈顶in类型数值小于0时跳转</td></tr><tr><td>ifle</td><td>lower or equals，当栈顶in类型数值小于等于0时跳转</td></tr><tr><td>ifgt</td><td>greater than，当栈顶int类型数组大于0时跳转</td></tr><tr><td>ifge</td><td>greater or equals，当栈顶in类型数值大于等于0时跳转</td></tr><tr><td>ifnull</td><td>为 null 时跳转</td></tr><tr><td>ifnonnull</td><td>不为 null 时跳转</td></tr></tbody></table><p>比较条件跳转指令：</p><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>if_icmpeq</td><td>比较栈顶两 int 类型数值大小（下同），当前者等于后者时跳转</td></tr><tr><td>if_icmpne</td><td>当前者不等于后者时跳转</td></tr><tr><td>if_icmplt</td><td>当前者小于后者时跳转</td></tr><tr><td>if_icmple</td><td>当前者小于等于后者时跳转</td></tr><tr><td>if_icmpgt</td><td>当前者大于后者时跳转</td></tr><tr><td>if_icmpge</td><td>当前者大于等于后者时跳转</td></tr><tr><td>if_acmpeq</td><td>当结果相等时跳转</td></tr><tr><td>if_acmpne</td><td>当结果不相等时跳转</td></tr></tbody></table><p>多条件分支跳转指令：</p><ul><li>tableswitch：用于 switch 条件跳转，case 值连续</li><li>lookupswitch：用于 switch 条件跳转，case 值不连续</li></ul><p>无条件跳转指令：</p><ul><li><p>goto：用来进行跳转到指定行号的字节码</p></li><li><p>goto_w：无条件跳转（宽索引）</p></li></ul><hr><h5 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h5><h6 id="处理机制"><a href="#处理机制" class="headerlink" title="处理机制"></a>处理机制</h6><p>抛出异常指令：athrow 指令</p><p>JVM 处理异常（catch 语句）不是由字节码指令来实现的，而是<strong>采用异常表来完成</strong>的</p><ul><li><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        <span class="keyword">int</span> i = <span class="number">0</span>;        <span class="keyword">try</span> &#123;            i = <span class="number">10</span>;        &#125; <span class="keyword">catch</span> (Exception e) &#123;           i = <span class="number">20</span>;       &#125; <span class="keyword">finally</span> &#123;        i = <span class="number">30</span>;    &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>字节码：</p><ul><li>多出一个 <strong>Exception table</strong> 的结构，**[from, to) 是前闭后开的检测范围**，一旦这个范围内的字节码执行出现异常，则通过 type 匹配异常类型，如果一致，进入 target 所指示行号</li><li>11 行的字节码指令 astore_2 是将异常对象引用存入局部变量表的 slot 2 位置，因为异常出现时，只能进入 Exception table 中一个分支，所以局部变量表 slot 2 位置被共用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: iconst_0    <span class="number">1</span>: istore_1 <span class="comment">// 0 -&gt; i-&gt;赋值    2: bipush 10 // try 10 放入操作数栈顶    4: istore_1 // 10 -&gt; i 将操作数栈顶数据弹出，存入局部变量表的 slot1    5: bipush 30 // 【finally】     7: istore_1 // 30 -&gt; i     8: goto 27 // return -----------------------------------    11: astore_2 // catch Exceptin -&gt; e ----------------------    12: bipush 20 //     14: istore_1 // 20 -&gt; i     15: bipush 30 // 【finally】     17: istore_1 // 30 -&gt; i     18: goto 27 // return -----------------------------------    21: astore_3 // catch any -&gt; slot 3 ----------------------    22: bipush 30 // 【finally】    24: istore_1 // 30 -&gt; i     25: aload_3 // 将局部变量表的slot 3数据弹出，放入操作数栈栈顶    26: athrow // throw 抛出异常    27: returnException table:// 任何阶段出现任务异常都会执行 finallyfrom   to target type25 11 Class java/lang/Exception2 5 21 any // 剩余的异常类型，比如 Error11 15 21 any // 剩余的异常类型，比如 ErrorLineNumberTable: ...LocalVariableTable:Start Length Slot Name Signature12 3 2 e Ljava/lang/Exception;0 28 0 args [Ljava/lang/String;2 26 1 i I</span></span><br></pre></td></tr></table></figure></li></ul><hr><h6 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h6><p>finally 中的代码被<strong>复制了 3 份</strong>，分别放入 try 流程，catch 流程以及 catch 剩余的异常类型流程（上节案例）</p><ul><li><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123;    <span class="keyword">try</span> &#123;    <span class="keyword">return</span> <span class="number">10</span>;    &#125; <span class="keyword">finally</span> &#123;    <span class="keyword">return</span> <span class="number">20</span>;    &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>字节码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: bipush <span class="number">10</span> <span class="comment">// 10 放入栈顶    2: istore_0 // 10 -&gt; slot 0 【从栈顶移除了】    3: bipush 20 // 20 放入栈顶    5: ireturn // 返回栈顶 int(20)    6: astore_1 // catch any 存入局部变量表的 slot1    7: bipush 20 // 20 放入栈顶    9: ireturn // 返回栈顶 int(20)Exception table:from   to target type036 any      </span></span><br></pre></td></tr></table></figure></li></ul><hr><h6 id="return"><a href="#return" class="headerlink" title="return"></a>return</h6><ul><li><p>吞异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123;    <span class="keyword">try</span> &#123;    <span class="keyword">return</span> <span class="number">10</span>;    &#125; <span class="keyword">finally</span> &#123;    <span class="keyword">return</span> <span class="number">20</span>;    &#125;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: bipush <span class="number">10</span> <span class="comment">// 10 放入栈顶    2: istore_0 // 10 -&gt; slot 0 【从栈顶移除了】    3: bipush 20 // 20 放入栈顶    5: ireturn // 返回栈顶 int(20)    6: astore_1 // catch any  存入局部变量表的 slot1    7: bipush 20 // 20 放入栈顶    9: ireturn // 返回栈顶 int(20)Exception table:from   to target type036 any      </span></span><br></pre></td></tr></table></figure><ul><li>由于 finally 中的 ireturn 被插入了所有可能的流程，因此返回结果以 finally 的为准</li><li>字节码中没有 <strong>athrow</strong> ，表明如果在 finally 中出现了 return，会<strong>吞掉异常</strong></li></ul></li><li><p>不吞异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    <span class="keyword">int</span> result = test();    System.out.println(result);<span class="comment">//10&#125;public static int test() &#123;        int i = 10;        try &#123;            return i;//返回10        &#125; finally &#123;            i = 20;        &#125;   &#125;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: bipush <span class="number">10</span> <span class="comment">// 10 放入栈顶    2: istore_0 // 10 赋值给i，放入slot 0    3: iload_0 // i(10)加载至操作数栈    4: istore_1 // 10 -&gt; slot 1，【暂存至 slot 1，目的是为了固定返回值】    5: bipush 20 // 20 放入栈顶    7: istore_0 // 20 slot 0    8: iload_1 // slot 1(10) 载入 slot 1 暂存的值    9: ireturn // 返回栈顶的 int(10)    10: astore_2// catch any -&gt; slot 2 存入局部变量表的 slot2    11: bipush 20    13: istore_0    14: aload_2    15: athrow// 不会吞掉异常Exception table:from   to target type  3   510 any  </span></span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="同步控制"><a href="#同步控制" class="headerlink" title="同步控制"></a>同步控制</h5><p>方法级的同步：是隐式的，无须通过字节码指令来控制，它实现在方法调用和返回操作之中，虚拟机可以从方法常量池的方法表结构中的 ACC_SYNCHRONIZED 访问标志得知一个方法是否声明为同步方法</p><p>方法内指定指令序列的同步：有 monitorenter 和 monitorexit 两条指令来支持 synchronized 关键字的语义</p><ul><li>montiorenter：进入并获取对象监视器，即为栈顶对象加锁</li><li>monitorexit：释放并退出对象监视器，即为栈顶对象解锁</li></ul><img src="https://gitee.com/seazean/images/raw/master/Java/JVM-字节码指令同步控制.png" style="zoom: 33%;"><hr><h4 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h4><p>原始 Java 代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;                <span class="keyword">int</span> a = <span class="number">10</span>;                <span class="keyword">int</span> b = Short.MAX_VALUE + <span class="number">1</span>;                <span class="keyword">int</span> c = a + b;                System.out.println(c);    &#125;&#125;</span><br></pre></td></tr></table></figure><p>javap -v Demo.class：省略</p><ul><li><p>常量池载入运行时常量池</p></li><li><p>方法区字节码载入方法区</p></li><li><p>main 线程开始运行，分配栈帧内存：（操作数栈stack=2，局部变量表locals=4）</p></li><li><p><strong>执行引擎</strong>开始执行字节码</p><p><code>bipush 10</code>：将一个 byte 压入操作数栈（其长度会补齐 4 个字节），类似的指令</p><ul><li>sipush 将一个 short 压入操作数栈（其长度会补齐 4 个字节）</li><li>ldc 将一个 int 压入操作数栈</li><li>ldc2_w 将一个 long 压入操作数栈（分两次压入，因为 long 是 8 个字节）</li><li>这里小的数字都是和字节码指令存在一起，超过 short 范围的数字存入了常量池</li></ul><p><code>istore_1</code>：将操作数栈顶数据弹出，存入局部变量表的 slot 1</p><p><img src="https://gitee.com/seazean/images/raw/master/Java/JVM-%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B1.png"></p><p><code>ldc #3</code>：从常量池加载 #3 数据到操作数栈<br>Short.MAX_VALUE 是 32767，所以 32768 = Short.MAX_VALUE + 1 实际是在编译期间计算完成</p><p><img src="https://gitee.com/seazean/images/raw/master/Java/JVM-%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B2.png"></p><p><code>istore_2</code>：将操作数栈顶数据弹出，存入局部变量表的 slot 2</p><p><code>iload_1</code>：将局部变量表的 slot 1数据弹出，放入操作数栈栈顶</p><p><code>iload_2</code>：将局部变量表的 slot 2数据弹出，放入操作数栈栈顶</p><p><code>iadd</code>：执行相加操作</p><p><img src="https://gitee.com/seazean/images/raw/master/Java/JVM-%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B3.png"></p><p><code>istore_3</code>：将操作数栈顶数据弹出，存入局部变量表的 slot 3</p><p><code>getstatic #4</code>：获取静态字段</p><p><img src="https://gitee.com/seazean/images/raw/master/Java/JVM-%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B4.png"></p><p><code>iload_3</code>：</p><p><img src="https://gitee.com/seazean/images/raw/master/Java/JVM-%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B5.png"></p><p><code>invokevirtual #5</code>：</p><ul><li>找到常量池 #5 项</li><li>定位到方法区 java/io/PrintStream.println:(I)V 方法</li><li><strong>生成新的栈帧</strong>（分配 locals、stack等）</li><li>传递参数，执行新栈帧中的字节码</li><li>执行完毕，弹出栈帧</li><li>清除 main 操作数栈内容</li></ul><p><img src="https://gitee.com/seazean/images/raw/master/Java/JVM-%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B6.png"></p><p>return：完成 main 方法调用，弹出 main 栈帧，程序结束</p></li></ul><hr><h3 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h3><h4 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>执行引擎：Java 虚拟机的核心组成部分之一，类加载主要任务是负责装载字节码到其内部，但字节码并不能够直接运行在操作系统之上，需要执行引擎将字节码指令解释/编译为对应平台上的本地机器指令</p><p>虚拟机是一个相对于物理机的概念，这两种机器都有代码执行能力：</p><ul><li>物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上</li><li>虚拟机的执行引擎是由软件自行实现的，可以不受物理条件制约地定制指令集与执行引擎的结构体系</li></ul><p>Java 是<strong>半编译半解释型语言</strong>，将解释执行与编译执行二者结合起来进行：</p><ul><li>解释器：根据预定义的规范对字节码采用逐行解释的方式执行，将每条字节码文件中的内容翻译为对应平台的本地机器指令执行</li><li>即时编译器（JIT : Just In Time Compiler）：虚拟机运行时将源代码直接编译成<strong>和本地机器平台相关的机器码</strong>后再执行，并存入 Code Cache，下次遇到相同的代码直接执行，效率高</li></ul><hr><h4 id="执行方式"><a href="#执行方式" class="headerlink" title="执行方式"></a>执行方式</h4><p>HotSpot VM 采用<strong>解释器与即时编译器并存的架构</strong>，解释器和即时编译器能够相互协作，去选择最合适的方式来权衡编译本地代码和直接解释执行代码的时间</p><p>HostSpot JVM 的默认执行方式：</p><ul><li>当程序启动后，解释器可以马上发挥作用立即执行，省去编译器编译的时间（解释器存在的<strong>必要性</strong>）</li><li>随着程序运行时间的推移，即时编译器逐渐发挥作用，根据热点探测功能，将有价值的字节码编译为本地机器指令，以换取更高的程序执行效率</li></ul><p>HotSpot VM 可以通过 VM 参数设置程序执行方式：</p><ul><li>-Xint：完全采用解释器模式执行程序</li><li>-Xcomp：完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行</li><li>-Xmixed：采用解释器 + 即时编译器的混合模式共同执行程序</li></ul><p><img src="https://gitee.com/seazean/images/raw/master/Java/JVM-%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png"></p><hr><h4 id="热点探测"><a href="#热点探测" class="headerlink" title="热点探测"></a>热点探测</h4><p>热点代码：被 JIT 编译器编译的字节码，根据代码被调用执行的频率而定，一个被多次调用的方法或者一个循环次数较多的循环体都可以被称之为热点代码</p><p>热点探测：JIT 编译器在运行时会针热点代码做出深度优化，将其直接编译为对应平台的本地机器指令进行缓存，以提升程序执行性能</p><p>JIT 编译在默认情况是异步进行的，当触发某方法或某代码块的优化时，先将其放入编译队列，然后由编译线程进行编译，编译之后的代码放在 CodeCache 中，通过 <code>-XX:-BackgroundCompilation</code> 参数可以关闭异步编译</p><ul><li>CodeCache 用于缓存编译后的机器码、动态生成的代码和本地方法代码 JNI</li><li>如果 CodeCache 区域被占满，编译器被停用，字节码将不会编译为机器码，应用程序继续运行，但运行性能会降低很多</li></ul><p>HotSpot VM 采用的热点探测方式是基于计数器的热点探测，为每一个方法都建立 2 个不同类型的计数器：方法调用计数器（Invocation Counter）和回边计数器（BackEdge Counter）</p><ul><li><p>方法调用计数器：用于统计方法被调用的次数，默认阈值在 Client 模式 下是 1500 次，在 Server 模式下是 10000 次（需要进行激进的优化），超过这个阈值，就会触发 JIT 编译，阈值可以通过虚拟机参数 <code>-XX:CompileThreshold</code> 设置</p><p>工作流程：当一个方法被调用时， 会先检查该方法是否存在被 JIT 编译过的版本，存在则使用编译后的本地代码来执行；如果不存在则将此方法的调用计数器值加 1，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阈值，如果超过阈值会向即时编译器<strong>提交一个该方法的代码编译请求</strong></p></li><li><p>回边计数器：统计一个方法中循环体代码执行的次数，在字节码中控制流向后跳转的指令称为回边</p><p>如果一个方法中的循环体需要执行多次，可以优化为为栈上替换，简称 OSR (On StackReplacement) 编译，<strong>OSR 替换循环代码体的入口，C1、C2 替换的是方法调用的入口</strong>，OSR 编译后会出现方法的整段代码被编译了，但是只有循环体部分才执行编译后的机器码，其他部分仍是解释执行</p></li></ul><hr><h4 id="分层编译"><a href="#分层编译" class="headerlink" title="分层编译"></a>分层编译</h4><p>HotSpot VM 内嵌两个 JIT 编译器，分别为 Client Compiler 和 Server Compiler，简称 C1 编译器和 C2 编译器</p><p>C1 编译器会对字节码进行简单可靠的优化，耗时短，以达到更快的编译速度，C1 编译器的优化方法：</p><ul><li><p>方法内联：<strong>将调用的函数代码编译到调用点处</strong>，这样可以减少栈帧的生成，减少参数传递以及跳转过程</p><p>方法内联能够消除方法调用的固定开销，任何方法除非被内联，否则调用都会有固定开销，来源于保存程序在该方法中的执行位置，以及新建、压入和弹出新方法所使用的栈帧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">square</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> i)</span> </span>&#123;<span class="keyword">return</span> i * i;&#125;System.out.println(square(<span class="number">9</span>));</span><br></pre></td></tr></table></figure><p>square 是热点方法，会进行内联，把方法内代码拷贝粘贴到调用者的位置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">9</span> * <span class="number">9</span>);</span><br></pre></td></tr></table></figure><p>还能够进行常量折叠（constant folding）的优化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">81</span>);</span><br></pre></td></tr></table></figure></li><li><p>冗余消除：根据运行时状况进行代码折叠或削除</p></li><li><p>内联缓存：是一种加快动态绑定的优化技术（方法调用部分详解）</p></li></ul><p>C2 编译器进行耗时较长的优化以及激进优化，优化的代码执行效率更高，当激进优化的假设不成立时，再退回使用 C1 编译，这也是使用分层编译的原因</p><p>C2 的优化主要是在全局层面，逃逸分析是优化的基础：标量替换、栈上分配、同步消除</p><p>VM 参数设置：</p><ul><li>-client：指定 Java 虚拟机运行在 Client 模式下，并使用 C1 编译器</li><li>-server：指定 Java 虚拟机运行在 Server 模式下，并使用 C2 编译器</li><li><code>-server -XX:+TieredCompilation</code>：在 1.8 之前，分层编译默认是关闭的，可以添加该参数开启</li></ul><p>分层编译策略 (Tiered Compilation)：程序解释执行可以触发 C1 编译，将字节码编译成机器码，加上性能监控，C2 编译会根据性能监控信息进行激进优化，JVM 将执行状态分成了 5 个层次：</p><ul><li><p>0 层，解释执行（Interpreter）</p></li><li><p>1 层，使用 C1 即时编译器编译执行（不带 profiling）</p></li><li><p>2 层，使用 C1 即时编译器编译执行（带基本的 profiling）</p></li><li><p>3 层，使用 C1 即时编译器编译执行（带完全的 profiling）</p></li><li><p>4 层，使用 C2 即时编译器编译执行（C1 和 C2 协作运行）</p><p>说明：profiling 是指在运行过程中收集一些程序执行状态的数据，例如方法的调用次数，循环的回边次数等</p></li></ul><p>参考文章：<a href="https://www.jianshu.com/p/20bd2e9b1f03">https://www.jianshu.com/p/20bd2e9b1f03</a></p><hr><h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><h4 id="方法识别"><a href="#方法识别" class="headerlink" title="方法识别"></a>方法识别</h4><p>Java 虚拟机识别方法的关键在于类名、方法名以及方法描述符（method descriptor）</p><ul><li><strong>方法描述符是由方法的参数类型以及返回类型所构成</strong>，Java 层面叫方法特征签名</li><li>在同一个类中，如果同时出现多个名字相同且描述符也相同的方法，那么 Java 虚拟机会在类的验证阶段报错</li></ul><p>JVM 根据名字和描述符来判断的，只要返回值不一样（方法描述符不一样），其它完全一样，在 JVM 中是允许的，但 Java 语言不允许</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回值类型不同，编译阶段直接报错public static Integer invoke(Object... args) &#123;    return 1;&#125;public static int invoke(Object... args) &#123;    return 2;&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="调用机制"><a href="#调用机制" class="headerlink" title="调用机制"></a>调用机制</h4><p>方法调用并不等于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本，不是方法的具体运行过程</p><p>在 JVM 中，将符号引用转换为直接引用有两种机制：</p><ul><li>静态链接：当一个字节码文件被装载进 JVM 内部时，如果被调用的目标方法在编译期可知，且运行期保持不变，将调用方法的符号引用转换为直接引用的过程称之为静态链接（类加载的解析阶段）</li><li>动态链接：如果被调用的方法在编译期无法被确定下来，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此被称为动态链接（初始化后的解析阶段）</li></ul><p>对应方法的绑定（分配）机制：静态绑定和动态绑定。绑定是一个字段、方法或者类从符号引用被替换为直接引用的过程，仅发生一次：</p><ul><li>静态绑定：被调用的目标方法在编译期可知，且运行期保持不变，将这个方法与所属的类型进行绑定</li><li>动态绑定：被调用的目标方法在编译期无法确定，只能在程序运行期根据实际的类型绑定相关的方法</li></ul><ul><li>Java 编译器已经区分了重载的方法（静态绑定和动态绑定），因此可以认为虚拟机中不存在重载</li></ul><p>非虚方法：</p><ul><li>非虚方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的</li><li>静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法</li><li>所有普通成员方法、实例方法、被重写的方法都是虚方法</li></ul><p>动态类型语言和静态类型语言：</p><ul><li><p>在于对类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，反之则是动态类型语言</p></li><li><p>静态语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息</p></li><li><p><strong>Java 是静态类型语言</strong>（尽管 lambda 表达式为其增加了动态特性），js，python是动态类型语言</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">&quot;abc&quot;</span>;   <span class="comment">//Javainfo = &quot;abc&quot;;       //Python</span></span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="调用指令"><a href="#调用指令" class="headerlink" title="调用指令"></a>调用指令</h4><h5 id="五种指令"><a href="#五种指令" class="headerlink" title="五种指令"></a>五种指令</h5><p>普通调用指令：</p><ul><li>invokestatic：调用静态方法</li><li>invokespecial：调用私有实例方法、构造器，和父类的实例方法或构造器，以及所实现接口的默认方法</li><li>invokevirtual：调用所有虚方法（虚方法分派）</li><li>invokeinterface：调用接口方法</li></ul><p>动态调用指令：</p><ul><li>invokedynamic：动态解析出需要调用的方法<ul><li>Java7 为了实现动态类型语言支持而引入了该指令，但是并没有提供直接生成 invokedynamic 指令的方法，需要借助 ASM 这种底层字节码工具来产生 invokedynamic 指令</li><li>Java8 的 lambda 表达式的出现，invokedynamic 指令在 Java 中才有了直接生成方式</li></ul></li></ul><p>指令对比：</p><ul><li>普通调用指令固化在虚拟机内部，方法的调用执行不可干预，根据方法的符号引用链接到具体的目标方法</li><li>动态调用指令支持用户确定方法</li><li>invokestatic 和 invokespecial 指令调用的方法称为非虚方法，虚拟机能够直接识别具体的目标方法</li><li>invokevirtual 和 invokeinterface 指令调用的方法称为虚方法，虚拟机需要在执行过程中根据调用者的动态类型来确定目标方法</li></ul><p>指令说明：</p><ul><li>如果虚拟机能够确定目标方法有且仅有一个，比如说目标方法被标记为 final，那么可以不通过动态绑定，直接确定目标方法</li><li>普通成员方法是由 invokevirtual 调用，属于<strong>动态绑定</strong>，即支持多态</li></ul><hr><h5 id="符号引用"><a href="#符号引用" class="headerlink" title="符号引用"></a>符号引用</h5><p>在编译过程中，虚拟机并不知道目标方法的具体内存地址，Java 编译器会暂时用符号引用来表示该目标方法，这一符号引用包括目标方法所在的类或接口的名字，以及目标方法的方法名和方法描述符</p><ul><li>对于静态绑定的方法调用而言，实际引用是一个指向方法的指针</li><li>对于需要动态绑定的方法调用而言，实际引用则是一个方法表的索引</li></ul><p>符号引用存储在方法区常量池中，根据目标方法是否为接口方法，分为接口符号引用和非接口符号引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Constant pool:...  #<span class="number">16</span> = InterfaceMethodref #<span class="number">27.</span>#<span class="number">29</span><span class="comment">// 接口...  #22 = Methodref          #1.#33// 非接口...</span></span><br></pre></td></tr></table></figure><p>对于非接口符号引用，假定该符号引用所指向的类为 C，则 Java 虚拟机会按照如下步骤进行查找：</p><ol><li>在 C 中查找符合名字及描述符的方法</li><li>如果没有找到，在 C 的父类中继续搜索，直至 Object 类</li><li>如果没有找到，在 C 所直接实现或间接实现的接口中搜索，这一步搜索得到的目标方法必须是非私有、非静态的。如果有多个符合条件的目标方法，则任意返回其中一个</li></ol><p>对于接口符号引用，假定该符号引用所指向的接口为 I，则 Java 虚拟机会按照如下步骤进行查找：</p><ol><li>在 I 中查找符合名字及描述符的方法</li><li>如果没有找到，在 Object 类中的公有实例方法中搜索</li><li>如果没有找到，则在 I 的超接口中搜索，这一步的搜索结果的要求与非接口符号引用步骤 3 的要求一致</li></ol><hr><h5 id="执行流程-1"><a href="#执行流程-1" class="headerlink" title="执行流程"></a>执行流程</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="title">Demo</span><span class="params">()</span> </span>&#123; &#125;    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123; &#125;    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123; &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123; &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123; &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        Demo3_9 d = <span class="keyword">new</span> Demo3_9();        d.test1();        d.test2();        d.test3();        d.test4();        Demo.test4();    &#125;&#125;</span><br></pre></td></tr></table></figure><p>几种不同的方法调用对应的字节码指令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:  <span class="keyword">new</span>             #<span class="number">2</span> <span class="comment">// class cn/jvm/t3/bytecode/Demo3:  dup4:  invokespecial   #3 // Method &quot;&lt;init&gt;&quot;:()V7:  astore_18:  aload_19:  invokespecial   #4 // Method test1:()V12: aload_113: invokespecial   #5 // Method test2:()V16: aload_117: invokevirtual   #6 // Method test3:()V20: aload_121: pop22: invokestatic    #7 // Method test4:()V25: invokestatic    #7 // Method test4:()V28: return</span></span><br></pre></td></tr></table></figure><ul><li><p>invokespecial 调用该对象的构造方法 <init>:()V </init></p></li><li><p><code>d.test4()</code> 是通过<strong>对象引用</strong>调用一个静态方法，在调用 invokestatic 之前执行了 pop 指令，把对象引用从操作数栈弹掉</p><ul><li>不建议使用 <code>对象.静态方法()</code> 的方式调用静态方法，多了aload 和 pop 指令</li><li>成员方法与静态方法调用的区别是：执行方法前是否需要对象引用</li></ul></li></ul><hr><h4 id="多态原理"><a href="#多态原理" class="headerlink" title="多态原理"></a>多态原理</h4><h5 id="执行原理"><a href="#执行原理" class="headerlink" title="执行原理"></a>执行原理</h5><p>Java 虚拟机中关于方法重写的判定基于方法描述符，如果子类定义了与父类中非私有、非静态方法同名的方法，只有当这两个方法的参数类型以及返回类型一致，Java 虚拟机才会判定为重写。</p><p>理解多态：</p><ul><li>多态有编译时多态和运行时多态，即静态绑定和动态绑定</li><li>前者是通过方法重载实现，后者是通过重写实现（子类覆盖父类方法，虚方法表）</li><li>虚方法：运行时动态绑定的方法，对比静态绑定的非虚方法调用来说，虚方法调用更加耗时</li></ul><p>方法重写的本质：</p><ol><li><p>找到操作数栈的第一个元素<strong>所执行的对象的实际类型</strong>，记作 C</p></li><li><p>如果在类型 C 中找到与描述符和名称都相符的方法，则进行访问<strong>权限校验</strong>（私有的），如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回 java.lang.IllegalAccessError 异常</p><p>IllegalAccessError：表示程序试图访问或修改一个属性或调用一个方法，这个属性或方法没有权限访问，一般会引起编译器异常。如果这个错误发生在运行时，就说明一个类发生了不兼容的改变</p></li><li><p>找不到，就会按照继承关系从下往上依次对 C 的各个父类进行第二步的搜索和验证过程</p></li><li><p>如果始终没有找到合适的方法，则抛出 java.lang.AbstractMethodError 异常</p></li></ol><hr><h5 id="虚方法表"><a href="#虚方法表" class="headerlink" title="虚方法表"></a>虚方法表</h5><p>在虚拟机工作过程中会频繁使用到动态绑定，每次动态绑定的过程中都要重新在类的元数据中搜索合适目标，影响到执行效率。为了提高性能，JVM 采取了一种用<strong>空间换取时间</strong>的策略来实现动态绑定，在每个类的方法区建立一个虚方法表（virtual method table），实现使用索引表来代替查找，可以快速定位目标方法</p><ul><li>invokevirtual 所使用的虚方法表（virtual method table，vtable），执行流程<ol><li>先通过栈帧中的对象引用找到对象，分析对象头，找到对象的实际 Class</li><li>Class 结构中有 vtable，查表得到方法的具体地址，执行方法的字节码</li></ol></li><li>invokeinterface 所使用的接口方法表（interface method table，itable）</li></ul><p>虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM 会把该类的方法表也初始化完毕</p><p>虚方法表的执行过程：</p><ul><li>对于静态绑定的方法调用而言，实际引用将指向具体的目标方法</li><li>对于动态绑定的方法调用而言，实际引用则是方法表的索引值，也就是方法的间接地址。Java 虚拟机获取调用者的实际类型，并在该实际类型的虚方法表中，根据索引值获得目标方法内存偏移量（指针）</li></ul><p>为了优化对象调用方法的速度，方法区的类型信息会增加一个指针，该指针指向一个记录该类方法的方法表。每个类中都有一个虚方法表，本质上是一个数组，每个数组元素指向一个当前类及其祖先类中非私有的实例方法</p><p>方法表满足以下的特质：</p><ul><li>其一，子类方法表中包含父类方法表中的<strong>所有方法</strong>，并且在方法表中的索引值与父类方法表种的索引值相同</li><li>其二，<strong>非重写的方法指向父类的方法表项，与父类共享一个方法表项，重写的方法指向本身自己的实现</strong>。所以这就是为什么多态情况下可以访问父类的方法。</li></ul><img src="https://gitee.com/seazean/images/raw/master/Java/JVM-虚方法表.png" style="zoom: 80%;"><p>Passenger 类的方法表包括两个方法，分别对应 0 号和 1 号。方法表调换了 toString 方法和 passThroughImmigration 方法的位置，是因为 toString 方法的索引值需要与 Object 类中同名方法的索引值一致，为了保持简洁，这里不考虑 Object 类中的其他方法。</p><p>虚方法表对性能的影响：</p><ul><li>使用了方法表的动态绑定与静态绑定相比，仅仅多出几个内存解引用操作：访问栈上的调用者、读取调用者的动态类型、读取该类型的方法表、读取方法表中某个索引值所对应的目标方法，但是相对于创建并初始化 Java 栈帧这操作的开销可以忽略不计</li><li>上述优化的效果看上去不错，但实际上<strong>仅存在于解释执行</strong>中，或者即时编译代码的最坏情况。因为即时编译还拥有另外两种性能更好的优化手段：内联缓存（inlining cache）和方法内联（method inlining）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> <span class="string">&quot;I&#x27;m a person.&quot;</span>;    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;&#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;&#125;&#125;<span class="class"><span class="keyword">class</span> <span class="title">Boy</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> <span class="string">&quot;I&#x27;m a boy&quot;</span>;    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;&#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fight</span><span class="params">()</span> </span>&#123;&#125;&#125;<span class="class"><span class="keyword">class</span> <span class="title">Girl</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> <span class="string">&quot;I&#x27;m a girl&quot;</span>;    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;&#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sing</span><span class="params">()</span> </span>&#123;&#125;&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/seazean/images/raw/master/Java/JVM-%E8%99%9A%E6%96%B9%E6%B3%95%E8%A1%A8%E6%8C%87%E5%90%91.png"></p><p>参考文档：<a href="https://www.cnblogs.com/kaleidoscope/p/9790766.html">https://www.cnblogs.com/kaleidoscope/p/9790766.html</a></p><hr><h5 id="内联缓存"><a href="#内联缓存" class="headerlink" title="内联缓存"></a>内联缓存</h5><p>内联缓存：是一种加快动态绑定的优化技术，能够缓存虚方法调用中<strong>调用者的动态类型以及该类型所对应的目标方法</strong>。在之后的执行过程中，如果碰到已缓存的类型，便会直接调用该类型所对应的目标方法；反之内联缓存则会退化至使用基于方法表的动态绑定</p><p>多态的三个术语：</p><ul><li>单态 (monomorphic)：指的是仅有一种状态的情况</li><li>多态 (polymorphic)：指的是有限数量种状态的情况，二态（bimorphic）是多态的其中一种</li><li>超多态 (megamorphic)：指的是更多种状态的情况，通常用一个具体数值来区分多态和超多态，在这个数值之下，称之为多态，否则称之为超多态</li></ul><p>对于内联缓存来说，有对应的单态内联缓存、多态内联缓存：</p><ul><li>单态内联缓存：只缓存了一种动态类型以及所对应的目标方法，实现简单，比较所缓存的动态类型，如果命中，则直接调用对应的目标方法。</li><li>多态内联缓存：缓存了多个动态类型及其目标方法，需要逐个将所缓存的动态类型与当前动态类型进行比较，如果命中，则调用对应的目标方法</li></ul><p>为了节省内存空间，<strong>Java 虚拟机只采用单态内联缓存</strong>，没有命中的处理方法：</p><ul><li>替换单态内联缓存中的纪录，类似于 CPU 中的数据缓存，对数据的局部性有要求，即在替换内联缓存之后的一段时间内，方法调用的调用者的动态类型应当保持一致，从而能够有效地利用内联缓存</li><li>劣化为超多态状态，这也是 Java 虚拟机的具体实现方式，这种状态实际上放弃了优化的机会，将直接访问方法表来动态绑定目标方法，但是与替换内联缓存纪录相比节省了写缓存的额外开销</li></ul><p>虽然内联缓存附带内联二字，但是并没有内联目标方法</p><hr><h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h3><h4 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h4><p>语法糖：指 java 编译器把 *.java 源码编译为 *.class 字节码的过程中，自动生成和转换的一些代码，主要是为了减轻程序员的负担</p><h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy1</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy1</span> </span>&#123;    <span class="comment">// 这个无参构造是编译器帮助我们加上的    public Candy1() &#123;        super(); // 即调用父类 Object 的无参构造方法，即调用 java/lang/Object.&quot;        &lt;init&gt;&quot;:()V    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="拆装箱"><a href="#拆装箱" class="headerlink" title="拆装箱"></a>拆装箱</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer x = <span class="number">1</span>;<span class="keyword">int</span> y = x;</span><br></pre></td></tr></table></figure><p>这段代码在 JDK 5 之前是无法编译通过的，必须改写为代码片段2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer x = Integer.valueOf(<span class="number">1</span>);<span class="keyword">int</span> y = x.intValue();</span><br></pre></td></tr></table></figure><p>JDK5 以后编译阶段自动转换成上述片段</p><hr><h4 id="泛型擦除"><a href="#泛型擦除" class="headerlink" title="泛型擦除"></a>泛型擦除</h4><p>泛型也是在 JDK 5 开始加入的特性，但 java 在编译泛型代码后会执行<strong>泛型擦除</strong>的动作，即泛型信息<br>在编译为字节码之后就丢失了，实际的类型都<strong>当做了 Object 类型</strong>来处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();list.add(<span class="number">10</span>); <span class="comment">// 实际调用的是 List.add(Object e)Integer x = list.get(0); // 实际调用的是 Object obj = List.get(int index);</span></span><br></pre></td></tr></table></figure><p>编译器真正生成的字节码中，还要额外做一个类型转换的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要将 Object 转为 IntegerInteger x = (Integer)list.get(0);</span></span><br></pre></td></tr></table></figure><p>如果前面的 x 变量类型修改为 int 基本类型那么最终生成的字节码是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要将 Object 转为 Integer, 并执行拆箱操作int x = ((Integer)list.get(0)).intValue();</span></span><br></pre></td></tr></table></figure><hr><h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy4</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(String... args)</span> </span>&#123;        String[] array = args; <span class="comment">// 直接赋值        System.out.println(array);    &#125;    public static void main(String[] args) &#123;    foo(&quot;hello&quot;, &quot;world&quot;);    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>可变参数 <code>String... args</code> 其实是 <code>String[] args</code> ， java 编译器会在编译期间将上述代码变换为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;foo(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;);&#125;</span><br></pre></td></tr></table></figure><p>注意：如果调用了 foo() 则等价代码为 <code>foo(new String[]&#123;&#125;)</code> ，创建了一个空的数组，而不会传递 null 进去</p><hr><h4 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h4><p><strong>数组的循环：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">// 数组赋初值的简化写法也是语法糖for (int e : array) &#123;System.out.println(e);&#125;</span></span><br></pre></td></tr></table></figure><p>编译后为循环取数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; ++i) &#123;<span class="keyword">int</span> e = array[i];System.out.println(e);&#125;</span><br></pre></td></tr></table></figure><p><strong>集合的循环：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);<span class="keyword">for</span> (Integer i : list) &#123;System.out.println(i);&#125;</span><br></pre></td></tr></table></figure><p>编译后转换为对迭代器的调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);Iterator iter = list.iterator();<span class="keyword">while</span>(iter.hasNext()) &#123;    Integer e = (Integer)iter.next();    System.out.println(e);&#125;</span><br></pre></td></tr></table></figure><p>注意：foreach 循环写法，能够配合数组以及所有实现了 Iterable 接口的集合类一起使用，其中 Iterable 用来获取集合的迭代器</p><hr><h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h4><h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h5><p>从 JDK  开始，switch 可以作用于字符串和枚举类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (str) &#123;    <span class="keyword">case</span> <span class="string">&quot;hello&quot;</span>: &#123;        System.out.println(<span class="string">&quot;h&quot;</span>);        <span class="keyword">break</span>;    &#125;    <span class="keyword">case</span> <span class="string">&quot;world&quot;</span>: &#123;        System.out.println(<span class="string">&quot;w&quot;</span>);        <span class="keyword">break</span>;    &#125;&#125;</span><br></pre></td></tr></table></figure><p>注意：<strong>switch 配合 String 和枚举使用时，变量不能为null</strong></p><p>会被编译器转换为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> x = -<span class="number">1</span>;<span class="keyword">switch</span>(str.hashCode()) &#123;    <span class="keyword">case</span> <span class="number">99162322</span>: <span class="comment">// hello 的 hashCode        if (str.equals(&quot;hello&quot;)) &#123;        x = 0;        &#125;    break;    case 113318802: // world 的 hashCode        if (str.equals(&quot;world&quot;)) &#123;        x = 1;        &#125;&#125;switch(x) &#123;    case 0:    System.out.println(&quot;h&quot;);    break;    case 1:    System.out.println(&quot;w&quot;);        break;&#125;</span></span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>执行了两遍 switch，第一遍是根据字符串的 hashCode 和 equals 将字符串的转换为相应 byte 类型，第二遍才是利用 byte 执行进行比较</li><li>hashCode 是为了提高效率，减少可能的比较；而 equals 是为了防止 hashCode 冲突</li></ul><hr><h5 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h5><p>switch 枚举的例子，原始代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Sex</span> </span>&#123;MALE, FEMALE&#125;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy7</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Sex sex)</span> </span>&#123;        <span class="keyword">switch</span> (sex) &#123;            <span class="keyword">case</span> MALE:                System.out.println(<span class="string">&quot;男&quot;</span>);                 <span class="keyword">break</span>;            <span class="keyword">case</span> FEMALE:                System.out.println(<span class="string">&quot;女&quot;</span>);                 <span class="keyword">break</span>;        &#125;&#125;&#125;</span><br></pre></td></tr></table></figure><p>编译转换后的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*** 定义一个合成类（仅 jvm 使用，对我们不可见）* 用来映射枚举的 ordinal 与数组元素的关系* 枚举的 ordinal 表示枚举对象的序号，从 0 开始* 即 MALE 的 ordinal()=0，FEMALE 的 ordinal()=1*/</span><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> $<span class="title">MAP</span> </span>&#123;    <span class="comment">// 数组大小即为枚举元素个数，里面存储 case 用来对比的数字    static int[] map = new int[2];    static &#123;    map[Sex.MALE.ordinal()] = 1;    map[Sex.FEMALE.ordinal()] = 2;&#125;&#125;public static void foo(Sex sex) &#123;    int x = $MAP.map[sex.ordinal()];    switch (x) &#123;        case 1:        System.out.println(&quot;男&quot;);        break;        case 2:        System.out.println(&quot;女&quot;);        break;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h4><p>JDK 7 新增了枚举类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Sex</span> </span>&#123;MALE, FEMALE&#125;</span><br></pre></td></tr></table></figure><p>编译转换后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sex</span> <span class="keyword">extends</span> <span class="title">Enum</span>&lt;<span class="title">Sex</span>&gt; </span>&#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Sex MALE;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Sex FEMALE;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Sex[] $VALUES;    <span class="keyword">static</span> &#123;        MALE = <span class="keyword">new</span> Sex(<span class="string">&quot;MALE&quot;</span>, <span class="number">0</span>);        FEMALE = <span class="keyword">new</span> Sex(<span class="string">&quot;FEMALE&quot;</span>, <span class="number">1</span>);        $VALUES = <span class="keyword">new</span> Sex[]&#123;MALE, FEMALE&#125;;    &#125;    <span class="function"><span class="keyword">private</span> <span class="title">Sex</span><span class="params">(String name, <span class="keyword">int</span> ordinal)</span> </span>&#123;    <span class="keyword">super</span>(name, ordinal);    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> Sex[] values() &#123;    <span class="keyword">return</span> $VALUES.clone();    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Sex <span class="title">valueOf</span><span class="params">(String name)</span> </span>&#123;    <span class="keyword">return</span> Enum.valueOf(Sex.class, name);    &#125;&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="try-w-r"><a href="#try-w-r" class="headerlink" title="try-w-r"></a>try-w-r</h4><p>JDK 7 开始新增了对需要关闭的资源处理的特殊语法 <code>try-with-resources</code>，格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(资源变量 = 创建资源对象)&#123;&#125; <span class="keyword">catch</span>( ) &#123;&#125;</span><br></pre></td></tr></table></figure><p>其中资源对象需要实现 <strong>AutoCloseable</strong>接口，例如 InputStream、OutputStream、Connection、Statement、ResultSet 等接口都实现了 AutoCloseable ，使用 try-withresources可以不用写 finally 语句块，编译器会帮助生成关闭资源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(InputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;d:\\1.txt&quot;</span>)) &#123;System.out.println(is);&#125; <span class="keyword">catch</span> (IOException e) &#123;e.printStackTrace();&#125;</span><br></pre></td></tr></table></figure><p>转换成：</p><p><code>addSuppressed(Throwable e)</code>：添加被压制异常，是为了防止异常信息的丢失（<strong>fianlly 中如果抛出了异常</strong>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;    InputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;d:\\1.txt&quot;</span>);    Throwable t = <span class="keyword">null</span>;    <span class="keyword">try</span> &#123;    System.out.println(is);    &#125; <span class="keyword">catch</span> (Throwable e1) &#123;    <span class="comment">// t 是我们代码出现的异常    t = e1;    throw e1;    &#125; finally &#123;        // 判断了资源不为空        if (is != null) &#123;            // 如果我们代码有异常            if (t != null) &#123;                try &#123;                is.close();                &#125; catch (Throwable e2) &#123;                    // 如果 close 出现异常，作为被压制异常添加                    t.addSuppressed(e2);                &#125;            &#125; else &#123;                // 如果我们代码没有异常，close 出现的异常就是最后 catch 块中的 e                is.close();            &#125;&#125;&#125;&#125; catch (IOException e) &#123;    e.printStackTrace();&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h4><p>方法重写时对返回值分两种情况：</p><ul><li>父子类的返回值完全一致</li><li>子类返回值可以是父类返回值的子类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;    <span class="function"><span class="keyword">public</span> Number <span class="title">m</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="number">1</span>;    &#125;&#125;<span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;    <span class="meta">@Override</span>    <span class="comment">// 子类m方法的返回值是Integer是父类m方法返回值Number的子类    public Integer m() &#123;    return 2;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>对于子类，java 编译器会做如下处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;    <span class="function"><span class="keyword">public</span> Integer <span class="title">m</span><span class="params">()</span> </span>&#123;    <span class="keyword">return</span> <span class="number">2</span>;    &#125;<span class="comment">// 此方法才是真正重写了父类 public Number m() 方法public synthetic bridge Number m() &#123;    // 调用 public Integer m()    return m();    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>其中桥接方法比较特殊，仅对 java 虚拟机可见，并且与原来的 public Integer m() 没有命名冲突</p><hr><h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><h5 id="无参优化"><a href="#无参优化" class="headerlink" title="无参优化"></a>无参优化</h5><p>源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy11</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        Runnable runnable = <span class="keyword">new</span> Runnable() &#123;            <span class="meta">@Override</span>            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;            System.out.println(<span class="string">&quot;ok&quot;</span>);            &#125;        &#125;;    &#125;&#125;</span><br></pre></td></tr></table></figure><p>转化后代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 额外生成的类final class Candy11$1 implements Runnable &#123;    Candy11$1() &#123;    &#125;    public void run() &#123;    System.out.println(&quot;ok&quot;);    &#125;&#125;public class Candy11 &#123;    public static void main(String[] args) &#123;    Runnable runnable = new Candy11$1();    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h5 id="带参优化"><a href="#带参优化" class="headerlink" title="带参优化"></a>带参优化</h5><p>引用局部变量的匿名内部类，源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy11</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> x)</span> </span>&#123;        Runnable runnable = <span class="keyword">new</span> Runnable() &#123;            <span class="meta">@Override</span>            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;            System.out.println(<span class="string">&quot;ok:&quot;</span> + x);            &#125;        &#125;;    &#125;&#125;</span><br></pre></td></tr></table></figure><p>转换后代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy11</span>$1 <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;    <span class="keyword">int</span> val$x;    Candy11$<span class="number">1</span>(<span class="keyword">int</span> x) &#123;    <span class="keyword">this</span>.val$x = x;    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;    System.out.println(<span class="string">&quot;ok:&quot;</span> + <span class="keyword">this</span>.val$x);    &#125;&#125;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy11</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> x)</span> </span>&#123;    Runnable runnable = <span class="keyword">new</span> Candy11$<span class="number">1</span>(x);    &#125;&#125;</span><br></pre></td></tr></table></figure><p>局部变量在底层创建为内部类的成员变量，必须是 final 的原因：</p><ul><li><p>在 Java 中方法调用是值传递的，在匿名内部类中对变量的操作都是基于原变量的副本，不会影响到原变量的值，所以原变量的值的改变也无法同步到副本中</p></li><li><p>外部变量为 final 是在编译期以强制手段确保用户不会在内部类中做修改原变量值的操作，也是<strong>防止外部操作修改了变量而内部类无法随之变化</strong>出现的影响</p><p>在创建 <code>Candy11$1 </code> 对象时，将 x 的值赋值给了 <code>Candy11$1</code> 对象的 val 属性，x 不应该再发生变化了，因为发生变化，this.val$x 属性没有机会再跟着变化</p></li></ul><hr><h4 id="反射优化"><a href="#反射优化" class="headerlink" title="反射优化"></a>反射优化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reflect1</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;    System.out.println(<span class="string">&quot;foo...&quot;</span>);    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;        Method foo = Reflect1.class.getMethod(<span class="string">&quot;foo&quot;</span>);        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">16</span>; i++) &#123;            System.out.printf(<span class="string">&quot;%d\t&quot;</span>, i);            foo.invoke(<span class="keyword">null</span>);        &#125;        System.in.read();    &#125;&#125;</span><br></pre></td></tr></table></figure><p>foo.invoke 0 ~ 15次调用的是 MethodAccessor 的实现类 <code>NativeMethodAccessorImpl.invoke0()</code>，本地方法执行速度慢；当调用到第 16 次时，会采用运行时生成的类 <code>sun.reflect.GeneratedMethodAccessor1</code> 代替</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object[] args)</span><span class="keyword">throws</span> Exception </span>&#123;    <span class="comment">// inflationThreshold 膨胀阈值，默认 15    if (++numInvocations &gt; ReflectionFactory.inflationThreshold()        &amp;&amp; !ReflectUtil.isVMAnonymousClass(method.getDeclaringClass())) &#123;        MethodAccessorImpl acc = (MethodAccessorImpl)            new MethodAccessorGenerator().            generateMethod(method.getDeclaringClass(),                           method.getName(),                           method.getParameterTypes(),                           method.getReturnType(),                           method.getExceptionTypes(),                           method.getModifiers());        parent.setDelegate(acc);    &#125;    // 【调用本地方法实现】    return invoke0(method, obj, args);&#125;private static native Object invoke0(Method m, Object obj, Object[] args);</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GeneratedMethodAccessor1</span> <span class="keyword">extends</span> <span class="title">MethodAccessorImpl</span> </span>&#123;    <span class="comment">// 如果有参数，那么抛非法参数异常    block4 : &#123;        if (arrobject == null || arrobject.length == 0) break block4;            throw new IllegalArgumentException();    &#125;    try &#123;        // 【可以看到，已经是直接调用方法】        Reflect1.foo();        // 因为没有返回值        return null;    &#125;   //....&#125;</span></span><br></pre></td></tr></table></figure><p>通过查看 ReflectionFactory 源码可知：</p><ul><li>sun.reflect.noInflation 可以用来禁用膨胀，直接生成 GeneratedMethodAccessor1，但首次生成比较耗时，如果仅反射调用一次，不划算</li><li>sun.reflect.inflationThreshold 可以修改膨胀阈值</li></ul><hr><h2 id="系统优化"><a href="#系统优化" class="headerlink" title="系统优化"></a>系统优化</h2><h3 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h3><h4 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h4><p>性能指标主要是吞吐量、响应时间、QPS、TPS 等、并发用户数等，而这些性能指标又依赖于系统服务器的资源，如 CPU、内存、磁盘 IO、网络 IO 等，对于这些指标数据的收集，通常可以根据Java本身的工具或指令进行查询</p><p>几个重要的指标：</p><ol><li>停顿时间（响应时间）：提交请求和返回该请求的响应之间使用的时间，比如垃圾回收中 STW 的时间</li><li>吞吐量：对单位时间内完成的工作量（请求）的量度（可以对比 GC 的性能指标）</li><li>并发数：同一时刻，对服务器有实际交互的请求数</li><li>QPS：Queries Per Second，每秒处理的查询量</li><li>TPS：Transactions Per Second，每秒产生的事务数</li><li>内存占用：Java 堆区所占的内存大小</li></ol><hr><h4 id="优化步骤"><a href="#优化步骤" class="headerlink" title="优化步骤"></a>优化步骤</h4><p>对于一个系统要部署上线时，则一定会对 JVM 进行调整，不经过任何调整直接上线，容易出现线上系统频繁 FullGC 造成系统卡顿、CPU 使用频率过高、系统无反应等问题</p><ol><li><p>性能监控：通过运行日志、堆栈信息、线程快照等信息监控是否出现 GC 频繁、OOM、内存泄漏、死锁、响应时间过长等情况</p></li><li><p>性能分析：</p><ul><li>打印 GC 日志，通过 GCviewe r或者 <a href="http://gceasy.io/">http://gceasy.io</a> 来分析异常信息</li></ul><ul><li><p>运用命令行工具、jstack、jmap、jinfo 等</p></li><li><p>dump 出堆文件，使用内存分析工具分析文件</p></li><li><p>使用阿里 Arthas、jconsole、JVisualVM 来<strong>实时查看 JVM 状态</strong></p></li><li><p>jstack 查看堆栈信息</p></li></ul></li><li><p>性能调优：</p><ul><li>适当增加内存，根据业务背景选择垃圾回收器</li></ul><ul><li><p>优化代码，控制内存使用</p></li><li><p>增加机器，分散节点压力</p></li><li><p>合理设置线程池线程数量</p></li><li><p>使用中间件提高程序效率，比如缓存、消息队列等</p></li></ul></li></ol><hr><h4 id="参数调优"><a href="#参数调优" class="headerlink" title="参数调优"></a>参数调优</h4><p>对于 JVM 调优，主要就是调整年轻代、老年代、元空间的内存空间大小及使用的垃圾回收器类型</p><ul><li><p>设置堆的初始大小和最大大小，为了防止垃圾收集器在初始大小、最大大小之间收缩堆而产生额外的时间，通常把最大、初始大小设置为相同的值</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms：设置堆的初始化大小-Xmx：设置堆的最大大小</span><br></pre></td></tr></table></figure></li><li><p>设置年轻代中 Eden 区和两个 Survivor 区的大小比例。该值如果不设置，则默认比例为 8:1:1。Java 官方通过增大 Eden 区的大小，来减少 YGC 发生的次数，虽然次数减少了，但 Eden 区满的时候，由于占用的空间较大，导致释放缓慢，此时 STW 的时间较长，因此需要按照程序情况去调优</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:SurvivorRatio</span><br></pre></td></tr></table></figure></li><li><p>年轻代和老年代默认比例为 1:2，可以通过调整二者空间大小比率来设置两者的大小。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:newSize   设置年轻代的初始大小-XX:MaxNewSize   设置年轻代的最大大小，  初始大小和最大大小两个值通常相同</span><br></pre></td></tr></table></figure></li><li><p>线程堆栈的设置：<strong>每个线程默认会开启 1M 的堆栈</strong>，用于存放栈帧、调用参数、局部变量等，但一般 256K 就够用，通常减少每个线程的堆栈，可以产生更多的线程，但这实际上还受限于操作系统</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xss   对每个线程stack大小的调整,-Xss128k</span><br></pre></td></tr></table></figure></li><li><p>一般一天超过一次 FullGC 就是有问题，首先通过工具查看是否出现内存泄露，如果出现内存泄露则调整代码，没有的话则调整 JVM 参数</p></li><li><p>系统 CPU 持续飙高的话，首先先排查代码问题，如果代码没问题，则咨询运维或者云服务器供应商，通常服务器重启或者服务器迁移即可解决</p></li><li><p>如果数据查询性能很低下的话，如果系统并发量并没有多少，则应更加关注数据库的相关问题</p></li><li><p>如果服务器配置还不错，JDK8 开始尽量使用 G1 或者新生代和老年代组合使用并行垃圾回收器</p></li></ul><hr><h3 id="命令行篇"><a href="#命令行篇" class="headerlink" title="命令行篇"></a>命令行篇</h3><h4 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h4><p>jps（Java Process Statu）：显示指定系统内所有的 HotSpot 虚拟机进程（查看虚拟机进程信息），可用于查询正在运行的虚拟机进程，进程的本地虚拟机 ID 与操作系统的进程 ID 是一致的，是唯一的</p><p>使用语法：<code>jps [options] [hostid]</code></p><p>options 参数：</p><ul><li><p>-q：仅仅显示 LVMID（local virtual machine id），即本地虚拟机唯一 id，不显示主类的名称等</p></li><li><p>-l：输出应用程序主类的全类名或如果进程执行的是 jar 包，则输出 jar 完整路径</p></li><li><p>-m：输出虚拟机进程启动时传递给主类 main()的参数</p></li><li><p>-v：列出虚拟机进程启动时的JVM参数，比如 -Xms20m -Xmx50m是启动程序指定的 jvm 参数</p></li></ul><p>ostid 参数：RMI注册表中注册的主机名，如果想要远程监控主机上的 java 程序，需要安装 jstatd</p><hr><h4 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h4><p>jstat（JVM Statistics Monitoring Tool）：用于监视 JVM 各种运行状态信息的命令行工具，可以显示本地或者远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据，在没有 GUI 的图形界面，只提供了纯文本控制台环境的服务器上，它是运行期定位虚拟机性能问题的首选工具，常用于检测垃圾回收问题以及内存泄漏问题</p><p>使用语法：<code>jstat -&lt;option&gt; [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]]</code></p><p>查看命令相关参数：jstat-h 或 jstat-help</p><ul><li><p>vmid 是进程 id 号</p></li><li><p>option 参数：</p><p>类装载相关：</p><ul><li>-class：显示 ClassLoader 的相关信息，类的装载、卸载数量、总空间、类装载所消耗的时间等</li></ul><p>垃圾回收相关：</p><ul><li><p>-gc：显示与GC相关的堆信息，年轻代、老年代、永久代等的容量、已用空间、GC时间合计等信息</p></li><li><p>-gccapacity：显示内容与 -gc 基本相同，但输出主要关注 Java 堆各个区域使用到的最大、最小空间</p></li><li><p>-gcutil：显示内容与 -gc 基本相同，但输出主要关注已使用空间占总空间的百分比</p></li><li><p>-gccause：与 -gcutil 功能一样，但是会额外输出导致最后一次或当前正在发生的 GC 产生的原因</p></li><li><p>-gcnew：显示新生代 GC 状况</p></li><li><p>-gcnewcapacity：显示内容与 -gcnew 基本相同，输出主要关注使用到的最大、最小空间</p></li><li><p>-geold：显示老年代 GC 状况</p></li><li><p>-gcoldcapacity：显示内容与 -gcold 基本相同，输出主要关注使用到的最大、最小空间</p></li><li><p>-gcpermcapacity：显示永久代使用到的最大、最小空间</p></li></ul><p>JIT 相关：</p><ul><li><p>-compiler：显示 JIT 编译器编译过的方法、耗时等信息</p></li><li><p>-printcompilation：输出已经被 JIT 编译的方法</p></li></ul></li></ul><hr><h4 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h4><p>jinfo（Configuration Info for Java）：查看虚拟机配置参数信息，也可用于调整虚拟机的配置参数，开发人员可以很方便地找到 Java 虚拟机参数的当前值</p><p>使用语法：<code>jinfo [options] pid</code></p><p>options 参数：</p><ul><li>no option：输出全部的参数和系统属性</li><li>-flag name：输出对应名称的参数</li><li>-flag [+-]name：开启或者关闭对应名称的参数 只有被标记为manageable的参数才可以被动态修改</li><li>-flag name=value：设定对应名称的参数</li><li>-flags：输出全部的参数</li><li>-sysprops：输出系统属性</li></ul><hr><h4 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h4><p>jmap（JVM Memory Map）：获取 dump 文件，还可以获取目标 Java 进程的内存相关信息，包括 Java 堆各区域的使用情况、堆中对象的统计信息、类加载信息等</p><p>使用语法：</p><ul><li><p><code>jmap [options] &lt;pid&gt;</code></p></li><li><p><code>jmap [options] &lt;executable &lt;core&gt;</code></p></li><li><p><code>jmap [options] [server_id@] &lt;remote server IP or hostname&gt;</code></p></li></ul><p>option 参数：</p><ul><li>-dump：生成 dump 文件（Java堆转储快照，二进制文件），-dump:live 只保存堆中的存活对象</li><li>-heap：输出整个堆空间的详细信息，包括 GC 的使用、堆配置信息，以及内存的使用信息等</li><li>-histo：输出堆空间中对象的统计信息，包括类、实例数量和合计容量，-histo:live 只统计堆中的存活对象</li><li>-J <flag>：传递参数给 jmap 启动的 jvm</flag></li><li>-finalizerinfo：显示在 F-Queue 中等待 Finalizer 线程执行 finalize 方法的对象，仅 linux/solaris 平台有效</li><li>-permstat：以 ClassLoader 为统计口径输出永久代的内存状态信息，仅 linux/solaris 平台有效</li><li>-F：当虚拟机进程对 -dump 选项没有任何响应时，强制执行生成 dump 文件，仅 linux/solaris 平台有效</li></ul><hr><h4 id="jhat"><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h4><p>jhat（JVM Heap Analysis Tool）：Sun JDK 提供的 jhat 命令与 jmap 命令搭配使用，用于<strong>分析 jmap 生成的 heap dump 文件</strong>（堆转储快照），jhat 内置了一个微型的 HTTP/HTML 服务器，生成 dump 文件的分析结果后，用户可以在浏览器中查看分析结果</p><p>使用语法：<code>jhat &lt;options&gt; &lt;dumpfile&gt;</code></p><p>options 参数：</p><ul><li>-stack false｜true：关闭｜打开对象分配调用栈跟踪</li><li>-refs false｜true：关闭｜打开对象引用跟踪</li><li>-port port-number：设置 jhat HTTP Server 的端口号，默认 7000</li><li>-exclude exclude-file：执行对象查询时需要排除的数据成员</li><li>-baseline exclude-file：指定一个基准堆转储</li><li>-debug int：设置 debug 级别</li><li>-version：启动后显示版本信息就退出</li><li>-J <flag>：传入启动参数，比如 -J-Xmx512m</flag></li></ul><p>说明：jhat 命令在 JDK9、JDK10 中已经被删除，官方建议用 VisualVM 代替</p><hr><h4 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h4><p>jstack（JVM Stack Trace）：用于生成虚拟机指定进程当前时刻的线程快照（虚拟机堆栈跟踪），线程快照就是当前虚拟机内指定进程的每一条线程正在执行的方法堆栈的集合</p><p>线程快照的作用：可用于定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等问题，用 jstack 显示各个线程调用的堆栈情况</p><p>使用语法：<code>jstack [options] pid</code></p><p>options 参数：</p><ul><li>-F：当正常输出的请求不被响应时，强制输出线程堆栈</li><li>-l：除堆栈外，显示关于锁的附加信息</li><li>-m：如果调用本地方法的话，可以显示 C/C++ 的堆栈</li></ul><p>在 thread dump 中的几种状态：</p><ul><li><p>死锁：Deadlock</p></li><li><p>等待资源：Waiting on condition</p></li><li><p>等待获取监视器：Waiting on monitor entry</p></li><li><p>阻塞：Blocked</p></li><li><p>执行中：Runnable</p></li><li><p>暂停：Suspended</p></li><li><p>对象等待中：Object.wait() 或 TIMED＿WAITING</p></li><li><p>停止：Parked</p></li></ul><hr><h4 id="jcmd"><a href="#jcmd" class="headerlink" title="jcmd"></a>jcmd</h4><p>jcmd 是一个多功能命令行工具，可以用来实现前面除了 jstat 之外所有命令的功能，比如 dump、内存使用、查看 Java 进程、导出线程信息、执行 GC、JVM 运行时间等</p><p>jcmd -l：列出所有的JVM进程</p><p>jcmd 进程号 help：针对指定的进程，列出支持的所有具体命令</p><ul><li>Thread.print：可以替换 jstack 指令</li></ul><ul><li><p>GC.class_histogram：可以替换 jmap 中的 -histo 操作</p></li><li><p>GC.heap_dump：可以替换 jmap 中的 -dump 操作</p></li><li><p>GC.run：可以查看GC的执行情况</p></li><li><p>VM.uptime：可以查看程序的总执行时间，可以替换 jstat 指令中的 -t  操作</p></li><li><p>VM.system_properties：可以替换 jinfo -sysprops 进程 id</p></li><li><p>VM.flags：可以获取 JVM 的配置参数信息</p></li></ul><hr><h4 id="jstatd"><a href="#jstatd" class="headerlink" title="jstatd"></a>jstatd</h4><p>jstatd 是一个 RMI 服务端程序，相当于代理服务器，建立本地计算机与远程监控工具的通信，jstatd 服务器将本机的 Java 应用程序信息传递到远程计算机</p><p>远程主机信息收集，前面的指令只涉及到监控本机的 Java 应用程序，而在这些工具中，一些监控工具也支持对远程计算机的监控（如 jps、jstat），为了启用远程监控，则需要配合使用 jstatd 工具。</p><p><img src="https://gitee.com/seazean/images/raw/master/Java/JVM-jstatd%E5%9B%BE%E8%A7%A3.png"></p><hr><h3 id="GUI工具"><a href="#GUI工具" class="headerlink" title="GUI工具"></a>GUI工具</h3><p>工具的使用此处不再多言，推荐一个写的非常好的文章，JVM 调优部分的笔记全部参考此文章编写</p><p>视频链接：<a href="https://www.bilibili.com/video/BV1PJ411n7xZ?p=304">https://www.bilibili.com/video/BV1PJ411n7xZ?p=304</a></p><p>文章链接：<a href="https://www.yuque.com/u21195183/jvm/lv1zot">https://www.yuque.com/u21195183/jvm/lv1zot</a></p><hr><h3 id="运行参数"><a href="#运行参数" class="headerlink" title="运行参数"></a>运行参数</h3><h4 id="参数选项"><a href="#参数选项" class="headerlink" title="参数选项"></a>参数选项</h4><p>添加 JVM 参数选项：进入 Run/Debug Configurations → VM options 设置参数</p><ul><li><p>标准参数选项：<code>java [-options] class [args...]</code> 或 <code>java [-options] -jar jarfile [args...]</code></p><p>命令：<code>-? -help</code> 可以输出此命令的相关选项</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Seazean&gt;java -versionjava version <span class="string">&quot;1.8.0_221&quot;</span>Java(TM) SE Runtime Environment (build 1.8.0_221-b11)Java HotSpot(TM) 64-Bit Server VM (build 25.221-b11, mixed mode)<span class="comment"># mixed mode 字样，代表当前系统使用的是混合模式</span></span><br></pre></td></tr></table></figure><p>Hotspot JVM 有两种模式，分别是 Server 和 Client，分别通过 -server 和- client 设置模式：</p><ul><li><p>32 位系统上，默认使用 Client 类型的 JVM，要使用 Server 模式，机器配置至少有 2 个以上的内核和 2G 以上的物理内存，Client 模式适用于对内存要求较小的桌面应用程序，默认使用 Serial 串行垃圾收集器</p></li><li><p>64 位系统上，只支持 Server 模式的 JVM，适用于需要大内存的应用程序，默认使用并行垃圾收集器</p></li></ul></li><li><p>-X 参数选项：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xmixed           混合模式执行 (默认)-Xint             仅解释模式执行-Xbootclasspath:&lt;用;分隔的目录和zip/jar文件&gt;设置搜索路径以引导类和资源-Xbootclasspath/a:&lt;用;分隔的目录和zip/jar文件&gt;附加在引导类路径末尾-Xbootclasspath/p:&lt;用;分隔的目录和zip/jar文件&gt;置于引导类路径之前-Xdiag            显示附加诊断消息-Xnoclassgc       禁用类垃圾收集-Xincgc           启用增量垃圾收集-Xloggc:&lt;file&gt;    将 GC 状态记录在文件中 (带时间戳)-Xbatch           禁用后台编译-Xprof            输出 cpu 配置文件数据-Xfuture          启用最严格的检查, 预期将来的默认值-Xrs              减少 Java/VM 对操作系统信号的使用 (请参阅文档)-Xcheck:jni       对 JNI 函数执行其他检查-Xshare:off       不尝试使用共享类数据-Xshare:auto      在可能的情况下使用共享类数据 (默认)-Xshare:on        要求使用共享类数据, 否则将失败。-XshowSettings    显示所有设置并继续-XshowSettings:all显示所有设置并继续-XshowSettings:vm 显示所有与 vm 相关的设置并继续-XshowSettings:properties显示所有属性设置并继续-XshowSettings:locale显示所有与区域设置相关的设置并继续</span><br></pre></td></tr></table></figure></li><li><p>-XX 参数选项：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Boolean类型格式-XX:+&lt;option&gt;  启用option属性-XX:-&lt;option&gt;  禁用option属性#非Boolean类型格式-XX:&lt;option&gt;=&lt;number&gt;  设置option数值，可以带单位如k/K/m/M/g/G-XX:&lt;option&gt;=&lt;string&gt;  设置option字符值</span></span><br></pre></td></tr></table></figure></li></ul><p>程序运行中：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置Boolean类型参数jinfo -flag [+|-]&lt;name&gt; &lt;pid&gt;# 设置非Boolean类型参数jinfo -flag &lt;name&gt;=&lt;value&gt; &lt;pid&gt;</span></span><br></pre></td></tr></table></figure><hr><h4 id="打印参数"><a href="#打印参数" class="headerlink" title="打印参数"></a>打印参数</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintCommandLineFlags 程序运行时JVM默认设置或用户手动设置的XX选项-XX:+PrintFlagsInitial 打印所有XX选项的默认值-XX:+PrintFlagsFinal 打印所有XX选项的实际值-XX:+PrintVMOptions 打印JVM的参数</span><br></pre></td></tr></table></figure><hr><h4 id="内存参数"><a href="#内存参数" class="headerlink" title="内存参数"></a>内存参数</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 栈-Xss128k &lt;==&gt; -XX:ThreadStackSize=128k 设置线程栈的大小为128K# 堆-Xms2048m &lt;==&gt; -XX:InitialHeapSize=2048m 设置JVM初始堆内存为2048M（默认为物理内存的1/64）-Xmx2048m &lt;==&gt; -XX:MaxHeapSize=2048m 设置JVM最大堆内存为2048M（默认为物理内存的1/4）-Xmn2g &lt;==&gt; -XX:NewSize=2g 设置年轻代大小为2G-XX:SurvivorRatio=8 设置Eden区与Survivor区的比值，默认为8-XX:NewRatio=2 设置老年代与年轻代的比例，默认为2-XX:+UseAdaptiveSizePolicy 设置大小比例自适应，默认开启-XX:PretenureSizeThreadshold=1024 设置让大于此阈值的对象直接分配在老年代，只对Serial、ParNew收集器有效-XX:MaxTenuringThreshold=15 设置新生代晋升老年代的年龄限制，默认为15-XX:TargetSurvivorRatio 设置MinorGC结束后Survivor区占用空间的期望比例# 方法区-XX:MetaspaceSize / -XX:PermSize=256m 设置元空间/永久代初始值为256M-XX:MaxMetaspaceSize / -XX:MaxPermSize=256m 设置元空间/永久代最大值为256M-XX:+UseCompressedOops 使用压缩对象-XX:+UseCompressedClassPointers 使用压缩类指针-XX:CompressedClassSpaceSize 设置Klass Metaspace的大小，默认1G# 直接内存-XX:MaxDirectMemorySize 指定DirectMemory容量，默认等于Java堆最大值</span></span><br></pre></td></tr></table></figure><p>说明：参数前面是<code>+</code>号说明是开启，如果是<code>- </code>号说明是关闭</p><hr><h4 id="OOM参数"><a href="#OOM参数" class="headerlink" title="OOM参数"></a>OOM参数</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+HeapDumpOnOutMemoryError 内存出现OOM时生成Heap转储文件，两者互斥-XX:+HeapDumpBeforeFullGC 出现FullGC时生成Heap转储文件，两者互斥-XX:HeapDumpPath=&lt;path&gt; 指定heap转储文件的存储路径，默认当前目录-XX:OnOutOfMemoryError=&lt;path&gt; 指定可行性程序或脚本的路径，当发生OOM时执行脚本</span><br></pre></td></tr></table></figure><hr><h4 id="日志参数"><a href="#日志参数" class="headerlink" title="日志参数"></a>日志参数</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGC &lt;==&gt; -verbose:gc  打印简要日志信息-XX:+PrintGCDetails            打印详细日志信息-XX:+PrintGCTimeStamps  打印程序启动到GC发生的时间，搭配-XX:+PrintGCDetails使用-XX:+PrintGCDateStamps  打印GC发生时的时间戳，搭配-XX:+PrintGCDetails使用-XX:+PrintHeapAtGC  打印GC前后的堆信息，如下图-Xloggc:&lt;file&gt; 输出GC导指定路径下的文件中-XX:+TraceClassLoading  监控类的加载-XX:+PrintTenuringDistribution打印JVM在每次MinorGC后当前使用的Survivor中对象的年龄分布-XX:+PrintGCApplicationStoppedTime  打印GC时线程的停顿时间-XX:+PrintGCApplicationConcurrentTime  打印垃圾收集之前应用未中断的执行时间-XX:+PrintReferenceGC 打印回收了多少种不同引用类型的引用-XX:+UseGCLogFileRotation 启用GC日志文件的自动转储-XX:NumberOfGCLogFiles=1  设置GC日志文件的循环数目-XX:GCLogFileSize=1M  设置GC日志文件的大小</span><br></pre></td></tr></table></figure><hr><h4 id="其他参数"><a href="#其他参数" class="headerlink" title="其他参数"></a>其他参数</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+DisableExplicitGC  禁用hotspot执行System.gc()，默认禁用-XX:+DoEscapeAnalysis  开启逃逸分析-XX:+UseBiasedLocking  开启偏向锁-XX:+UseLargePages  开启使用大页面-XX:+PrintTLAB  打印TLAB的使用情况-XX:TLABSize  设置TLAB大小-XX:ReservedCodeCacheSize=&lt;n&gt;[g|m|k]、-XX:InitialCodeCacheSize=&lt;n&gt;[g|m|k] 指定代码缓存大小-XX:+UseCodeCacheFlushing  放弃一些被编译的代码，避免代码缓存被占满时JVM切换到interpreted-only的情况</span><br></pre></td></tr></table></figure><hr><h4 id="代码获取"><a href="#代码获取" class="headerlink" title="代码获取"></a>代码获取</h4><p>Java 提供了 java.lang.management 包用于监视和管理 Java 虚拟机和 Java 运行时中的其他组件，允许本地或远程监控和管理运行的 Java 虚拟机。ManagementFactory 类较为常用，Runtime 类可获取内存、CPU 核数等相关的数据，通过使用这些方法，可以监控应用服务器的堆内存使用情况，设置一些阈值进行报警等处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryMonitor</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        MemoryMXBean memorymbean = ManagementFactory.getMemoryMXBean();        MemoryUsage usage = memorymbean.getHeapMemoryUsage();        System.out.println(<span class="string">&quot;INIT HEAP: &quot;</span> + usage.getInit() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;m&quot;</span>);        System.out.println(<span class="string">&quot;MAX HEAP: &quot;</span> + usage.getMax() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;m&quot;</span>);        System.out.println(<span class="string">&quot;USE HEAP: &quot;</span> + usage.getUsed() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;m&quot;</span>);        System.out.println(<span class="string">&quot;\nFull Information:&quot;</span>);        System.out.println(<span class="string">&quot;Heap Memory Usage: &quot;</span> + memorymbean.getHeapMemoryUsage());        System.out.println(<span class="string">&quot;Non-Heap Memory Usage: &quot;</span> + memorymbean.getNonHeapMemoryUsage());        System.out.println(<span class="string">&quot;====通过java来获取相关系统状态====&quot;</span>);        System.out.println(<span class="string">&quot;当前堆内存大小totalMemory &quot;</span> + (<span class="keyword">int</span>) Runtime.getRuntime().totalMemory() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;m&quot;</span>);<span class="comment">// 当前堆内存大小        System.out.println(&quot;空闲堆内存大小freeMemory &quot; + (int) Runtime.getRuntime().freeMemory() / 1024 / 1024 + &quot;m&quot;);// 空闲堆内存大小        System.out.println(&quot;最大可用总堆内存maxMemory &quot; + Runtime.getRuntime().maxMemory() / 1024 / 1024 + &quot;m&quot;);// 最大可用总堆内存大小    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h3 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h3><h4 id="日志分类"><a href="#日志分类" class="headerlink" title="日志分类"></a>日志分类</h4><p>HotSpot VM 的 GC 按照回收区域分为两类：一种是部分收集（Partial GC），一种是整堆收集（Full GC）</p><ul><li><p>部分收集（Partial GC）：不是完整收集整个 Java 堆的垃圾收集。其中又分为： </p><ul><li>新生代收集（Minor GC/Young GC）：只是新生代（Eden/S0、S1）的垃圾收集</li><li>老年代收集（Major GC/Old GC）：只是老年代的垃圾收集，只有 CMS GC 会有单独收集老年代的行为</li></ul></li><li><p>混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集，只有 G1 GC 会有这种行为 </p></li><li><p>整堆收集（Full GC）：收集整个 Java 堆和方法区的垃圾收集。</p></li></ul><p>Minor GC/Young GC 日志：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 31744K-&gt;2192K (36864K) ] 31744K-&gt;2200K (121856K), 0.0139308 secs] [Times: user=0.05 sys=0.01, real=0.01 secs]</span><br></pre></td></tr></table></figure><p>Full GC 日志：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Full GC (Metadata GC Threshold) [PSYoungGen: 5104K-&gt;0K (132096K) ] [Par01dGen: 416K-&gt;5453K (50176K) ]5520K-&gt;5453K (182272K), [Metaspace: 20637K-&gt;20637K (1067008K) ], 0.0245883 secs] [Times: user=0.06 sys=0.00, real=0.02 secs]</span><br></pre></td></tr></table></figure><hr><h4 id="日志解析"><a href="#日志解析" class="headerlink" title="日志解析"></a>日志解析</h4><p>通过日志看垃圾收集器：</p><ul><li><p> Serial 收集器：新生代显示 <code>[DefNew</code>，即 <code>Default New Generation</code></p></li><li><p> ParNew 收集器：新生代显示 <code>[ParNew</code>，即 <code>Parallel New Generation</code></p></li><li><p> Parallel Scavenge 收集器：新生代显示 <code>[PSYoungGen</code>，JDK1.7 使用的 PSYoungGen </p></li><li><p> Parallel Old 收集器：老年代显示 <code>[ParoldGen</code></p></li><li><p> G1 收集器：显示 <code>garbage-first heap</code></p></li></ul><p>通过日志看 GC 原因：</p><ul><li><p>Allocation Failure：表明本次引起 GC 的原因是因为新生代中没有足够的区域存放需要分配的数据</p></li><li><p>Metadata GCThreshold：Metaspace 区不足</p></li><li><p>FErgonomics：JVM 自适应调整导致的 GC</p></li><li><p>System：调用了 System.gc() 方法</p></li></ul><p>通过日志看 GC 前后情况：GC 前内存占用 → GC 后内存占用（该区域内存总大小）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[PSYoungGen: 5986K-&gt;696K (8704K)] 5986K-&gt;704K (9216K)</span><br></pre></td></tr></table></figure><ul><li><p> 中括号内：GC 回收前年轻代堆大小 → 回收后大小（年轻代堆总大小） </p></li><li><p> 括号外：GC 回收前年轻代和老年代大小 → 回收后大小（年轻代和老年代总大小） </p></li></ul><ul><li>Minor GC 堆内存总容量 = 9/10 年轻代 + 老年代，Survivor 区只计算 from 部分，而 JVM 默认年轻代中 Eden 区和 Survivor 区的比例关系：Eden:S0:S1=8:1:1</li></ul><p>通过日志看 GC 时间：GC 日志中有三个时间 user、sys、real</p><ul><li><p>user：进程执行用户态代码（核心之外）所使用的时间，这是执行此进程所使用的实际 CPU 时间，其他进程和此进程阻塞的时间并不包括在内，在垃圾收集的情况下，表示 GC 线程执行所使用的 CPU 总时间。</p></li><li><p>sys：进程在内核态消耗的 CPU 时间，即在内核执行系统调用或等待系统事件所使用的 CPU 时间</p></li><li><p>real：程序从开始到结束所用的时钟时间，这个时间包括其他进程使用的时间片和进程阻塞的时间（比如等待 I/O 完成），对于并行 GC，这个数字应该接近（用户时间＋系统时间）除以垃圾收集器使用的线程数</p></li></ul><p>由于多核的原因，一般的 GC 事件中，real time 小于 sys time＋user time，因为是多个线程并发的去做 GC。如果 real＞sys＋user 的话，则说明 IO 负载非常重或 CPU 不够用</p><hr><h4 id="分析工具"><a href="#分析工具" class="headerlink" title="分析工具"></a>分析工具</h4><p>GCEasy 是一款在线的 GC 日志分析器，可以通过 GC 日志分析进行内存泄露检测、GC 暂停原因分析、JVM 配置建议优化等功能，大多数功能是免费的</p><ul><li>官网地址：<a href="https://gceasy.io/">https://gceasy.io/</a></li></ul><p>GCViewer 是一款离线的 GC 日志分析器，用于可视化 Java VM 选项 -verbose:gc 和 .NET 生成的数据 -Xloggc:<file>，还可以计算与垃圾回收相关的性能指标（吞吐量、累积的暂停、最长的暂停等），当通过更改世代大小或设置初始堆大小来调整特定应用程序的垃圾回收时，此功能非常有用</file></p><ul><li><p>源码下载：<a href="https://github.com/chewiebug/GCViewer">https://github.com/chewiebug/GCViewer</a></p></li><li><p>运行版本下载：<a href="https://github.com/chewiebug/GCViewer/wiki/Changelog">https://github.com/chewiebug/GCViewer/wiki/Changelog</a></p></li></ul><p>参考文章：<a href="https://www.yuque.com/u21195183/jvm/ukmb3k">https://www.yuque.com/u21195183/jvm/ukmb3k</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础笔记3-ALG</title>
      <link href="./2021/09/16/java/java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B03-ALG/"/>
      <url>./2021/09/16/java/java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B03-ALG/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="assets\css\APlayer.min.css"><script src="assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="ALG"><a href="#ALG" class="headerlink" title="ALG"></a>ALG</h1><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>算法：解题方案的准确而完整的描述，是一系列解决问题的清晰指令，代表着用系统的方法解决问题的策略机制</p><p>递归：程序调用自身的编程技巧</p><p>递归：</p><ul><li>直接递归：自己的方法调用自己</li><li>间接递归：自己的方法调用别的方法，别的方法又调用自己</li></ul><p>递归如果控制的不恰当，会形成递归的死循环，从而导致栈内存溢出错误</p><p>参考书籍：<a href="https://book.douban.com/subject/35263893/">https://book.douban.com/subject/35263893/</a></p><hr><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h4 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h4><p>递归的三要素（理论）：</p><ol><li>递归的终结点</li><li>递归的公式</li><li>递归的方向：必须走向终结点</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// f(x)=f(x-1)+1;   f(1)=1;    f(10)=?// 1.递归的终结点： f(1)  = 1// 2.递归的公式：f(x) = f(x - 1) + 1// 3.递归的方向：必须走向终结点public static int f(int x)&#123;    if(x == 1)&#123;        return 1;    &#125;else&#123;        return f(x-1) + 1;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="公式转换"><a href="#公式转换" class="headerlink" title="公式转换"></a>公式转换</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 已知： f(x) = f(x + 1) + 2,  f(1) = 1。求：f(10) = ?// 公式转换// f(x-1)=f(x-1+1)+2 =&gt; f(x)=f(x-1)+2//（1）递归的公式：   f(n) = f(n-1)- 2 ;//（2）递归的终结点：  f(1) = 1//（3）递归的方向：必须走向终结点。public static int f(int n)&#123;    if(n == 1)&#123;        return 1;    &#125;else&#123;        return f(n-1) - 2;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>以上理论只能针对于<strong>规律化递归</strong>，如果是非规律化是不能套用以上公式的！<br>非规律化递归的问题：文件搜索，啤酒问题。</p><hr><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="猴子吃桃"><a href="#猴子吃桃" class="headerlink" title="猴子吃桃"></a>猴子吃桃</h4><p>猴子第一天摘了若干个桃子，当即吃了一半，觉得好不过瘾，然后又多吃了一个。第二天又吃了前一天剩下的一半，觉得好不过瘾，然后又多吃了一个。以后每天都是如此。等到第十天再吃的时候发现只有1个桃子，问猴子第一天总共摘了多少个桃子？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*（1）公式： f(x+1)=f(x)-f(x)/2-1; ==&gt; 2f(x+1) = f(x) - 2 ==&gt; f(x)=2f(x+1)+2（2）终结点：f(10) = 1（3）递归的方向：走向了终结点*/</span><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;    <span class="keyword">if</span>(x == <span class="number">10</span>)&#123;        <span class="keyword">return</span> <span class="number">1</span>;    &#125; <span class="keyword">else</span> &#123;        <span class="keyword">return</span> <span class="number">2</span>*f(x+<span class="number">1</span>)+<span class="number">2</span>    &#125;&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="递归求和"><a href="#递归求和" class="headerlink" title="递归求和"></a>递归求和</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//（1）递归的终点接：f(1) = 1//（2）递归的公式： f(n) = f(n-1) + n//（3）递归的方向必须走向终结点：public static int f(int n)&#123;        if(n == 1 ) return 1;        return f(n-1) + n;&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="汉诺塔"><a href="#汉诺塔" class="headerlink" title="汉诺塔"></a>汉诺塔</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hanoi</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        hanoi(<span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;Y&#x27;</span>, <span class="string">&#x27;Z&#x27;</span>, <span class="number">3</span>);    &#125;    <span class="comment">// 将n个块分治的从x移动到z，y为辅助柱    private static void hanoi(char x, char y, char z, int n) &#123;        if (n == 1) &#123;            System.out.println(x + &quot;→&quot; + z);    // 直接将x的块移动到z        &#125; else &#123;            hanoi(x, z, y, n - 1);           // 分治处理n-1个块，先将n-1个块借助z移到y            System.out.println(x + &quot;→&quot; + z);    // 然后将x最下面的块（最大的）移动到z            hanoi(y, x, z, n - 1);           // 最后将n-1个块从y移动到z，x为辅助柱        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>时间复杂度 O(2^n)</p><hr><h4 id="啤酒问题"><a href="#啤酒问题" class="headerlink" title="啤酒问题"></a>啤酒问题</h4><p>非规律化递归问题，啤酒 2 元 1 瓶，4 个盖子可以换 1 瓶，2 个空瓶可以换 1 瓶</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeerDemo</span></span>&#123;    <span class="comment">// 定义一个静态变量存储可以喝酒的总数    public static int totalNum;    public static int lastBottleNum;    public static int lastCoverNum;    public static void main(String[] args) &#123;        buyBeer(10);        System.out.println(&quot;总数：&quot;+totalNum);        System.out.println(&quot;剩余盖子：&quot;+ lastCoverNum);        System.out.println(&quot;剩余瓶子：&quot;+ lastBottleNum);    &#125;    public static void buyBeer(int money)&#123;        int number = money / 2;        totalNum += number;        // 算出当前剩余的全部盖子和瓶子数，换算成金额继续购买。        int currentBottleNum = lastBottleNum + number ;        int currentCoverNum = lastCoverNum + number ;        // 把他们换算成金额        int totalMoney = 0 ;        totalMoney += (currentBottleNum/2)*2; // 除2代表可以换几个瓶子，乘2代表换算成钱，秒！        lastBottleNum = currentBottleNum % 2 ;// 取余//算出剩余的瓶子             totalMoney += (currentCoverNum / 4) * 2;        lastCoverNum = currentCoverNum % 4 ;        // 继续拿钱买酒        if(totalMoney &gt;= 2)&#123;            buyBeer(totalMoney);        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序（Bubble Sort）：两个数比较大小，较大的数下沉，较小的数冒起来</p><p>算法描述：每次从数组的第一个位置开始两两比较，把较大的元素与较小的元素进行层层交换，最终把当前最大的一个元素存入到数组当前的末尾</p><p>实现思路：</p><ol><li>确定总共需要冒几轮：数组的长度-1</li><li>每轮两两比较几次</li></ol><img src="https://gitee.com/seazean/images/raw/master/Java/Sort-冒泡排序.gif" style="zoom: 80%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0 1位置比较，大的放后面，然后1 2位置比较，大的继续放后面，一轮循环最后一位是最大值public class BubbleSort &#123;    public static void main(String[] args) &#123;        int[] arr = &#123;55, 22, 2, 5, 1, 3, 8, 5, 7, 4, 3, 99, 88&#125;;        int flag;//标记本趟排序是否发生了交换        //比较i和i+1，不需要再比最后一个位置        for (int i = 0; i &lt; arr.length - 1; i++) &#123;            flag = 0;            //最后i位不需要比，已经排序好            for (int j = 0; j &lt; arr.length - 1 - i; j++) &#123;                if (arr[j] &gt; arr[j + 1]) &#123;                    int temp = arr[j];                    arr[j] = arr[j + 1];                    arr[j + 1] = temp;                    flag = 1;//发生了交换                &#125;            &#125;            //没有发生交换，证明已经有序，不需要继续排序，节省时间            if(flag == 0) &#123;                break;            &#125;        &#125;        System.out.println(Arrays.toString(arr));    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>冒泡排序时间复杂度：最坏情况</p><ul><li>元素比较的次数为：<code>(N-1)+(N-2)+(N-3)+...+2+1=((N-1)+1)*(N-1)/2=N^2/2-N/2</code></li><li>元素交换的次数为：<code>(N-1)+(N-2)+(N-3)+...+2+1=((N-1)+1)*(N-1)/2=N^2/2-N/2</code></li><li>总执行次数为：<code>(N^2/2-N/2)+(N^2/2-N/2)=N^2-N</code></li></ul><p>按照大 O 推导法则，保留函数中的最高阶项那么最终冒泡排序的时间复杂度为 O(N^2)</p><hr><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><h4 id="简单选择"><a href="#简单选择" class="headerlink" title="简单选择"></a>简单选择</h4><p>选择排序（Selection-sort）：一种简单直观的排序算法</p><p>算法描述：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕</p><p>实现思路：</p><ol><li>控制选择几轮：数组的长度 - 1</li><li>控制每轮从当前位置开始比较几次</li></ol><img src="https://gitee.com/seazean/images/raw/master/Java/Sort-选择排序.gif" style="zoom: 80%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectSort</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        <span class="keyword">int</span>[] arr = &#123;<span class="number">55</span>, <span class="number">22</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">99</span>, <span class="number">88</span>&#125;;        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;            <span class="comment">//获取最小索引位置            int minIndex = i;            for (int j = i + 1; j &lt; arr.length; j++) &#123;                if (arr[minIndex] &gt; arr[j]) &#123;                    minIndex = j;                &#125;            &#125;            //交换元素            int temp = arr[i];            arr[i] = arr[minIndex];            arr[minIndex] = temp;        &#125;        System.out.println(Arrays.toString(arr));    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>选择排序时间复杂度：</p><ul><li>数据比较次数：<code>(N-1)+(N-2)+(N-3)+...+2+1=((N-1)+1)*(N-1)/2=N^2/2-N/2</code></li><li>数据交换次数：<code>N-1</code></li><li>时间复杂度：<code>N^2/2-N/2+（N-1）=N^2/2+N/2-1</code></li></ul><p>根据大 O 推导法则，保留最高阶项，去除常数因子，时间复杂度为 O(N^2)</p><hr><h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法，堆结构是一个近似完全二叉树的结构，并同时满足子结点的键值或索引总是小于（或者大于）父节点</p><p>优先队列：堆排序每次上浮过程都会将最大或者最小值放在堆顶，应用于优先队列可以将优先级最高的元素浮到堆顶</p><p>实现思路：</p><ol><li><p>将初始待排序关键字序列（R1,R2….Rn）构建成大顶堆，并通过上浮对堆进行调整，此堆为初始的无序区，<strong>堆顶为最大数</strong></p></li><li><p>将堆顶元素 R[1] 与最后一个元素 R[n] 交换，此时得到新的无序区（R1,R2,……Rn-1）和新的有序区 Rn，且满足 R[1,2…n-1]&lt;=R[n]</p></li><li><p>交换后新的堆顶 R[1] 可能违反堆的性质，因此需要对当前无序区（R1,R2,……Rn-1）调整为新堆，然后再次将 R[1] 与无序区最后一个元素交换，得到新的无序区（R1,R2….Rn-2）和新的有序区（Rn-1,Rn），不断重复此过程直到有序区的元素个数为 n-1，则整个排序过程完成</p></li></ol><img src="https://gitee.com/seazean/images/raw/master/Java/Sort-堆排序.jpg" style="zoom:67%;"><p>floor：向下取整</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        <span class="keyword">int</span>[] arr = &#123;<span class="number">55</span>, <span class="number">22</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">99</span>, <span class="number">88</span>&#125;;        heapSort(arr, arr.length - <span class="number">1</span>);        System.out.println(Arrays.toString(arr));    &#125;    <span class="comment">//high为数组最大索引    private static void heapSort(int[] arr, int high) &#123;        //建堆，逆排序，因为堆排序定义的交换顺序是从当前结点往下交换，逆序排可以避免多余的交换        //i初始值是最后一个节点的父节点，如果参数是数组长度len，则 i = len / 2 -1        for (int i = (high - 1) / 2; i &gt;= 0; i--) &#123;            //调整函数            sift(arr, i, high);        &#125;        //从尾索引开始排序        for (int i = high; i &gt; 0; i--) &#123;            //将最大的节点放入末尾            int temp = arr[0];            arr[0] = arr[i];            arr[i] = temp;            //继续寻找最大的节点            sift(arr, 0, i - 1);        &#125;    &#125;    //调整函数，调整arr[low]的元素，从索引low到high的范围调整    private static void sift(int[] arr, int low, int high) &#123;        //暂存调整元素        int temp = arr[low];        int i = low, j = low * 2 + 1;//j是左节点        while (j &lt;= high) &#123;            //判断是否有右孩子，并且比较左右孩子中较大的节点            if (j &lt; high &amp;&amp; arr[j] &lt; arr[j + 1]) &#123;                j++;    //指向右孩子            &#125;            if (temp &lt; arr[j]) &#123;                arr[i] = arr[j];                i = j;  //继续向下调整                j = 2 * i + 1;            &#125; else &#123;                //temp &gt; arr[j]，说明也大于j的孩子，探测结束                break;            &#125;        &#125;        //将被调整的节点放入最终的位置        arr[i] = temp;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>堆排序的时间复杂度是 O(nlogn)</p><hr><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><h4 id="直接插入"><a href="#直接插入" class="headerlink" title="直接插入"></a>直接插入</h4><p>插入排序（Insertion Sort）：在要排序的一组数中，假定前 n-1 个数已经排好序，现在将第 n 个数插到这个有序数列中，使得这 n 个数也是排好顺序的，如此反复循环，直到全部排好顺序</p><img src="https://gitee.com/seazean/images/raw/master/Java/Sort-插入排序.png" style="zoom: 67%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertSort</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        <span class="keyword">int</span>[] arr = &#123;<span class="number">55</span>, <span class="number">22</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">99</span>, <span class="number">88</span>&#125;;        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span>; j--) &#123;                <span class="comment">// 比较索引j处的值和索引j-1处的值，                // 如果索引j-1处的值比索引j处的值大，则交换数据，                // 如果不大，那么就找到合适的位置了，退出循环即可；                if (arr[j - 1] &gt; arr[j]) &#123;                    int temp = arr[j];                    arr[j] = arr[j - 1];                    arr[j - 1] = temp;                &#125;            &#125;        &#125;        System.out.println(Arrays.toString(arr));    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>插入排序时间复杂度：</p><ul><li>比较的次数为：<code>(N-1)+(N-2)+(N-3)+...+2+1=((N-1)+1)*(N-1)/2=N^2/2-N/2</code></li><li>交换的次数为：<code>(N-1)+(N-2)+(N-3)+...+2+1=((N-1)+1)(N-1)/2=N^2/2-N/2</code></li><li>总执行次数为：<code>(N^2/2-N/2)+(N^2/2-N/2)=N^2-N</code></li></ul><p>按照大 O 推导法则，保留函数中的最高阶项那么最终插入排序的时间复杂度为 O(N^2)</p><hr><h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><p>希尔排序（Shell Sort）：也是一种插入排序，也称为缩小增量排序</p><p>实现思路：</p><ol><li>选定一个增长量 h，按照增长量 h 作为数据分组的依据，对数据进行分组</li><li>对分好组的每一组数据完成插入排序</li><li>减小增长量，最小减为 1，重复第二步操作</li></ol><img src="https://gitee.com/seazean/images/raw/master/Java/Sort-希尔排序.png" style="zoom:67%;"><p>希尔排序的核心在于间隔序列的设定，既可以提前设定好间隔序列，也可以动态的定义间隔序列，希尔排序就是插入排序增加了间隔</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        <span class="keyword">int</span>[] arr = &#123;<span class="number">55</span>, <span class="number">22</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">99</span>, <span class="number">88</span>&#125;;        <span class="comment">// 确定增长量h的初始值        int h = 1;        while (h &lt; arr.length / 2) &#123;            h = 2 * h + 1;        &#125;        // 希尔排序        while (h &gt;= 1) &#123;            // 找到待插入的元素            for (int i = h; i &lt; arr.length; i++) &#123;                // 把待插入的元素插到有序数列中                for (int j = i; j &gt;= h; j -= h) &#123;                    // 待插入的元素是arr[j]，比较arr[j]和arr[j-h]                    if (arr[j] &lt; arr[j - h]) &#123;                        int temp = arr[j];                        arr[j] = arr[j - h];                        arr[j - h] = temp;                    &#125;                &#125;            &#125;            // 减小h的值，减小规则为：            h = h / 2;        &#125;        System.out.println(Arrays.toString(arr));    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>在希尔排序中，增长量 h 并没有固定的规则，有很多论文研究了各种不同的递增序列，但都无法证明某个序列是最好的，所以对于希尔排序的时间复杂度分析就认为 O(nlogn)</p><hr><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><p>归并排序（Merge Sort）：建立在归并操作上的一种有效的排序算法，该算法是采用分治法的典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p><p>实现思路：</p><ol><li>一组数据拆分成两个元素相等的子组，并对每一个子组继续拆分，直到拆分后的每个子组的元素个数是1为止</li><li>将相邻的两个子组进行合并成一个有序的大组</li><li>不断的重复步骤2，直到最终只有一个组为止</li></ol><img src="https://gitee.com/seazean/images/raw/master/Java/Sort-归并排序.png" style="zoom:50%;"><p>归并步骤：每次比较两端最小的值，把最小的值放在辅助数组的左边</p><p><img src="https://gitee.com/seazean/images/raw/master/Java/Sort-%E5%BD%92%E5%B9%B6%E6%AD%A5%E9%AA%A41.png"></p><p><img src="https://gitee.com/seazean/images/raw/master/Java/Sort-%E5%BD%92%E5%B9%B6%E6%AD%A5%E9%AA%A42.png"></p><p><img src="https://gitee.com/seazean/images/raw/master/Java/Sort-%E5%BD%92%E5%B9%B6%E6%AD%A5%E9%AA%A43.png"></p><hr><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">55</span>, <span class="number">22</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">99</span>, <span class="number">88</span>&#125;;        mergeSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);        System.out.println(Arrays.toString(arr));    &#125;<span class="comment">// low为arr最小索引，high为最大索引    public static void mergeSort(int[] arr, int low, int high) &#123;        // low == high 时说明只有一个元素了，直接返回        if (low &lt; high) &#123;            int mid = (low + high) / 2;            mergeSort(arr, low, mid);// 归并排序前半段            mergeSort(arr, mid + 1, high);// 归并排序后半段            merge(arr, low, mid, high);// 将两段有序段合成一段有序段        &#125;    &#125;    private static void merge(int[] arr, int low, int mid, int high) &#123;        int index = 0;        // 定义左右指针        int left = low, right = mid + 1;        int[] assist = new int[high - low + 1];                while (left &lt;= mid &amp;&amp; right &lt;= high) &#123;            assist[index++] = arr[left] &lt; arr[right] ? arr[left++] : arr[right++];        &#125;        while (left &lt;= mid) &#123;            assist[index++] = arr[left++];        &#125;        while (right &lt;= high) &#123;            assist[index++] = arr[right++];        &#125;        for (int k = 0; k &lt; assist.length; k++) &#123;            arr[low++] = assist[k];        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><img src="https://gitee.com/seazean/images/raw/master/Java/Sort-归并排序时间复杂度.png" style="zoom: 67%;"><p>用树状图来描述归并，假设元素的个数为 n，那么使用归并排序拆分的次数为 <code>log2(n)</code>，即层数，每次归并需要做 n 次对比，最终得出的归并排序的时间复杂度为 <code>log2(n)*n</code>，根据大O推导法则，忽略底数，最终归并排序的时间复杂度为 O(nlogn)</p><p>归并排序的缺点：需要申请额外的数组空间，导致空间复杂度提升，是典型的<strong>以空间换时间</strong>的操作</p><hr><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序（Quick Sort）：通过<strong>分治思想</strong>对冒泡排序的改进，基本过程是通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，以此达到整个数据变成有序序列</p><p>实现思路：</p><ol><li>从数列中挑出一个元素，称为基准（pivot）</li><li>重新排序数列，所有比基准值小的摆放在基准前面，所有比基准值大的摆在基准的后面（相同的数可以到任一边），在这个分区退出之后，该基准就处于数列的中间位置，这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序</li></ol><img src="https://gitee.com/seazean/images/raw/master/Java/Sort-快速排序.gif" style="zoom:80%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        <span class="keyword">int</span>[] arr = &#123;<span class="number">55</span>, <span class="number">22</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">99</span>, <span class="number">88</span>&#125;;        quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);        System.out.println(Arrays.toString(arr));    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;        <span class="comment">// 递归结束的条件        if (low &gt;= high) &#123;            return;        &#125;                int left = low;        int right = high;        // 基准数        int temp = arr[left];        while (left &lt; right) &#123;            // 用 &gt;= 可以防止多余的交换            while (arr[right] &gt;= temp &amp;&amp; right &gt; left) &#123;                right--;            &#125;            // 做判断防止相等            if (right &gt; left) &#123;                // 到这里说明 arr[right] &lt; temp                 arr[left] = arr[right];// 此时把arr[right]元素视为空                left++;            &#125;            while (arr[left] &lt;= temp &amp;&amp; left &lt; right) &#123;                left++;            &#125;            if (right &gt; left) &#123;                arr[right] = arr[left];                right--;            &#125;        &#125;        // left == right        arr[left] = temp;        quickSort(arr, low, left-1);        quickSort(arr, right + 1, high);    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>快速排序和归并排序的区别：</p><ul><li>快速排序是另外一种分治的排序算法，将一个数组分成两个子数组，将两部分独立的排序</li><li>归并排序的处理过程是由下到上的，先处理子问题，然后再合并。而快排正好相反，它的处理过程是由上到下的，先分区，然后再处理子问题</li><li>快速排序和归并排序是互补的：归并排序将数组分成两个子数组分别排序，并将有序的子数组归并从而将整个数组排序，而快速排序的方式则是当两个数组都有序时，整个数组自然就有序了</li><li>在归并排序中，一个数组被等分为两半，归并调用发生在处理整个数组之前，在快速排序中，切分数组的位置取决于数组的内容，递归调用发生在处理整个数组之后</li></ul><p>时间复杂度：</p><ul><li><p>最优情况：每一次切分选择的基准数字刚好将当前序列等分。把数组的切分看做是一个树，共切分了 logn 次，所以，最优情况下快速排序的时间复杂度为 O(nlogn)</p></li><li><p>最坏情况：每一次切分选择的基准数字是当前序列中最大数或者最小数，这使得每次切分都会有一个子组，那么总共就得切分n次，所以最坏情况下，快速排序的时间复杂度为 O(n^2)</p><img src="https://gitee.com/seazean/images/raw/master/Java/Sort-快排时间复杂度.png" style="zoom: 50%;"></li><li><p>平均情况：每一次切分选择的基准数字不是最大值和最小值，也不是中值，这种情况用数学归纳法证明，快速排序的时间复杂度为 O(nlogn)</p></li></ul><p>推荐视频：<a href="https://www.bilibili.com/video/BV1b7411N798?t=1001&amp;p=81">https://www.bilibili.com/video/BV1b7411N798?t=1001&amp;p=81</a></p><p>参考文章：<a href="https://blog.csdn.net/nrsc272420199/article/details/82587933">https://blog.csdn.net/nrsc272420199/article/details/82587933</a></p><hr><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>基数排序（Radix Sort）：又叫桶排序和箱排序，借助多关键字排序的思想对单逻辑关键字进行排序的方法</p><p>计数排序其实是桶排序的一种特殊情况，当要排序的 n 个数据，所处的范围并不大的时候，比如最大值是 k，我们就可以把数据划分成 k 个桶，每个桶内的数据值都是相同的，省掉了桶内排序的时间</p><p>按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前</p><p>解释：先排低位再排高位，可以说明在高位相等的情况下低位是递增的，如果高位也是递增，则数据有序</p><img src="https://gitee.com/seazean/images/raw/master/Java/Sort-基数排序.gif" style="zoom:67%;"><p>实现思路：</p><ul><li>获得最大数的位数，可以通过将最大数变为String类型，再求长度</li><li>将所有待比较数值（正整数）统一为同样的数位长度，<strong>位数较短的数前面补零</strong></li><li>从最低位开始，依次进行一次排序</li><li>从最低位排序一直到最高位（个位 → 十位 → 百位 → … →最高位）排序完成以后，数列就变成一个有序序列</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BucketSort</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">576</span>, <span class="number">22</span>, <span class="number">26</span>, <span class="number">548</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">843</span>, <span class="number">536</span>, <span class="number">735</span>, <span class="number">43</span>, <span class="number">3</span>, <span class="number">912</span>, <span class="number">88</span>&#125;;        bucketSort(arr);        System.out.println(Arrays.toString(arr));    &#125;    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bucketSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;        <span class="comment">// 桶的个数固定为10个（个位是0~9），数组长度为了防止所有的数在同一行        int[][] bucket = new int[10][arr.length];        //记录每个桶中的有多少个元素        int[] elementCounts = new int[10];        //获取数组的最大元素        int max = arr[0];        for (int i = 1; i &lt; arr.length; i++) &#123;            max = max &gt; arr[i] ? max : arr[i];        &#125;        String maxEle = Integer.toString(max);        //将数组中的元素放入桶中，最大数的位数相当于需要几次放入桶中        for (int i = 0, step = 1; i &lt; maxEle.length(); i++, step *= 10) &#123;            for (int j = 0; j &lt; arr.length; j++) &#123;                //获取最后一位的数据，也就是索引                int index = (arr[j] / step) % 10;                //放入具体位置                bucket[index][elementCounts[index]] = arr[j];                //存储每个桶的数量                elementCounts[index]++;            &#125;            //收集回数组            for (int j = 0, index = 0; j &lt; 10; j++) &#123;                //先进先出                int position = 0;                //桶中有元素就取出                while (elementCounts[j] &gt; 0) &#123;                    arr[index] = bucket[j][position];                    elementCounts[j]--;                    position++;                    index++;                &#125;            &#125;        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>空间换时间</p><p>推荐视频：<a href="https://www.bilibili.com/video/BV1b7411N798?p=86">https://www.bilibili.com/video/BV1b7411N798?p=86</a></p><p>参考文章：<a href="https://www.toutiao.com/a6593273307280179715/?iid=6593273307280179715">https://www.toutiao.com/a6593273307280179715/?iid=6593273307280179715</a></p><hr><h3 id="算法总结"><a href="#算法总结" class="headerlink" title="算法总结"></a>算法总结</h3><h4 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h4><p>稳定性：在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中 <code>r[i]=r[j]</code>，且 r[i] 在 r[j] 之前，而在排序后的序列中，r[i] 仍在 r[j] 之前，则称这种排序算法是稳定的，否则称为不稳定的</p><p>如果一组数据只需要一次排序，则稳定性一般是没有意义的，如果一组数据需要多次排序，稳定性是有意义的。</p><img src="https://gitee.com/seazean/images/raw/master/Java/Sort-稳定性.png" style="zoom:50%;"><ul><li>冒泡排序：只有当 <code>arr[i]&gt;arr[i+1]</code> 的时候，才会交换元素的位置，而相等的时候并不交换位置，所以冒泡排序是一种稳定排序算法</li><li>选择排序：是给每个位置选择当前元素最小的，例如有数据{5(1)，8 ，5(2)， 3， 9 }，第一遍选择到的最小元素为3，所以5(1)会和3进行交换位置，此时5(1)到了5(2)后面，破坏了稳定性，所以是不稳定的排序算法</li><li>插入排序：比较是从有序序列的末尾开始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置。如果碰见一个和插入元素相等的，那么把要插入的元素放在相等元素的后面。相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳定的</li><li>希尔排序：按照不同步长对元素进行插入排序，虽然一次插入排序是稳定的，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以希尔排序是不稳定的</li><li>归并排序在归并的过程中，只有 <code>arr[i]&lt;arr[i+1]</code> 的时候才会交换位置，如果两个元素相等则不会交换位置，所以它并不会破坏稳定性，归并排序是稳定的</li><li>快速排序：快排需要一个基准值，在基准值的右侧找一个比基准值小的元素，在基准值的左侧找一个比基准值大的元素，然后交换这两个元素，此时会破坏稳定性，所以快速排序是一种不稳定的算法</li></ul><p>记忆口诀：</p><ul><li><p>情绪不稳定，快些选一堆好友来聊天</p></li><li><p>快：快速排序、些：希尔排序、选：选择排序、堆：堆排序</p></li></ul><hr><h4 id="算法对比"><a href="#算法对比" class="headerlink" title="算法对比"></a>算法对比</h4><p><img src="https://gitee.com/seazean/images/raw/master/Java/Sort-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94.png"></p><hr><h4 id="补充问题"><a href="#补充问题" class="headerlink" title="补充问题"></a>补充问题</h4><p>海量数据问题：</p><ul><li>海量数据排序：<ul><li>外部排序：归并 + 败者树</li><li>基数排序：<a href="https://time.geekbang.org/column/article/42038">https://time.geekbang.org/column/article/42038</a></li></ul></li><li>海量数据查询：<ul><li>布隆过滤器判断是否存在</li><li>构建索引：B+ 树、跳表</li></ul></li></ul><hr><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>正常查找：从第一个元素开始遍历，一个一个的往后找，综合查找比较耗时</p><p>二分查找也称折半查找（Binary Search）是一种效率较高的查找方法，数组必须是有序数组</p><p>过程：每次先与中间的元素进行比较，如果大于往右边找，如果小于往左边找，如果等于就返回该元素索引位置，如果没有该元素，返回 -1</p><p>时间复杂度：O(logn)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*定义一个方法，记录开始的索引位置和结束的索引位置。取出中间索引位置的值，拿元素与中间位置的值进行比较，如果小于中间值，结束位置=中间索引-1.取出中间索引位置的值，拿元素与中间位置的值进行比较，如果大于中间值，开始位置=中间索引+1.循环正常执行的条件：开始位置索引&lt;=结束位置索引。否则说明寻找完毕但是没有该元素值返回-1.*/</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">binarySearch</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        <span class="keyword">int</span>[] arr = &#123;<span class="number">10</span>, <span class="number">14</span>, <span class="number">21</span>, <span class="number">38</span>, <span class="number">45</span>, <span class="number">47</span>, <span class="number">53</span>, <span class="number">81</span>, <span class="number">87</span>, <span class="number">99</span>&#125;;        System.out.println(<span class="string">&quot;81的索引是：&quot;</span> + binarySearch(arr,<span class="number">81</span>));    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> des)</span> </span>&#123;        <span class="keyword">int</span> start = <span class="number">0</span>;        <span class="keyword">int</span> end = arr.length - <span class="number">1</span>;        <span class="comment">// 确保不会出现重复查找，越界        while (start &lt;= end) &#123;            // 计算出中间索引值            int mid = (start + end) / 2;            if (des == arr[mid]) &#123;                return mid;            &#125; else if (des &gt; arr[mid]) &#123;                start = mid + 1;            &#125; else if (des &lt; arr[mid]) &#123;                end = mid - 1;            &#125;        &#125;        // 如果上述循环执行完毕还没有返回索引，说明根本不存在该元素值，直接返回-1        return -1;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/seazean/images/raw/master/Java/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.gif"></p><p>查找第一个匹配的元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> des)</span> </span>&#123;        <span class="keyword">int</span> start = <span class="number">0</span>;        <span class="keyword">int</span> end = arr.length - <span class="number">1</span>;        <span class="keyword">while</span> (start &lt;= end) &#123;            <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;            <span class="keyword">if</span> (des == arr[mid]) &#123;                <span class="comment">//如果 mid 等于 0，那这个元素已经是数组的第一个元素，那肯定是我要找的                if (mid == 0 || a[mid - 1] != des) &#123;                    return mid;                &#125; else &#123;                    //a[mid]前面的一个元素 a[mid-1]也等于 value，                    //要找的元素肯定出现在[low, mid-1]之间                    high = mid - 1                &#125;            &#125; else if (des &gt; arr[mid]) &#123;                start = mid + 1;            &#125; else if (des &lt; arr[mid]) &#123;                end = mid - 1;            &#125;        &#125;        return -1;    &#125;</span></span><br></pre></td></tr></table></figure><hr><h2 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h2><h3 id="BF"><a href="#BF" class="headerlink" title="BF"></a>BF</h3><p>Brute Force 暴力匹配算法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    String s = <span class="string">&quot;seazean&quot;</span>;    String t = <span class="string">&quot;az&quot;</span>;    System.out.println(match(s,t));<span class="comment">//2&#125;public static int match(String s,String t) &#123;    int k = 0;    int i = k, j = 0;    //防止越界    while (i &lt; s.length() &amp;&amp; j &lt; t.length()) &#123;        if (s.charAt(i) == t.charAt(j)) &#123;            ++i;            ++j;        &#125; else &#123;            k++;            i = k;            j = 0;        &#125;    &#125;    //说明是匹配成功    if (j &gt;= t.length()) &#123;        return k;    &#125;    return 0;&#125;</span></span><br></pre></td></tr></table></figure><p>平均时间复杂度：O(m+n)，最坏时间复杂度：O(m*n)</p><hr><h3 id="RK"><a href="#RK" class="headerlink" title="RK"></a>RK</h3><p>把主串得长度记为 n，模式串得长度记为 m，通过哈希算法对主串中的 n-m+1 个子串分别求哈希值，然后逐个与模式串的哈希值比较大小，如果某个子串的哈希值与模式串相等，再去对比值是否相等（防止哈希冲突），那就说明对应的子串和模式串匹配了</p><p>因为哈希值是一个数字，数字之间比较是否相等是非常快速的</p><p>第一部分计算哈希值的时间复杂度为 O(n)，第二部分对比的时间复杂度为 O(1)，整体平均时间复杂度为 O(n)，最坏为 O(n*m)</p><hr><h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><p>KMP 匹配：</p><ul><li>next 数组的核心就是自己匹配自己，主串代表后缀，模式串代表前缀</li><li>nextVal 数组的核心就是回退失配</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Kmp</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        String s = <span class="string">&quot;acababaabc&quot;</span>;        String t = <span class="string">&quot;abaabc&quot;</span>;        <span class="comment">//[-1, 0, 0, 1, 1, 2]        System.out.println(Arrays.toString(getNext(t)));        //[-1, 0, -1, 1, 0, 2]        System.out.println(Arrays.toString(getNextVal(t)));        //5        System.out.println(kmp(s, t));    &#125;    private static int kmp(String s, String t) &#123;        int[] next = getNext(t);        int i = 0, j = 0;        while (i &lt; s.length() &amp;&amp; j &lt; t.length()) &#123;            //j==-1时说明第一个位置匹配失败，所以将s的下一个和t的首字符比较            if (j == -1 || s.charAt(i) == t.charAt(j)) &#123;                i++;                j++;            &#125; else &#123;                //模式串右移，比较s的当前位置与t的next[j]位置                j = next[j];            &#125;        &#125;        if (j &gt;= t.length()) &#123;            return i - j + 1;        &#125;        return -1;    &#125;//next数组    private static int[] getNext(String t) &#123;        int[] next = new int[t.length()];        next[0] = -1;        int j = -1;        int i = 0;        while (i &lt; t.length() - 1) &#123;            // 根据已知的前j位推测第j+1位            // j=-1说明首位就没有匹配，即t[0]!=t[i]，说明next[i+1]没有最大前缀，为0            if (j == -1 || t.charAt(i) == t.charAt(j)) &#123;                // 因为模式串已经匹配到了索引j处，说明之前的位都是相等的                // 因为是自己匹配自己，所以模式串就是前缀，主串就是后缀，j就是最长公共前缀                // 当i+1位置不匹配时（i位之前匹配），可以跳转到j+1位置对比，next[i+1]=j+1                i++;                j++;                next[i] = j;            &#125; else &#123;                //i位置的数据和j位置的不相等，所以回退对比i和next[j]位置的数据                j = next[j];            &#125;        &#125;        return next;    &#125;//nextVal    private static int[] getNextVal(String t) &#123;        int[] nextVal = new int[t.length()];        nextVal[0] = -1;        int j = -1;        int i = 0;        while (i &lt; t.length() - 1) &#123;            if (j == -1 || t.charAt(i) == t.charAt(j)) &#123;                i++;                j++;                // 如果t[i+1] == t[next(i+1)]=next[j+1]，回退后仍然失配，所以要继续回退                if (t.charAt(i) == t.charAt(j)) &#123;                    nextVal[i] = nextVal[j];                &#125; else &#123;                    nextVal[i] = j;                &#125;            &#125; else &#123;                j = nextVal[j];            &#125;        &#125;        return nextVal;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>平均和最坏时间复杂度都是 O(m+n)</p><p>参考文章：<a href="https://www.cnblogs.com/tangzhengyue/p/4315393.html">https://www.cnblogs.com/tangzhengyue/p/4315393.html</a></p><hr><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>二叉树中，任意一个节点的度要小于等于 2</p><ul><li>节点：在树结构中,每一个元素称之为节点</li><li>度：每一个节点的子节点数量称之为度</li></ul><img src="https://gitee.com/seazean/images/raw/master/Java/二叉树结构图.png" alt="二叉树结构图" style="zoom:80%;"><hr><h3 id="排序树"><a href="#排序树" class="headerlink" title="排序树"></a>排序树</h3><h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><p>二叉排序树（BST），又称二叉查找树或者二叉搜索树</p><ul><li>每一个节点上最多有两个子节点</li><li>左子树上所有节点的值都小于根节点的值</li><li>右子树上所有节点的值都大于根节点的值</li><li>不存在重复的节点</li></ul><img src="https://gitee.com/seazean/images/raw/master/Java/二叉查找树结构图.png" alt="二叉查找树" style="zoom: 80%;"><hr><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><ul><li><p>节点类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;    <span class="keyword">int</span> key;    TreeNode left;  <span class="comment">//左节点    TreeNode right; //右节点    private TreeNode(int key) &#123;        this.key = key;    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>查找节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归查找private static TreeNode search(TreeNode root, int key) &#123;    //递归结束的条件    if (root == null) &#123;        return null;    &#125;    if (key == root.key) &#123;        return root;    &#125; else if (key &gt; root.key) &#123;        return search(root.right, key);    &#125; else &#123;        return search(root.left, key);    &#125;&#125;// 非递归private static TreeNode search1(TreeNode root, int key) &#123;    while (root != null) &#123;        if (key == root.key) &#123;            return root;        &#125; else if (key &gt; root.key) &#123;            root = root.right;        &#125; else &#123;            root = root.left;        &#125;    &#125;    return null;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>插入节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">insert</span><span class="params">(TreeNode root, <span class="keyword">int</span> key)</span> </span>&#123;    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;        root = <span class="keyword">new</span> TreeNode(key);        root.left = <span class="keyword">null</span>;        root.right = <span class="keyword">null</span>;        <span class="keyword">return</span> <span class="number">1</span>;    &#125; <span class="keyword">else</span> &#123;        <span class="keyword">if</span> (key == root.key) &#123;            <span class="keyword">return</span> <span class="number">0</span>;        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; root.key) &#123;            <span class="keyword">return</span> insert(root.right, key);        &#125; <span class="keyword">else</span> &#123;            <span class="keyword">return</span> insert(root.left, key);        &#125;    &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数，返回根节点private static TreeNode createBST(int[] arr) &#123;    if (arr.length &gt; 0) &#123;        TreeNode root = new TreeNode(arr[0]);        for (int i = 1; i &lt; arr.length; i++) &#123;            insert(root, arr[i]);        &#125;        return root;    &#125;    return null;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>删除节点：要删除节点12，先找到节点19，然后移动并替换节点12<img src="https://gitee.com/seazean/images/raw/master/Java/Tree-二叉查找树删除节点.png" style="zoom: 50%;"></p><p>代码链接：<a href="https://leetcode-cn.com/submissions/detail/190232548/">https://leetcode-cn.com/submissions/detail/190232548/</a></p></li></ul><p>参考视频：<a href="https://www.bilibili.com/video/BV1iJ411E7xW?t=756&amp;p=86">https://www.bilibili.com/video/BV1iJ411E7xW?t=756&amp;p=86</a></p><p>图片来源：<a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/solution/tu-jie-yi-dong-jie-dian-er-bu-shi-xiu-ga-edtn/">https://leetcode-cn.com/problems/delete-node-in-a-bst/solution/tu-jie-yi-dong-jie-dian-er-bu-shi-xiu-ga-edtn/</a></p><hr><h3 id="平衡树"><a href="#平衡树" class="headerlink" title="平衡树"></a>平衡树</h3><p>平衡二叉树（AVL）的特点：</p><ul><li>二叉树左右两个子树的高度差不超过 1</li><li>任意节点的左右两个子树都是一颗平衡二叉树</li></ul><p>平衡二叉树旋转：</p><ul><li><p>旋转触发时机：当添加一个节点之后，该树不再是一颗平衡二叉树</p></li><li><p>平衡二叉树和二叉查找树对比结构图</p></li></ul><p><img src="https://gitee.com/seazean/images/raw/master/Java/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E5%AF%B9%E6%AF%94%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="平衡二叉树和二叉查找树对比"></p><ul><li><p>左旋：将根节点的右侧往左拉，原先的右子节点变成新的父节点，并把多余的左子节点出让，给已经降级的根节点当右子节点</p><p><img src="https://gitee.com/seazean/images/raw/master/Java/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B7%A6%E6%97%8B01.png" alt="平衡二叉树左旋"></p></li></ul><ul><li><p>右旋：将根节点的左侧往右拉，左子节点变成了新的父节点，并把多余的右子节点出让，给已经降级根节点当左子节点</p><p><img src="https://gitee.com/seazean/images/raw/master/Java/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%B3%E6%97%8B01.png" alt="平衡二叉树右旋"></p></li></ul><p>推荐文章：<a href="https://pdai.tech/md/algorithm/alg-basic-tree-balance.html">https://pdai.tech/md/algorithm/alg-basic-tree-balance.html</a></p><hr><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>红黑树的特点：</p><ul><li>每一个节点可以是红或者黑</li></ul><ul><li>红黑树不是高度平衡的，它的平衡是通过自己的红黑规则进行实现的</li></ul><p>红黑树的红黑规则有哪些：</p><ol><li>每一个节点或是红色的，或者是黑色的</li><li>根节点必须是黑色</li><li>如果一个节点没有子节点或者父节点，则该节点相应的指针属性值为 Nil，这些 Nil 视为叶节点，每个叶节点 (Nil) 是黑色的</li><li>如果某一个节点是红色，那么它的子节点必须是黑色（不能出现两个红色节点相连的情况）</li><li>对每一个节点，从该节点到其所有后代叶节点的简单路径上，均包含相同数目的黑色节点</li></ol><p>红黑树与 AVL 树的比较：</p><ul><li>AVL 树是更加严格的平衡，可以提供更快的查找速度，适用于读取<strong>查找密集型任务</strong></li><li>红黑树只是做到近似平衡，并不是严格的平衡，红黑树的插入删除比 AVL 树更便于控制，红黑树更适合于<strong>插入修改密集型任务</strong></li></ul><ul><li>红黑树整体性能略优于 AVL 树，AVL 树的旋转比红黑树的旋转多，更加难以平衡和调试，插入和删除的效率比红黑树慢</li></ul><p><img src="https://gitee.com/seazean/images/raw/master/Java/%E7%BA%A2%E9%BB%91%E6%A0%91%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="红黑树"></p><p>红黑树添加节点的默认颜色为红色，效率高<br><img src="https://gitee.com/seazean/images/raw/master/Java/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%B7%BB%E5%8A%A0%E8%8A%82%E7%82%B9%E9%A2%9C%E8%89%B2.png"></p><p><strong>红黑树添加节点后如何保持红黑规则：</strong></p><ul><li>根节点位置<ul><li>直接变为黑色</li></ul></li><li>非根节点位置<ul><li>父节点为黑色<ul><li>不需要任何操作,默认红色即可</li></ul></li><li>父节点为红色<ul><li>叔叔节点为红色<ol><li>将”父节点”设为黑色,将”叔叔节点”设为黑色</li><li>将”祖父节点”设为红色</li><li>如果”祖父节点”为根节点,则将根节点再次变成黑色</li></ol></li><li>叔叔节点为黑色<ol><li>将”父节点”设为黑色</li><li>将”祖父节点”设为红色</li><li>以”祖父节点”为支点进行旋转</li></ol></li></ul></li></ul></li></ul><hr><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><h4 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h4><p>并查集是一种树型的数据结构，有以下特点：</p><ul><li>每个元素都唯一的对应一个结点</li><li>每一组数据中的多个元素都在同一颗树中</li><li>一个组中的数据对应的树和另外一个组中的数据对应的树之间没有任何联系</li><li>元素在树中并没有子父级关系的硬性要求</li></ul><img src="https://gitee.com/seazean/images/raw/master/Java/Tree-并查集.png" style="zoom:50%;"><p>可以高效地进行如下操作：</p><ul><li>查询元素 p 和元素 q 是否属于同一组</li><li>合并元素 p 和元素 q 所在的组</li></ul><p>存储结构：</p><img src="https://gitee.com/seazean/images/raw/master/Java/Tree-并查集存储结构.png" style="zoom:67%;"><p>合并方式：</p><img src="https://gitee.com/seazean/images/raw/master/Java/Tree-并查集合并.png" style="zoom:67%;"><p>代码实现：</p><ul><li><p>类实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UF</span> </span>&#123;    <span class="comment">//记录节点元素和该元素所在分组的标识    private int[] eleAndGroup;    //记录分组的个数    private int count;    //初始化并查集    public UF(int N) &#123;        //初始化分组数量        this.count = N;        //初始化eleAndGroup数量        this.eleAndGroup = new int[N];        //初始化eleAndGroup中的元素及其所在分组的标识符，eleAndGroup索引作为每个节点的元素        //每个索引处的值就是该组的索引，就是该元素所在的组的标识符        for (int i = 0; i &lt; eleAndGroup.length; i++) &#123;            eleAndGroup[i] = i;        &#125;    &#125;    //查询p所在的分组的标识符    public int find(int p) &#123;        return eleAndGroup[p];    &#125;    //判断并查集中元素p和元素q是否在同一分组中    public boolean connect(int p, int q) &#123;        return find(p) == find(q);    &#125;    //把p元素所在分组和q元素所在分组合并    public void union(int p, int q) &#123;        //判断元素q和p是否已经在同一个分组中，如果已经在同一个分组中，则结束方法就可以了        if (connect(p, q)) &#123;            return;        &#125;        int pGroup = find(p);//找到p所在分组的标识符        int qGroup = find(q);//找到q所在分组的标识符        //合并组，让p所在组的 所有元素 的组标识符变为q所在分组的标识符        for (int i = 0; i &lt; eleAndGroup.length; i++) &#123;            if (eleAndGroup[i] == pGroup) &#123;                eleAndGroup[i] = qGroup;            &#125;        &#125;        //分组个数-1        this.count--;    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    <span class="comment">//创建并查集对象    UF uf = new UF(5);    System.out.println(uf);    //从控制台录入两个合并的元素，调用union方法合并，观察合并后并查集的分组    Scanner sc = new Scanner(System.in);    while (true) &#123;        System.out.println(&quot;输入第一个要合并的元素&quot;);        int p = sc.nextInt();        System.out.println(&quot;输入第二个要合并的元素&quot;);        int q = sc.nextInt();        if (uf.connect(p, q)) &#123;            System.out.println(p + &quot;元素已经和&quot; + q + &quot;元素已经在同一个组&quot;);            continue;        &#125;        uf.union(p, q);        System.out.println(&quot;当前并查集中还有：&quot; + uf.count() + &quot;个分组&quot;);        System.out.println(uf);        System.out.println(&quot;********************&quot;);    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><p>最坏情况下 union 算法的时间复杂度也是 O(N^2)</p><hr><h4 id="优化实现"><a href="#优化实现" class="headerlink" title="优化实现"></a>优化实现</h4><p>让每个索引处的节点都指向它的父节点，当 eleGroup[i] = i 时，说明 i 是根节点</p><img src="https://gitee.com/seazean/images/raw/master/Java/Tree-并查集优化.png" style="zoom: 67%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询p所在的分组的标识符，递归寻找父标识符，直到找到根节点public int findRoot(int p) &#123;    while (p != eleAndGroup[p]) &#123;        p = eleAndGroup[p];    &#125;    //p == eleGroup[p]，说明p是根节点    return p;&#125;//判断并查集中元素p和元素q是否在同一分组中public boolean connect(int p, int q) &#123;    return findRoot(p) == findRoot(q);&#125;//把p元素所在分组和q元素所在分组合并public void union(int p, int q) &#123;    //找到p q对应的根节点    int pRoot = findRoot(p);    int qRoot = findRoot(q);    if (pRoot == qRoot) &#123;        return;    &#125;    //让p所在树的节点根节点为q的所在的根节点，只需要把根节点改一下，时间复杂度 O(1)    eleAndGroup[pRoot] = qRoot;    this.count-&#125;</span></span><br></pre></td></tr></table></figure><p>平均时间复杂度为 O(N)，最坏时间复杂度是 O(N^2)</p><img src="https://gitee.com/seazean/images/raw/master/Java/Tree-并查集时间复杂度.png" style="zoom:67%;"><p>继续优化：路径压缩，保证每次把小树合并到大树</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UF_Tree_Weighted</span> </span>&#123;    <span class="keyword">private</span> <span class="keyword">int</span>[] eleAndGroup;    <span class="keyword">private</span> <span class="keyword">int</span> count;    <span class="keyword">private</span> <span class="keyword">int</span>[] size;<span class="comment">//存储每一个根结点对应的树中的保存的节点的个数    //初始化并查集    public UF_Tree_Weighted(int N) &#123;        this.count = N;        this.eleAndGroup = new int[N];        for (int i = 0; i &lt; eleAndGroup.length; i++) &#123;            eleAndGroup[i] = i;        &#125;        this.size = new int[N];        //默认情况下，size中每个索引处的值都是1        for (int i = 0; i &lt; size.length; i++) &#123;            size[i] = 1;        &#125;    &#125;//查询p所在的分组的标识符，父标识符    public int findRoot(int p) &#123;        while (p != eleAndGroup[p]) &#123;            p = eleAndGroup[p];        &#125;        return p;    &#125;    //判断并查集中元素p和元素q是否在同一分组中    public boolean connect(int p, int q) &#123;        return findRoot(p) == findRoot(q);    &#125;    //把p元素所在分组和q元素所在分组合并    public void union(int p, int q) &#123;        //找到p q对应的根节点        int pRoot = findRoot(p);        int qRoot = findRoot(q);        if (pRoot == qRoot) &#123;            return;        &#125;        //判断pRoot对应的树大还是qRoot对应的树大，最终需要把较小的树合并到较大的树中        if (size[pRoot] &lt; size[qRoot]) &#123;            eleAndGroup[pRoot] = qRoot;            size[qRoot] += size[pRoot];        &#125; else &#123;            eleAndGroup[qRoot] = pRoot;            size[pRoot] += size[qRoot];        &#125;        //组的数量-1、        this.count--;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>并查集存储的每一个整数表示的是一个大型计算机网络中的计算机：</p><ul><li>可以通过 connected(int p, int q) 来检测该网络中的某两台计算机之间是否连通</li><li>可以调用 union(int p,int q) 使得 p 和 q 之间连通，这样两台计算机之间就可以通信</li></ul><p>畅通工程：某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。省政府畅通工程的目标是使全省任何两个城镇间都可以实现交通，但不一定有直接的道路相连，只要互相间接通过道路可达即可，问最少还需要建设多少条道路？</p><img src="https://gitee.com/seazean/images/raw/master/Java/Tree-应用场景.png" style="zoom:67%;"><p>解题思路：</p><ol><li>创建一个并查集 UF_Tree_Weighted(20)</li><li>分别调用 union(0,1)、union(6,9)、union(3,8)、union(5,11)、union(2,12)、union(6,10)、union(4,8)，表示已经修建好的道路把对应的城市连接起来</li><li>如果城市全部连接起来，那么并查集中剩余的分组数目为 1，所有的城市都在一个树中，只需要获取当前并查集中剩余的数目减去 1，就是还需要修建的道路数目</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception </span>&#123;    Scanner sc = <span class="keyword">new</span> Scanner(System.in);    <span class="comment">//读取城市数目，初始化并查集    int number = sc.nextInt();    //读取已经修建好的道路数目    int roadNumber = sc.nextInt();    UF_Tree_Weighted uf = new UF_Tree_Weighted(number);    //循环读取已经修建好的道路，并调用union方法    for (int i = 0; i &lt; roadNumber; i++) &#123;        int p = sc.nextInt();        int q = sc.nextInt();        uf.union(p,q);    &#125;    //获取剩余的分组数量    int groupNumber = uf.count();    //计算出还需要修建的道路    System.out.println(&quot;还需要修建&quot;+(groupNumber-1)+&quot;道路，城市才能相通&quot;);&#125;</span></span><br></pre></td></tr></table></figure><p>参考视频：<a href="https://www.bilibili.com/video/BV1iJ411E7xW?p=142">https://www.bilibili.com/video/BV1iJ411E7xW?p=142</a></p><hr><h3 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>Trie 树，也叫字典树，是一种专门处理字符串匹配的树形结构，用来解决在一组字符串集合中快速查找某个字符串的问题，Trie 树的本质就是利用字符串之间的公共前缀，将重复的前缀合并在一起</p><ul><li>根节点不包含任何信息</li><li>每个节点表示一个字符串中的字符，从<strong>根节点到红色节点的一条路径表示一个字符串</strong></li><li>红色节点并不都是叶子节点</li></ul><img src="https://gitee.com/seazean/images/raw/master/Java/Tree-字典树构造过程1.png" style="zoom: 50%;"><img src="https://gitee.com/seazean/images/raw/master/Java/Tree-字典树构造过程2.png" style="zoom:50%;"><p>注意：要查找的是字符串“he”，从根节点开始，沿着某条路径来匹配，可以匹配成功。但是路径的最后一个节点“e”并不是红色的，也就是说，“he”是某个字符串的前缀子串，但并不能完全匹配任何字符串</p><hr><h4 id="实现Trie"><a href="#实现Trie" class="headerlink" title="实现Trie"></a>实现Trie</h4><p>通过一个下标与字符一一映射的数组，来存储子节点的指针</p><img src="https://gitee.com/seazean/images/raw/master/Java/Tree-字典树存储结构.png" style="zoom:50%;"><p>时间复杂度是 O(n)（n 表示要查找字符串的长度）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;    <span class="keyword">private</span> TrieNode root = <span class="keyword">new</span> TrieNode(<span class="string">&#x27;/&#x27;</span>);    <span class="comment">//插入一个字符    public void insert(char[] chars) &#123;        TrieNode p = root;        for (int i = 0; i &lt; chars.length; i++) &#123;            //获取字符的索引位置            int index = chars[i] - &#x27;a&#x27;;            if (p.children[index] == null) &#123;                TrieNode node = new TrieNode(chars[i]);                p.children[index] = node;            &#125;            p = p.children[index];        &#125;        p.isEndChar = true;    &#125;    //查找一个字符串    public boolean find(char[] chars) &#123;        TrieNode p = root;        for (int i = 0; i &lt; chars.length; i++) &#123;            int index = chars[i] - &#x27;a&#x27;;            if (p.children[index] == null) &#123;                return false;            &#125;            p = p.children[index];        &#125;        if (p.isEndChar) &#123;            //完全匹配            return true;        &#125; else &#123;            // 不能完全匹配，只是前缀            return false;        &#125;    &#125;    private class TrieNode &#123;        char data;        TrieNode[] children = new TrieNode[26];//26个英文字母        boolean isEndChar = false;//结尾字符为true        public TrieNode(char data) &#123;            this.data = data;        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="优化Trie"><a href="#优化Trie" class="headerlink" title="优化Trie"></a>优化Trie</h4><p>Trie 树是非常耗内存，采取空间换时间的思路。Trie 树的变体有很多，可以在一定程度上解决内存消耗的问题。比如缩点优化，对只有一个子节点的节点，而且此节点不是一个串的结束节点，可以将此节点与子节点合并</p><p><img src="https://gitee.com/seazean/images/raw/master/Java/Tree-%E5%AD%97%E5%85%B8%E6%A0%91%E7%BC%A9%E7%82%B9%E4%BC%98%E5%8C%96.png"></p><p>参考文章：<a href="https://time.geekbang.org/column/article/72414">https://time.geekbang.org/column/article/72414</a></p><hr><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p>图的邻接表形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AGraph</span> </span>&#123;    <span class="keyword">private</span> VertexNode[] adjList;   <span class="comment">//邻接数组    private int vLen, eLen;         //顶点数和边数    public AGraph(int vLen, int eLen) &#123;        this.vLen = vLen;        this.eLen = eLen;        adjList = new VertexNode[vLen];    &#125;    //弧节点    private class ArcNode &#123;        int adjVex;         //该边所指向的顶点的位置        ArcNode nextArc;    //下一条边（弧）        //int info  //添加权值        public ArcNode(int adjVex) &#123;            this.adjVex = adjVex;            nextArc = null;        &#125;    &#125;    //表顶点    private class VertexNode &#123;        char data;      //顶点信息        ArcNode firstArc;  //指向第一条边的指针        public VertexNode(char data) &#123;            this.data = data;            firstArc = null;        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>图的邻接矩阵形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MGraph</span> </span>&#123;    <span class="keyword">private</span> <span class="keyword">int</span>[][] edges;      <span class="comment">//邻接矩阵定义，有权图将int改为float    private int vLen;           //顶点数    private int eLen;           //边数    private VertexNode[] vex;   //存放节点信息    public MGraph(int vLen, int eLen) &#123;        this.vLen = vLen;        this.eLen = eLen;        this.edges = new int[vLen][vLen];        this.vex = new VertexNode[vLen];    &#125;    private class VertexNode &#123;        int num;    //顶点编号        String info;  //顶点信息        public VertexNode(int num) &#123;            this.num = num;            this.info = null;        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>图相关的算法需要很多的流程图，此处不再一一列举，推荐参考书籍《数据结构高分笔记》</p><hr><h2 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h2><h3 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>布隆过滤器：一种数据结构，是一个很长的二进制向量（位数组）和一系列随机映射函数（哈希函数），既然是二进制，每个空间存放的不是 0 就是 1，但是初始默认值都是 0，所以布隆过滤器不存数据只存状态</p><img src="https://gitee.com/seazean/images/raw/master/DB/Redis-Bitmaps数据结构.png" style="zoom: 80%;"><p>这种数据结构是高效且性能很好的，但缺点是具有一定的错误识别率和删除难度。并且理论情况下，添加到集合中的元素越多，误报的可能性就越大</p><hr><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>向布隆过滤器中添加一个元素 key 时，会通过多个 hash 函数得到多个哈希值，在位数组中把对应下标的值置为 1</p><p><img src="https://gitee.com/seazean/images/raw/master/DB/Redis-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E6%B7%BB%E5%8A%A0%E6%95%B0%E6%8D%AE.png"></p><p>布隆过滤器查询一个数据，是否在二进制的集合中，查询过程如下：</p><ul><li>通过 K 个哈希函数计算该数据，对应计算出的 K 个hash值</li><li>通过 hash 值找到对应的二进制的数组下标</li><li>判断方法：如果存在一处位置的二进制数据是 0，那么该数据一定不存在。如果都是 1，则认为数据存在集合中（会误判）</li></ul><p>布隆过滤器优缺点：</p><ul><li><p>优点：</p><ul><li>二进制组成的数组，占用内存极少，并且插入和查询速度都足够快</li><li>去重方便：当字符串第一次存储时对应的位数组下标设置为 1，当第二次存储相同字符串时，因为对应位置已设置为 1，所以很容易知道此值已经存在</li></ul></li><li><p>缺点：</p><ul><li>随着数据的增加，误判率会增加：添加数据是通过计算数据的 hash 值，不同的字符串可能哈希出来的位置相同，导致无法确定到底是哪个数据存在，<strong>这种情况可以适当增加位数组大小或者调整哈希函数</strong></li><li>无法删除数据：可能存在几个数据占据相同的位置，所以删除一位会导致很多数据失效</li></ul></li><li><p>总结：<strong>布隆过滤器判断某个元素存在，小概率会误判。如果判断某个元素不在，那这个元素一定不在</strong></p></li></ul><p>参考文章：<a href="https://www.cnblogs.com/ysocean/p/12594982.html">https://www.cnblogs.com/ysocean/p/12594982.html</a></p><hr><h3 id="Guava"><a href="#Guava" class="headerlink" title="Guava"></a>Guava</h3><p>引入 Guava 的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>28.0-jre<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>指定误判率为（0.01）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    <span class="comment">// 创建布隆过滤器对象    BloomFilter&lt;Integer&gt; filter = BloomFilter.create(        Funnels.integerFunnel(),        1500,        0.01);    // 判断指定元素是否存在    System.out.println(filter.mightContain(1));    System.out.println(filter.mightContain(2));    // 将元素添加进布隆过滤器    filter.put(1);    filter.put(2);    System.out.println(filter.mightContain(1));    System.out.println(filter.mightContain(2));&#125;</span></span><br></pre></td></tr></table></figure><hr><h3 id="实现布隆"><a href="#实现布隆" class="headerlink" title="实现布隆"></a>实现布隆</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyBloomFilter</span> </span>&#123;    <span class="comment">//布隆过滤器容量    private static final int DEFAULT_SIZE = 2 &lt;&lt; 28;    //bit数组，用来存放key    private static BitSet bitSet = new BitSet(DEFAULT_SIZE);    //后面hash函数会用到，用来生成不同的hash值，随意设置    private static final int[] ints = &#123;1, 6, 16, 38, 58, 68&#125;;    //add方法，计算出key的hash值，并将对应下标置为true    public void add(Object key) &#123;        Arrays.stream(ints).forEach(i -&gt; bitSet.set(hash(key, i)));    &#125;    //判断key是否存在，true不一定说明key存在，但是false一定说明不存在    public boolean isContain(Object key) &#123;        boolean result = true;        for (int i : ints) &#123;            //短路与，只要有一个bit位为false，则返回false            result = result &amp;&amp; bitSet.get(hash(key, i));        &#125;        return result;    &#125;    //hash函数，借鉴了hashmap的扰动算法    private int hash(Object key, int i) &#123;        int h;        return key == null ? 0 : (i * (DEFAULT_SIZE - 1) &amp; ((h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)));    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础笔记1-SE</title>
      <link href="./2021/09/16/java/java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B01-SE/"/>
      <url>./2021/09/16/java/java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B01-SE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="assets\css\APlayer.min.css"><script src="assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="SE"><a href="#SE" class="headerlink" title="SE"></a>SE</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><h4 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h4><table><thead><tr><th align="center"></th><th align="center">成员变量</th><th align="center">局部变量</th><th align="center">静态变量</th></tr></thead><tbody><tr><td align="center">定义位置</td><td align="center">在类中，方法外</td><td align="center">方法中或者方法的形参</td><td align="center">在类中，方法外</td></tr><tr><td align="center">初始化值</td><td align="center">有默认初始化值</td><td align="center">无，先定义，赋值后才能使用</td><td align="center">有默认初始化值</td></tr><tr><td align="center">调用方法</td><td align="center">对象调用</td><td align="center"></td><td align="center">对象调用，类名调用</td></tr><tr><td align="center">存储位置</td><td align="center">堆中</td><td align="center">栈中</td><td align="center">方法区（JDK8 以后移到堆中）</td></tr><tr><td align="center">生命周期</td><td align="center">与对象共存亡</td><td align="center">与方法共存亡</td><td align="center">与类共存亡</td></tr><tr><td align="center">别名</td><td align="center">实例变量</td><td align="center"></td><td align="center">类变量，静态成员变量</td></tr></tbody></table><p><strong>静态变量只有一个，成员变量是类中的变量，局部变量是方法中的变量</strong></p><hr><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><h5 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h5><p>Java 语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型</p><p><strong>byte：</strong></p><ul><li>byte 数据类型是 8 位、有符号的，以<strong>二进制补码</strong>表示的整数，<strong>8 位一个字节</strong>，首位是符号位</li><li>最小值是 <strong>-128（-2^7）</strong></li><li>最大值是 <strong>127（2^7-1）</strong></li><li>默认值是 <strong><code>0</code></strong></li><li>byte 类型用在大型数组中节约空间，主要代替整数，byte 变量占用的空间只有 int 类型的四分之一</li><li>例子：<code>byte a = 100，byte b = -50</code></li></ul><p><strong>short：</strong></p><ul><li>short 数据类型是 16 位、有符号的以二进制补码表示的整数</li><li>最小值是 <strong>-32768（-2^15）</strong></li><li>最大值是 <strong>32767（2^15 - 1）</strong></li><li>short 数据类型也可以像 byte 那样节省空间，一个 short 变量是 int 型变量所占空间的二分之一</li><li>默认值是 <strong><code>0</code></strong></li><li>例子：<code>short s = 1000，short r = -20000</code></li></ul><p><strong>int：</strong></p><ul><li>int 数据类型是 32 位 4 字节、有符号的以二进制补码表示的整数</li><li>最小值是 <strong>-2,147,483,648（-2^31）</strong></li><li>最大值是 <strong>2,147,483,647（2^31 - 1）</strong></li><li>一般地整型变量默认为 int 类型</li><li>默认值是 <strong><code>0</code></strong></li><li>例子：<code>int a = 100000, int b = -200000</code></li></ul><p><strong>long：</strong></p><ul><li>long 数据类型是 64 位 8 字节、有符号的以二进制补码表示的整数</li><li>最小值是 <strong>-9,223,372,036,854,775,808（-2^63）</strong></li><li>最大值是 <strong>9,223,372,036,854,775,807（2^63 -1）</strong></li><li>这种类型主要使用在需要比较大整数的系统上</li><li>默认值是 <strong><code> 0L</code></strong></li><li>例子： <code>long a = 100000L，Long b = -200000L</code><br>“L”理论上不分大小写，但是若写成”l”容易与数字”1”混淆，不容易分辩，所以最好大写</li></ul><p><strong>float：</strong></p><ul><li>float 数据类型是单精度、32 位、符合 IEEE 754 标准的浮点数</li><li>float 在储存大型浮点数组的时候可节省内存空间</li><li>默认值是 <strong><code>0.0f</code></strong></li><li>浮点数不能用来表示精确的值，如货币</li><li>例子：<code>float f1 = 234.5F</code></li></ul><p><strong>double：</strong></p><ul><li>double 数据类型是双精度、64 位、符合 IEEE 754 标准的浮点数</li><li>浮点数的默认类型为 double 类型</li><li>double 类型同样不能表示精确的值，如货币</li><li>默认值是 <strong><code>0.0d</code></strong></li><li>例子：<code>double d1 = 123.4</code></li></ul><p><strong>boolean：</strong></p><ul><li>boolean 数据类型表示一位的信息</li><li>只有两个取值：true 和 false</li><li>JVM 规范指出 boolean 当做 int 处理，boolean 数组当做 byte 数组处理，这样可以得出 boolean 类型单独使用占了 4 个字节，在数组中是 1 个字节</li><li>默认值是 <strong><code>false</code></strong></li><li>例子：<code>boolean one = true</code></li></ul><p><strong>char：</strong></p><ul><li>char 类型是一个单一的 16 位两个字节的 Unicode 字符</li><li>最小值是 **<code>\u0000</code>**（即为 0）</li><li>最大值是 **<code>\uffff</code>**（即为 65535）</li><li>char 数据类型可以储存任何字符</li><li>例子：<code>char c = &#39;A&#39;;</code>   <code>char c = &#39;张&#39;</code></li></ul><p>上下转型</p><ul><li><p>float 与 double：</p><p>Java 不能隐式执行<strong>向下转型</strong>，因为这会使得精度降低（参考多态），但是可以向上转型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.1字面量属于double类型，不能直接将1.1直接赋值给 float 变量，因为这是向下转型float f = 1.1;//报错//1.1f 字面量才是 float 类型float f = 1.1f;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> f1 = <span class="number">1.234f</span>;<span class="keyword">double</span> d1 = f1;<span class="keyword">double</span> d2 = <span class="number">1.23</span>;<span class="keyword">float</span> f2 = (<span class="keyword">float</span>) d2;<span class="comment">//向下转型需要强转</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i1 = <span class="number">1245</span>;<span class="keyword">long</span> l1 = i1;<span class="keyword">long</span> l2 = <span class="number">1234</span>;<span class="keyword">int</span> i2 = (<span class="keyword">int</span>) l2;</span><br></pre></td></tr></table></figure></li><li><p>隐式类型转换：</p><p>字面量 1 是 int 类型，它比 short 类型精度要高，因此不能隐式地将 int 类型向下转型为 short 类型</p><p>使用 += 或者 ++ 运算符会执行隐式类型转换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1 += <span class="number">1</span>;<span class="comment">//s1++;//上面的语句相当于将 s1 + 1 的计算结果进行了向下转型s1 = (short) (s1 + 1);</span></span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h5><p>引用数据类型：类，接口，数组都是引用数据类型，又叫包装类</p><p>包装类的作用：</p><ul><li>包装类作为类首先拥有了 Object 类的方法</li><li>包装类作为引用类型的变量可以<strong>存储 null 值</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">基本数据类型                包装类（引用数据类型）<span class="function"><span class="keyword">byte</span>                      Byteshort                     Shortint                       <span class="title">Integer</span><span class="params">(特殊)</span><span class="keyword">long</span>                      Longfloat                     Floatdouble                    Doublechar                      <span class="title">Character</span><span class="params">(特殊)</span><span class="keyword">boolean</span>                   Boolean</span></span><br></pre></td></tr></table></figure><p>Java 为包装类做了一些特殊功能，具体来看特殊功能主要有：</p><ul><li><p>可以把基本数据类型的值转换成字符串类型的值</p><ol><li>调用 toString() 方法</li><li>调用 Integer.toString(基本数据类型的值) 得到字符串</li><li>直接把基本数据类型 + 空字符串就得到了字符串（推荐使用）</li></ol></li><li><p>把字符串类型的数值转换成对应的基本数据类型的值（<strong>重要</strong>）</p><ol><li>Xxx.parseXxx(“字符串类型的数值”) → Integer.parseInt(numStr)</li><li>Xxx.valueOf(“字符串类型的数值”)   → Integer.valueOf(numStr) （推荐使用）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PackageClass02</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        <span class="comment">// 1.把基本数据类型的值转成字符串        Integer it = 100 ;        // a.调用toString()方法。        String itStr = it.toString();        System.out.println(itStr+1);//1001        // b.调用Integer.toString(基本数据类型的值)得到字符串。        String itStr1 = Integer.toString(it);        System.out.println(itStr1+1);//1001        // c.直接把基本数据类型+空字符串就得到了字符串。        String itStr2 = it+&quot;&quot;;        System.out.println(itStr2+1);// 1001        // 2.把字符串类型的数值转换成对应的基本数据类型的值。（真的很有用）        String numStr = &quot;23&quot;;        //int numInt = Integer.parseInt(numStr);        int numInt = Integer.valueOf(numStr);        System.out.println(numInt+1);//24        String doubleStr = &quot;99.9&quot;;        //double doubleDb = Double.parseDouble(doubleStr);        double doubleDb = Double.valueOf(doubleStr);        System.out.println(doubleDb+0.1);//100.0    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="装箱拆箱"><a href="#装箱拆箱" class="headerlink" title="装箱拆箱"></a>装箱拆箱</h4><p><strong>自动装箱</strong>：可以直接把基本数据类型的值或者变量赋值给包装类</p><p><strong>自动拆箱</strong>：可以把包装类的变量直接赋值给基本数据类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PackegeClass</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        <span class="keyword">int</span> a = <span class="number">12</span> ;        Integer a1 = <span class="number">12</span> ;  <span class="comment">// 自动装箱        Integer a2 = a ;   // 自动装箱        Integer a3 = null; // 引用数据类型的默认值可以为null        Integer c = 100 ;        int c1 = c ;      // 自动拆箱        Integer it = Integer.valueOf(12);  // 手工装箱！        // Integer it1 = new Integer(12); // 手工装箱！        Integer it2 = 12;        Integer it3 = 111 ;        int it33 = it3.intValue(); // 手工拆箱    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p><strong>自动装箱</strong>反编译后底层调用 <code>Integer.valueOf()</code> 实现，源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);&#125;</span><br></pre></td></tr></table></figure><p>自动拆箱调用 <code>java.lang.Integer#intValue</code>，源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">intValue</span><span class="params">()</span> </span>&#123;    <span class="keyword">return</span> value;&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="缓存池"><a href="#缓存池" class="headerlink" title="缓存池"></a>缓存池</h4><p>new Integer(123) 与 Integer.valueOf(123) 的区别在于：</p><ul><li><p>new Integer(123)：每次都会新建一个对象</p></li><li><p>Integer.valueOf(123)：会使用缓存池中的对象，多次调用取得同一个对象的引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer x = <span class="keyword">new</span> Integer(<span class="number">123</span>);Integer y = <span class="keyword">new</span> Integer(<span class="number">123</span>);System.out.println(x == y);    <span class="comment">// falseInteger z = Integer.valueOf(123);Integer k = Integer.valueOf(123);System.out.println(z == k);   // true</span></span><br></pre></td></tr></table></figure></li></ul><p>valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。编译器会在自动装箱过程调用 valueOf() 方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象。</p><p><strong>基本类型对应的缓存池如下：</strong></p><ul><li>Boolean values true and false</li><li>all byte values</li><li>Short values between -128 and 127</li><li>Long values between -128 and 127</li><li>Integer values between -128 and 127</li><li>Character in the range \u0000 to \u007F (0 and 127)</li></ul><p>在 jdk 1.8 所有的数值类缓冲池中，<strong>Integer 的缓存池 IntegerCache 很特殊，这个缓冲池的下界是 -128，上界默认是 127</strong>，但是上界是可调的，在启动 jvm 的时候，通过 AutoBoxCacheMax=<size> 来指定这个缓冲池的大小，该选项在 JVM 初始化的时候会设定一个名为 java.lang.IntegerCache.high 系统属性，然后 IntegerCache 初始化的时候就会读取该系统属性来决定上界</size></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer x = <span class="number">100</span>;<span class="comment">//自动装箱，底层调用 Integer.valueOf(1)Integer y = 100;System.out.println(x == y);   // trueInteger x = 1000;Integer y = 1000;System.out.println(x == y);   // false，因为缓存池最大127int x = 1000;Integer y = 1000;System.out.println(x == y);// true，因为 y 会调用 intValue 自动拆箱返回 int 原始值进行比较</span></span><br></pre></td></tr></table></figure><hr><h4 id="输入数据"><a href="#输入数据" class="headerlink" title="输入数据"></a>输入数据</h4><p>语法：<code>Scanner sc = new Scanner(System.in)</code></p><ul><li>next()：遇到了空格，就不再录入数据了，结束标记：空格、tab 键</li><li>nextLine()：可以将数据完整的接收过来，结束标记：回车换行符</li></ul><p>一般使用 <code>sc.nextInt()</code> 或者 <code>sc.nextLine()</code> 接受整型和字符串，然后转成需要的数据类型</p><p>Scanner：<code>BufferedReader br = new BufferedReader(new InputStreamReader(System.in))</code><br>print：<code>PrintStream.write()</code></p><blockquote><p>使用引用数据类型的API</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    Scanner sc = <span class="keyword">new</span> Scanner(System.in);    <span class="keyword">while</span> (sc.hasNextLine()) &#123;        String msg = sc.nextLine();    &#125;&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><ul><li><p>有了基本数据类型，为什么还要引用数据类型？</p><blockquote><p>1、引用数据类型封装了数据和处理该数据的方法，比如 Integer.parseInt(String) 就是将 String 字符类型数据转换为 Integer 整型数据</p><p>2、Java 中大部分类和方法都是针对引用数据类型，包括泛型和集合</p></blockquote></li><li><p>引用数据类型那么好，为什么还用基本数据类型？</p><blockquote><p>引用类型的对象要多储存对象头，对基本数据类型来说空间浪费率太高<br>逻辑上来讲，java 只有包装类就够了，为了运行速度，需要用到基本数据类型；优先考虑运行效率的问题，所以二者同时存在是合乎情理的</p></blockquote></li><li><p>Java 集合不能存放基本数据类型，只存放对象的引用？</p><blockquote><p>不能放基本数据类型是因为不是 Object 的子类。泛型思想，如果不用泛型要写很多参数类型不同的但功能相同的函数（方法重载）</p></blockquote></li><li><p>==</p><blockquote><p>== 比较基本数据类型：比较的是具体的值<br>== 比较引用数据类型：比较的是对象地址值</p></blockquote></li></ul><hr><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>数组就是存储数据长度固定的容器，存储多个数据的<strong>数据类型要一致</strong>，数组也是一个对象</p><p>创建数组：</p><ul><li>数据类型[] 数组名：<code>int[] arr;</code>  （常用）</li><li>数据类型 数组名[]：<code>int arr[];</code></li></ul><p>静态初始化：</p><ul><li>数据类型[] 数组名 = new 数据类型[]{元素1,元素2,…}：<code>int[] arr = new int[]&#123;11,22,33&#125;</code></li><li>数据类型[] 数组名 = {元素1,元素2,…}：<code>int[] arr = &#123;44,55,66&#125;</code></li></ul><p>动态初始化</p><ul><li>数据类型[] 数组名 = new 数据类型[数组长度]：<code>int[] arr = new int[3]</code></li></ul><h4 id="元素访问"><a href="#元素访问" class="headerlink" title="元素访问"></a>元素访问</h4><ul><li><p><strong>索引</strong>：每一个存储到数组的元素，都会自动的拥有一个编号，从 <strong>0</strong> 开始。这个自动编号称为数组索引（index），可以通过数组的索引访问到数组中的元素。     </p></li><li><p><strong>访问格式</strong>：数组名[索引] <code>arr[0]</code></p></li><li><p><strong>赋值：</strong><code>arr[0] = 10</code></p></li></ul><hr><h4 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h4><p>内存是计算机中的重要原件，临时存储区域，作用是运行程序。我们编写的程序是存放在硬盘中的，在硬盘中的程序是不会运行的。必须放进内存中才能运行，运行完毕后会清空内存。 Java虚拟机要运行程序，必须要对内存进行空间的分配和管理。 </p><table><thead><tr><th>区域名称</th><th>作用</th></tr></thead><tbody><tr><td>寄存器</td><td>给CPU使用，和我们开发无关</td></tr><tr><td>本地方法栈</td><td>JVM在使用操作系统功能的时候使用，和我们开发无关</td></tr><tr><td>方法区</td><td>存储可以运行的class文件</td></tr><tr><td>堆内存</td><td>存储对象或者数组，new来创建的，都存储在堆内存</td></tr><tr><td>方法栈</td><td>方法运行时使用的内存，比如main方法运行，进入方法栈中执行</td></tr></tbody></table><p><strong>内存分配图</strong>：</p><ul><li><p>Java内存分配-一个数组内存图</p><p><img src="https://gitee.com/seazean/images/raw/master/Java/%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%9B%BE.png"></p></li><li><p>两个数组内存图</p><p><img src="https://gitee.com/seazean/images/raw/master/Java/%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%9B%BE.png"></p></li><li><p>多个数组指向相同内存图</p><p><img src="https://gitee.com/seazean/images/raw/master/Java/%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-%E5%A4%9A%E4%B8%AA%E6%95%B0%E7%BB%84%E6%8C%87%E5%90%91%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%9B%BE.png"></p></li></ul><hr><h4 id="数组异常"><a href="#数组异常" class="headerlink" title="数组异常"></a>数组异常</h4><ul><li><p>索引越界异常：ArrayIndexOutOfBoundsException </p></li><li><p>空指针异常：NullPointerException </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayDemo</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];        <span class="comment">//把null赋值给数组        arr = null;        System.out.println(arr[0]);    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>arr = null，表示变量arr将不再保存数组的内存地址，也就不允许再操作数组，因此运行的时候会抛出空指针异常。在开发中，空指针异常是不能出现的，一旦出现了，就必须要修改我们编写的代码。</p><p>解决方案：给数组一个真正的堆内存空间引用即可！</p></li></ul><hr><h4 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h4><p>二维数组也是一种容器，不同于一维数组，该容器存储的都是一维数组容器</p><p>初始化：</p><ul><li><p>动态初始化：</p><p>数据类型[][] 变量名 = new 数据类型[m] [n] : <code>int[][] arr = new int[3][3];</code></p><ul><li>m 表示这个二维数组，可以存放多少个一维数组，行</li><li>n 表示每一个一维数组，可以存放多少个元素，列</li></ul></li><li><p>静态初始化</p><ul><li>数据类型[][] 变量名 = new 数据类型[][]{ {元素1, 元素2…} , {元素1, 元素2…} </li><li>数据类型[][] 变量名 = { {元素1, 元素2…} , {元素1, 元素2…} …}</li><li><code>int[][] arr = &#123;&#123;11,22,33&#125;, &#123;44,55,66&#125;&#125;;</code></li></ul></li></ul><p>遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;    <span class="comment">/*        步骤:            1. 遍历二维数组，取出里面每一个一维数组            2. 在遍历的过程中，对每一个一维数组继续完成遍历，获取内部存储的每一个元素     */</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        <span class="keyword">int</span>[][] arr = &#123;&#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>&#125;, &#123;<span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>&#125;&#125;;        <span class="comment">// 1. 遍历二维数组，取出里面每一个一维数组        for (int i = 0; i &lt; arr.length; i++) &#123;            //System.out.println(arr[i]);            // 2. 在遍历的过程中，对每一个一维数组继续完成遍历，获取内部存储的每一个元素            //int[] temp = arr[i];            for (int j = 0; j &lt; arr[i].length; j++) &#123;                System.out.println(arr[i][j]);            &#125;        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><ul><li><p>i++ 与++i 的区别？<br>i++ 表示先将 i 放在表达式中运算，然后再加 1<br>++i 表示先将 i 加 1，然后再放在表达式中运算</p></li><li><p>|| 和 |，&amp;&amp; 和&amp; 的区别，逻辑运算符</p><p><strong>&amp;和| 称为布尔运算符，位运算符。&amp;&amp;和|| 称为条件布尔运算符,也叫短路运算符</strong>。</p><p>两种运算符得到的结果完全相同，但得到结果的方式又一个重要区别：条件布尔运算符性能比较好。他检查第一个操作数的值，再根据该操作数的值进行操作，可能根本就不处理第二个操作数。</p><p>结论：如果 &amp;&amp; 运算符的第一个操作数是 false，就不需要考虑第二个操作数的值了，因为无论第二个操作数的值是什么，其结果都是 false；同样，如果第一个操作数是 true，|| 运算符就返回 true，无需考虑第二个操作数的值。但 &amp; 和 | 却不是这样，它们总是要计算两个操作数。为了提高性能，<strong>尽可能使用 &amp;&amp; 和 || 运算符</strong></p></li><li><p>switch</p><p>从 Java 7 开始，可以在 switch 条件判断语句中使用 String 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">&quot;a&quot;</span>;<span class="keyword">switch</span> (s) &#123;    <span class="keyword">case</span> <span class="string">&quot;a&quot;</span>:        System.out.println(<span class="string">&quot;aaa&quot;</span>);        <span class="keyword">break</span>;    <span class="keyword">case</span> <span class="string">&quot;b&quot;</span>:        System.out.println(<span class="string">&quot;bbb&quot;</span>);        <span class="keyword">break</span>;    <span class="keyword">default</span>:        <span class="keyword">break</span>;&#125;</span><br></pre></td></tr></table></figure><p>switch 不支持 long、float、double，switch 的设计初衷是对那些只有少数几个值的类型进行等值判断，如果值过于复杂，那么用 if 比较合适</p></li><li><p>break：跳出一层循环</p></li><li><p>移位运算</p><p>计算机里一般用<strong>补码表示数字</strong>，正数、负数的表示区别就是最高位是 0 还是 1</p><ul><li><p>正数的原码反码补码相同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100</span>:<span class="number">00000000</span>  <span class="number">00000000</span>  <span class="number">00000000</span>  <span class="number">01100100</span></span><br></pre></td></tr></table></figure></li><li><p>负数：<br>原码：最高位为1，其余位置和正数相同<br>反码：保证符号位不变，其余位置取反<br>补码：保证符号位不变，其余位置取反加 1，即反码 +1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="number">100</span>原码:<span class="number">10000000</span>  <span class="number">00000000</span>  <span class="number">00000000</span>  <span class="number">01100100</span><span class="comment">//32位-100反码:11111111  11111111  11111111  10011011-100补码:11111111  11111111  11111111  10011100</span></span><br></pre></td></tr></table></figure><p>补码 → 原码：符号位不变，其余位置取反加 1</p></li></ul><p>运算符：</p><ul><li><code>&gt;&gt;</code> 运算符：将二进制位进行右移操作，相当于除 2</li><li><code>&lt;&lt;</code> 运算符：将二进制位进行左移操作，相当于乘 2</li><li><code>&gt;&gt;&gt;</code> 运算符：无符号右移，忽略符号位，空位都以 0 补齐</li></ul><p>运算规则：</p><ul><li><p>正数的左移与右移，空位补 0</p></li><li><p>负数原码的左移与右移，空位补 0</p><p>负数反码的左移与右移，空位补 1</p><p>负数补码，左移低位补 0（会导致负数变为正数的问题，因为移动了符号位），右移高位补 1</p></li><li><p>无符号移位，空位补 0</p></li></ul></li></ul><hr><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><h4 id="形参实参"><a href="#形参实参" class="headerlink" title="形参实参"></a>形参实参</h4><p>形参：</p><ul><li>形式参数，用于定义方法的时候使用的参数，只能是变量</li><li>形参只有在方法被调用的时候，虚拟机才分配内存单元，方法调用结束之后便会释放所分配的内存单元</li></ul><p>实参：调用方法时传递的数据可以是常量，也可以是变量</p><h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><p>可变参数用在形参中可以接收多个数据。</p><p>可变参数的格式：数据类型… 参数名称</p><p>可变参数的作用：传输参数非常灵活，方便。可以不传输参数、传输一个参数、或者传输一个数组。</p><p>可变参数在方法内部本质上就是一个数组。</p><p>可变参数的注意事项：<br>    1.一个形参列表中可变参数只能有一个！<br>    2.可变参数必须放在形参列表的<strong>最后面</strong>！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;sum(); <span class="comment">// 可以不传输参数。sum(10); // 可以传输一个参数。sum(10,20,30); // 可以传输多个参数。sum(new int[]&#123;10,30,50,70,90&#125;); // 可以传输一个数组。&#125;public static void sum(int... nums)&#123;int sum = 0;for(int i : a) &#123;sum += i;&#125;return sum;&#125;</span></span><br></pre></td></tr></table></figure><hr><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="方法概述"><a href="#方法概述" class="headerlink" title="方法概述"></a>方法概述</h4><p>方法（method）是将具有独立功能的代码块组织成为一个整体，使其具有特殊功能的代码集</p><p>注意：方法必须先创建才可以使用，该过程成为方法定义，方法创建后并不是直接可以运行的，需要手动使用后才执行，该过程成为方法调用</p><p>在方法内部定义的叫局部变量，局部变量不能加 static，包括 protected、private、public 这些也不能加</p><p>原因：局部变量是保存在栈中的，而静态变量保存于方法区（JDK8 在堆中），局部变量出了方法就被栈回收了，而静态变量不会，所以在局部变量前不能加 static 关键字，静态变量是定义在类中，又叫类变量</p><hr><h4 id="定义调用"><a href="#定义调用" class="headerlink" title="定义调用"></a>定义调用</h4><p>定义格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> 返回值类型 方法名(参数) &#123;<span class="comment">//方法体;return 数据 ;&#125;</span></span><br></pre></td></tr></table></figure><p>调用格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型 变量名 = 方法名 ( 参数 ) ;<span class="comment">//注意：方法的返回值通常会使用变量接收，否则该返回值将无意义</span></span><br></pre></td></tr></table></figure><ul><li>方法名：调用方法时候使用的标识</li><li>参数：由数据类型和变量名组成，多个参数之间用逗号隔开</li><li>方法体：完成功能的代码块</li><li>return：如果方法操作完毕，有数据返回，用于把数据返回给调用者</li></ul><p>如果方法操作完毕</p><ul><li>void 类型的方法，直接调用即可，而且方法体中一般不写return</li><li>非 void 类型的方法，推荐用变量接收调用</li></ul><p>原理：每个方法在被调用执行的时候，都会进入栈内存，并且拥有自己独立的内存空间，方法内部代码调用完毕之后，会从栈内存中弹栈消失。</p><hr><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><p>方法不能嵌套定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodDemo</span> </span>&#123;<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;&#125;<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodOne</span><span class="params">()</span> </span>&#123;<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodTwo</span><span class="params">()</span> </span>&#123;<span class="comment">// 这里会引发编译错误!!!&#125;&#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>void 表示无返回值，可以省略 return，也可以单独的书写 return，后面不加数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodTwo</span><span class="params">()</span> </span>&#123;<span class="comment">//return 100; 编译错误，因为没有具体返回值类型return;//System.out.println(100); return语句后面不能跟数据或代码&#125;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h4><h5 id="重载介绍"><a href="#重载介绍" class="headerlink" title="重载介绍"></a>重载介绍</h5><p>方法重载指同一个类中定义的多个方法之间的关系，满足下列条件的多个方法相互构成重载：</p><ol><li>多个方法在<strong>同一个类</strong>中</li><li>多个方法具有<strong>相同的方法名</strong></li><li>多个方法的<strong>参数不相同</strong>，类型不同或者数量不同</li></ol><p>重载仅对应方法的定义，与方法的调用无关，调用方式参照标准格式</p><p>重载仅针对同一个类中方法的名称与参数进行识别，与返回值无关，<strong>不能通过返回值来判定两个方法是否构成重载</strong></p><p>原理：JVM → 运行机制 → 方法调用 → 多态原理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodDemo</span> </span>&#123;<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fn</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;<span class="comment">//方法体&#125;    public static int fn(int a) &#123; /*错误原因：重载与返回值无关*///方法体&#125;        public static void fn(int a, int b) &#123;/*正确格式*///方法体&#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h5 id="方法选取"><a href="#方法选取" class="headerlink" title="方法选取"></a>方法选取</h5><p>重载的方法在编译过程中即可完成识别，方法调用时 Java 编译器会根据所传入参数的声明类型（注意与实际类型区分）来选取重载方法。选取的过程共分为三个阶段：</p><ul><li>在不考虑对基本类型自动装拆箱 (auto-boxing，auto-unboxing)，以及可变长参数的情况下选取重载方法</li><li>如果第 1 个阶段中没有找到适配的方法，那么在允许自动装拆箱，但不允许可变长参数的情况下选取重载方法</li><li>如果第 2 个阶段中没有找到适配的方法，那么在允许自动装拆箱以及可变长参数的情况下选取重载方法</li></ul><p>如果 Java 编译器在同一个阶段中找到了多个适配的方法，那么会选择一个最为贴切的，而决定贴切程度的一个关键就是形式参数类型的继承关系，<strong>一般会选择形参为参数类型的子类的方法，因为子类时更具体的实现</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodDemo</span> </span>&#123;    <span class="function"><span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span> </span>&#123; ... &#125;    <span class="function"><span class="keyword">void</span> <span class="title">invoke</span><span class="params">(String s, Object obj, Object... args)</span> </span>&#123; ... &#125;    invoke(<span class="keyword">null</span>, <span class="number">1</span>); <span class="comment">// 调用第二个invoke方法，选取的第二阶段    invoke(null, 1, 2); // 调用第二个invoke方法，匹配第一个和第二个，但String是Object的子类        invoke(null, new Object[]&#123;1&#125;); // 只有手动绕开可变长参数的语法糖，才能调用第一个invoke方法       // 可变参数底层是数组，JVM-&gt;运行机制-&gt;代码优化&#125;</span></span><br></pre></td></tr></table></figure><p>因此不提倡可变长参数方法的重载</p><hr><h5 id="继承重载"><a href="#继承重载" class="headerlink" title="继承重载"></a>继承重载</h5><p>除了同一个类中的方法，重载也可以作用于这个类所继承而来的方法。如果子类定义了与父类中<strong>非私有方法</strong>同名的方法，而且这两个方法的参数类型不同，那么在子类中，这两个方法同样构成了重载</p><ul><li>如果这两个方法都是静态的，那么子类中的方法隐藏了父类中的方法</li><li>如果这两个方法都不是静态的，且都不是私有的，那么子类的方法重写了父类中的方法，也就是<strong>多态</strong></li></ul><hr><h4 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h4><p>Java 的参数是以<strong>值传递</strong>的形式传入方法中</p><p>值传递和引用传递的区别在于传递后会不会影响实参的值：值传递会创建副本，引用传递不会创建副本</p><ul><li><p>基本数据类型：形式参数的改变，不影响实际参数</p><p>每个方法在栈内存中，都会有独立的栈空间，方法运行结束后就会弹栈消失</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArgsDemo01</span> </span>&#123;<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;<span class="keyword">int</span> number = <span class="number">100</span>;System.out.println(<span class="string">&quot;调用change方法前：&quot;</span> + number);<span class="comment">//100change(number);System.out.println(&quot;调用change方法后：&quot; + number);//100&#125;public static void change(int number) &#123;number = 200;&#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>引用类型：形式参数的改变，影响实际参数的值</p><p><strong>引用数据类型的传参，本质上是将对象的地址以值的方式传递到形参中</strong>，内存中会造成两个引用指向同一个内存的效果，所以即使方法弹栈，堆内存中的数据也已经是改变后的结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PassByValueExample</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        Dog dog = <span class="keyword">new</span> Dog(<span class="string">&quot;A&quot;</span>);        func(dog);        System.out.println(dog.getName());<span class="comment">// B    &#125;    private static void func(Dog dog) &#123;        dog.setName(&quot;B&quot;);    &#125;&#125;class Dog &#123;    String name;//.....&#125;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>枚举是 Java 中的一种特殊类型，为了做信息的标志和信息的分类</p><p>定义枚举的格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="class"><span class="keyword">enum</span> 枚举名称</span>&#123;第一行都是罗列枚举实例的名称。&#125;</span><br></pre></td></tr></table></figure><p>枚举的特点：</p><ul><li>枚举类是用 final 修饰的，枚举类不能被继承</li><li>枚举类默认继承了 java.lang.Enum 枚举类</li><li>枚举类的第一行都是常量，必须是罗列枚举类的实例名称</li><li>枚举类相当于是多例设计模式</li><li>每个枚举项都是一个实例，是一个静态成员变量</li></ul><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>String name()</td><td>获取枚举项的名称</td></tr><tr><td>int ordinal()</td><td>返回枚举项在枚举类中的索引值</td></tr><tr><td>int compareTo(E  o)</td><td>比较两个枚举项，返回的是索引值的差值</td></tr><tr><td>String toString()</td><td>返回枚举常量的名称</td></tr><tr><td>static <T> T  valueOf(Class<T> type,String  name)</T></T></td><td>获取指定枚举类中的指定名称的枚举值</td></tr><tr><td>values()</td><td>获得所有的枚举项</td></tr></tbody></table><ul><li><p>源码分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Season</span> </span>&#123;    SPRING , SUMMER , AUTUMN , WINTER;&#125;<span class="comment">// 枚举类的编译以后源代码：public final class Season extends java.lang.Enum&lt;Season&gt; &#123;public static final Season SPRING = new Season();public static final Season SUMMER = new Season();public static final Season AUTUMN = new Season();public static final Season WINTER = new Season();public static Season[] values();public static Season valueOf(java.lang.String);&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>API 使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumDemo</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;        <span class="comment">// 获取索引        Season s = Season.SPRING;/        System.out.println(s);//SPRING        System.out.println(s.ordinal()); // 0，代表索引，summer 就是 1        s.s.doSomething();        // 获取全部枚举        Season[] ss = Season.values();        for(int i = 0; i &lt; ss.length; i++)&#123;            System.out.println(ss[i]);        &#125;                int result = Season.SPRING.compareTo(Season.WINTER);        System.out.println(result);//-3    &#125;&#125;enum Season &#123;    SPRING , SUMMER , AUTUMN , WINTER;        public void doSomething() &#123;        System.out.println(&quot;hello &quot;);    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h3><p>Debug 是供程序员使用的程序调试工具，它可以用于查看程序的执行流程，也可以用于追踪程序执行过程来调试程序。</p><p>加断点 → Debug 运行 → 单步运行 → 看 Debugger 窗口 → 看 Console 窗口</p><p><img src="https://gitee.com/seazean/images/raw/master/Java/Debug%E6%8C%89%E9%94%AE%E8%AF%B4%E6%98%8E.png"></p><img src="https://gitee.com/seazean/images/raw/master/Java/Debug条件断点.png" alt="Debug条件断点" style="zoom:50%;"><hr><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><strong>Java是一种面向对象的高级编程语言。</strong></p><p><strong>三大特征：封装，继承，多态</strong></p><p>面向对象最重要的两个概念：类和对象</p><ul><li>类：相同事物共同特征的描述。类只是学术上的一个概念并非真实存在的，只能描述一类事物</li><li>对象：是真实存在的实例， 实例==对象，<strong>对象是类的实例化</strong></li><li>结论：有了类和对象就可以描述万千世界所有的事物。 必须先有类才能有对象</li></ul><hr><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>定义格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="class"><span class="keyword">class</span> 类名</span>&#123;&#125;</span><br></pre></td></tr></table></figure><ol><li>类名的首字母建议大写，满足驼峰模式，比如 StudentNameCode</li><li>一个 Java 代码中可以定义多个类，按照规范一个 Java 文件一个类</li><li>一个 Java 代码文件中，只能有一个类是 public 修饰，<strong>public修饰的类名必须成为当前Java代码的文件名称</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类中的成分:有且仅有五大成分修饰符 <span class="class"><span class="keyword">class</span> 类名</span>&#123;<span class="number">1.</span>成员变量(Field):  描述类或者对象的属性信息的。        <span class="number">2.</span>成员方法(Method):描述类或者对象的行为信息的。<span class="number">3.</span>构造器(Constructor): 初始化一个对象返回。<span class="number">4.</span>代码块<span class="number">5.</span>内部类  &#125;类中有且仅有这五种成分，否则代码报错！<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassDemo</span> </span>&#123;    System.out.println(<span class="number">1</span>);<span class="comment">//报错&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><p>构造器格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 类名(形参列表)&#123;&#125;</span><br></pre></td></tr></table></figure><p>作用：初始化类的一个对象返回</p><p>分类：无参数构造器，有参数构造器</p><p>注意：<strong>一个类默认自带一个无参数构造器</strong>，写了有参数构造器默认的无参数构造器就消失，还需要用无参数构造器就要重新写</p><p>构造器初始化对象的格式：类名 对象名称 = new 构造器</p><ul><li>无参数构造器的作用：初始化一个类的对象（使用对象的默认值初始化）返回</li><li>有参数构造器的作用：初始化一个类的对象（可以在初始化对象的时候为对象赋值）返回</li></ul><hr><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>包：分门别类的管理各种不同的技术，便于管理技术，扩展技术，阅读技术</p><p>定义包的格式：<code>package 包名</code>，必须放在类名的最上面</p><p>导包格式：<code>import 包名.类名</code></p><p>相同包下的类可以直接访问；不同包下的类必须导包才可以使用</p><hr><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装的哲学思维：合理隐藏，合理暴露<br>封装最初的目的：提高代码的安全性和复用性，组件化</p><p>封装的步骤：</p><ol><li><strong>成员变量应该私有，用 private 修饰，只能在本类中直接访问</strong></li><li><strong>提供成套的 getter 和 setter 方法暴露成员变量的取值和赋值</strong></li></ol><p>使用 private 修饰成员变量的原因：实现数据封装，不想让别人使用修改你的数据，比较安全</p><hr><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>this 关键字的作用：</p><ul><li>this 关键字代表了当前对象的引用</li><li>this 出现在方法中：<strong>哪个对象调用这个方法 this 就代表谁</strong></li><li>this 可以出现在构造器中：代表构造器正在初始化的那个对象</li><li>this 可以区分变量是访问的成员变量还是局部变量</li></ul><hr><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>Java 是通过成员变量是否有 static 修饰来区分是类的还是属于对象的。</p><p>static 静态修饰的成员（方法和成员变量）属于类本身的。</p><p>按照有无 static 修饰，成员变量和方法可以分为：</p><ul><li><p>成员变量：</p><ul><li>静态成员变量（类变量）：static 修饰的成员变量，属于类本身，<strong>与类一起加载一次，只有一个</strong>，直接用类名访问即可</li><li>实例成员变量：无 static 修饰的成员变量，属于类的每个对象的，<strong>与类的对象一起加载</strong>，对象有多少个，实例成员变量就加载多少个，必须用类的对象来访问</li></ul></li><li><p>成员方法：</p><ul><li>静态方法：有 static 修饰的成员方法称为静态方法也叫类方法，属于类本身的，直接用类名访问即可</li><li>实例方法：无 static 修饰的成员方法称为实例方法，属于类的每个对象的，必须用类的对象来访问</li></ul></li></ul><hr><h4 id="static用法"><a href="#static用法" class="headerlink" title="static用法"></a>static用法</h4><p>成员变量的访问语法：</p><ul><li><p>静态成员变量：只有一份可以被类和类的对象<strong>共享访问</strong></p><ul><li>类名.静态成员变量（同一个类中访问静态成员变量可以省略类名不写）</li><li>对象.静态成员变量（不推荐）</li></ul></li><li><p>实例成员变量：</p><ul><li>对象.实例成员变量（先创建对象）</li></ul></li></ul><p>成员方法的访问语法：</p><ul><li><p>静态方法：有 static 修饰，属于类</p><ul><li>类名.静态方法（同一个类中访问静态成员可以省略类名不写）</li><li>对象.静态方法（不推荐，参考 JVM → 运行机制 → 方法调用）</li></ul></li><li><p>实例方法：无 static 修饰，属于对象</p><ul><li>对象.实例方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;    <span class="comment">// 1.静态方法：有static修饰，属于类，直接用类名访问即可！    public static void inAddr()&#123; &#125;    // 2.实例方法：无static修饰，属于对象，必须用对象访问！    public void eat()&#123;&#125;        public static void main(String[] args) &#123;        // a.类名.静态方法        Student.inAddr();        inAddr();        // b.对象.实例方法        // Student.eat(); // 报错了！        Student zbj = new Student();        zbj.eat();    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="两个问题"><a href="#两个问题" class="headerlink" title="两个问题"></a>两个问题</h4><p>内存问题：</p><ul><li><p><strong>栈内存存放 main 方法和地址</strong></p></li><li><p><strong>堆内存存放对象和变量</strong></p></li><li><p><strong>方法区存放 class 和静态变量（jdk8 以后移入堆）</strong></p></li></ul><p>访问问题：</p><ul><li>实例方法是否可以直接访问实例成员变量？可以的，因为它们都属于对象</li><li>实例方法是否可以直接访问静态成员变量？可以的，静态成员变量可以被共享访问</li><li>实例方法是否可以直接访问实例方法? 可以的，实例方法和实例方法都属于对象</li><li>实例方法是否可以直接访问静态方法？可以的，静态方法可以被共享访问</li><li>静态方法是否可以直接访问实例变量？ 不可以的，实例变量必须用对象访问！！</li><li>静态方法是否可以直接访问静态变量？ 可以的，静态成员变量可以被共享访问。</li><li>静态方法是否可以直接访问实例方法? 不可以的，实例方法必须用对象访问！！</li><li>静态方法是否可以直接访问静态方法？可以的，静态方法可以被共享访问！！</li></ul><hr><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>继承是 Java 中一般到特殊的关系，是一种子类到父类的关系</p><ul><li>被继承的类称为：父类/超类。</li><li>继承父类的类称为：子类。</li></ul><p>继承的作用：</p><ul><li><strong>提高代码的复用</strong>，相同代码可以定义在父类中</li><li>子类继承父类，可以直接使用父类这些代码（相同代码重复利用）</li><li>子类得到父类的属性（成员变量）和行为（方法），还可以定义自己的功能，子类更强大</li></ul><p>继承的特点：</p><ol><li>子类的全部构造器默认先访问父类的无参数构造器，再执行自己的构造器</li><li><strong>单继承</strong>：一个类只能继承一个直接父类</li><li>多层继承：一个类可以间接继承多个父类（家谱）</li><li>一个类可以有多个子类</li><li>一个类要么默认继承了 Object 类，要么间接继承了 Object 类，Object 类是 Java 中的祖宗类</li></ol><p>继承的格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">子类 extends 父类&#123;&#125;</span><br></pre></td></tr></table></figure><p>子类不能继承父类的东西：</p><ul><li>子类不能继承父类的构造器，子类有自己的构造器</li><li>子类是不能可以继承父类的私有成员的，可以反射暴力去访问继承自父类的私有成员</li><li>子类是不能继承父类的静态成员的，子类只是可以访问父类的静态成员，父类静态成员只有一份可以被子类共享访问，<strong>共享并非继承</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendsDemo</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        Cat c = <span class="keyword">new</span> Cat();        <span class="comment">// c.run();        Cat.test();        System.out.println(Cat.schoolName);    &#125;&#125;class Cat extends Animal&#123;&#125;class Animal&#123;    public static String schoolName =&quot;seazean&quot;;    public static void test()&#123;&#125;    private void run()&#123;&#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="变量访问"><a href="#变量访问" class="headerlink" title="变量访问"></a>变量访问</h4><p>继承后成员变量的访问特点：<strong>就近原则</strong>，子类有找子类，子类没有找父类，父类没有就报错</p><p>如果要申明访问父类的成员变量可以使用：super.父类成员变量，super指父类引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendsDemo</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">wmain</span><span class="params">(String[] args)</span> </span>&#123;        Wolf w = <span class="keyword">new</span> Wolf();w        w.showName();    &#125;&#125;<span class="class"><span class="keyword">class</span> <span class="title">Wolf</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;    <span class="keyword">private</span> String name = <span class="string">&quot;子类狼&quot;</span>;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showName</span><span class="params">()</span></span>&#123;        String name = <span class="string">&quot;局部名称&quot;</span>;        System.out.println(name); <span class="comment">// 局部name        System.out.println(this.name); // 子类对象的name        System.out.println(super.name); // 父类的        System.out.println(name1); // 父类的        //System.out.println(name2); // 报错。子类父类都没有    &#125;&#125;class Animal&#123;    public String name = &quot;父类动物名称&quot;;    public String name1 = &quot;父类&quot;;&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="方法访问"><a href="#方法访问" class="headerlink" title="方法访问"></a>方法访问</h4><p>子类继承了父类就得到了父类的方法，<strong>可以直接调用</strong>，受权限修饰符的限制，也可以重写方法</p><p>方法重写：子类重写一个与父类申明一样的方法来<strong>覆盖</strong>父类的该方法</p><p>方法重写的校验注解：@Override</p><ul><li>方法加了这个注解，那就必须是成功重写父类的方法，否则报错 </li><li>@Override 优势：可读性好，安全，优雅</li></ul><p><strong>子类可以扩展父类的功能，但不能改变父类原有的功能</strong>，重写有以下三个限制：</p><ul><li>子类方法的访问权限必须大于等于父类方法</li><li>子类方法的返回类型必须是父类方法返回类型或为其子类型</li><li>子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型</li></ul><p>继承中的隐藏问题：</p><ul><li>子类和父类方法都是静态的，那么子类中的方法会隐藏父类中的方法</li><li>在子类中可以定义和父类成员变量同名的成员变量，此时子类的成员变量隐藏了父类的成员变量，在创建对象为对象分配内存的过程中，<strong>隐藏变量依然会被分配内存</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendsDemo</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        Wolf w = <span class="keyword">new</span> Wolf();        w.run();    &#125;&#125;<span class="class"><span class="keyword">class</span> <span class="title">Wolf</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//&#125;class Animal&#123;    public void run()&#123;&#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="面试问题"><a href="#面试问题" class="headerlink" title="面试问题"></a>面试问题</h4><ul><li><p>为什么子类构造器会先调用父类构造器？</p><ol><li>子类的构造器的第一行默认 super() 调用父类的无参数构造器，写不写都存在</li><li>子类继承父类，子类就得到了父类的属性和行为。调用子类构造器初始化子类对象数据时，必须先调用父类构造器初始化继承自父类的属性和行为</li><li>参考 JVM → 类加载 → 对象创建</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">()</span></span>&#123;        System.out.println(<span class="string">&quot;==父类Animal的无参数构造器==&quot;</span>);    &#125;&#125;<span class="class"><span class="keyword">class</span> <span class="title">Tiger</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;    <span class="function"><span class="keyword">public</span> <span class="title">Tiger</span><span class="params">()</span></span>&#123;        <span class="keyword">super</span>(); <span class="comment">// 默认存在的，根据参数去匹配调用父类的构造器。        System.out.println(&quot;==子类Tiger的无参数构造器==&quot;);    &#125;    public Tiger(String name)&#123;        //super();  默认存在的，根据参数去匹配调用父类的构造器。        System.out.println(&quot;==子类Tiger的有参数构造器==&quot;);    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>为什么 Java 是单继承的？</strong></p><p>答：反证法，假如 Java 可以多继承，请看如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;System.out.println(<span class="string">&quot;A&quot;</span>);&#125;&#125;<span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;System.out.println(<span class="string">&quot;B&quot;</span>);&#125;&#125;<span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">A</span> , <span class="title">B</span> </span>&#123;<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;C c = <span class="keyword">new</span> C();        c.test();         <span class="comment">// 出现了类的二义性！所以Java不能多继承！！&#125;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><p>继承后 super 调用父类构造器，父类构造器初始化继承自父类的数据。</p><p>总结与拓展：</p><ul><li>this 代表了当前对象的引用（继承中指代子类对象）：this.子类成员变量、this.子类成员方法、**this(…)**可以根据参数匹配访问本类其他构造器。</li><li>super 代表了父类对象的引用（继承中指代了父类对象空间）：super.父类成员变量、super.父类的成员方法、super(…)可以根据参数匹配访问父类的构造器</li></ul><p><strong>注意：</strong></p><ul><li>this(…) 借用本类其他构造器，super(…) 调用父类的构造器。</li><li>this(…) 或 super(…) 必须放在构造器的第一行，否则报错!</li><li>this(…) 和 super(…) 不能同时出现在构造器中，因为构造函数必须出现在第一行上，只能选择一个。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThisDemo</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        <span class="comment">// 需求：希望如果不写学校默认就是”张三“！        Student s1 = new Student(&quot;天蓬元帅&quot;, 1000 );        Student s2 = new Student(&quot;齐天大圣&quot;, 2000, &quot;清华大学&quot; );    &#125;&#125;class Study extends Student &#123;   public Study(String name, int age, String schoolName) &#123;        super(name , age , schoolName) ;        // 根据参数匹配调用父类构造器   &#125;&#125;class Student&#123;    private String name ;    private int age ;    private String schoolName ;    public Student() &#123;    &#125;    public Student(String name , int age)&#123;        // 借用兄弟构造器的功能！        this(name , age , &quot;张三&quot;);    &#125;public Student(String name, int age, String schoolName) &#123;        this.name = name;        this.age = age;        this.schoolName = schoolName;    &#125;// .......get + set&#125;</span></span><br></pre></td></tr></table></figure><hr><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><h4 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>final 用于修饰：类，方法，变量</p><ul><li>final 修饰类，类不能被继承了，类中的方法和变量可以使用</li><li>final 可以修饰方法，方法就不能被重写</li><li>final 修饰变量总规则：变量有且仅能被赋值一次</li></ul><p><strong>面试题</strong>：final 和 abstract 的关系是互斥关系，不能同时修饰类或者同时修饰方法！</p><hr><h4 id="修饰变量"><a href="#修饰变量" class="headerlink" title="修饰变量"></a>修饰变量</h4><h5 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h5><p>final 修饰静态成员变量，变量变成了常量</p><p><strong>常量：有 public static final 修饰，名称字母全部大写，多个单词用下划线连接。</strong></p><p>final 修饰静态成员变量可以在哪些地方赋值：</p><ol><li><p>定义的时候赋值一次</p></li><li><p>可以在静态代码块中赋值一次</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalDemo</span> </span>&#123;<span class="comment">//常量：public static final修饰，名称字母全部大写，下划线连接。    public static final String SCHOOL_NAME = &quot;张三&quot; ;    public static final String SCHOOL_NAME1;    static&#123;        //SCHOOL_NAME = &quot;java&quot;;//报错        SCHOOL_NAME1 = &quot;张三1&quot;;        //SCHOOL_NAME1 = &quot;张三2&quot;; // 报错，第二次赋值！    &#125;&#125;</span></span><br></pre></td></tr></table></figure><h5 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h5><p>final 修饰变量的总规则：有且仅能被赋值一次</p><p>final 修饰实例成员变量可以在哪些地方赋值 1 次：</p><ol><li>定义的时候赋值一次</li><li>可以在实例代码块中赋值一次</li><li>可以在每个构造器中赋值一次</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalDemo</span> </span>&#123;    <span class="keyword">private</span> <span class="keyword">final</span> String name = <span class="string">&quot;张三&quot;</span> ;    <span class="keyword">private</span> <span class="keyword">final</span> String name1;    <span class="keyword">private</span> <span class="keyword">final</span> String name2;    &#123;        <span class="comment">// 可以在实例代码块中赋值一次。        name1 = &quot;张三1&quot;;    &#125;//构造器赋值一次    public FinalDemo()&#123;        name2 = &quot;张三2&quot;;    &#125;    public FinalDemo(String a)&#123;        name2 = &quot;张三2&quot;;    &#125;    public static void main(String[] args) &#123;        FinalDemo f1 = new FinalDemo();        //f1.name = &quot;张三1&quot;; // 第二次赋值 报错！    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><h4 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h4><blockquote><p>父类知道子类要完成某个功能，但是每个子类实现情况不一样。</p></blockquote><p>抽象方法：没有方法体，只有方法签名，必须用<strong>abstract</strong>修饰的方法就是抽象方法</p><p>抽象类：拥有抽象方法的类必须定义成抽象类，必须用<strong>abstract</strong>修饰，抽象类是为了被继承</p><p>一个类继承抽象类，<strong>必须重写抽象类的全部抽象方法</strong>，否则这个类必须定义成抽象类，因为拥有抽象方法的类必须定义成抽象类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractDemo</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        Dog d = <span class="keyword">new</span> Dog();        d.run();    &#125;&#125;<span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;         System.out.println(<span class="string">&quot;🐕跑&quot;</span>);     &#125;&#125;<span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="面试问题-1"><a href="#面试问题-1" class="headerlink" title="面试问题"></a>面试问题</h4><p>一、抽象类是否有构造器，是否可以创建对象?<br>答：抽象类作为类一定有构造器，而且必须有构造器，提供给子类继承后调用父类构造器使用的</p><ul><li>抽象类有构造器，但是抽象类不能创建对象，类的其他成分它都具备</li><li>抽象类中存在抽象方法，但不能执行，<strong>抽象类中也可没有抽象方法</strong></li></ul><blockquote><p>抽象在学术上本身意味着不能实例化</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractDemo</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        <span class="comment">//Animal a = new Animal(); 抽象类不能创建对象！        //a.run(); // 抽象方法不能执行    &#125;&#125;abstract class Animal&#123;    private String name;    public static String schoolName = &quot;张三&quot;;    public Animal()&#123; &#125;    public abstract void run();    //普通方法    public void go()&#123; &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>二、static 与 abstract 能同时使用吗？</p><p>答：不能，被 static 修饰的方法属于类，是类自己的东西，不是给子类来继承的，而抽象方法本身没有实现，就是用来给子类继承</p><hr><h4 id="存在意义"><a href="#存在意义" class="headerlink" title="存在意义"></a>存在意义</h4><p><strong>被继承</strong>，抽象类就是为了被子类继承，否则抽象类将毫无意义（核心）</p><p>抽象类体现的是”模板思想”：<strong>部分实现，部分抽象</strong>，可以使用抽象类设计一个模板模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//作文模板public class ExtendsDemo &#123;    public static void main(String[] args) &#123;        Student xiaoMa = new Student();        xiaoMa.write();    &#125;&#125;class Student extends Template&#123;    @Override    public String writeText() &#123;return &quot;\t内容&quot;&#125;&#125;// 1.写一个模板类：代表了作文模板。abstract class Template&#123;    private String title = &quot;\t\t\t\t\t标题&quot;;    private String start = &quot;\t开头&quot;;    private String last = &quot;\t结尾&quot;;    public void write()&#123;        System.out.println(title+&quot;\n&quot;+start);        System.out.println(writeText());        System.out.println(last);    &#125;    // 正文部分定义成抽象方法，交给子类重写！！    public abstract String writeText();&#125;</span></span><br></pre></td></tr></table></figure><hr><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><h4 id="基本介绍-4"><a href="#基本介绍-4" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>接口，是 Java 语言中一种引用类型，是方法的集合。</p><p>接口是更加彻底的抽象，接口中只有抽象方法和常量，没有其他成分，jdk1.8 前</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="class"><span class="keyword">interface</span> 接口名称</span>&#123;<span class="comment">// 抽象方法// 默认方法// 静态方法// 私有方法&#125;</span></span><br></pre></td></tr></table></figure><ul><li><p>抽象方法：接口中的抽象方法默认会加上public abstract修饰，所以可以省略不写</p></li><li><p>静态方法：静态方法必须有方法体</p></li><li><p>常量：常量是public static final修饰的成员变量，仅能被赋值一次，值不能改变。常量的名称规范上要求全部大写，多个单词下划线连接。public static final可以省略不写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InterfaceDemo</span></span>&#123;    <span class="comment">//public static final String SCHOOL_NAME = &quot;张三&quot;;String SCHOOL_NAME = &quot;张三&quot;;        //public abstract void run();    void run();//默认补充&#125;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h4><p>作用：<strong>接口是用来被类实现的。</strong></p><p>类与类是继承关系：一个类只能直接继承一个父类，单继承<br>类与接口是实现关系：一个类可以实现多个接口，多实现，接口不能继承类<br>接口与接口继承关系：<strong>多继承</strong></p><blockquote><p>子类   继承   父类<br>实现类 实现   接口</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="class"><span class="keyword">class</span> 实现类名称 <span class="keyword">implements</span> 接口1,接口2,接口3,....</span>&#123;&#125;修饰符 <span class="class"><span class="keyword">interface</span> 接口名 <span class="title">extend</span> 接口1,接口2,接口3,....</span>&#123;    &#125;</span><br></pre></td></tr></table></figure><p>实现多个接口的使用注意事项：</p><ol><li><p>当一个类实现多个接口时，多个接口中存在同名的静态方法并不会冲突，只能通过各自接口名访问静态方法</p></li><li><p>当一个类实现多个接口时，多个接口中存在同名的默认方法，实现类必须重写这个方法</p></li><li><p>当一个类，既继承一个父类，又实现若干个接口时，父类中的成员方法与接口中的默认方法重名，子类<strong>就近选择执行父类</strong>的成员方法</p></li><li><p>接口中，没有构造器，<strong>不能创建对象</strong>，接口是更彻底的抽象，连构造器都没有，自然不能创建对象！！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterfaceDemo</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        Student s = <span class="keyword">new</span> Student();        s.run();        s.rule();    &#125;&#125;<span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Food</span>, <span class="title">Person</span></span>&#123;    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;&#125;        <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;&#125;&#125;<span class="class"><span class="keyword">interface</span> <span class="title">Food</span></span>&#123;    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;&#125;<span class="class"><span class="keyword">interface</span> <span class="title">Person</span></span>&#123;    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;&#125;<span class="comment">//可以直接 interface Person extend Food,//然后 class Student implements Person 效果一样</span></span><br></pre></td></tr></table></figure></li></ol><hr><h4 id="新增功能"><a href="#新增功能" class="headerlink" title="新增功能"></a>新增功能</h4><p>jdk1.8 以后新增的功能：</p><ul><li>默认方法（就是普通实例方法）<ul><li>必须用 default 修饰，默认会 public 修饰</li><li>必须用接口的实现类的对象来调用</li></ul></li><li>静态方法<ul><li>默认会 public 修饰</li><li>接口的静态方法必须用接口的类名本身来调用</li><li>调用格式：ClassName.method()</li></ul></li><li>私有方法：JDK 1.9 才开始有的，只能在<strong>本类中</strong>被其他的默认方法或者私有方法访问</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterfaceDemo</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        <span class="comment">// 1.默认方法调用：必须用接口的实现类对象调用。        Man m = new Man();        m.run();        m.work();        // 2.接口的静态方法必须用接口的类名本身来调用。        InterfaceJDK8.inAddr();    &#125;&#125;class Man implements InterfaceJDK8&#123;    @Override    public void work() &#123;        System.out.println(&quot;工作中。。。&quot;);    &#125;&#125;interface InterfaceJDK8&#123;    //抽象方法！！    void work();    // a.默认方法（就是之前写的普通实例方法）    // 必须用接口的实现类的对象来调用。    default void run()&#123;        go();        System.out.println(&quot;开始跑步🏃‍&quot;);    &#125;    // b.静态方法    // 注意：接口的静态方法必须用接口的类名本身来调用    static void inAddr()&#123;        System.out.println(&quot;我们在武汉&quot;);    &#125;        // c.私有方法（就是私有的实例方法）: JDK 1.9才开始有的。    // 只能在本接口中被其他的默认方法或者私有方法访问。    private void go()&#123;        System.out.println(&quot;开始。。&quot;);    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="对比抽象类"><a href="#对比抽象类" class="headerlink" title="对比抽象类"></a>对比抽象类</h4><table><thead><tr><th><strong>参数</strong></th><th><strong>抽象类</strong></th><th><strong>接口</strong></th></tr></thead><tbody><tr><td>默认的方法实现</td><td>可以有默认的方法实现</td><td>接口完全是抽象的，jdk8 以后有默认的实现</td></tr><tr><td>实现</td><td>子类使用 <strong>extends</strong> 关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。</td><td>子类使用关键字 <strong>implements</strong> 来实现接口。它需要提供接口中所有声明的方法的实现</td></tr><tr><td>构造器</td><td>抽象类可以有构造器</td><td>接口不能有构造器</td></tr><tr><td>与正常Java类的区别</td><td>除了不能实例化抽象类之外，和普通 Java 类没有任何区别</td><td>接口是完全不同的类型</td></tr><tr><td>访问修饰符</td><td>抽象方法有 <strong>public</strong>、<strong>protected</strong> 和 <strong>default</strong> 这些修饰符</td><td>接口方法默认修饰符是 <strong>public</strong>，别的修饰符需要有方法体</td></tr><tr><td>main方法</td><td>抽象方法可以有 main 方法并且我们可以运行它</td><td>jdk8 以前接口没有 main 方法，不能运行；jdk8 以后接口可以有 default 和 static 方法，可以运行 main 方法</td></tr><tr><td>多继承</td><td>抽象方法可以继承一个类和实现多个接口</td><td>接口可以继承一个或多个其它接口，接口不可继承类</td></tr><tr><td>速度</td><td>比接口速度要快</td><td>接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法</td></tr><tr><td>添加新方法</td><td>如果往抽象类中添加新的方法，可以给它提供默认的实现，因此不需要改变现在的代码</td><td>如果往接口中添加方法，那么必须改变实现该接口的类</td></tr></tbody></table><hr><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><h4 id="基本介绍-5"><a href="#基本介绍-5" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>多态的概念：同一个实体同时具有多种形式同一个类型的对象，执行同一个行为，在不同的状态下会表现出不同的行为特征。</p><p>多态的格式：</p><ul><li>父类类型范围 &gt; 子类类型范围</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">父类类型 对象名称 = <span class="keyword">new</span> 子类构造器;接口  对象名称 = <span class="keyword">new</span> 实现类构造器;</span><br></pre></td></tr></table></figure><p>多态的执行：</p><ul><li>对于方法的调用：<strong>编译看左边，运行看右边</strong>（分派机制）</li><li>对于变量的调用：<strong>编译看左边，运行看左边</strong></li></ul><p>多态的使用规则：</p><ul><li>必须存在继承或者实现关系</li><li>必须存在父类类型的变量引用子类类型的对象</li><li>存在方法重写</li></ul><p>多态的优势：</p><ul><li>在多态形式下，右边对象可以实现组件化切换，业务功能也随之改变，便于扩展和维护。可以实现类与类之间的<strong>解耦</strong></li><li>父类类型作为方法形式参数，传递子类对象给方法，可以传入一切子类对象进行方法的调用，更能体现出多态的<strong>扩展性</strong>与便利性</li></ul><p>多态的劣势： </p><ul><li>多态形式下，不能直接调用子类特有的功能，因为编译看左边，父类中没有子类独有的功能，所以代码在编译阶段就直接报错了！ </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PolymorphicDemo</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        Animal c = <span class="keyword">new</span> Cat();        c.run();        <span class="comment">//c.eat();//报错  编译看左边 需要强转        go(c);        go(new Dog);       &#125;    //用 Dog或者Cat 都没办法让所有动物参与进来，只能用Anima    public static void go(Animal d)&#123;&#125;    &#125;class Dog extends Animal&#123;&#125;class Cat extends Animal&#123;    public void eat();    @Override    public void run()&#123;&#125;&#125;class Animal&#123;    public void run()&#123;&#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="上下转型"><a href="#上下转型" class="headerlink" title="上下转型"></a>上下转型</h4><blockquote><p>基本数据类型的转换：<br>1.小范围类型的变量或者值可以直接赋值给大范围类型的变量。<br>2.大范围类型的变量或者值必须强制类型转换给小范围类型的变量。</p></blockquote><p>引用数据类型的<strong>自动</strong>类型转换语法：子类类型的对象或者变量可以自动类型转换赋值给父类类型的变量。</p><p><strong>父类引用指向子类对象</strong></p><ul><li>**向上转型(upcasting)**：通过子类对象(小范围)实例化父类对象(大范围)，这种属于自动转换</li><li>**向下转型(downcasting)**：通过父类对象(大范围)实例化子类对象(小范围)，这种属于强制转换</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PolymorphicDemo</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;        Animal a = <span class="keyword">new</span> Cat();<span class="comment">//向上转型        Cat c = (Cat)a;//向下转型    &#125;&#125;class Animal&#123;&#125;class Cat extends Animal&#123;&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h4><p>instanceof：判断左边的对象是否是右边的类的实例，或者是其直接或间接子类，或者是其接口的实现类</p><ul><li>引用类型强制类型转换：父类类型的变量或者对象强制类型转换成子类类型的变量，否则报错</li><li>强制类型转换的格式：<strong>类型 变量名称 = (类型)(对象或者变量)</strong></li><li>有继承/实现关系的两个类型就可以进行强制类型转换，编译阶段一定不报错，但是运行阶段可能出现类型转换异常 ClassCastException</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;Aniaml a = <span class="keyword">new</span> Dog();<span class="comment">//Dog d = (Dog)a;        //Cat c = (Cat)a; 编译不报错，运行报ClassCastException错误        if(a instanceof Cat)&#123;            Cat c = (Cat)a;         &#125; else if(a instanceof Dog) &#123;            Dog d = (Dog)a;        &#125;    &#125;&#125;class Dog extends Animal&#123;&#125;class Cat extends Animal&#123;&#125;class Animal&#123;&#125;</span></span><br></pre></td></tr></table></figure><hr><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>内部类是类的五大成分之一：成员变量，方法，构造器，代码块，内部类</p><p>概念：定义在一个类里面的类就是内部类</p><p>作用：提供更好的封装性，体现出组件思想，<strong>间接解决类无法多继承引起的一系列问题</strong></p><p>分类：静态内部类、实例内部类（成员内部类）、局部内部类、<strong>匿名内部类</strong>（重点）</p><hr><h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p>定义：有static修饰，属于外部类本身，会加载一次</p><p>静态内部类中的成分研究：</p><ul><li>类有的成分它都有，静态内部类属于外部类本身，只会加载一次</li><li>特点与外部类是完全一样的，只是位置在别人里面</li><li>可以定义静态成员</li></ul><p>静态内部类的访问格式：外部类名称.内部类名称</p><p>静态内部类创建对象的格式：外部类名称.内部类名称 对象名称 = new 外部类名称.内部类构造器;</p><p>静态内部类的访问拓展：</p><ul><li>静态内部类中是否可以直接访问外部类的静态成员?    可以，外部类的静态成员只有一份，可以被共享</li><li>静态内部类中是否可以直接访问外部类的实例成员?    不可以，外部类的成员必须用外部类对象访问</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;        Outter.Inner in = <span class="keyword">new</span> Outter.Inner();    &#125;&#125;<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Outter</span></span>&#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> age;    <span class="keyword">private</span> <span class="keyword">double</span> salary;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;         <span class="comment">//拥有类的所有功能 构造器 方法 成员变量         System.out.println(age);         //System.out.println(salary);报错&#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="实例内部类"><a href="#实例内部类" class="headerlink" title="实例内部类"></a>实例内部类</h4><p>定义：无static修饰的内部类，属于外部类的每个对象，跟着外部类对象一起加载。</p><p>实例内部类的成分特点：实例内部类中不能定义静态成员，其他都可以定义</p><p>实例内部类的访问格式：外部类名称.内部类名称</p><p>创建对象的格式：外部类名称.内部类名称 对象名称 = new 外部类构造器.new 内部构造器;</p><ul><li><code>Outter.Inner in = new Outter().new Inner();</code></li></ul><p>拓展：<strong>实例内部类可以访问外部类的全部成员</strong></p><blockquote><ul><li>实例内部类中是否可以直接访问外部类的静态成员？<br>可以，外部类的静态成员可以被共享访问！</li><li>实例内部类中是否可以访问外部类的实例成员？<br>可以，实例内部类属于外部类对象，可以直接访问外部类对象的实例成员！</li></ul></blockquote><hr><h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><p>局部内部类：定义在方法中，在构造器中，代码块中，for循环中定义的内部类。</p><p>局部内部类中的成分特点：只能定义实例成员，不能定义静态成员</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;        String name;        <span class="class"><span class="keyword">class</span></span>&#123;&#125;    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;<span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;&#125;<span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;&#125;  &#125;&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><p>匿名内部类：没有名字的局部内部类<br>作用：简化代码，是开发中常用的形式</p><p>匿名内部类的格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 类名|抽象类|接口(形参)&#123;<span class="comment">//方法重写。&#125;</span></span><br></pre></td></tr></table></figure><p> 匿名内部类的特点：</p><ul><li>匿名内部类不能定义静态成员</li><li>匿名内部类一旦写出来，就会立即创建一个匿名内部类的对象返回</li><li><strong>匿名内部类的对象的类型相当于是当前new的那个的类型的子类类型</strong></li><li>匿名内部类引用局部变量必须是<strong>常量</strong>，底层创建为内部类的成员变量（原因：JVM → 运行机制 → 代码优化）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Anonymity</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        Animal a = <span class="keyword">new</span> Animal()&#123;            <span class="meta">@Override</span>            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;                System.out.println(<span class="string">&quot;猫跑的贼溜~~&quot;</span>);                <span class="comment">//System.out.println(n);            &#125;        &#125;;        a.run();        a.go();    &#125;&#125;abstract class Animal&#123;    public abstract void run();    public void go()&#123;        System.out.println(&quot;开始go~~~&quot;);    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h3 id="权限符"><a href="#权限符" class="headerlink" title="权限符"></a>权限符</h3><p>权限修饰符：有四种<strong>（private -&gt; 缺省 -&gt; protected - &gt; public ）</strong><br>可以修饰成员变量，修饰方法，修饰构造器，内部类，不同修饰符修饰的成员能够被访问的权限将受到限制!</p><table><thead><tr><th>四种修饰符访问权限</th><th align="center">private</th><th align="center">缺省</th><th align="center">protected</th><th align="center">public</th></tr></thead><tbody><tr><td>本类中</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td>本包下的子类中</td><td align="center">X</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td>本包下其他类中</td><td align="center">X</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td>其他包下的子类中</td><td align="center">X</td><td align="center">X</td><td align="center">√</td><td align="center">√</td></tr><tr><td>其他包下的其他类中</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">√</td></tr></tbody></table><p>protected 用于修饰成员，表示在继承体系中成员对于子类可见</p><ul><li>基类的 protected 成员是包内可见的，并且对子类可见</li><li>若子类与基类不在同一包中，那么子类实例可以访问其从基类继承而来的 protected 方法（重写），而不能访问基类实例的 protected 方法</li></ul><hr><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><h4 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h4><p>静态代码块的格式：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>静态代码块特点： <ul><li>必须有static修饰</li><li>会与类一起优先加载，且自动触发执行一次</li><li>只能访问静态资源</li></ul></li><li>静态代码块作用：<ul><li>可以在执行类的方法等操作之前先在静态代码块中进行静态资源的初始化 </li><li><strong>先执行静态代码块，在执行main函数里的操作</strong></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CodeDemo</span> </span>&#123;    <span class="keyword">public</span> <span class="keyword">static</span> String schoolName ;    <span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;String&gt; lists = <span class="keyword">new</span> ArrayList&lt;&gt;();    <span class="comment">// 静态代码块,属于类，与类一起加载一次!    static &#123;        System.out.println(&quot;静态代码块被触发执行~~~~~~~&quot;);        // 在静态代码块中进行静态资源的初始化操作        schoolName = &quot;张三&quot;;        lists.add(&quot;3&quot;);        lists.add(&quot;4&quot;);        lists.add(&quot;5&quot;);    &#125;    public static void main(String[] args) &#123;        System.out.println(&quot;main方法被执行&quot;);        System.out.println(schoolName);        System.out.println(lists);    &#125;&#125;/*静态代码块被触发执行~~~~~~~main方法被执行张三[3, 4, 5] */</span></span><br></pre></td></tr></table></figure><hr><h4 id="实例代码块"><a href="#实例代码块" class="headerlink" title="实例代码块"></a>实例代码块</h4><p>实例代码块的格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li><p>实例代码块的特点：</p><ul><li>无static修饰，属于对象</li><li>会与类的对象一起加载，每次创建类的对象的时候，实例代码块都会被加载且自动触发执行一次</li><li>实例代码块的代码在底层实际上是提取到每个构造器中去执行的</li></ul></li><li><p>实例代码块的作用：实例代码块可以在创建对象之前进行实例资源的初始化操作</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CodeDemo</span> </span>&#123;    <span class="keyword">private</span> String name;    <span class="keyword">private</span> ArrayList&lt;String&gt; lists = <span class="keyword">new</span> ArrayList&lt;&gt;();    &#123;        name = <span class="string">&quot;代码块&quot;</span>;        lists.add(<span class="string">&quot;java&quot;</span>);        System.out.println(<span class="string">&quot;实例代码块被触发执行一次~~~~~~~~&quot;</span>);    &#125;    <span class="function"><span class="keyword">public</span> <span class="title">CodeDemo02</span><span class="params">()</span></span>&#123; &#125;<span class="comment">//构造方法    public CodeDemo02(String name)&#123;&#125;    public static void main(String[] args) &#123;        CodeDemo c = new CodeDemo();//实例代码块被触发执行一次        System.out.println(c.name);        System.out.println(c.lists);        new CodeDemo02();//实例代码块被触发执行一次    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><h4 id="基本介绍-6"><a href="#基本介绍-6" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>Object 类是 Java 中的祖宗类，一个类或者默认继承 Object 类，或者间接继承 Object 类，Object 类的方法是一切子类都可以直接使用</p><p>Object 类常用方法：</p><ul><li><code>public String toString()</code>：默认是返回当前对象在堆内存中的地址信息：类的全限名@内存地址，例：Student@735b478；<ul><li>直接输出对象名称，默认会调用 toString() 方法，所以省略 toString() 不写；</li><li>如果输出对象的内容，需要重写 toString() 方法，toString 方法存在的意义是为了被子类重写</li></ul></li><li><code>public boolean equals(Object o)</code>：默认是比较两个对象的引用是否相同</li><li><code>protected Object clone()</code>：创建并返回此对象的副本 </li></ul><p>只要两个对象的内容一样，就认为是相等的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;<span class="comment">// 1.判断是否自己和自己比较，如果是同一个对象比较直接返回trueif (this == o) return true;// 2.判断被比较者是否为null ,以及是否是学生类型。if (o == null || this.getClass() != o.getClass()) return false;// 3.o一定是学生类型，强制转换成学生，开始比较内容！Student student = (Student) o;return age == student.age &amp;&amp;           sex == student.sex &amp;&amp;           Objects.equals(name, student.name);&#125;</span></span><br></pre></td></tr></table></figure><p><strong>面试题</strong>：== 和 equals 的区别</p><ul><li>== 比较的是变量（栈）内存中存放的对象的（堆）内存地址，用来判断两个对象的<strong>地址</strong>是否相同，即是否是指相同一个对象，比较的是真正意义上的指针操作</li><li>Object 类中的方法，默认比较两个对象的引用，重写 equals 方法比较的是两个对象的<strong>内容</strong>是否相等，所有的类都是继承自 java.lang.Object 类，所以适用于所有对象</li></ul><p>hashCode 的作用：</p><ul><li>hashCode 的存在主要是用于查找的快捷性，如 Hashtable，HashMap 等，可以在散列存储结构中确定对象的存储地址</li><li>如果两个对象相同，就是适用于 equals(java.lang.Object) 方法，那么这两个对象的 hashCode 一定要相同</li><li>哈希值相同的数据不一定内容相同，内容相同的数据哈希值一定相同</li></ul><hr><h4 id="深浅克隆"><a href="#深浅克隆" class="headerlink" title="深浅克隆"></a>深浅克隆</h4><p>深浅拷贝（克隆）的概念：</p><ul><li><p>浅拷贝 (shallowCopy)：<strong>对基本数据类型进行值传递，对引用数据类型只是复制了引用</strong>，被复制对象属性的所有的引用仍然指向原来的对象，简而言之就是增加了一个指针指向原来对象的内存地址</p><p>Java 中的复制方法基本都是浅克隆：Object.clone()、System.arraycopy()、Arrays.copyOf()</p></li><li><p>深拷贝 (deepCopy)：对基本数据类型进行值传递，对引用数据类型是一个整个独立的对象拷贝，会拷贝所有的属性并指向的动态分配的内存，简而言之就是把所有属性复制到一个新的内存，增加一个指针指向新内存。所以使用深拷贝的情况下，释放内存的时候不会出现使用浅拷贝时释放同一块内存的错误</p></li></ul><p>Object 的 clone() 是 protected 方法，一个类不显式去重写 clone()，就不能直接去调用该类实例的 clone() 方法</p><p>Cloneable 接口是一个标识性接口，即该接口不包含任何方法（包括clone()），但是如果一个类想合法的进行克隆，那么就必须实现这个接口，在使用 clone() 方法时，若该类未实现 Cloneable 接口，则抛出异常</p><ul><li><p>Clone &amp; Copy：<code>Student s = new Student</code></p><p><code>Student s1 = s</code>：只是 copy 了一下 reference，s 和 s1 指向内存中同一个 object，对对象的修改会影响对方</p><p><code>Student s2 = s.clone()</code>：会生成一个新的Student对象，并且和s具有相同的属性值和方法</p></li><li><p>Shallow Clone &amp; Deep Clone：</p><p>浅克隆：Object 中的 clone() 方法在对某个对象克隆时对其仅仅是简单地执行域对域的 copy</p><ul><li>对基本数据类型和包装类的克隆是没有问题的。String、Integer 等包装类型在内存中是不可以被改变的对象，所以在使用克隆时可以视为基本类型，只需浅克隆引用即可</li><li>如果对一个引用类型进行克隆时只是克隆了它的引用，和原始对象共享对象成员变量</li></ul><p><img src="https://gitee.com/seazean/images/raw/master/Java/Object%E6%B5%85%E5%85%8B%E9%9A%86.jpg"></p><p>深克隆：在对整个对象浅克隆后，对其引用变量进行克隆，并将其更新到浅克隆对象中去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span>  <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;    <span class="keyword">private</span> String name;    <span class="keyword">private</span> Integer age;    <span class="keyword">private</span> Date date;    <span class="meta">@Override</span>    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;        Student s = (Student) <span class="keyword">super</span>.clone();        s.date = (Date) date.clone();        <span class="keyword">return</span> s;    &#125;    <span class="comment">//.....&#125;</span></span><br></pre></td></tr></table></figure></li></ul><p>SDP → 创建型 → 原型模式</p><hr><h3 id="Objects"><a href="#Objects" class="headerlink" title="Objects"></a>Objects</h3><p>Objects 类与 Object 是继承关系。</p><p>Objects的方法：</p><ul><li><p><code>public static boolean equals(Object a, Object b)</code> : 比较两个对象是否相同。<br>底层进行非空判断，从而可以避免空指针异常，更安全！！推荐使用！！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object a, Object b)</span> </span>&#123;    <span class="keyword">return</span> a == b || a != <span class="keyword">null</span> &amp;&amp; a.equals(b);&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>public static boolean isNull(Object obj)</code> : 判断变量是否为null ,为null返回true ,反之！</p></li><li><p><code>public static String toString(对象)</code> : 返回参数中对象的字符串表示形式</p></li><li><p><code>public static String toString(对象, 默认字符串)</code> : 返回对象的字符串表示形式。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectsDemo</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        Student s1 = <span class="keyword">null</span>;        Student s2 = <span class="keyword">new</span> Student();        System.out.println(Objects.equals(s1 , s2));<span class="comment">//推荐使用        // System.out.println(s1.equals(s2)); // 空指针异常         System.out.println(Objects.isNull(s1));        System.out.println(s1 == null);//直接判断比较好    &#125;&#125;public class Student &#123;&#125;</span></span><br></pre></td></tr></table></figure><hr><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h4 id="基本介绍-7"><a href="#基本介绍-7" class="headerlink" title="基本介绍"></a>基本介绍</h4><p><strong>String 被声明为 final，因此不可被继承 (Integer 等包装类也不能被继承）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123; <span class="comment">/** The value is used for character storage. */</span>    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] value;    <span class="comment">/** The identifier of the encoding used to encode the bytes in &#123;<span class="doctag">@code</span> value&#125;. */</span>    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span> coder;&#125;</span><br></pre></td></tr></table></figure><p>在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 <code>coder</code> 来标识使用了哪种编码</p><p>value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组，并且 String 内部没有改变 value 数组的方法，因此可以<strong>保证 String 不可变，也保证线程安全</strong></p><p><strong>注意：不能改变的意思是每次更改字符串都会产生新的对象，并不是对原始对象进行改变</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">&quot;abc&quot;</span>;s = s + <span class="string">&quot;cd&quot;</span>; <span class="comment">//s = abccd 新对象</span></span><br></pre></td></tr></table></figure><hr><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><p>常用 API：</p><ul><li><p><code>public boolean equals(String s)</code> : 比较两个字符串内容是否相同、区分大小写</p></li><li><p><code>public boolean equalsIgnoreCase(String anotherString)</code> : 比较字符串的内容，忽略大小写</p></li><li><p><code>public int length()</code> : 返回此字符串的长度</p></li><li><p><code>public String trim()</code> : 返回一个字符串，其值为此字符串，并删除任何前导和尾随空格</p></li><li><p><code>public String[] split(String regex)</code> : 将字符串按给定的正则表达式分割成字符串数组</p></li><li><p><code>public char charAt(int index)</code> : 取索引处的值</p></li><li><p><code>public char[] toCharArray()</code> : 将字符串拆分为字符数组后返回</p></li><li><p><code>public boolean startsWith(String prefix)</code> : 测试此字符串是否以指定的前缀开头</p></li><li><p><code>public int indexOf(String str)</code> : 返回指定子字符串第一次出现的字符串内的索引，没有返回 -1</p></li><li><p><code>public int lastIndexOf(String str)</code> : 返回字符串最后一次出现str的索引，没有返回 -1</p></li><li><p><code>public String substring(int beginIndex)</code> : 返回子字符串，以原字符串指定索引处到结尾</p></li><li><p><code>public String substring(int i, int j)</code> : 指定索引处扩展到 j - 1 的位置，字符串长度为 j - i</p></li><li><p><code>public String toLowerCase()</code> : 将此 String 所有字符转换为小写，使用默认语言环境的规则</p></li><li><p><code>public String toUpperCase()</code> : 使用默认语言环境的规则将此 String 所有字符转换为大写</p></li><li><p><code>public String replace(CharSequence target, CharSequence replacement)</code> : 使用新值，将字符串中的旧值替换，得到新的字符串</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="number">123</span>-<span class="number">78</span>;s.replace(<span class="string">&quot;-&quot;</span>,<span class="string">&quot;&quot;</span>);<span class="comment">//12378</span></span><br></pre></td></tr></table></figure><hr><h4 id="构造方式"><a href="#构造方式" class="headerlink" title="构造方式"></a>构造方式</h4><p>构造方法：</p><ul><li><code>public String()</code> : 创建一个空白字符串对象，不含有任何内容</li><li><code>public String(char[] chs)</code> : 根据字符数组的内容，来创建字符串对象</li><li><code>public String(String original)</code> : 根据传入的字符串内容，来创建字符串对象</li></ul><p>直接赋值：<code>String s = &quot;abc&quot;</code> 直接赋值的方式创建字符串对象，内容就是 abc</p><ul><li>通过构造方法创建：通过 new 创建的字符串对象，每一次 new 都会申请一个内存空间，虽然内容相同，但是地址值不同，<strong>返回堆内存中对象的引用</strong></li><li>直接赋值方式创建：以“ ”方式给出的字符串，只要字符序列相同（顺序和大小写），无论在程序代码中出现几次，JVM 都只会<strong>在 String Pool 中创建一个字符串对象</strong>，并在字符串池中维护</li></ul><p><code>String str = new String(&quot;abc&quot;)</code> 创建字符串对象：</p><ul><li>创建一个对象：字符串池中已经存在 abc 对象，那么直接在创建一个对象放入堆中，返回堆内引用</li><li>创建两个对象：字符串池中未找到 abc 对象，那么分别在堆中和字符串池中创建一个对象，字符串池中的比较都是采用 equals() <img src="https://gitee.com/seazean/images/raw/master/Java/String构造方法字节码.png" style="zoom: 67%;"></li></ul><p><code>new String(&quot;a&quot;) + new String(&quot;b&quot;)</code> 创建字符串对象：</p><ul><li><p>对象 1：new StringBuilder()</p></li><li><p>对象 2：new String(“a”)、对象 3：常量池中的 a</p></li><li><p>对象 4：new String(“b”)、对象 5：常量池中的 b</p><img src="https://gitee.com/seazean/images/raw/master/Java/String拼接方法字节码.png" style="zoom:67%;"></li><li><p>StringBuilder 的 toString()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Overridepublic</span> <span class="function">String <span class="title">toString</span><span class="params">()</span> </span>&#123;    <span class="keyword">return</span> <span class="keyword">new</span> String(value, <span class="number">0</span>, count);&#125;</span><br></pre></td></tr></table></figure><ul><li>对象 6：new String(“ab”)</li><li>StringBuilder 的 toString() 调用，<strong>在字符串常量池中没有生成 ab</strong>，new String(“ab”) 会创建两个对象因为传参数的时候使用字面量创建了对象 ab，当使用数组构造 String 对象时，没有加入常量池的操作</li></ul></li></ul><hr><h4 id="String-Pool"><a href="#String-Pool" class="headerlink" title="String Pool"></a>String Pool</h4><h5 id="基本介绍-8"><a href="#基本介绍-8" class="headerlink" title="基本介绍"></a>基本介绍</h5><p>字符串常量池（String Pool / StringTable / 串池）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定，常量池类似于 Java 系统级别提供的<strong>缓存</strong>，存放对象和引用</p><ul><li>StringTable，类似 HashTable 结构，通过 <code>-XX:StringTableSize</code> 设置大小，JDK 1.8 中默认 60013</li><li>常量池中的字符串仅是符号，第一次使用时才变为对象，可以避免重复创建字符串对象</li><li>字符串<strong>变量</strong>的拼接的原理是 StringBuilder#append，append 方法比字符串拼接效率高（JDK 1.8）</li><li>字符串<strong>常量</strong>拼接的原理是编译期优化，拼接结果放入常量池</li><li>可以使用 String 的 intern() 方法在运行过程将字符串添加到 String Pool 中</li></ul><hr><h5 id="intern"><a href="#intern" class="headerlink" title="intern()"></a>intern()</h5><p>JDK 1.8：当一个字符串调用 intern() 方法时，如果 String Pool 中：</p><ul><li>存在一个字符串和该字符串值相等，就会返回 String Pool 中字符串的引用（需要变量接收）</li><li>不存在，会把对象的<strong>引用地址</strong>复制一份放入串池，并返回串池中的引用地址，前提是堆内存有该对象，因为 Pool 在堆中，为了节省内存不再创建新对象</li></ul><p>JDK 1.6：将这个字符串对象尝试放入串池，如果有就不放入，返回已有的串池中的对象的地址；如果没有会把此对象复制一份，放入串池，把串池中的对象返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;    <span class="comment">// 常量池中的信息都加载到运行时常量池，这时a b ab是常量池中的符号，还不是java字符串对象，是懒惰的    // ldc #2 会把 a 符号变为 &quot;a&quot; 字符串对象     ldc:反编译后的指令    // ldc #3 会把 b 符号变为 &quot;b&quot; 字符串对象    // ldc #4 会把 ab 符号变为 &quot;ab&quot; 字符串对象    public static void main(String[] args) &#123;        String s1 = &quot;a&quot;; // 懒惰的        String s2 = &quot;b&quot;;        String s3 = &quot;ab&quot;;// 串池                String s4 = s1 + s2;// 返回的是堆内地址        // 原理：new StringBuilder().append(&quot;a&quot;).append(&quot;b&quot;).toString()  new String(&quot;ab&quot;)                String s5 = &quot;a&quot; + &quot;b&quot;;  // javac 在编译期间的优化，结果已经在编译期确定为ab        System.out.println(s3 == s4); // false        System.out.println(s3 == s5); // true        String x2 = new String(&quot;c&quot;) + new String(&quot;d&quot;); // new String(&quot;cd&quot;)        // 虽然 new，但是在字符串常量池没有 cd 对象，toString() 方法        x2.intern();        String x1 = &quot;cd&quot;;        System.out.println(x1 == x2); //true    &#125;&#125;</span></span><br></pre></td></tr></table></figure><ul><li>== 比较基本数据类型：比较的是具体的值</li><li>== 比较引用数据类型：比较的是对象地址值</li></ul><p>结论：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">&quot;ab&quot;</span>;<span class="comment">// 仅放入串池String s2 = new String(&quot;a&quot;) + new String(&quot;b&quot;);// 仅放入堆// 上面两条指令的结果和下面的 效果 相同String s = new String(&quot;ab&quot;);</span></span><br></pre></td></tr></table></figure><hr><h5 id="面试问题-2"><a href="#面试问题-2" class="headerlink" title="面试问题"></a>面试问题</h5><p>问题一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    String s = <span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;b&quot;</span>);<span class="comment">//new String(&quot;ab&quot;)    //在上一行代码执行完以后，字符串常量池中并没有&quot;ab&quot;    String s2 = s.intern();    //jdk6：串池中创建一个字符串&quot;ab&quot;    //jdk8：串池中没有创建字符串&quot;ab&quot;,而是创建一个引用指向new String(&quot;ab&quot;)，将此引用返回    System.out.println(s2 == &quot;ab&quot;);//jdk6:true  jdk8:true    System.out.println(s == &quot;ab&quot;);//jdk6:false  jdk8:true&#125;</span></span><br></pre></td></tr></table></figure><p>问题二：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    String str1 = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;58&quot;</span>).append(<span class="string">&quot;tongcheng&quot;</span>).toString();    System.out.println(str1 == str1.intern());<span class="comment">//true，字符串池中不存在，把堆中的引用复制一份放入串池    String str2 = new StringBuilder(&quot;ja&quot;).append(&quot;va&quot;).toString();    System.out.println(str2 == str2.intern());//false&#125;</span></span><br></pre></td></tr></table></figure><p>原因：</p><ul><li><p>System 类当调用 Version 的静态方法，导致 Version 初始化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initializeSystemClass</span><span class="params">()</span> </span>&#123;    sun.misc.Version.init();&#125;</span><br></pre></td></tr></table></figure></li><li><p>Version类初始化时需要对静态常量字段初始化，被 launcher_name 静态常量字段所引用的”java”字符串字面量就被放入的字符串常量池：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sun.misc;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Version</span> </span>&#123;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String launcher_name = <span class="string">&quot;java&quot;</span>;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String java_version = <span class="string">&quot;1.8.0_221&quot;</span>;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String java_runtime_name = <span class="string">&quot;Java(TM) SE Runtime Environment&quot;</span>;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String java_profile_name = <span class="string">&quot;&quot;</span>;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String java_runtime_version = <span class="string">&quot;1.8.0_221-b11&quot;</span>;    <span class="comment">//...&#125;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="内存位置"><a href="#内存位置" class="headerlink" title="内存位置"></a>内存位置</h5><p>Java 7之前，String Pool 被放在运行时常量池中，它属于永久代；Java 7以后，String Pool 被移到堆中，这是因为永久代的空间有限，在大量使用字符串的场景下会导致OutOfMemoryError 错误</p><p>演示 StringTable 位置：</p><ul><li><p><code>-Xmx10m</code>设置堆内存10m</p></li><li><p>在jdk8下设置： <code>-Xmx10m -XX:-UseGCOverheadLimit</code>（运行参数在Run Configurations VM options）</p></li><li><p>在jdk6下设置： <code>-XX:MaxPermSize=10m</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();    <span class="keyword">int</span> i = <span class="number">0</span>;    <span class="keyword">try</span> &#123;        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">260000</span>; j++) &#123;            list.add(String.valueOf(j).intern());            i++;        &#125;    &#125; <span class="keyword">catch</span> (Throwable e) &#123;        e.printStackTrace();    &#125; <span class="keyword">finally</span> &#123;        System.out.println(i);    &#125;&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://gitee.com/seazean/images/raw/master/Java/JVM-%E5%86%85%E5%AD%98%E5%9B%BE%E5%AF%B9%E6%AF%94.png"></p><hr><h4 id="优化常量池"><a href="#优化常量池" class="headerlink" title="优化常量池"></a>优化常量池</h4><p>两种方式：</p><ul><li><p>调整 -XX:StringTableSize=桶个数，数量越少，性能越差</p></li><li><p>intern 将字符串对象放入常量池，通过复用字符串的引用，减少内存占用</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** * 演示 intern 减少内存占用 * -XX:StringTableSize=200000 -XX:+PrintStringTableStatistics * -Xsx500m -Xmx500m -XX:+PrintStringTableStatistics -XX:StringTableSize=200000 */</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1_25</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;        List&lt;String&gt; address = <span class="keyword">new</span> ArrayList&lt;&gt;();        System.in.read();        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;            <span class="comment">//很多数据            try (BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(&quot;linux.words&quot;), &quot;utf-8&quot;))) &#123;                String line = null;                long start = System.nanoTime();                while (true) &#123;                    line = reader.readLine();                    if(line == null) &#123;                        break;                    &#125;                    address.add(line.intern());                &#125;                System.out.println(&quot;cost:&quot; +(System.nanoTime()-start)/1000000);            &#125;        &#125;        System.in.read();    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="不可变好处"><a href="#不可变好处" class="headerlink" title="不可变好处"></a>不可变好处</h4><ul><li>可以缓存 hash 值，例如 String 用做 HashMap 的 key，不可变的特性可以使得 hash 值也不可变，只要进行一次计算</li><li>String Pool 的需要，如果一个 String 对象已经被创建过了，就会从 String Pool 中取得引用，只有 String 是不可变的，才可能使用 String Pool</li><li>安全性，String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 的那一方以为现在连接的是其它主机，而实际情况却不一定是</li><li>String 不可变性天生具备线程安全，可以在多个线程中安全地使用</li><li>防止子类继承，破坏 String 的 API 的使用</li></ul><hr><h3 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h3><p>String StringBuffer 和 StringBuilder 区别：</p><ul><li>String : <strong>不可变</strong>的字符序列，线程安全</li><li>StringBuffer : <strong>可变</strong>的字符序列，线程安全，底层方法加 synchronized，效率低</li><li>StringBuilder : <strong>可变</strong>的字符序列，JDK5.0 新增；线程不安全，效率高</li></ul><p>相同点：底层使用 char[] 存储</p><p>构造方法：</p><ul><li><code>public StringBuilder()</code>：创建一个空白可变字符串对象，不含有任何内容</li><li><code>public StringBuilder(String str)</code>：根据字符串的内容，来创建可变字符串对象</li></ul><p>常用API : </p><ul><li><code>public StringBuilder append(任意类型)</code>：添加数据，并返回对象本身</li><li><code>public StringBuilder reverse()</code>：返回相反的字符序列</li><li><code>public String toString()</code>：通过 toString() 就可以实现把 StringBuilder 转换为 String</li></ul><p>存储原理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;abc&quot;</span>;<span class="keyword">char</span> data[] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;;StringBuffer sb1 = <span class="keyword">new</span> StringBuffer();<span class="comment">//new byte[16] sb1.append(&#x27;a&#x27;); //value[0] = &#x27;a&#x27;;</span></span><br></pre></td></tr></table></figure><p>append 源码：扩容为二倍</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;    <span class="keyword">if</span> (str == <span class="keyword">null</span>) <span class="keyword">return</span> appendNull();    <span class="keyword">int</span> len = str.length();    ensureCapacityInternal(count + len);    str.getChars(<span class="number">0</span>, len, value, count);    count += len;    <span class="keyword">return</span> <span class="keyword">this</span>;&#125;<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minimumCapacity)</span> </span>&#123;    <span class="comment">// 创建超过数组长度就新的char数组，把数据拷贝过去    if (minimumCapacity - value.length &gt; 0) &#123;        //int newCapacity = (value.length &lt;&lt; 1) + 2;每次扩容2倍+2        value = Arrays.copyOf(value, newCapacity(minimumCapacity));    &#125;&#125;public void getChars(int srcBegin, int srcEnd, char dst[], int dstBegin) &#123;    // 将字符串中的字符复制到目标字符数组中// 字符串调用该方法，此时value是字符串的值，dst是目标字符数组    System.arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin);&#125;</span></span><br></pre></td></tr></table></figure><hr><h3 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h3><p>Array 的工具类</p><p>常用API：</p><ul><li><code>public static String toString(int[] a)</code>：返回指定数组的内容的字符串表示形式</li><li><code>public static void sort(int[] a)</code>：按照数字顺序排列指定的数组</li><li><code>public static int binarySearch(int[] a, int key)</code>：利用二分查找返回指定元素的索引</li><li><code>public static &lt;T&gt; List&lt;T&gt; asList(T... a)</code>：返回由指定数组支持的列表</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyArraysDemo</span> </span>&#123;      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;<span class="comment">//按照数字顺序排列指定的数组        int [] arr = &#123;3,2,4,6,7&#125;;        Arrays.sort(arr);        System.out.println(Arrays.toString(arr));        int [] arr = &#123;1,2,3,4,5,6,7,8,9,10&#125;;        int index = Arrays.binarySearch(arr, 0);        System.out.println(index);        //1,数组必须有序        //2.如果要查找的元素存在,那么返回的是这个元素实际的索引        //3.如果要查找的元素不存在,那么返回的是 (-插入点-1)            //插入点:如果这个元素在数组中,他应该在哪个索引上.      &#125;  &#125;</span></span><br></pre></td></tr></table></figure><hr><h3 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h3><p>用于生成伪随机数。</p><p>使用步骤：</p><ol><li><p>导入包：<code>import java.util.Random</code></p></li><li><p>创建对象：<code>Random r = new Random()</code></p></li><li><p>随机整数：<code>int num = r.nextInt(10)</code></p><ul><li>解释：10 代表的是一个范围，如果括号写 10，产生的随机数就是 0 - 9，括号写 20 的随机数则是 0 - 19    </li><li>获取 0 - 10：<code>int num = r.nextInt(10 + 1)</code></li></ul></li><li><p>随机小数：<code>public double nextDouble()</code> 从范围 <code>0.0d</code> 至 <code>1.0d</code> （左闭右开），伪随机地生成并返回</p></li></ol><hr><h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><p>构造器：</p><ul><li><code>public Date()</code>：创建当前系统的此刻日期时间对象。</li><li><code>public Date(long time)</code>：把时间毫秒值转换成日期对象</li></ul><p>方法：</p><ul><li><code>public long getTime()</code>：返回自 1970 年 1 月 1 日 00:00:00 GMT 以来总的毫秒数。</li></ul><p>时间记录的两种方式：</p><ol><li>Date日期对象</li><li>时间毫秒值：从1970-01-01 00:00:00开始走到此刻的总的毫秒值。 1s = 1000ms</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateDemo</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        Date d = <span class="keyword">new</span> Date();        System.out.println(d);<span class="comment">//Fri Oct 16 21:58:44 CST 2020        long time = d.getTime() + 121*1000;//过121s是什么时间        System.out.println(time);//1602856875485                Date d1 = new Date(time);        System.out.println(d1);//Fri Oct 16 22:01:15 CST 2020    &#125;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;    Date d = <span class="keyword">new</span> Date();    <span class="keyword">long</span> startTime = d.getTime();    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)&#123;输出i&#125;    <span class="keyword">long</span> endTime = <span class="keyword">new</span> Date().getTime();    System.out.println( (endTime - startTime) / <span class="number">1000.0</span> +<span class="string">&quot;s&quot;</span>);    <span class="comment">//运行一万次输出需要多长时间&#125;</span></span><br></pre></td></tr></table></figure><hr><h3 id="DateFormat"><a href="#DateFormat" class="headerlink" title="DateFormat"></a>DateFormat</h3><p>DateFormat 作用：</p><ol><li>可以把“日期对象”或者“时间毫秒值”格式化成我们喜欢的时间形式（格式化时间）</li><li>可以把字符串的时间形式解析成日期对象（解析字符串时间）</li></ol><p>DateFormat 是一个抽象类，不能直接使用，使用它的子类：SimpleDateFormat</p><p>SimpleDateFormat  简单日期格式化类：</p><ul><li><code>public SimpleDateFormat(String pattern)</code> : 指定时间的格式创建简单日期对象</li><li><code>public String format(Date date) </code> : 把日期对象格式化成我们喜欢的时间形式，返回字符串</li><li><code>public String format(Object time)</code> : 把时间毫秒值格式化成设定的时间形式，返回字符串!</li><li><code>public Date parse(String date)</code> : 把字符串的时间解析成日期对象</li></ul><blockquote><p>yyyy年MM月dd日 HH:mm:ss EEE a” 周几 上午下午</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;Date date = <span class="keyword">new</span> Date();    SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss);    String time = sdf.format(date);    System.out.println(time);//2020-10-18 19:58:34    //过121s后是什么时间    long time = date.getTime();    time+=121;    System.out.println(sdf.formate(time));    String d = &quot;</span><span class="number">2020</span>-<span class="number">10</span>-<span class="number">18</span> <span class="number">20</span>:<span class="number">20</span>:<span class="number">20</span><span class="string">&quot;;//格式一致    Date newDate = sdf.parse(d);    System.out.println(sdf.format(newDate)); //按照前面的方法输出&#125;</span></span><br></pre></td></tr></table></figure><hr><h3 id="Calendar"><a href="#Calendar" class="headerlink" title="Calendar"></a>Calendar</h3><p>Calendar 代表了系统此刻日期对应的日历对象，是一个抽象类，不能直接创建对象</p><p>Calendar 日历类创建日历对象：<code>Calendar rightNow = Calendar.getInstance()</code>（<strong>饿汉单例模式</strong>）</p><p>Calendar 的方法：</p><ul><li><code>public static Calendar getInstance()</code>: 返回一个日历类的对象</li><li><code>public int get(int field)</code>：取日期中的某个字段信息</li><li><code>public void set(int field,int value)</code>：修改日历的某个字段信息</li><li><code>public void add(int field,int amount)</code>：为某个字段增加/减少指定的值</li><li><code>public final Date getTime()</code>: 拿到此刻日期对象</li><li><code>public long getTimeInMillis()</code>: 拿到此刻时间毫秒值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;Calendar rightNow = Calendar.getInsance(); <span class="keyword">int</span> year = rightNow.get(Calendar.YEAR);<span class="comment">//获取年    int month = rightNow.get(Calendar.MONTH) + 1;//月要+1    int days = rightNow.get(Calendar.DAY_OF_YEAR);    rightNow.set(Calendar.YEAR , 2099);//修改某个字段    rightNow.add(Calendar.HOUR , 15);//加15小时  -15就是减去15小时    Date date = rightNow.getTime();//日历对象    long time = rightNow.getTimeInMillis();//时间毫秒值    //700天后是什么日子    rightNow.add(Calendar.DAY_OF_YEAR , 701);    Date date d = rightNow.getTime();    SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);    System.out.println(sdf.format(d));//输出700天后的日期&#125;</span></span><br></pre></td></tr></table></figure><hr><h3 id="LocalDateTime"><a href="#LocalDateTime" class="headerlink" title="LocalDateTime"></a>LocalDateTime</h3><p>JDK1.8 新增，线程安全</p><ul><li>LocalDate       表示日期（年月日）  </li><li>LocalTime       表示时间（时分秒）</li><li>LocalDateTime    表示时间+ 日期 （年月日时分秒）</li></ul><p>构造方法：</p><ul><li>public static LocalDateTime now()：获取当前系统时间 </li><li>public static LocalDateTime of(年, 月 , 日, 时, 分, 秒)：使用指定年月日和时分秒初始化一个对象</li></ul><p>常用API：</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public int getYear()</td><td>获取年</td></tr><tr><td>public int getMonthValue()</td><td>获取月份（1-12）</td></tr><tr><td>public int getDayOfMonth()</td><td>获取月份中的第几天（1-31）</td></tr><tr><td>public int getDayOfYear()</td><td>获取一年中的第几天（1-366）</td></tr><tr><td>public DayOfWeek getDayOfWeek()</td><td>获取星期</td></tr><tr><td>public int getMinute()</td><td>获取分钟</td></tr><tr><td>public int getHour()</td><td>获取小时</td></tr><tr><td>public LocalDate  toLocalDate()</td><td>转换成为一个LocalDate对象（年月日）</td></tr><tr><td>public LocalTime toLocalTime()</td><td>转换成为一个LocalTime对象（时分秒）</td></tr><tr><td>public String format(指定格式)</td><td>把一个LocalDateTime格式化成为一个字符串</td></tr><tr><td>public LocalDateTime parse(准备解析的字符串, 解析格式)</td><td>把一个日期字符串解析成为一个LocalDateTime对象</td></tr><tr><td>public static DateTimeFormatter ofPattern(String pattern)</td><td>使用指定的日期模板获取一个日期格式化器DateTimeFormatter对象</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDK8DateDemo2</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        LocalDateTime now = LocalDateTime.now();        System.out.println(now);        LocalDateTime localDateTime = LocalDateTime.of(<span class="number">2020</span>, <span class="number">11</span>, <span class="number">11</span>, <span class="number">11</span>, <span class="number">11</span>, <span class="number">11</span>);        System.out.println(localDateTime);        DateTimeFormatter pattern = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy年MM月dd日 HH:mm:ss&quot;</span>);        String s = localDateTime.format(pattern);LocalDateTime parse = LocalDateTime.parse(s, pattern);    &#125;&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public LocalDateTime plusYears (long years)</td><td>添加或者减去年</td></tr><tr><td>public LocalDateTime plusMonths(long months)</td><td>添加或者减去月</td></tr><tr><td>public LocalDateTime plusDays(long days)</td><td>添加或者减去日</td></tr><tr><td>public LocalDateTime plusHours(long hours)</td><td>添加或者减去时</td></tr><tr><td>public LocalDateTime plusMinutes(long minutes)</td><td>添加或者减去分</td></tr><tr><td>public LocalDateTime plusSeconds(long seconds)</td><td>添加或者减去秒</td></tr><tr><td>public LocalDateTime plusWeeks(long weeks)</td><td>添加或者减去周</td></tr><tr><td>public LocalDateTime  minusYears (long years)</td><td>减去或者添加年</td></tr><tr><td>public LocalDateTime withYear(int year)</td><td>直接修改年</td></tr><tr><td>public LocalDateTime withMonth(int month)</td><td>直接修改月</td></tr><tr><td>public LocalDateTime withDayOfMonth(int dayofmonth)</td><td>直接修改日期(一个月中的第几天)</td></tr><tr><td>public LocalDateTime withDayOfYear(int dayOfYear)</td><td>直接修改日期(一年中的第几天)</td></tr><tr><td>public LocalDateTime withHour(int hour)</td><td>直接修改小时</td></tr><tr><td>public LocalDateTime withMinute(int minute)</td><td>直接修改分钟</td></tr><tr><td>public LocalDateTime withSecond(int second)</td><td>直接修改秒</td></tr></tbody></table><p><strong>时间间隔</strong> Duration 类API：</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public static Period between(开始时间,结束时间)</td><td>计算两个“时间”的间隔</td></tr><tr><td>public int getYears()</td><td>获得这段时间的年数</td></tr><tr><td>public int getMonths()</td><td>获得此期间的总月数</td></tr><tr><td>public int getDays()</td><td>获得此期间的天数</td></tr><tr><td>public long toTotalMonths()</td><td>获取此期间的总月数</td></tr><tr><td>public static Durationbetween(开始时间,结束时间)</td><td>计算两个“时间”的间隔</td></tr><tr><td>public long toSeconds()</td><td>获得此时间间隔的秒</td></tr><tr><td>public long toMillis()</td><td>获得此时间间隔的毫秒</td></tr><tr><td>public long toNanos()</td><td>获得此时间间隔的纳秒</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDK8DateDemo9</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        LocalDate localDate1 = LocalDate.of(<span class="number">2020</span>, <span class="number">1</span>, <span class="number">1</span>);        LocalDate localDate2 = LocalDate.of(<span class="number">2048</span>, <span class="number">12</span>, <span class="number">12</span>);        Period period = Period.between(localDate1, localDate2);        System.out.println(period);<span class="comment">//P28Y11M11DDuration duration = Duration.between(localDateTime1, localDateTime2);        System.out.println(duration);//PT21H57M58S    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><p>Math 用于做数学运算</p><p>Math 类中的方法全部是静态方法，直接用类名调用即可：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public static int abs(int a)</td><td>获取参数a的绝对值</td></tr><tr><td>public static double ceil(double a)</td><td>向上取整</td></tr><tr><td>public static double floor(double a)</td><td>向下取整</td></tr><tr><td>public static double pow(double a, double b)</td><td>获取 a 的 b 次幂</td></tr><tr><td>public static long round(double a)</td><td>四舍五入取整</td></tr><tr><td>public static int max(int a,int b)</td><td>返回较大值</td></tr><tr><td>public static int min(int a,int b)</td><td>返回较小值</td></tr><tr><td>public static double random()</td><td>返回值为 double 的正值，[0.0,1.0)</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MathDemo</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        <span class="comment">// 1.取绝对值:返回正数。        System.out.println(Math.abs(10));        System.out.println(Math.abs(-10.3));        // 2.向上取整: 5        System.out.println(Math.ceil(4.00000001)); // 5.0        System.out.println(Math.ceil(-4.00000001));//4.0        // 3.向下取整：4        System.out.println(Math.floor(4.99999999)); // 4.0        System.out.println(Math.floor(-4.99999999)); // 5.0        // 4.求指数次方        System.out.println(Math.pow(2 , 3)); // 2^3 = 8.0        // 5.四舍五入 10        System.out.println(Math.round(4.49999)); // 4        System.out.println(Math.round(4.500001)); // 5        System.out.println(Math.round(5.5));//6    &#125;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="DecimalFormat"><a href="#DecimalFormat" class="headerlink" title="DecimalFormat"></a>DecimalFormat</h3><p>使任何形式的数字解析和格式化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;    <span class="keyword">double</span> pi = <span class="number">3.1415927</span>;　<span class="comment">//圆周率    //取一位整数    System.out.println(new DecimalFormat(&quot;0&quot;).format(pi));　　　//3    //取一位整数和两位小数    System.out.println(new DecimalFormat(&quot;0.00&quot;).format(pi));　//3.14    //取两位整数和三位小数，整数不足部分以0填补。    System.out.println(new DecimalFormat(&quot;00.000&quot;).format(pi));// 03.142    //取所有整数部分    System.out.println(new DecimalFormat(&quot;#&quot;).format(pi));　　　//3    //以百分比方式计数，并取两位小数    System.out.println(new DecimalFormat(&quot;#.##%&quot;).format(pi));　//314.16%    long c =299792458;　　//光速    //显示为科学计数法，并取五位小数    System.out.println(new DecimalFormat(&quot;#.#####E0&quot;).format(c));//2.99792E8    //显示为两位整数的科学计数法，并取四位小数    System.out.println(new DecimalFormat(&quot;00.####E0&quot;).format(c));//29.9792E7    //每三位以逗号进行分隔。    System.out.println(new DecimalFormat(&quot;,###&quot;).format(c));//299,792,458    //将格式嵌入文本    System.out.println(new DecimalFormat(&quot;光速大小为每秒,###米。&quot;).format(c));&#125;</span></span><br></pre></td></tr></table></figure><hr><h3 id="System"><a href="#System" class="headerlink" title="System"></a>System</h3><p>System代表当前系统。</p><p>静态方法：</p><ol><li><code>public static void exit(int status)</code> : 终止JVM虚拟机，非0是异常终止</li><li><code>public static long currentTimeMillis()</code> : 获取当前系统此刻时间毫秒值</li><li><code>static void arraycopy(Object var0, int var1, Object var2, int var3, int var4)</code> : 数组拷贝<br>参数一：原数组<br>参数二：从原数组的哪个位置开始赋值。<br>参数三：目标数组<br>参数四：从目标数组的哪个位置开始赋值<br>参数五：赋值几个。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemDemo</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        <span class="comment">//System.exit(0); // 0代表正常终止!!        long startTime = System.currentTimeMillis();//定义sdf 按照格式输出        for(int i = 0; i &lt; 10000; i++)&#123;输出i&#125;long endTime = new Date().getTime();System.out.println( (endTime - startTime)/1000.0 +&quot;s&quot;);//程序用时        int[] arr1 = new int[]&#123;10 ,20 ,30 ,40 ,50 ,60 ,70&#125;;        int[] arr2 = new int[6]; // [ 0 , 0 , 0 , 0 , 0 , 0]        // 变成arrs2 = [0 , 30 , 40 , 50 , 0 , 0 ]        System.arraycopy(arr1, 2, arr2, 1, 3);    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h3 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h3><p>Java 在 java.math 包中提供的 API 类，用来对超过16位有效位的数进行精确的运算</p><p>构造方法：</p><ul><li><code>public static BigDecimal valueOf(double val)</code>：包装浮点数成为大数据对象。</li><li><code>public BigDecimal(double val)</code></li><li><code>public BigDecimal(String val)</code></li></ul><p>常用API：</p><ul><li><code>public BigDecimal add(BigDecimal value)</code>：加法运算</li><li><code>public BigDecimal subtract(BigDecimal value)</code>：减法运算 </li><li><code>public BigDecimal multiply(BigDecimal value)</code>：乘法运算 </li><li><code>public BigDecimal divide(BigDecimal value)</code>：除法运算</li><li><code>public double doubleValue()</code>：把BigDecimal转换成double类型。</li><li><code>public int intValue()</code>：转为int  其他类型相同</li><li><code>public BigDecimal divide (BigDecimal value，精确几位，舍入模式)</code>：除法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigDecimalDemo</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        <span class="comment">// 浮点型运算的时候直接+ - * / 可能会出现数据失真（精度问题）。        System.out.println(0.1 + 0.2);        System.out.println(1.301 / 100);                double a = 0.1 ;        double b = 0.2 ;        double c = a + b ;        System.out.println(c);//0.30000000000000004                // 1.把浮点数转换成大数据对象运算        BigDecimal a1 = BigDecimal.valueOf(a);        BigDecimal b1 = BigDecimal.valueOf(b);        BigDecimal c1 = a1.add(b1);//a1.divide(b1);也可以System.out.println(c1);        // BigDecimal只是解决精度问题的手段，double数据才是我们的目的！！        double d = c1.doubleValue();    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>总结</p><ol><li>BigDecimal 是用来进行精确计算的</li><li>创建 BigDecimal 的对象，构造方法使用参数类型为字符串的。</li><li>四则运算中的除法，如果除不尽请使用 divide 的三个参数的方法。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal divide = bd1.divide(参与运算的对象,小数点后精确到多少位,舍入模式);参数<span class="number">1</span>：表示参与运算的BigDecimal 对象。参数<span class="number">2</span>：表示小数点后面精确到多少位参数<span class="number">3</span>：舍入模式    BigDecimal.ROUND_UP  进一法  BigDecimal.ROUND_FLOOR 去尾法  BigDecimal.ROUND_HALF_UP 四舍五入</span><br></pre></td></tr></table></figure><hr><h3 id="Regex"><a href="#Regex" class="headerlink" title="Regex"></a>Regex</h3><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><p>正则表达式的作用：是一些特殊字符组成的校验规则，可以校验信息的正确性，校验邮箱、电话号码、金额等。</p><p>比如检验qq号：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkQQRegex</span><span class="params">(String qq)</span></span>&#123;    <span class="keyword">return</span> qq!=<span class="keyword">null</span> &amp;&amp; qq.matches(<span class="string">&quot;\\d&#123;4,&#125;&quot;</span>);<span class="comment">//即是数字 必须大于4位数&#125;// 用\\d  是因为\用来告诉它是一个校验类，不是普通的字符 比如 \t \n</span></span><br></pre></td></tr></table></figure><p>java.util.regex 包主要包括以下三个类：</p><ul><li><p>Pattern 类：</p><p>Pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法，要创建一个 Pattern 对象，必须首先调用其公共静态编译方法，返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数</p></li><li><p>Matcher 类：</p><p>Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法，需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象</p></li><li><p>PatternSyntaxException：</p><p>PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。</p></li></ul><hr><h4 id="字符匹配"><a href="#字符匹配" class="headerlink" title="字符匹配"></a>字符匹配</h4><h5 id="普通字符"><a href="#普通字符" class="headerlink" title="普通字符"></a>普通字符</h5><p>字母、数字、汉字、下划线、以及没有特殊定义的标点符号，都是“普通字符”。表达式中的普通字符，在匹配一个字符串的时候，匹配与之相同的一个字符。其他统称<strong>元字符</strong></p><hr><h5 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h5><p>\r\n 是Windows中的文本行结束标签，在Unix/Linux则是 \n</p><table><thead><tr><th>元字符</th><th>说明</th></tr></thead><tbody><tr><td>\</td><td>将下一个字符标记为一个特殊字符或原义字符，告诉它是一个校验类，不是普通字符</td></tr><tr><td>\f</td><td>换页符</td></tr><tr><td>\n</td><td>换行符</td></tr><tr><td>\r</td><td>回车符</td></tr><tr><td>\t</td><td>制表符</td></tr><tr><td>\</td><td>代表\本身</td></tr><tr><td>()</td><td>使用( )定义一个子表达式。子表达式的内容可以当成一个独立元素</td></tr></tbody></table><hr><h5 id="标准字符"><a href="#标准字符" class="headerlink" title="标准字符"></a>标准字符</h5><p>标准字符集合<br>能够与”多种字符“匹配的表达式。注意区分大小写，大写是相反的意思。只能校验**”单”**个字符。</p><table><thead><tr><th>元字符</th><th>说明</th></tr></thead><tbody><tr><td>.</td><td>匹配任意一个字符(除了换行符)，如果要匹配包括“\n”在内的所有字符，一般用[\s\S]</td></tr><tr><td>\d</td><td>数字字符，0~9 中的任意一个，等价于 [0-9]</td></tr><tr><td>\D</td><td>非数字字符，等价于  [ ^0-9]</td></tr><tr><td>\w</td><td>大小写字母或数字或下划线，等价于[a-zA-Z_0-9_]</td></tr><tr><td>\W</td><td>对\w取非，等价于[ ^\w]</td></tr><tr><td>\s</td><td>空格、制表符、换行符等空白字符的其中任意一个，等价于[\f\n\r\t\v]</td></tr><tr><td>\S</td><td>对 \s 取非</td></tr></tbody></table><p>\x 匹配十六进制字符，\0 匹配八进制，例如 \xA 对应值为 10 的 ASCII 字符 ，即 \n</p><hr><h5 id="自定义符"><a href="#自定义符" class="headerlink" title="自定义符"></a>自定义符</h5><p>自定义符号集合，[ ]方括号匹配方式，能够匹配方括号中<strong>任意一个</strong>字符</p><table><thead><tr><th>元字符</th><th>说明</th></tr></thead><tbody><tr><td>[ab5@]</td><td>匹配 “a” 或 “b” 或 “5” 或 “@”</td></tr><tr><td>[^abc]</td><td>匹配 “a”,”b”,”c” 之外的任意一个字符</td></tr><tr><td>[f-k]</td><td>匹配 “f”~”k” 之间的任意一个字母</td></tr><tr><td>[^A-F0-3]</td><td>匹配 “A”,”F”,”0”~”3” 之外的任意一个字符</td></tr><tr><td>[a-d[m-p]]</td><td>匹配 a 到 d 或者 m 到 p：[a-dm-p]（并集）</td></tr><tr><td>[a-z&amp;&amp;[m-p]]</td><td>匹配 a 到 z 并且 m 到 p：[a-dm-p]（交集）</td></tr><tr><td>[^]</td><td>取反</td></tr></tbody></table><ul><li><p>正则表达式的特殊符号，被包含到中括号中，则失去特殊意义，除了^,-之外，需要在前面加 \</p></li><li><p>标准字符集合，除小数点外，如果被包含于中括号，自定义字符集合将包含该集合。<br>比如：[\d. \ -+]将匹配：数字、小数点、+、-</p></li></ul><hr><h5 id="量词字符"><a href="#量词字符" class="headerlink" title="量词字符"></a>量词字符</h5><p>修饰匹配次数的特殊符号。</p><ul><li>匹配次数中的贪婪模式(匹配字符越多越好，默认！)，* 和 + 都是贪婪型元字符。</li><li>匹配次数中的非贪婪模式（匹配字符越少越好，修饰匹配次数的特殊符号后再加上一个 “?” 号）</li></ul><table><thead><tr><th>元字符</th><th>说明</th></tr></thead><tbody><tr><td>X?</td><td>X一次或一次也没，有相当于 {0,1}</td></tr><tr><td>X*</td><td>X不出现或出现任意次，相当于 {0,}</td></tr><tr><td>X+</td><td>X至少一次，相当于 {1,}</td></tr><tr><td>X{n}</td><td>X恰好 n 次</td></tr><tr><td>{n,}</td><td>X至少 n 次</td></tr><tr><td>{n,m}</td><td>X至少 n 次，但是不超过 m 次</td></tr></tbody></table><hr><h4 id="位置匹配"><a href="#位置匹配" class="headerlink" title="位置匹配"></a>位置匹配</h4><h5 id="字符边界"><a href="#字符边界" class="headerlink" title="字符边界"></a>字符边界</h5><p>本组标记匹配的不是字符而是位置，符合某种条件的位置</p><table><thead><tr><th>元字符</th><th>说明</th></tr></thead><tbody><tr><td>^</td><td>与字符串开始的地方匹配（在字符集合中用来求非，在字符集合外用作匹配字符串的开头）</td></tr><tr><td>$</td><td>与字符串结束的地方匹配</td></tr><tr><td>\b</td><td>匹配一个单词边界</td></tr></tbody></table><hr><h5 id="捕获组"><a href="#捕获组" class="headerlink" title="捕获组"></a>捕获组</h5><p>捕获组是把多个字符当一个单独单元进行处理的方法，它通过对括号内的字符分组来创建。</p><p>在表达式<code>((A)(B(C)))</code>，有四个这样的组：((A)(B(C)))、(A)、(B(C))、(C)（按照括号从左到右依次为 group(1)…）</p><ul><li>调用 matcher 对象的 groupCount 方法返回一个 int 值，表示 matcher 对象当前有多个捕获组。</li><li>特殊的组group(0)、group()，它代表整个表达式，该组不包括在 groupCount 的返回值中。 </li></ul><table><thead><tr><th>表达式</th><th>说明</th></tr></thead><tbody><tr><td>|  (分支结构)</td><td>左右两边表达式之间 “或” 关系，匹配左边或者右边</td></tr><tr><td>()  (捕获组)</td><td>(1) 在被修饰匹配次数的时候，括号中的表达式可以作为整体被修饰<br>(2) 取匹配结果的时候，括号中的表达式匹配到的内容可以被单独得到<br>(3) 每一对括号分配一个编号,()的捕获根据左括号的顺序从1开始自动编号。捕获元素编号为零的第一个捕获是由整个正则表达式模式匹配的文本</td></tr><tr><td>(?:Expression)   非捕获组</td><td>一些表达式中，不得不使用( )，但又不需要保存( )中子表达式匹配的内容，这时可以用非捕获组来抵消使用( )带来的副作用。</td></tr></tbody></table><hr><h5 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h5><p>反向引用（\number），又叫回溯引用：</p><ul><li><p>每一对()会分配一个编号，使用 () 的捕获根据左括号的顺序从1开始自动编号</p></li><li><p>通过反向引用，可以对分组已捕获的字符串进行引用，继续匹配</p></li><li><p><strong>把匹配到的字符重复一遍在进行匹配</strong></p></li><li><p>应用1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String regex = <span class="string">&quot;((\d)3)\1[0-9](\w)\2&#123;2&#125;&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li>首先匹配((\d)3)，其次\1匹配((\d)3)已经匹配到的内容，\2匹配（\d）， {2}指的是\2的值出现两次</li><li>实例：23238n22（匹配到2未来就继续匹配2）</li><li>实例：43438n44</li></ul></li><li><p>应用2：爬虫</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String regex = <span class="string">&quot;&lt;(h[1-6])&gt;\w*?&lt;\/\1&gt;&quot;</span>;</span><br></pre></td></tr></table></figure><p>匹配结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;x&lt;/h1&gt;<span class="comment">//匹配&lt;h2&gt;x&lt;/h2&gt;//匹配&lt;h3&gt;x&lt;/h1&gt;//不匹配</span></span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="零宽断言"><a href="#零宽断言" class="headerlink" title="零宽断言"></a>零宽断言</h5><p>预搜索（零宽断言）（环视）</p><ul><li><p>只进行子表达式的匹配，匹配内容不计入最终的匹配结果，是零宽度</p></li><li><p>判断当前位置的前后字符，是否符合指定的条件，但不匹配前后的字符。<strong>是对位置的匹配</strong>。</p></li><li><p>正则表达式匹配过程中，如果子表达式匹配到的是字符内容，而非位置，并被保存到最终的匹配结果中，那么就认为这个子表达式是占有字符的；如果子表达式匹配的仅仅是位置，或者匹配的内容并不保存到最终的匹配结果中，那么就认为这个子表达式是<strong>零宽度</strong>的。占有字符还是零宽度，是针对匹配的内容是否保存到最终的匹配结果中而言的</p><table><thead><tr><th>表达式</th><th>说明</th></tr></thead><tbody><tr><td>(?=exp)</td><td>断言自身出现的位置的后面能匹配表达式exp</td></tr><tr><td>(?&lt;=exp)</td><td>断言自身出现的位置的前面能匹配表达式exp</td></tr><tr><td>(?!exp)</td><td>断言此位置的后面不能匹配表达式exp</td></tr><tr><td>(?&lt;!exp)</td><td>断言此位置的前面不能匹配表达式exp</td></tr></tbody></table></li></ul><hr><h4 id="匹配模式"><a href="#匹配模式" class="headerlink" title="匹配模式"></a>匹配模式</h4><p>正则表达式的匹配模式：</p><ul><li>IGNORECASE 忽略大小写模式<ul><li>匹配时忽略大小写。</li><li>默认情况下，正则表达式是要区分大小写的。</li></ul></li><li>SINGLELINE 单行模式<ul><li>整个文本看作一个字符串，只有一个开头，一个结尾。</li><li>使小数点 “.” 可以匹配包含换行符（\n）在内的任意字符。</li></ul></li><li>MULTILINE 多行模式<ul><li>每行都是一个字符串，都有开头和结尾。</li><li>在指定了 MULTILINE 之后，如果需要仅匹配字符串开始和结束位置，可以使用 \A 和 \Z</li></ul></li></ul><hr><h4 id="分组匹配"><a href="#分组匹配" class="headerlink" title="分组匹配"></a>分组匹配</h4><p>Pattern 类：</p><ul><li><code>static Pattern compile(String regex)</code>：将给定的正则表达式编译为模式</li><li><code>Matcher matcher(CharSequence input)</code>：创建一个匹配器，匹配给定的输入与此模式</li><li><code>static boolean matches(String regex, CharSequence input)</code>：编译正则表达式，并匹配输入</li></ul><p>Matcher 类：</p><ul><li><code>boolean find()</code>：扫描输入的序列，查找与该模式匹配的下一个子序列</li><li><code>String group()</code>：返回与上一个匹配的输入子序列。同group(0)，匹配整个表达式的子字符串</li><li><code>String group(int group)</code>：返回在上一次匹配操作期间由给定组捕获的输入子序列 </li><li><code>int groupCount()</code>：返回此匹配器模式中捕获组的数量</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span></span>&#123;<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;<span class="comment">//表达式对象Pattern p = Pattern.compile(&quot;\\w+&quot;);//创建Matcher对象Matcher m = p.matcher(&quot;asfsdf2&amp;&amp;3323&quot;);//boolean b = m.matches();//尝试将整个字符序列与该模式匹配//System.out.println(b);//false//boolean b2 = m.find();//该方法扫描输入的序列，查找与该模式匹配的下一个子序列//System.out.println(b2);//true//System.out.println(m.find());//System.out.println(m.group());//asfsdf2//System.out.println(m.find());//System.out.println(m.group());//3323while(m.find())&#123;System.out.println(m.group());//group(),group(0)匹配整个表达式的子字符串System.out.println(m.group(0));&#125;&#125;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02</span> </span>&#123;<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;<span class="comment">//在这个字符串：asfsdf23323，是否符合指定的正则表达式：\w+//表达式对象        Pattern p = Pattern.compile(&quot;(([a-z]+)([0-9]+))&quot;);//不需要加多余的括号//创建Matcher对象Matcher m = p.matcher(&quot;aa232**ssd445&quot;);while(m.find())&#123;System.out.println(m.group());//aa232  ssd445System.out.println(m.group(1));//aa232  ssd445System.out.println(m.group(2));//aa     ssd            System.out.println(m.group(3));//232    445 &#125;&#125;&#125;</span></span><br></pre></td></tr></table></figure><ul><li>正则表达式改为<code>&quot;(([a-z]+)(?:[0-9]+))&quot;</code>   没有group(3) 因为是非捕获组</li><li>正则表达式改为<code>&quot;([a-z]+)([0-9]+)&quot;</code>  没有 group(3)    aa232  - aa  –232</li></ul><hr><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><h5 id="基本验证"><a href="#基本验证" class="headerlink" title="基本验证"></a>基本验证</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;System.out.println(<span class="string">&quot;a&quot;</span>.matches(<span class="string">&quot;[abc]&quot;</span>));<span class="comment">//true判断a是否在abc    System.out.println(&quot;a&quot;.matches(&quot;[^abc]&quot;));//false 判断a是否在abc之外的    System.out.println(&quot;a&quot;.matches(&quot;\\d&quot;)); //false 是否a是整数    System.out.println(&quot;a&quot;.matches(&quot;\\w&quot;)); //true 是否是字符    System.out.println(&quot;你&quot;.matches(&quot;\\w&quot;)); // false    System.out.println(&quot;aa&quot;.matches(&quot;\\w&quot;));//false 只能检验单个字符        // 密码 必须是数字 字母 下划线 至少 6位System.out.println(&quot;ssds3c&quot;.matches(&quot;\\w&#123;6,&#125;&quot;)); // true    // 验证。必须是数字和字符  必须是4位    System.out.println(&quot;dsd22&quot;.matches(&quot;[a-zA-Z0-9]&#123;4&#125;&quot;)); // false    System.out.println(&quot;A3dy&quot;.matches(&quot;[a-zA-Z0-9]&#123;4&#125;&quot;)); // true&#125;</span></span><br></pre></td></tr></table></figure><hr><h5 id="验证号码"><a href="#验证号码" class="headerlink" title="验证号码"></a>验证号码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1开头 第二位是2-9的数字public static void checkPhone(String phone)&#123;    if(phone.matches(&quot;1[3-9]\\d&#123;9&#125;&quot;))&#123;        System.out.println(&quot;手机号码格式正确！&quot;);    &#125; else &#123;.......&#125;&#125;//1111@qq.com  zhy@pic.com.cnpublic static void checkEmail(String email)&#123;    if(email.matches(&quot;\\w&#123;1,&#125;@\\w&#123;1,&#125;(\\.\\w&#123;2,5&#125;)&#123;1,2&#125;&quot;))&#123;        System.out.println(&quot;邮箱格式正确！&quot;);    &#125;// .是任意字符 \\.就是点&#125;</span></span><br></pre></td></tr></table></figure><hr><h5 id="查找替换"><a href="#查找替换" class="headerlink" title="查找替换"></a>查找替换</h5><ul><li><code>public String[] split(String regex)</code>：按照正则表达式匹配的内容进行分割字符串，反回一个字符串数组</li><li><code>public String replaceAll(String regex,String newStr)</code>：按照正则表达式匹配的内容进行替换</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组分割public static void main(String[] args) &#123;// 1.split的基础用法String names = &quot;风清扬,张无忌,周芷若&quot;;// 以“，”分割成字符串数组    String[] nameArrs = names.split(&quot;,&quot;);    // 2.split集合正则表达式做分割    String names1 = &quot;风清扬lv434fda324张无忌87632fad2342423周芷若&quot;;    // 以匹配正则表达式的内容为分割点分割成字符串数组String[] nameArrs1 = names1.split(&quot;\\w+&quot;);    // 使用正则表达式定位出内容，替换成/System.out.println(names1.replaceAll(&quot;\\w+&quot;,&quot;/&quot;));//风清扬/张无忌/周芷若String names3 = &quot;风清扬,张无忌,周芷若&quot;;System.out.println(names3.replaceAll(&quot;,&quot;,&quot;-&quot;));//风清扬-张无忌-周芷若&#125;</span></span><br></pre></td></tr></table></figure><hr><h5 id="面试问题-3"><a href="#面试问题-3" class="headerlink" title="面试问题"></a>面试问题</h5><p>找出所有189和132开头的手机号</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegexDemo</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        String rs = <span class="string">&quot;189asjk65as1891898777745gkkkk189745612318936457894&quot;</span>;        String regex = <span class="string">&quot;(?=((189|132)\\d&#123;8&#125;))&quot;</span>;        Pattern pattern = Pattern.compile(regex);        Matcher matcher = pattern.matcher(rs);        <span class="keyword">while</span> (matcher.find()) &#123;            System.out.println(matcher.group(<span class="number">1</span>));        &#125;    &#125;&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="集合概述"><a href="#集合概述" class="headerlink" title="集合概述"></a>集合概述</h3><p>集合是一个大小可变的容器，容器中的每个数据称为一个元素</p><p>集合特点：类型可以不确定，大小不固定；集合有很多，不同的集合特点和使用场景不同</p><p>数组：类型和长度一旦定义出来就都固定</p><p>作用：</p><ul><li>在开发中，很多时候元素的个数是不确定的</li><li>而且经常要进行元素的增删该查操作，集合都是非常合适的，开发中集合用的更多</li></ul><hr><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p>数据结构指的是数据以什么方式组织在一起，不同的数据结构，增删查的性能是不一样的</p><p>数据存储的常用结构有：栈、队列、数组、链表和红黑树</p><ul><li><p>队列（queue）：先进先出，后进后出。(FIFO first in first out)<br>场景：各种排队、叫号系统，有很多集合可以实现队列</p></li><li><p>栈（stack）：后进先出，先进后出 （LIFO）<br>压栈 == 入栈、弹栈 == 出栈<br>场景：手枪的弹夹 </p></li><li><p>数组：数组是内存中的连续存储区域，分成若干等分的小区域（每个区域大小是一样的）。元素存在索引<br>特点：<strong>查询元素快</strong>（根据索引快速计算出元素的地址，然后立即去定位）</p><pre><code>        **增删元素慢**（创建新数组，迁移元素）</code></pre></li><li><p>链表：元素不是内存中的连续区域存储，元素是游离存储的，每个元素会记录下个元素的地址<br>特点：<strong>查询元素慢，增删元素快</strong>（针对于首尾元素，速度极快，一般是双链表）</p></li><li><p>树：</p><ul><li><p>二叉树：binary tree 永远只有一个根节点，是每个结点不超过2个节点的树（tree）<br>特点：二叉排序树：小的左边，大的右边，但是可能树很高，性能变差</p><pre><code>        为了做排序和搜索会进行左旋和右旋实现平衡查找二叉树，让树的高度差不大于1</code></pre></li><li><p>红黑树（基于红黑规则实现自平衡的排序二叉树）：树保证到了很矮小，但是又排好序，性能最高的树</p><p>特点：<strong>红黑树的增删查改性能都好</strong></p></li></ul></li></ul><p>各数据结构时间复杂度对比：</p><p><img src="https://gitee.com/seazean/images/raw/master/Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%AF%B9%E6%AF%94.png"></p><p>图片来源：<a href="https://www.bigocheatsheet.com/">https://www.bigocheatsheet.com/</a></p><hr><h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><h4 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h4><p>Java 中集合的代表是Collection，Collection 集合是 Java 中集合的祖宗类</p><p>Collection 集合底层为数组：<code>[value1, value2, ....]</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collection集合的体系:                      Collection&lt;E&gt;(接口)                 /                         \          Set&lt;E&gt;(接口)                    List&lt;E&gt;(接口)      /               \                  /             \ HashSet&lt;E&gt;(实现类) TreeSet&lt;&gt;(实现类)  ArrayList&lt;E&gt;(实现类)  LinekdList&lt;&gt;(实现类) /LinkedHashSet&lt;&gt;(实现类)</span><br></pre></td></tr></table></figure><p><strong>集合的特点：</strong></p><ul><li>Set 系列集合：添加的元素是无序，不重复，无索引的<ul><li>HashSet：添加的元素是无序，不重复，无索引的</li><li>LinkedHashSet：添加的元素是有序，不重复，无索引的</li><li>TreeSet：不重复，无索引，按照大小默认升序排序</li></ul></li><li>List 系列集合：添加的元素是有序，可重复，有索引<ul><li>ArrayList：添加的元素是有序，可重复，有索引</li><li>LinekdList：添加的元素是有序，可重复，有索引</li></ul></li></ul><hr><h4 id="API-1"><a href="#API-1" class="headerlink" title="API"></a>API</h4><p>Collection 是集合的祖宗类，它的功能是全部集合都可以继承使用的，所以要学习它。</p><p>Collection 子类的构造器都有可以包装其他子类的构造方法，如：</p><ul><li><p><code>public ArrayList(Collection&lt;? extends E&gt; c)</code>：构造新集合，元素按照由集合的迭代器返回的顺序</p></li><li><p><code>public HashSet(Collection&lt;? extends E&gt; c)</code>：构造一个包含指定集合中的元素的新集合</p></li></ul><p>Collection API 如下：</p><ul><li><code>public boolean add(E e)</code>：把给定的对象添加到当前集合中 。</li><li><code>public void clear()</code>：清空集合中所有的元素。</li><li><code>public boolean remove(E e)</code>：把给定的对象在当前集合中删除。</li><li><code>public boolean contains(Object obj)</code>：判断当前集合中是否包含给定的对象。</li><li><code>public boolean isEmpty()</code>：判断当前集合是否为空。</li><li><code>public int size()</code>：返回集合中元素的个数。</li><li><code>public Object[] toArray()</code>：把集合中的元素，存储到数组中</li><li><code>public boolean addAll(Collection&lt;? extends E&gt; c)</code>：将指定集合中的所有元素添加到此集合</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionDemo</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        Collection&lt;String&gt; sets = <span class="keyword">new</span> HashSet&lt;&gt;();        sets.add(<span class="string">&quot;MyBatis&quot;</span>);        System.out.println(sets.add(<span class="string">&quot;Java&quot;</span>));<span class="comment">//true        System.out.println(sets.add(&quot;Java&quot;));//false        sets.add(&quot;Spring&quot;);        sets.add(&quot;MySQL&quot;);        System.out.println(sets)//[]无序的;        System.out.println(sets.contains(&quot;java&quot;));//true 存在        Object[] arrs = sets.toArray();        System.out.println(&quot;数组：&quot;+ Arrays.toString(arrs));                Collection&lt;String&gt; c1 = new ArrayList&lt;&gt;();        c1.add(&quot;java&quot;);        Collection&lt;String&gt; c2 = new ArrayList&lt;&gt;();        c2.add(&quot;ee&quot;);        c1.addAll(c2);// c1:[java,ee]  c2:[ee];    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><p>Collection 集合的遍历方式有三种:</p><p>集合可以直接输出内容，因为底层重写了 toString() 方法</p><ol><li><p>迭代器<br><code>public Iterator iterator()</code>：获取集合对应的迭代器，用来遍历集合中的元素的<br><code>E next()</code>：获取下一个元素值<br><code>boolean hasNext()</code>：判断是否有下一个元素，有返回true ,反之<br><code>default void remove()</code>：从底层集合中删除此迭代器返回的最后一个元素，这种方法只能在每次调用next() 时调用一次</p></li><li><p>增强 for 循环：可以遍历集合或者数组，遍历集合实际上是迭代器遍历的简化写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(被遍历集合或者数组中元素的类型 变量名称 : 被遍历集合或者数组)&#123;&#125;</span><br></pre></td></tr></table></figure><p>缺点：遍历无法知道遍历到了哪个元素了，因为没有索引</p></li><li><p>JDK 1.8 开始之后的新技术 Lambda 表达式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionDemo</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        Collection&lt;String&gt; lists = <span class="keyword">new</span> ArrayList&lt;&gt;();        lists.add(<span class="string">&quot;aa&quot;</span>);        lists.add(<span class="string">&quot;bb&quot;</span>);        lists.add(<span class="string">&quot;cc&quot;</span>);        System.out.println(lists); <span class="comment">// lists = [aa, bb, cc]//迭代器流程        // 1.得到集合的迭代器对象。        Iterator&lt;String&gt; it = lists.iterator();        // 2.使用while循环遍历。        while(it.hasNext())&#123;            String ele = it.next();            System.out.println(ele);        &#125;        //增强for        for (String ele : lists) &#123;            System.out.println(ele);        &#125;        //lambda表达式        lists.forEach(s -&gt; &#123;            System.out.println(s);        &#125;);    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li></ol><hr><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><h5 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h5><p>List集合继承了Collection集合全部的功能。</p><p>List系列集合有索引，所以多了很多按照索引操作元素的功能：for循环遍历（4种遍历）</p><p>List系列集合：添加的元素是有序，可重复，有索引。</p><ul><li><p>ArrayList：添加的元素是有序，可重复，有索引。</p></li><li><p>LinekdList：添加的元素是有序，可重复，有索引。</p></li></ul><hr><h5 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h5><h6 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h6><p>ArrayList 添加的元素，是有序，可重复，有索引的</p><ul><li><code>public boolean add(E e)</code>：将指定的元素追加到此集合的末尾</li><li><code>public void add(int index, E element)</code>：将指定的元素，添加到该集合中的指定位置上</li><li><code>public E get(int index)</code>：返回集合中指定位置的元素</li><li><code>public E remove(int index)</code>：移除列表中指定位置的元素, 返回的是被移除的元素</li><li><code>public E set(int index, E element)</code>：用指定元素替换集合中指定位置的元素,返回更新前的元素值</li><li><code>int indexOf(Object o)</code>：返回列表中指定元素第一次出现的索引，如果不包含此元素，则返回 -1</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;    List&lt;String&gt; lists = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//多态    lists.add(&quot;java1&quot;);    lists.add(&quot;java1&quot;);//可以重复    lists.add(&quot;java2&quot;);    for(int i = 0 ; i &lt; lists.size() ; i++ ) &#123;            String ele = lists.get(i);            System.out.println(ele);   &#125;&#125;</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/seazean/images/raw/master/Java/ArrayList%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.png" alt="ArrayList源码分析"></p><hr><h6 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h6><p>ArrayList 实现类集合底层<strong>基于数组存储数据</strong>的，查询快，增删慢，支持快速随机访问</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li><code>RandomAccess</code> 是一个标志接口，表明实现这个这个接口的 List 集合是支持<strong>快速随机访问</strong>的。在 <code>ArrayList</code> 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。</li><li><code>ArrayList</code> 实现了 <code>Cloneable</code> 接口 ，即覆盖了函数<code>clone()</code>，能被克隆</li><li><code>ArrayList</code> 实现了 <code>Serializable </code>接口，这意味着<code>ArrayList</code>支持序列化，能通过序列化去传输</li></ul><p>核心方法：</p><ul><li><p>构造函数：以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量，即向数组中添加第一个元素时，<strong>数组容量扩为 10</strong></p></li><li><p>添加元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// e 插入的元素  elementData底层数组   size 插入的位置public boolean add(E e) &#123;    ensureCapacityInternal(size + 1);// Increments modCount!!    elementData[size++] = e;// 插入size位置，然后加一    return true;&#125;</span></span><br></pre></td></tr></table></figure><p>当 add 第 1 个元素到 ArrayList，size 是 0，进入 ensureCapacityInternal 方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;    <span class="comment">// 判断elementData是不是空数组    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;        // 返回默认值和最小需求容量最大的一个        return Math.max(DEFAULT_CAPACITY, minCapacity);    &#125;    return minCapacity;&#125;</span></span><br></pre></td></tr></table></figure><p>如果需要的容量大于数组长度，进行扩容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否需要扩容private void ensureExplicitCapacity(int minCapacity) &#123;    modCount++;    // 索引越界    if (minCapacity - elementData.length &gt; 0)        // 调用grow方法进行扩容，调用此方法代表已经开始扩容了        grow(minCapacity);&#125;</span></span><br></pre></td></tr></table></figure><p>指定索引插入，<strong>在旧数组上操作</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;    rangeCheckForAdd(index);    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!    System.arraycopy(elementData, index, elementData, index + 1,                     size - index);    elementData[index] = element;    size++;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>扩容：新容量的大小为 <code>oldCapacity + (oldCapacity &gt;&gt; 1)</code>，<code>oldCapacity &gt;&gt; 1</code> 需要取整，所以新容量大约是旧容量的 1.5 倍左右，即 oldCapacity+oldCapacity/2</p><p>扩容操作需要调用 <code>Arrays.copyOf()</code>（底层 <code>System.arraycopy()</code>）把原数组整个复制到<strong>新数组</strong>中，这个操作代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;    <span class="keyword">int</span> oldCapacity = elementData.length;    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);    <span class="comment">//检查新容量是否大于最小需要容量，若小于最小需要容量，就把最小需要容量当作数组的新容量    if (newCapacity - minCapacity &lt; 0)newCapacity = minCapacity;//不需要扩容计算    //检查新容量是否大于最大数组容量    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)        //如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`        //否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`        newCapacity = hugeCapacity(minCapacity);    elementData = Arrays.copyOf(elementData, newCapacity);&#125;</span></span><br></pre></td></tr></table></figure><p>MAX_ARRAY_SIZE：要分配的数组的最大大小，分配更大的<strong>可能</strong>会导致</p><ul><li>OutOfMemoryError:Requested array size exceeds VM limit（请求的数组大小超出VM限制）</li><li>OutOfMemoryError: Java heap space（堆区内存不足，可以通过设置JVM参数 -Xmx 来调节）</li></ul></li><li><p>删除元素：需要调用 System.arraycopy() 将 index+1 后面的元素都复制到 index 位置上，在旧数组上操作，该操作的时间复杂度为 O(N)，可以看到 ArrayList 删除元素的代价是非常高的，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;    rangeCheck(index);    modCount++;    E oldValue = elementData(index);    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work    return oldValue;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>序列化：ArrayList 基于数组并且具有动态扩容特性，因此保存元素的数组不一定都会被使用，就没必要全部进行序列化。保存元素的数组 elementData 使用 transient 修饰，该关键字声明数组默认不会被序列化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br></pre></td></tr></table></figure></li><li><p>ensureCapacity：增加此实例的容量，以确保它至少可以容纳最小容量参数指定的元素数，减少增量重新分配的次数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;     <span class="keyword">if</span> (minCapacity &gt; elementData.length         &amp;&amp; !(elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA              &amp;&amp; minCapacity &lt;= DEFAULT_CAPACITY)) &#123;         modCount++;         grow(minCapacity);     &#125; &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Fail-Fast</strong>：快速失败，modCount 用来记录 ArrayList <strong>结构发生变化</strong>的次数，结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化</p><p>在进行序列化或者迭代等操作时，需要比较操作前后 modCount 是否改变，改变了抛出 ConcurrentModificationException 异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;    <span class="keyword">return</span> <span class="keyword">new</span> Itr();&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;    <span class="keyword">int</span> cursor;       <span class="comment">// index of next element to return    int lastRet = -1; // index of last element returned; -1 if no such    int expectedModCount = modCount;    Itr() &#123;&#125;    public boolean hasNext() &#123;        return cursor != size;    &#125;   // 获取下一个元素时首先判断结构是否发生变化    public E next() &#123;        checkForComodification();       // .....    &#125;    // modCount 被其他线程改变抛出并发修改异常    final void checkForComodification() &#123;        if (modCount != expectedModCount)            throw new ConcurrentModificationException();    &#125;// 允许删除操作    public void remove() &#123;        // ...        checkForComodification();        // ...        // 删除后重置 expectedModCount        expectedModCount = modCount;    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h5><p>同步：Vector的实现与 ArrayList 类似，但是方法上使用了 synchronized 进行同步</p><p>构造：默认长度为 10 的数组</p><p>扩容：Vector 的构造函数可以传入 capacityIncrement 参数，作用是在扩容时使容量 capacity 增长 capacityIncrement，如果这个参数的值小于等于 0（默认0），扩容时每次都令 capacity 为原来的两倍</p><p>对比 ArrayList</p><ol><li><p>Vector 是同步的，开销比 ArrayList 要大，访问速度更慢。最好使用 ArrayList 而不是 Vector，因为同步操作完全可以由程序来控制</p></li><li><p>Vector 每次扩容请求其大小的 2 倍（也可以通过构造函数设置增长的容量），而 ArrayList 是 1.5 倍</p></li><li><p>底层都是 <code>Object[]</code>数组存储</p></li></ol><hr><h5 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h5><h6 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h6><p>LinkedList 也是 List 的实现类：基于<strong>双向链表</strong>实现，使用 Node 存储链表节点信息，增删比较快，查询慢</p><p>LinkedList 除了拥有 List 集合的全部功能还多了很多操作首尾元素的特殊功能：</p><ul><li><code>public boolean add(E e)</code>：将指定元素添加到此列表的结尾</li><li><code>public E poll()</code>：检索并删除此列表的头（第一个元素）</li><li><code>public void addFirst(E e)</code>：将指定元素插入此列表的开头</li><li><code>public void addLast(E e)</code>：将指定元素添加到此列表的结尾</li><li><code>public E getFirst()</code>：返回此列表的第一个元素</li><li><code>public E getLast()</code>：返回此列表的最后一个元素</li><li><code>public E removeFirst()</code>：移除并返回此列表的第一个元素</li><li><code>public E removeLast()</code>：移除并返回此列表的最后一个元素</li><li><code>public E pop()</code>：从此列表所表示的堆栈处弹出一个元素</li><li><code>public void push(E e)</code>：将元素推入此列表所表示的堆栈</li><li><code>public int indexOf(Object o)</code>：返回此列表中指定元素的第一次出现的索引，如果不包含返回 -1</li><li><code>public int lastIndexOf(Object o)</code>：从尾遍历找</li><li><code> public boolean remove(Object o)</code>：一次只删除一个匹配的对象，如果删除了匹配对象返回true</li><li><code>public E remove(int index)</code>：删除指定位置的元素</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListDemo</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        <span class="comment">// 1.用LinkedList做一个队列:先进先出，后进后出。        LinkedList&lt;String&gt; queue = new LinkedList&lt;&gt;();        // 入队        queue.addLast(&quot;1号&quot;);        queue.addLast(&quot;2号&quot;);        queue.addLast(&quot;3号&quot;);        System.out.println(queue); // [1号, 2号, 3号]        // 出队        System.out.println(queue.removeFirst());//1号        System.out.println(queue.removeFirst());//2号        System.out.println(queue);//[3号]        // 做一个栈 先进后出        LinkedList&lt;String&gt; stack = new LinkedList&lt;&gt;();        // 压栈        stack.push(&quot;第1颗子弹&quot;);//addFirst(e);        stack.push(&quot;第2颗子弹&quot;);        stack.push(&quot;第3颗子弹&quot;);        System.out.println(stack); // [ 第3颗子弹, 第2颗子弹, 第1颗子弹]        // 弹栈        System.out.println(stack.pop());//removeFirst(); 第3颗子弹        System.out.println(stack.pop());        System.out.println(stack);// [第1颗子弹]    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/seazean/images/raw/master/Java/LinkedList%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.png"></p><h6 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h6><p>LinkedList 是一个实现了 List 接口的<strong>双端链表</strong>，支持高效的插入和删除操作，另外也实现了 Deque 接口，使得 LinkedList 类也具有队列的特性</p><p><img src="https://gitee.com/seazean/images/raw/master/Java/LinkedList%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84.png"></p><p>核心方法：</p><ul><li><p>使 LinkedList 变成线程安全的，可以调用静态类 Collections 类中的 synchronizedList 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List list = Collections.synchronizedList(<span class="keyword">new</span> LinkedList(...));</span><br></pre></td></tr></table></figure></li><li><p>私有内部类 Node：这个类代表双端链表的节点 Node</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;    E item;    Node&lt;E&gt; next;    Node&lt;E&gt; prev;    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;        <span class="keyword">this</span>.item = element;        <span class="keyword">this</span>.next = next;        <span class="keyword">this</span>.prev = prev;    &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>构造方法：只有无参构造和用已有的集合创建链表的构造方法</p></li><li><p>添加元素：默认加到尾部</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;    linkLast(e);    <span class="keyword">return</span> <span class="keyword">true</span>;&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取元素：<code>get(int index)</code> 根据指定索引返回数据</p><ul><li>获取头节点 (index=0)：getFirst()、element()、peek()、peekFirst() 这四个获取头结点方法的区别在于对链表为空时的处理，是抛出异常还是返回null，其中<strong>getFirst() 和element()</strong> 方法将会在链表为空时，抛出异常</li><li>获取尾节点 (index=-1)：getLast() 方法在链表为空时，会抛出NoSuchElementException，而peekLast() 则不会，只会返回 null</li></ul></li><li><p>删除元素：</p><ul><li>remove()、removeFirst()、pop()：删除头节点</li><li>removeLast()、pollLast()：删除尾节点，removeLast()在链表为空时抛出NoSuchElementException，而pollLast()方法返回null</li></ul></li></ul><p>对比 ArrayList</p><ol><li>是否保证线程安全：ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全</li><li>底层数据结构： <ul><li>Arraylist 底层使用的是 <code>Object</code> 数组</li><li>LinkedList 底层使用的是双向链表数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环）</li></ul></li><li>插入和删除是否受元素位置的影响：<ul><li>ArrayList 采用数组存储，所以插入和删除元素受元素位置的影响</li><li>LinkedList采 用链表存储，所以对于<code>add(E e)</code>方法的插入，删除元素不受元素位置的影响</li></ul></li><li>是否支持快速随机访问：<ul><li>LinkedList 不支持高效的随机元素访问，ArrayList 支持</li><li>快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</li></ul></li><li>内存空间占用：<ul><li>ArrayList 的空间浪费主要体现在在 list 列表的结尾会预留一定的容量空间</li><li>LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）</li></ul></li></ol><hr><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><h5 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h5><p>Set 系列集合：添加的元素是无序，不重复，无索引的</p><ul><li>HashSet：添加的元素是无序，不重复，无索引的</li><li>LinkedHashSet：添加的元素是有序，不重复，无索引的</li><li>TreeSet：不重复，无索引，按照大小默认升序排序</li></ul><p><strong>面试问题</strong>：没有索引，不能使用普通 for 循环遍历</p><hr><h5 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h5><p>哈希值：</p><ul><li><p>哈希值：JDK 根据对象的地址或者字符串或者数字计算出来的数值</p></li><li><p>获取哈希值：Object 类中的 public int hashCode()</p></li><li><p>哈希值的特点</p><ul><li>同一个对象多次调用 hashCode() 方法返回的哈希值是相同的</li><li>默认情况下，不同对象的哈希值是不同的。而重写 hashCode() 方法，可以实现让不同对象的哈希值相同</li></ul></li></ul><p><strong>HashSet 底层就是基于 HashMap 实现，值是  PRESENT = new Object()</strong></p><p>Set集合添加的元素是无序，不重复的。</p><ul><li><p>是如何去重复的？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>对于有值特性的，Set集合可以直接判断进行去重复。<span class="number">2.</span>对于引用数据类型的类对象，Set集合是按照如下流程进行是否重复的判断。    Set集合会让两两对象，先调用自己的hashCode()方法得到彼此的哈希值（所谓的内存地址）    然后比较两个对象的哈希值是否相同，如果不相同则直接认为两个对象不重复。    如果哈希值相同，会继续让两个对象进行equals比较内容是否相同，如果相同认为真的重复了    如果不相同认为不重复。            Set集合会先让对象调用hashCode()方法获取两个对象的哈希值比较               /                     \            <span class="keyword">false</span>                    <span class="keyword">true</span>            /                          \        不重复                        继续让两个对象进行equals比较                                       /          \                                     <span class="keyword">false</span>        <span class="keyword">true</span>                                      /             \                                    不重复          重复了</span><br></pre></td></tr></table></figure></li><li><p>Set系列集合元素无序的根本原因</p><p>Set系列集合添加元素无序的根本原因是因为<strong>底层采用了哈希表存储元素</strong>。</p><pre><code>    JDK 1.8 之前：哈希表 = 数组（初始容量16) + 链表  + （哈希算法）    JDK 1.8 之后：哈希表 = 数组（初始容量16) + 链表 + 红黑树  + （哈希算法）    当链表长度超过阈值8且当前数组的长度 &gt; 64时，将链表转换为红黑树，减少了查找时间    当链表长度超过阈值8且当前数组的长度 &lt; 64时，扩容</code></pre><p><img src="https://gitee.com/seazean/images/raw/master/Java/HashSet%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E5%93%88%E5%B8%8C%E8%A1%A8.png"></p><p>每个元素的 hashcode() 的值进行响应的算法运算，计算出的值相同的存入一个数组块中，以链表的形式存储，如果链表长度超过8就采取红黑树存储，所以输出的元素是无序的。</p></li><li><p>如何设置只要对象内容一样，就希望集合认为它们重复了：<strong>重写 hashCode 和 equals 方法</strong></p></li></ul><hr><h5 id="Linked"><a href="#Linked" class="headerlink" title="Linked"></a>Linked</h5><p>LinkedHashSet 为什么是有序的？</p><p>LinkedHashSet 底层依然是使用哈希表存储元素的，但是每个元素都额外带一个链来维护添加顺序，不光增删查快，还有顺序，缺点是多了一个存储顺序的链会<strong>占内存空间</strong>，而且不允许重复，无索引</p><hr><h5 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h5><p>TreeSet 集合自排序的方式：</p><ol><li>有值特性的元素直接可以升序排序（浮点型，整型）</li><li>字符串类型的元素会按照首字符的编号排序</li><li>对于自定义的引用数据类型，TreeSet 默认无法排序，执行的时候报错，因为不知道排序规则</li></ol><p>自定义的引用数据类型，TreeSet 默认无法排序，需要定制排序的规则，方案有 2 种：</p><ul><li><p>直接为<strong>对象的类</strong>实现比较器规则接口 Comparable，重写比较方法：</p><p>方法：<code>public int compareTo(Employee o): this 是比较者, o 是被比较者</code></p><ul><li>比较者大于被比较者，返回正数（升序）</li><li>比较者小于被比较者，返回负数</li><li>比较者等于被比较者，返回 0</li></ul></li><li><p>直接为<strong>集合</strong>设置比较器 Comparator 对象，重写比较方法：</p><p>方法：<code>public int compare(Employee o1, Employee o2): o1 比较者, o2 被比较者</code></p><ul><li>比较者大于被比较者，返回正数</li><li>比较者小于被比较者，返回负数</li><li>比较者等于被比较者，返回 0</li></ul></li></ul><p>注意：如果类和集合都带有比较规则，优先使用集合自带的比较规则</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSetDemo</span></span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;        Set&lt;Student&gt; students = <span class="keyword">new</span> TreeSet&lt;&gt;();Collections.add(students,s1,s2,s3);        System.out.println(students);<span class="comment">//按照年龄比较 升序                Set&lt;Student&gt; s = new TreeSet&lt;&gt;(new Comparator&lt;Student&gt;()&#123;            @Override            public int compare(Student o1, Student o2) &#123;                // o1比较者   o2被比较者                return o2.getAge() - o1.getAge();//降序            &#125;        &#125;);    &#125;&#125;public class Student implements Comparable&lt;Student&gt;&#123;    private String name;    private int age;    // 重写了比较方法。    // e1.compareTo(o)    // 比较者：this    // 被比较者：o    // 需求：按照年龄比较 升序，年龄相同按照姓名    @Override    public int compareTo(Student o) &#123;        int result = this.age - o.age;        return result == 0 ? this.getName().compareTo(o.getName):result;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>比较器原理：底层是以第一个元素为基准，加一个新元素，就会和第一个元素比，如果大于，就继续和大于的元素进行比较，直到遇到比新元素大的元素为止，放在该位置的左边。（树）</p><hr><h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><p>Queue：队列，先进先出的特性</p><p>PriorityQueue 是优先级队列，底层存储结构为 Object[]，默认实现为小顶堆，每次出队最小的元素</p><p>构造方法：</p><ul><li><p><code>public PriorityQueue()</code>：构造默认长度为 11 的队列（数组）</p></li><li><p><code>public PriorityQueue(Comparator&lt;? super E&gt; comparator)</code>：利用比较器自定义堆排序的规则</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((v1, v2) -&gt; v2 - v1);<span class="comment">//实现大顶堆</span></span><br></pre></td></tr></table></figure></li></ul><p>常用 API：</p><ul><li><code>public boolean offer(E e)</code>：将指定的元素插入到此优先级队列中<strong>尾部</strong></li><li><code>public E poll() </code>：检索并删除此队列的<strong>头元素</strong>，如果此队列为空，则返回 null </li><li><code>public E peek()</code>：检索但不删除此队列的头，如果此队列为空，则返回 null</li><li><code>public boolean remove(Object o)</code>：从该队列中删除指定元素（如果存在），删除元素 e 使用 o.equals(e) 比较，如果队列包含多个这样的元素，删除第一个</li></ul><hr><h4 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h4><p>java.utils.Collections：集合<strong>工具类</strong>，Collections 并不属于集合，是用来操作集合的工具类</p><p>Collections 有几个常用的API：</p><ul><li><code>public static &lt;T&gt; boolean addAll(Collection&lt;? super T&gt; c, T... e)</code>：给集合对象批量添加元素</li><li><code>public static void shuffle(List&lt;?&gt; list)</code>：打乱集合顺序</li><li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>：将集合中元素按照默认规则排序</li><li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list,Comparator&lt;? super T&gt; )</code>：集合中元素按照指定规则排序</li><li><code>public static &lt;T&gt; List&lt;T&gt; synchronizedList(List&lt;T&gt; list)</code>：返回由指定 list 支持的线程安全 list</li><li><code>public static &lt;T&gt; Set&lt;T&gt; singleton(T o)</code>：返回一个只包含指定对象的不可变组</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionsDemo</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        Collection&lt;String&gt; names = <span class="keyword">new</span> ArrayList&lt;&gt;();        Collections.addAll(names,<span class="string">&quot;张&quot;</span>,<span class="string">&quot;王&quot;</span>,<span class="string">&quot;李&quot;</span>,<span class="string">&quot;赵&quot;</span>);                List&lt;Double&gt; scores = <span class="keyword">new</span> ArrayList&lt;&gt;();        Collections.addAll(scores, <span class="number">98.5</span>, <span class="number">66.5</span> , <span class="number">59.5</span> , <span class="number">66.5</span> , <span class="number">99.5</span> );        Collections.shuffle(scores);        Collections.sort(scores); <span class="comment">// 默认升序排序！        System.out.println(scores);                List&lt;Student&gt; students = new ArrayList&lt;&gt;();        Collections.addAll(students,s1,s2,s3,s4);        Collections.sort(students,new Comparator&lt;Student&gt;()&#123;                    &#125;)    &#125;&#125;public class Student&#123;    private String name;    private int age;&#125;</span></span><br></pre></td></tr></table></figure><hr><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h4 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h4><p>Collection 是单值集合体系，Map集合是一种双列集合，每个元素包含两个值。</p><p>Map集合的每个元素的格式：key=value（键值对元素），Map集合也被称为键值对集合</p><p>Map集合的完整格式：<code>&#123;key1=value1, key2=value2, key3=value3, ...&#125;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map集合的体系：        Map&lt;K , V&gt;(接口,Map集合的祖宗类)       /                      \      TreeMap&lt;K , V&gt;           HashMap&lt;K , V&gt;(实现类,经典的，用的最多)                                 \                                  LinkedHashMap&lt;K, V&gt;(实现类)</span><br></pre></td></tr></table></figure><p>Map集合的特点：</p><ol><li>Map 集合的特点都是由键决定的</li><li>Map 集合的键是无序，不重复的，无索引的（Set）</li><li>Map 集合的值无要求（List）</li><li>Map 集合的键值对都可以为 null</li><li>Map 集合后面重复的键对应元素会覆盖前面的元素</li></ol><p>HashMap：元素按照键是无序，不重复，无索引，值不做要求</p><p>LinkedHashMap：元素按照键是有序，不重复，无索引，值不做要求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//经典代码Map&lt;String , Integer&gt; maps = new HashMap&lt;&gt;();maps.put(&quot;手机&quot;,1);System.out.println(maps);</span></span><br></pre></td></tr></table></figure><hr><h4 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h4><p>Map 集合的常用 API</p><ul><li><code>public V put(K key, V value)</code>：把指定的键与值添加到 Map 集合中，<strong>重复的键会覆盖前面的值元素</strong></li><li><code>public V remove(Object key)</code>：把指定的键对应的键值对元素在集合中删除，返回被删除元素的值</li><li><code>public V get(Object key)</code>：根据指定的键，在 Map 集合中获取对应的值</li><li><code>public Set&lt;K&gt; keySet()</code>：获取 Map 集合中所有的键，存储到 <strong>Set 集合</strong>中</li><li><code>public Collection&lt;V&gt; values()</code>：获取全部值的集合，存储到 <strong>Collection 集合</strong></li><li><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>：获取Map集合中所有的键值对对象的集合</li><li><code>public boolean containsKey(Object key)</code>：判断该集合中是否有此键</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapDemo</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        Map&lt;String , Integer&gt; maps = <span class="keyword">new</span> HashMap&lt;&gt;();        maps.put(.....);        System.out.println(maps.isEmpty());<span class="comment">//false        Integer value = maps.get(&quot;....&quot;);//返回键值对象        Set&lt;String&gt; keys = maps.keySet();//获取Map集合中所有的键，        //Map集合的键是无序不重复的，所以返回的是一个Set集合        Collection&lt;Integer&gt; values = maps.values();        //Map集合的值是不做要求的，可能重复，所以值要用Collection集合接收!    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h4><p>Map集合的遍历方式有：3种。</p><ol><li>“键找值”的方式遍历：先获取 Map 集合全部的键，再根据遍历键找值。</li><li>“键值对”的方式遍历：难度较大，采用增强 for 或者迭代器</li><li>JDK 1.8 开始之后的新技术：foreach，采用 Lambda表 达式</li></ol><p>集合可以直接输出内容，因为底层重写了 toString() 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;    Map&lt;String , Integer&gt; maps = <span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//(1)键找值    Set&lt;String&gt; keys = maps.keySet();    for(String key : keys) &#123;        System.out.println(key + &quot;=&quot; + maps.get(key));    &#125;    //Iterator&lt;String&gt; iterator = hm.keySet().iterator();        //(2)键值对    //(2.1)普通方式    Set&lt;Map.Entry&lt;String,Integer&gt;&gt; entries = maps.entrySet();    for (Map.Entry&lt;String, Integer&gt; entry : entries) &#123;             System.out.println(entry.getKey() + &quot;=&gt;&quot; + entry.getValue());    &#125;    //(2.2)迭代器方式    Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator = maps.entrySet().iterator();    while (iterator.hasNext()) &#123;        Map.Entry&lt;String, Integer&gt; entry = iterator.next();        System.out.println(entry.getKey() + &quot;=&quot; + entry.getValue());    &#125;    //(3) Lamda    maps.forEach((k,v) -&gt; &#123;        System.out.println(k + &quot;==&gt;&quot; + v);    &#125;)&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><h5 id="基本介绍-9"><a href="#基本介绍-9" class="headerlink" title="基本介绍"></a>基本介绍</h5><p>HashMap 基于哈希表的 Map 接口实现，是以 key-value 存储形式存在，主要用来存放键值对</p><p>特点：</p><ul><li>HashMap 的实现不是同步的，这意味着它不是线程安全的</li><li>key 是唯一不重复的，底层的哈希表结构，依赖 hashCode 方法和 equals 方法保证键的唯一</li><li>key、value 都可以为null，但是 key 位置只能是一个null</li><li>HashMap 中的映射不是有序的，即存取是无序的</li><li><strong>key 要存储的是自定义对象，需要重写 hashCode 和 equals 方法，防止出现地址不同内容相同的 key</strong></li></ul><p>JDK7 对比 JDK8：</p><ul><li>7 = 数组 + 链表，8 = 数组 + 链表 + 红黑树</li><li>7 中是头插法，多线程容易造成环，8 中是尾插法</li><li>7 的扩容是全部数据重新定位，8 中是位置不变或者当前位置 + 旧 size 大小来实现</li><li>7 是先判断是否要扩容再插入，8 中是先插入再看是否要扩容</li></ul><p>底层数据结构：</p><ul><li><p>哈希表（Hash table，也叫散列表），根据关键码值而直接访问的数据结构。通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度，这个映射函数叫做散列函数，存放记录的数组叫做散列表</p></li><li><p>JDK1.8 之前 HashMap 由 数组+链表 组成</p><ul><li>数组是 HashMap 的主体</li><li>链表则是为了解决哈希冲突而存在的（<strong>拉链法解决冲突</strong>），拉链法就是头插法，两个对象调用的 hashCode 方法计算的哈希码值（键的哈希）一致导致计算的数组索引值相同</li></ul></li><li><p>JDK1.8 以后 HashMap 由 <strong>数组+链表 +红黑树</strong>数据结构组成</p><ul><li>解决哈希冲突时有了较大的变化</li><li>当链表长度<strong>超过（大于）阈值</strong>（或者红黑树的边界值，默认为 8）并且当前数组的<strong>长度大于等于 64 时</strong>，此索引位置上的所有数据改为红黑树存储</li><li>即使哈希函数取得再好，也很难达到元素百分百均匀分布。当 HashMap 中有大量的元素都存放到同一个桶中时，就相当于一个长的单链表，假如单链表有 n 个元素，遍历的**时间复杂度是 O(n)<strong>，所以 JDK1.8 中引入了 红黑树（查找</strong>时间复杂度为 O(logn)**）来优化这个问题，使得查找效率更高</li></ul><p><img src="https://gitee.com/seazean/images/raw/master/Java/HashMap%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84.png"></p></li></ul><p>参考视频：<a href="https://www.bilibili.com/video/BV1nJ411J7AA">https://www.bilibili.com/video/BV1nJ411J7AA</a></p><hr><h5 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h5><p>HashMap继承关系如下图所示：</p><p><img src="https://gitee.com/seazean/images/raw/master/Java/HashMap%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.bmp"></p><p>说明：</p><ul><li>Cloneable 空接口，表示可以克隆， 创建并返回HashMap对象的一个副本。</li><li>Serializable 序列化接口，属于标记性接口，HashMap对象可以被序列化和反序列化。</li><li>AbstractMap 父类提供了Map实现接口，以最大限度地减少实现此接口所需的工作</li></ul><hr><h5 id="成员属性"><a href="#成员属性" class="headerlink" title="成员属性"></a>成员属性</h5><ol><li><p>序列化版本号</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">362498820763181265L</span>;</span><br></pre></td></tr></table></figure></li><li><p>集合的初始化容量（<strong>必须是二的 n 次幂</strong> ）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认的初始容量是16 -- 1&lt;&lt;4相当于1*2的4次方---1*16static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;   </span></span><br></pre></td></tr></table></figure><p>HashMap 构造方法指定集合的初始化容量大小：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashMap(<span class="keyword">int</span> initialCapacity)<span class="comment">// 构造一个带指定初始容量和默认加载因子 (0.75) 的空 HashMap</span></span><br></pre></td></tr></table></figure><ul><li><p>为什么必须是 2 的 n 次幂？</p><p>HashMap 中添加元素时，需要根据 key 的 hash 值，确定在数组中的具体位置。为了存取高效，要尽量较少碰撞，把数据尽可能分配均匀，每个链表长度大致相同，实现该方法的算法就是取模，hash%length，计算机中直接求余效率不如位移运算，所以源码中使用 hash&amp;(length-1)，实际上<strong>hash % length == hash &amp; (length-1)的前提是 length 是 2 的n次幂</strong></p><p>散列平均分布：2 的 n 次方是 1 后面 n 个 0，2 的 n 次方 -1 是 n 个 1，可以<strong>保证散列的均匀性</strong>，减少碰撞</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如长度为<span class="number">8</span>时候，<span class="number">3</span>&amp;(<span class="number">8</span>-<span class="number">1</span>)=<span class="number">3</span>  <span class="number">2</span>&amp;(<span class="number">8</span>-<span class="number">1</span>)=<span class="number">2</span> ，不同位置上，不碰撞；例如长度为<span class="number">9</span>时候，<span class="number">3</span>&amp;(<span class="number">9</span>-<span class="number">1</span>)=<span class="number">0</span>  <span class="number">2</span>&amp;(<span class="number">9</span>-<span class="number">1</span>)=<span class="number">0</span> ，都在<span class="number">0</span>上，碰撞了；</span><br></pre></td></tr></table></figure></li><li><p>如果输入值不是 2 的幂会怎么样？</p><p>创建 HashMap 对象时，HashMap 通过位移运算和或运算得到的肯定是 2 的幂次数，并且是大于那个数的最近的数字，底层采用 tableSizeFor() 方法</p></li></ul></li><li><p>默认的负载因子，默认值是 0.75 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure></li><li><p>集合最大容量 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 集合最大容量的上限是：2的30次幂static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;// 0100 0000 0000 0000 0000 0000 0000 0000 = 2 ^ 30</span></span><br></pre></td></tr></table></figure><p>最大容量为什么是 2 的 30 次方原因：</p><ul><li>int 类型是 32 位整型，占 4 个字节</li><li>Java 的原始类型里没有无符号类型，所以首位是符号位正数为 0，负数为 1，</li></ul></li><li><p>当链表的值超过 8 则会转红黑树（JDK1.8 新增）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当桶(bucket)上的结点数大于这个值时会转成红黑树static final int TREEIFY_THRESHOLD = 8;</span></span><br></pre></td></tr></table></figure><p>为什么 Map 桶中节点个数大于 8 才转为红黑树？</p><ul><li><p>在 HashMap 中有一段注释说明：<strong>空间和时间的权衡</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TreeNodes占用空间大约是普通节点的两倍，所以我们只在箱子包含足够的节点时才使用树节点。当节点变少(由于删除或调整大小)时，就会被转换回普通的桶。在使用分布良好的用户hashcode时，很少使用树箱。理想情况下，在随机哈希码下，箱子中节点的频率服从<span class="string">&quot;泊松分布&quot;</span>，默认调整阈值为<span class="number">0.75</span>，平均参数约为<span class="number">0.5</span>，尽管由于调整粒度的差异很大。忽略方差，列表大小k的预期出现次数是(exp(-<span class="number">0.5</span>)*pow(<span class="number">0.5</span>, k)/factorial(k))<span class="number">0</span>:    <span class="number">0.606530661</span>:    <span class="number">0.303265332</span>:    <span class="number">0.075816333</span>:    <span class="number">0.012636064</span>:    <span class="number">0.001579525</span>:    <span class="number">0.000157956</span>:    <span class="number">0.000013167</span>:    <span class="number">0.000000948</span>:    <span class="number">0.</span>00000006more: less than <span class="number">1</span> in ten million一个bin中链表长度达到<span class="number">8</span>个元素的概率为<span class="number">0.00000006</span>，几乎是不可能事件，所以我们选择<span class="number">8</span>这个数字</span><br></pre></td></tr></table></figure></li><li><p>其他说法<br>红黑树的平均查找长度是 log(n)，如果长度为 8，平均查找长度为 log(8)=3，链表的平均查找长度为 n/2，当长度为 8 时，平均查找长度为 8/2=4，这才有转换成树的必要；链表长度如果是小于等于 6，6/2=3，而 log(6)=2.6，虽然速度也很快的，但转化为树结构和生成树的时间并不短</p></li></ul></li><li><p>当链表的值小 于 6 则会从红黑树转回链表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当桶(bucket)上的结点数小于这个值时树转链表static final int UNTREEIFY_THRESHOLD = 6;</span></span><br></pre></td></tr></table></figure></li><li><p>当 Map 里面的数量<strong>大于等于</strong>这个阈值时，表中的桶才能进行树形化 ，否则桶内元素超过 8 时会扩容，而不是树形化。为了避免进行扩容、树形化选择的冲突，这个值不能小于 4 * TREEIFY_THRESHOLD (8)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 桶中结构转化为红黑树对应的数组长度最小的值 static final int MIN_TREEIFY_CAPACITY = 64;</span></span><br></pre></td></tr></table></figure><p>原因：数组比较小的情况下变为红黑树结构，反而会降低效率，红黑树需要进行左旋，右旋，变色这些操作来保持平衡。同时数组长度小于 64 时，搜索时间相对快些，所以为了提高性能和减少搜索时间，底层在阈值大于 8 并且数组长度大于 64 时，链表才转换为红黑树，效率也变的更高效</p></li><li><p>table 用来初始化（必须是二的 n 次幂）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储元素的数组 transient Node&lt;K,V&gt;[] table;</span></span><br></pre></td></tr></table></figure><p>jdk8 之前数组类型是 Entry&lt;K,V&gt;类型，之后是 Node&lt;K,V&gt; 类型。只是换了个名字，都实现了一样的接口 Map.Entry&lt;K,V&gt;，负责存储键值对数据的</p></li><li><p>HashMap 中<strong>存放元素的个数</strong>（<strong>重点</strong>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存放元素的个数，HashMap中K-V的实时数量，不是table数组的长度transient int size;</span></span><br></pre></td></tr></table></figure></li><li><p>记录 HashMap 的修改次数 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每次扩容和更改map结构的计数器 transient int modCount;  </span></span><br></pre></td></tr></table></figure></li><li><p>调整大小下一个容量的值计算方式为（容量 * 负载因子）</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 临界值，当实际大小(容量*负载因子)超过临界值时，会进行扩容int threshold;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>哈希表的加载因子（重点）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure><ul><li><p>加载因子的概述</p><p>loadFactor 加载因子，是用来衡量 HashMap 满的程度，表示 <strong>HashMap 的疏密程度</strong>，影响 hash 操作到同一个数组位置的概率，计算 HashMap 的实时加载因子的方法为：size/capacity，而不是占用桶的数量去除以 capacity，capacity 是桶的数量，也就是 table 的长度 length。</p><p>当 HashMap 里面容纳的元素已经达到 HashMap 数组长度的 75% 时，表示 HashMap 拥挤，需要扩容，而扩容这个过程涉及到  rehash、复制数据等操作，非常消耗性能，所以开发中尽量减少扩容的次数，可以通过创建 HashMap 集合对象时指定初始容量来尽量避免。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashMap(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)<span class="comment">//构造指定初始容量和加载因子的空HashMap</span></span><br></pre></td></tr></table></figure></li><li><p>为什么加载因子设置为 0.75，初始化临界值是 12？</p><p>loadFactor 太大导致查找元素效率低，存放的数据拥挤，太小导致数组的利用率低，存放的数据会很分散。loadFactor 的默认值为 <strong>0.75f 是官方给出的一个比较好的临界值</strong></p></li><li><p>threshold 计算公式：capacity(数组长度默认16) * loadFactor(负载因子默认 0.75)。这个值是当前已占用数组长度的最大值。<strong>当 size&gt;=threshold</strong> 的时候，那么就要考虑对数组的 resize(扩容)，这就是衡量数组是否需要扩增的一个标准， 扩容后的 HashMap 容量是之前容量的<strong>两倍</strong>.</p></li></ul></li></ol><hr><h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><ul><li><p>构造一个空的 HashMap ，<strong>默认初始容量（16）和默认负载因子（0.75）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;<span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// 将默认的加载因子0.75赋值给loadFactor，并没有创建数组&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>构造一个具有指定的初始容量和默认负载因子（0.75）HashMap</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定“容量大小”的构造函数public HashMap(int initialCapacity) &#123;    this(initialCapacity, DEFAULT_LOAD_FACTOR);&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>构造一个具有指定的初始容量和负载因子的 HashMap</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;    <span class="comment">// 进行判断    // 将指定的加载因子赋值给HashMap成员变量的负载因子loadFactor    this.loadFactor = loadFactor;  // 最后调用了tableSizeFor    this.threshold = tableSizeFor(initialCapacity);&#125;</span></span><br></pre></td></tr></table></figure><ul><li><p>对于 <code>this.threshold = tableSizeFor(initialCapacity)</code> </p><p>JDK8 以后的构造方法中，并没有对 table 这个成员变量进行初始化，table 的初始化被推迟到了 put 方法中，在 put 方法中会对 threshold 重新计算</p></li></ul></li><li><p>包含另一个 <code>Map</code> 的构造函数 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造一个映射关系与指定 Map 相同的新 HashMappublic HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;    // 负载因子loadFactor变为默认的负载因子0.75    this.loadFactor = DEFAULT_LOAD_FACTOR;    putMapEntries(m, false);&#125;</span></span><br></pre></td></tr></table></figure><p>putMapEntries 源码分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>&#123;    <span class="comment">//获取参数集合的长度    int s = m.size();    if (s &gt; 0) &#123;        //判断参数集合的长度是否大于0        if (table == null) &#123;  // 判断table是否已经初始化            // pre-size            // 未初始化，s为m的实际元素个数            float ft = ((float)s / loadFactor) + 1.0F;            int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ?                     (int)ft : MAXIMUM_CAPACITY);            // 计算得到的t大于阈值，则初始化阈值            if (t &gt; threshold)                threshold = tableSizeFor(t);        &#125;        // 已初始化，并且m元素个数大于阈值，进行扩容处理        else if (s &gt; threshold)            resize();        // 将m中的所有元素添加至HashMap中        for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;            K key = e.getKey();            V value = e.getValue();            putVal(hash(key), key, value, false, evict);        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p><code>float ft = ((float)s / loadFactor) + 1.0F</code> 这一行代码中为什么要加 1.0F ？</p><p>s / loadFactor 的结果是小数，加 1.0F 相当于是对小数做一个向上取整以尽可能的保证更大容量，更大的容量能够减少 resize 的调用次数，这样可以减少数组的扩容</p></li></ul><hr><h5 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h5><ul><li><p>hash()：HashMap 是支持 Key 为空的；HashTable 是直接用 Key 来获取 HashCode，key 为空会抛异常</p><ul><li>&amp;（按位与运算）：相同的二进制数位上，都是 1 的时候，结果为 1，否则为零</li><li>^（按位异或运算）：相同的二进制数位上，数字相同，结果为 0，不同为 1，<strong>不进位加法</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;    <span class="keyword">int</span> h;    <span class="comment">// 1）如果key等于null：可以看到当key等于null的时候也是有哈希值的，返回的是0.    // 2）如果key不等于null：首先计算出key的hashCode赋值给h,然后与h无符号右移16位后的二进制进行按位异或得到最后的hash值    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;</span></span><br></pre></td></tr></table></figure><p>计算 hash 的方法：将 hashCode 无符号右移 16 位，高 16bit 和低 16bit 做异或，扰动运算</p><p>原因：当数组长度很小，假设是 16，那么 n-1即为 1111 ，这样的值和 hashCode() 直接做按位与操作，实际上只使用了哈希值的后4位。如果当哈希值的高位变化很大，低位变化很小，就很容易造成哈希冲突了，所以这里<strong>把高低位都利用起来，让高16 位也参与运算</strong>，从而解决了这个问题</p><p>哈希冲突的处理方式：</p><ul><li>开放定址法：线性探查法（ThreadLocalMap 使用），平方探查法（i + 1^2、i - 1^2、i + 2^2……）、双重散列（多个哈希函数）</li><li>链地址法：拉链法</li></ul></li><li><p>put()：jdk1.8 前是头插法 (拉链法)，多线程下扩容出现循环链表，jdk1.8 以后引入红黑树，插入方法变成尾插法</p><p>第一次调用 put 方法时创建数组 Node[] table，因为散列表耗费内存，为了防止内存浪费，所以<strong>延迟初始化</strong></p><p>存储数据步骤（存储过程）：</p><ol><li>先通过 hash 值计算出 key 映射到哪个桶，哈希寻址</li><li>如果桶上没有碰撞冲突，则直接插入</li><li>如果出现碰撞冲突：如果该桶使用红黑树处理冲突，则调用红黑树的方法插入数据；否则采用传统的链式方法插入，如果链的长度达到临界值，则把链转变为红黑树</li><li>如果数组位置相同，通过 equals 比较内容是否相同：相同则新的 value 覆盖旧 value，不相同则将新的键值对添加到哈希表中</li><li>最后判断 size 是否大于阈值 threshold，则进行扩容</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);&#125;</span><br></pre></td></tr></table></figure><p>putVal() 方法中 key 在这里执行了一下 hash()，在 putVal 函数中使用到了上述 hash 函数计算的哈希值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;  <span class="comment">//。。。。。。。。。。。。。。  if ((p = tab[i = (n - 1) &amp; hash]) == null)&#123;//这里的n表示数组长度16  //.....      &#125; else &#123;          if (e != null) &#123; // existing mapping for key              V oldValue = e.value;              //onlyIfAbsent默认为false，所以可以覆盖已经存在的数据，如果为true说明不能覆盖              if (!onlyIfAbsent || oldValue == null)                  e.value = value;              afterNodeAccess(e);              // 如果这里允许覆盖，就直接返回了              return oldValue;          &#125;      &#125;    // 如果是添加操作，modCount ++，如果不是替换，不会走这里的逻辑，modCount用来记录逻辑的变化    ++modCount;    // 数量大于扩容阈值    if (++size &gt; threshold)        resize();    afterNodeInsertion(evict);    return null;&#125;</span></span><br></pre></td></tr></table></figure><ul><li><code>(n - 1) &amp; hash</code>：计算下标位置</li></ul>  <img src="https://gitee.com/seazean/images/raw/master/Java/HashMap-putVal哈希运算.png" style="zoom: 67%;"><ul><li>余数本质是不断做除法，把剩余的数减去，运算效率要比位运算低</li></ul></li><li><p>treeifyBin()</p><p>节点添加完成之后判断此时节点个数是否大于TREEIFY_THRESHOLD临界值8，如果大于则将链表转换为红黑树，转换红黑树的方法 treeifyBin，整体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st   //转换为红黑树 tab表示数组名  hash表示哈希值   treeifyBin(tab, hash);</span></span><br></pre></td></tr></table></figure><ol><li>如果当前数组为空或者数组的长度小于进行树形化的阈值(MIN_TREEIFY_CAPACITY = 64)就去扩容，而不是将节点变为红黑树</li><li>如果是树形化遍历桶中的元素，创建相同个数的树形节点，复制内容，建立起联系，类似单向链表转换为双向链表</li><li>让桶中的第一个元素即数组中的元素指向新建的红黑树的节点，以后这个桶里的元素就是红黑树而不是链表数据结构了</li></ol></li><li><p>tableSizeFor()：创建 HashMap 指定容量时，HashMap 通过位移运算和或运算得到比指定初始化容量大的最小的 2 的 n 次幂</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;<span class="comment">//int cap = 10    int n = cap - 1;    n |= n &gt;&gt;&gt; 1;    n |= n &gt;&gt;&gt; 2;    n |= n &gt;&gt;&gt; 4;    n |= n &gt;&gt;&gt; 8;    n |= n &gt;&gt;&gt; 16;    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;&#125;</span></span><br></pre></td></tr></table></figure><p>分析算法：</p><ol><li><code>int n = cap - 1</code>：防止 cap 已经是 2 的幂。如果 cap 已经是 2 的幂， 不执行减 1 操作，则执行完后面的无符号右移操作之后，返回的 capacity 将是这个 cap 的 2 倍</li><li>n=0 （cap-1 之后），则经过后面的几次无符号右移依然是 0，返回的 capacity 是 1，最后有 n+1</li><li>|（按位或运算）：相同的二进制数位上，都是 0 的时候，结果为 0，否则为 1</li><li>核心思想：<strong>把最高位是 1 的位以及右边的位全部置 1</strong>，结果加 1 后就是大于指定容量的最小的 2 的 n 次幂</li></ol><p>例如初始化的值为 10：</p><ul><li><p>第一次右移</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = cap - <span class="number">1</span>;<span class="comment">//cap=10  n=9n |= n &gt;&gt;&gt; 1;00000000 00000000 00000000 00001001 //900000000 00000000 00000000 00000100 //9右移之后变为4--------------------------------------------------00000000 00000000 00000000 00001101 //按位或之后是13//使得n的二进制表示中与最高位的1紧邻的右边一位为1</span></span><br></pre></td></tr></table></figure></li><li><p>第二次右移</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n |= n &gt;&gt;&gt; <span class="number">2</span>;<span class="comment">//n通过第一次右移变为了：n=1300000000 00000000 00000000 00001101  // 1300000000 00000000 00000000 00000011  // 13右移之后变为3-------------------------------------------------00000000 00000000 00000000 00001111 //按位或之后是15//无符号右移两位，会将最高位两个连续的1右移两位，然后再与原来的n做或操作，这样n的二进制表示的高位中会有4个连续的1</span></span><br></pre></td></tr></table></figure><p>注意：容量最大是 32bit 的正数，因此最后 <code>n |= n &gt;&gt;&gt; 16</code>，最多是 32 个 1（但是这已经是负数了）。在执行 tableSizeFor 之前，对 initialCapacity 做了判断，如果大于 MAXIMUM_CAPACITY(2 ^ 30)，则取 MAXIMUM_CAPACITY；如果小于 MAXIMUM_CAPACITY(2 ^ 30)，会执行移位操作，所以移位操作之后，最大 30 个 1，加 1 之后得 2 ^ 30</p></li><li><p>得到的 capacity 被赋值给了 threshold</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);<span class="comment">//initialCapacity=10</span></span><br></pre></td></tr></table></figure></li><li><p>JDK 11</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;    <span class="comment">//无符号右移，高位补0//-1补码: 11111111 11111111 11111111 11111111    int n = -1 &gt;&gt;&gt; Integer.numberOfLeadingZeros(cap - 1);    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;&#125;//返回最高位之前的0的位数public static int numberOfLeadingZeros(int i) &#123;    if (i &lt;= 0)        return i == 0 ? 32 : 0;    // 如果i&gt;0，那么就表明在二进制表示中其至少有一位为1    int n = 31;    // i的最高位1在高16位，把i右移16位，让最高位1进入低16位继续递进判断    if (i &gt;= 1 &lt;&lt; 16) &#123; n -= 16; i &gt;&gt;&gt;= 16; &#125;    if (i &gt;= 1 &lt;&lt;  8) &#123; n -=  8; i &gt;&gt;&gt;=  8; &#125;    if (i &gt;= 1 &lt;&lt;  4) &#123; n -=  4; i &gt;&gt;&gt;=  4; &#125;    if (i &gt;= 1 &lt;&lt;  2) &#123; n -=  2; i &gt;&gt;&gt;=  2; &#125;    return n - (i &gt;&gt;&gt; 1);&#125;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>resize()：</p><p>当 HashMap 中的<strong>元素个数</strong>超过 <code>(数组长度)*loadFactor(负载因子)</code> 或者链表过长时（链表长度 &gt; 8，数组长度 &lt; 64），就会进行数组扩容，创建新的数组，伴随一次重新 hash 分配，并且遍历 hash 表中所有的元素非常耗时，所以要尽量避免 resize</p><p>扩容机制为扩容为原来容量的 2 倍：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;    <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;        <span class="comment">// 以前的容量已经是最大容量了，这时调大 扩容阈值 threshold        threshold = Integer.MAX_VALUE;        return oldTab;    &#125;    else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;             oldCap &gt;= DEFAULT_INITIAL_CAPACITY)        newThr = oldThr &lt;&lt; 1; // double threshold&#125;else if (oldThr &gt; 0) // 初始化的threshold赋值给newCap    newCap = oldThr;else &#123;     newCap = DEFAULT_INITIAL_CAPACITY;    newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);&#125;</span></span><br></pre></td></tr></table></figure><p>HashMap 在进行扩容后，节点<strong>要么就在原来的位置，要么就被分配到”原位置+旧容量”的位置</strong></p><p>判断：e.hash 与 oldCap 对应的有效高位上的值是 1，即当前数组长度 n 二进制为 1 的位为 x 位，如果 key 的哈希值 x 位也为 1，则扩容后的索引为 now + n</p><p>注意：这里要求<strong>数组长度 2 的幂</strong></p><p><img src="https://gitee.com/seazean/images/raw/master/Java/HashMap-resize%E6%89%A9%E5%AE%B9.png"></p><p>普通节点：把所有节点分成高低位两个链表，转移到数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历所有的节点do &#123;    next = e.next;    // oldCap 旧数组大小，2 的 n 次幂    if ((e.hash &amp; oldCap) == 0) &#123;        if (loTail == null)            loHead = e;//指向低位链表头节点        else            loTail.next = e;        loTail = e;//指向低位链表尾节点    &#125;    else &#123;        if (hiTail == null)            hiHead = e;        else            hiTail.next = e;        hiTail = e;    &#125;&#125; while ((e = next) != null);if (loTail != null) &#123;    loTail.next = null;// 低位链表的最后一个节点可能在原哈希表中指向其他节点，需要断开    newTab[j] = loHead;&#125;</span></span><br></pre></td></tr></table></figure><p>红黑树节点：扩容时 split 方法会将树<strong>拆成高位和低位两个链表</strong>，判断长度是否小于等于 6</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果低位链表首节点不为null，说明有这个链表存在if (loHead != null) &#123;    //如果链表下的元素小于等于6    if (lc &lt;= UNTREEIFY_THRESHOLD)        //那就从红黑树转链表了，低位链表，迁移到新数组中下标不变，还是等于原数组到下标        tab[index] = loHead.untreeify(map);    else &#123;        //低位链表，迁移到新数组中下标不变，把低位链表整个赋值到这个下标下        tab[index] = loHead;        //如果高位首节点不为空，说明原来的红黑树已经被拆分成两个链表了        if (hiHead != null)            //需要构建新的红黑树了            loHead.treeify(tab);    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><p>​    </p><ul><li><p>remove()：删除是首先先找到元素的位置，如果是链表就遍历链表找到元素之后删除。如果是用红黑树就遍历树然后找到之后做删除，树小于 6 的时候退化为链表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,                            <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;     Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;     <span class="comment">// 节点数组tab不为空、数组长度n大于0、根据hash定位到的节点对象p，     // 该节点为树的根节点或链表的首节点）不为空，从该节点p向下遍历，找到那个和key匹配的节点对象     if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;         (p = tab[index = (n - 1) &amp; hash]) != null) &#123;         Node&lt;K,V&gt; node = null, e; K k; V v;//临时变量，储存要返回的节点信息         //key和value都相等，直接返回该节点         if (p.hash == hash &amp;&amp;             ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))             node = p;                  else if ((e = p.next) != null) &#123;             //如果是树节点，调用getTreeNode方法从树结构中查找满足条件的节点             if (p instanceof TreeNode)                 node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);             //遍历链表             else &#123;                 do &#123;                     //e节点的键是否和key相等，e节点就是要删除的节点，赋值给node变量                     if (e.hash == hash &amp;&amp;                         ((k = e.key) == key ||                          (key != null &amp;&amp; key.equals(k)))) &#123;                         node = e;                         //跳出循环                         break;                     &#125;                     p = e;//把当前节点p指向e 继续遍历                 &#125; while ((e = e.next) != null);             &#125;         &#125;         //如果node不为空，说明根据key匹配到了要删除的节点         //如果不需要对比value值或者对比value值但是value值也相等，可以直接删除         if (node != null &amp;&amp; (!matchValue || (v = node.value) == value ||                              (value != null &amp;&amp; value.equals(v)))) &#123;             if (node instanceof TreeNode)                 ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable);             else if (node == p)//node是首节点                 tab[index] = node.next;             else//node不是首节点                 p.next = node.next;             ++modCount;             --size;             //LinkedHashMap             afterNodeRemoval(node);             return node;         &#125;     &#125;     return null; &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>get()</p><ol><li><p>通过 hash 值获取该 key 映射到的桶</p></li><li><p>桶上的 key 就是要查找的 key，则直接找到并返回</p></li><li><p>桶上的 key 不是要找的 key，则查看后续的节点：</p><ul><li><p>如果后续节点是红黑树节点，通过调用红黑树的方法根据 key 获取v alue</p></li><li><p>如果后续节点是链表节点，则通过循环遍历链表根据 key 获取 value </p></li></ul></li><li><p>红黑树节点调用的是 getTreeNode 方法通过树形节点的 find 方法进行查</p><ul><li>查找红黑树，之前添加时已经保证这个树是有序的，因此查找时就是折半查找，效率更高。</li><li>这里和插入时一样，如果对比节点的哈希值相等并且通过 equals 判断值也相等，就会判断 key 相等，直接返回，不相等就从子树中递归查找</li></ul></li><li><p>时间复杂度 O(1)</p><ul><li>若为树，则在树中通过 key.equals(k) 查找，<strong>O(logn)</strong> </li><li>若为链表，则在链表中通过 key.equals(k) 查找，<strong>O(n)</strong></li></ul></li></ol></li></ul><hr><h5 id="并发异常"><a href="#并发异常" class="headerlink" title="并发异常"></a>并发异常</h5><p>HashMap 和 ArrayList 一样，内部采用 modCount 用来记录集合结构发生变化的次数，结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化</p><p>在进行序列化或者迭代等操作时，需要比较操作前后 modCount 是否改变，如果<strong>其他线程此时修改了集合内部的结构</strong>，就会直接抛出 ConcurrentModificationException 异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashMap map = <span class="keyword">new</span> HashMap();Iterator iterator = map.keySet().iterator();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">K</span>&gt; </span>&#123;    <span class="comment">// 底层获取的是 KeyIteratorpublic final Iterator&lt;K&gt; iterator()     &#123;         return new KeyIterator();     &#125;&#125;final class KeyIterator extends HashIterator implements Iterator&lt;K&gt; &#123;    // 回调 HashMap.HashIterator#nextNode    public final K next() &#123;         return nextNode().key;     &#125;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HashIterator</span> </span>&#123;    Node&lt;K,V&gt; next;        <span class="comment">// next entry to return    Node&lt;K,V&gt; current;     // current entry    int expectedModCount;  // for 【fast-fail】，快速失败    int index;             // current slot    HashIterator() &#123;        // 把当前 map 的数量赋值给 expectedModCount，迭代时判断        expectedModCount = modCount;        Node&lt;K,V&gt;[] t = table;        current = next = null;        index = 0;        if (t != null &amp;&amp; size &gt; 0) &#123; // advance to first entry            do &#123;&#125; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null);        &#125;    &#125;    public final boolean hasNext() &#123;        return next != null;    &#125;// iterator.next() 会调用这个函数    final Node&lt;K,V&gt; nextNode() &#123;        Node&lt;K,V&gt;[] t;        Node&lt;K,V&gt; e = next;        // 这里会判断 集合的结构是否发生了变化，变化后 modCount 会改变，直接抛出并发异常        if (modCount != expectedModCount)            throw new ConcurrentModificationException();        if (e == null)            throw new NoSuchElementException();        if ((next = (current = e).next) == null &amp;&amp; (t = table) != null) &#123;            do &#123;&#125; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null);        &#125;        return e;    &#125;// 迭代器允许删除集合的元素，【删除后会重置 expectedModCount = modCount】    public final void remove() &#123;        Node&lt;K,V&gt; p = current;        if (p == null)            throw new IllegalStateException();        if (modCount != expectedModCount)            throw new ConcurrentModificationException();        current = null;        K key = p.key;        removeNode(hash(key), key, null, false, false);        // 同步expectedModCount        expectedModCount = modCount;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="LinkedMap"><a href="#LinkedMap" class="headerlink" title="LinkedMap"></a>LinkedMap</h4><h5 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h5><p>LinkedHashMap 是 HashMap 的子类</p><ul><li><p>优点：添加的元素按照键有序不重复的，有序的原因是底层维护了一个双向链表</p></li><li><p>缺点：会占用一些内存空间</p></li></ul><p>对比 Set：</p><ul><li>HashSet 集合相当于是 HashMap 集合的键，不带值</li><li>LinkedHashSet 集合相当于是 LinkedHashMap 集合的键，不带值</li><li>底层原理完全一样，都是基于哈希表按照键存储数据的，只是 Map 多了一个键的值</li></ul><p>源码解析：</p><ul><li><p>内部维护了一个双向链表，用来维护插入顺序或者 LRU 顺序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;<span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br></pre></td></tr></table></figure></li><li><p>accessOrder 决定了顺序，默认为 false 维护的是插入顺序（先进先出），true 为访问顺序（<strong>LRU 顺序</strong>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</span><br></pre></td></tr></table></figure></li><li><p>维护顺序的函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123;&#125;<span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>put()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用父类HashMap的put方法public V put(K key, V value) &#123;    return putVal(hash(key), key, value, false, true);&#125;final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict)→ afterNodeInsertion(evict);// evict为true</span></span><br></pre></td></tr></table></figure><p>afterNodeInsertion方法，当 removeEldestEntry() 方法返回 true 时会移除最近最久未使用的节点，也就是链表首部节点 first</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123;    LinkedHashMap.Entry&lt;K,V&gt; first;    <span class="comment">// evict 只有在构建 Map 的时候才为 false，这里为 true    if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) &#123;        K key = first.key;        removeNode(hash(key), key, null, false, true);//移除头节点    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>removeEldestEntry() 默认为 false，如果需要让它为 true，需要继承 LinkedHashMap 并且覆盖这个方法的实现，在实现 LRU 的缓存中特别有用，通过移除最近最久未使用的节点，从而保证缓存空间足够，并且缓存的数据都是热点数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;    <span class="keyword">return</span> <span class="keyword">false</span>;&#125;</span><br></pre></td></tr></table></figure></li><li><p>get()</p><p>当一个节点被访问时，如果 accessOrder 为 true，则会将该节点移到链表尾部。也就是说指定为 LRU 顺序之后，在每次访问一个节点时会将这个节点移到链表尾部，那么链表首部就是最近最久未使用的节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;    Node&lt;K,V&gt; e;    <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)        <span class="keyword">return</span> <span class="keyword">null</span>;    <span class="keyword">if</span> (accessOrder)        afterNodeAccess(e);    <span class="keyword">return</span> e.value;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123;    LinkedHashMap.Entry&lt;K,V&gt; last;    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;        <span class="comment">// 向下转型        LinkedHashMap.Entry&lt;K,V&gt; p =            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;        p.after = null;        // 判断 p 是否是首节点        if (b == null)            //是头节点 让p后继节点成为头节点            head = a;        else            //不是头节点 让p的前驱节点的next指向p的后继节点，维护链表的连接            b.after = a;        // 判断p是否是尾节点        if (a != null)            // 不是尾节点 让p后继节点指向p的前驱节点            a.before = b;        else            // 是尾节点 让last指向p的前驱节点            last = b;        // 判断last是否是空        if (last == null)            // last为空说明p是尾节点或者只有p一个节点            head = p;        else &#123;            // last和p相互连接            p.before = last;            last.after = p;        &#125;        tail = p;        ++modCount;    &#125;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>remove()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用HashMap的remove方法final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value,boolean matchValue, boolean movable)→ afterNodeRemoval(node);</span></span><br></pre></td></tr></table></figure><p>当 HashMap 删除一个键值对时调用，会把在 HashMap 中删除的那个键值对一并从链表中删除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123;    LinkedHashMap.Entry&lt;K,V&gt; p =        (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;    <span class="comment">// 让p节点与前驱节点和后继节点断开链接    p.before = p.after = null;    // 判断p是否是头节点    if (b == null)        // p是头节点 让head指向p的后继节点        head = a;    else        // p不是头节点 让p的前驱节点的next指向p的后继节点，维护链表的连接        b.after = a;    // 判断p是否是尾节点，是就让tail指向p的前驱节点，不是就让p.after指向前驱节点，双向    if (a == null)        tail = b;    else        a.before = b;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h5><p>使用 LinkedHashMap 实现的一个 LRU 缓存：</p><ul><li>设定最大缓存空间 MAX_ENTRIES 为 3</li><li>使用 LinkedHashMap 的构造函数将 accessOrder 设置为 true，开启 LRU 顺序</li><li>覆盖 removeEldestEntry() 方法实现，在节点多于 MAX_ENTRIES 就会将最近最久未使用的数据移除</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    LRUCache&lt;Integer, String&gt; cache = <span class="keyword">new</span> LRUCache&lt;&gt;();    cache.put(<span class="number">1</span>, <span class="string">&quot;a&quot;</span>);    cache.put(<span class="number">2</span>, <span class="string">&quot;b&quot;</span>);    cache.put(<span class="number">3</span>, <span class="string">&quot;c&quot;</span>);    cache.get(<span class="number">1</span>);<span class="comment">//把1放入尾部    cache.put(4, &quot;d&quot;);    System.out.println(cache.keySet());//[3, 1, 4]只能存3个，移除2&#125;class LRUCache&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; &#123;    private static final int MAX_ENTRIES = 3;    protected boolean removeEldestEntry(Map.Entry eldest) &#123;        return size() &gt; MAX_ENTRIES;    &#125;    LRUCache() &#123;        super(MAX_ENTRIES, 0.75f, true);    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h4><p>TreeMap 实现了 SotredMap 接口，是有序不可重复的键值对集合，基于红黑树（Red-Black tree）实现，每个 key-value 都作为一个红黑树的节点。如果构造 TreeMap 没有指定比较器，则根据 key 执行自然排序（默认升序），如果指定了比较器则按照比较器来进行排序</p><p>TreeSet 集合的底层是基于TreeMap，只是键的附属值为空对象而已</p><p>TreeMap 集合指定大小规则有 2 种方式：</p><ul><li>直接为对象的类实现比较器规则接口 Comparable，重写比较方法（拓展方式）</li><li>直接为集合设置比较器 Comparator 对象，重写比较方法</li></ul><p>成员属性：</p><ul><li><p>Entry 节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;     K key;     V value;     Entry&lt;K,V&gt; left;<span class="comment">//左孩子节点     Entry&lt;K,V&gt; right;//右孩子节点     Entry&lt;K,V&gt; parent;//父节点     boolean color = BLACK;//节点的颜色，在红黑树中只有两种颜色，红色和黑色 &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>compare()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果comparator为null，采用comparable.compartTo进行比较，否则采用指定比较器比较大小final int compare(Object k1, Object k2) &#123;    return comparator == null ? ((Comparable&lt;? super K&gt;)k1).compareTo((K)k2)        : comparator.compare((K)k1, (K)k2);&#125;</span></span><br></pre></td></tr></table></figure></li></ul><p>参考文章：<a href="https://blog.csdn.net/weixin_33991727/article/details/91518677">https://blog.csdn.net/weixin_33991727/article/details/91518677</a></p><hr><h4 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h4><p>WeakHashMap 是基于弱引用的</p><p>内部的 Entry 继承 WeakReference，被弱引用关联的对象在下一次垃圾回收时会被回收，并且构造方法传入引用队列，用来在清理对象完成以后清理引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">Object</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;    Entry(Object key, V value,          ReferenceQueue&lt;Object&gt; queue,          <span class="keyword">int</span> hash, Entry&lt;K,V&gt; next) &#123;        <span class="keyword">super</span>(key, queue);        <span class="keyword">this</span>.value = value;        <span class="keyword">this</span>.hash  = hash;        <span class="keyword">this</span>.next  = next;    &#125;&#125;</span><br></pre></td></tr></table></figure><p>WeakHashMap 主要用来实现缓存，使用 WeakHashMap 来引用缓存对象，由 JVM 对这部分缓存进行回收</p><p>Tomcat 中的 ConcurrentCache 使用了 WeakHashMap 来实现缓存功能，ConcurrentCache 采取分代缓存：</p><ul><li><p>经常使用的对象放入 eden 中，eden 使用 ConcurrentHashMap 实现，不用担心会被回收（伊甸园）</p></li><li><p>不常用的对象放入 longterm，longterm 使用 WeakHashMap 实现，这些老对象会被垃圾收集器回收</p></li><li><p>当调用 get() 方法时，会先从 eden 区获取，如果没有找到的话再到 longterm 获取，当从 longterm 获取到就把对象放入 eden 中，从而保证经常被访问的节点不容易被回收</p></li><li><p>当调用 put() 方法时，如果 eden 的大小超过了 size，那么就将 eden 中的所有对象都放入 longterm 中，利用虚拟机回收掉一部分不经常使用的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> size;    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K, V&gt; eden;    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K, V&gt; longterm;    <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentCache</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;        <span class="keyword">this</span>.size = size;        <span class="keyword">this</span>.eden = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(size);        <span class="keyword">this</span>.longterm = <span class="keyword">new</span> WeakHashMap&lt;&gt;(size);    &#125;    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K k)</span> </span>&#123;        V v = <span class="keyword">this</span>.eden.get(k);        <span class="keyword">if</span> (v == <span class="keyword">null</span>) &#123;            v = <span class="keyword">this</span>.longterm.get(k);            <span class="keyword">if</span> (v != <span class="keyword">null</span>)                <span class="keyword">this</span>.eden.put(k, v);        &#125;        <span class="keyword">return</span> v;    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K k, V v)</span> </span>&#123;        <span class="keyword">if</span> (<span class="keyword">this</span>.eden.size() &gt;= size) &#123;            <span class="keyword">this</span>.longterm.putAll(<span class="keyword">this</span>.eden);            <span class="keyword">this</span>.eden.clear();        &#125;        <span class="keyword">this</span>.eden.put(k, v);    &#125;&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="面试题-1"><a href="#面试题-1" class="headerlink" title="面试题"></a>面试题</h4><p>输出一个字符串中每个字符出现的次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*    （1）键盘录入一个字符串。aabbccddaa123。    （2）定义一个Map集合，键是每个字符，值是其出现的次数。 &#123;a=4 , b=2 ,...&#125;    （3）遍历字符串中的每一个字符。    （4）拿着这个字符去Map集合中看是否有这个字符键，有说明之前统计过，其值+1         没有这个字符键，说明该字符是第一次统计，直接存入“该字符=1”*/</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapDemo</span></span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;        String s = <span class="string">&quot;aabbccddaa123&quot;</span>;        Map&lt;Character, Integer&gt; infos = <span class="keyword">new</span> HashMap&lt;&gt;();        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;            <span class="keyword">char</span> ch = datas.charAt(i);            <span class="keyword">if</span>(infos.containsKey(ch))&#123;                infos.put(ch,infos.get(ch) + <span class="number">1</span>);            &#125; <span class="keyword">else</span> &#123;                infos.put(ch,<span class="number">1</span>);            &#125;        &#125;        System.out.println(<span class="string">&quot;结果：&quot;</span>+infos);    &#125;&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><h4 id="概述-7"><a href="#概述-7" class="headerlink" title="概述"></a>概述</h4><p>泛型（Generic）：</p><ul><li>泛型就是一个标签：&lt;数据类型&gt;</li><li>泛型可以在编译阶段约束只能操作某种数据类型。</li></ul><p>注意：</p><ul><li>JDK 1.7 开始之后，泛型后面的申明可以省略不写</li><li><strong>泛型和集合都只能支持引用数据类型，不支持基本数据类型。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;    ArrayList&lt;Object&gt; lists = <span class="keyword">new</span> ArrayList&lt;&gt;();     lists.add(<span class="number">99.9</span>);    lists.add(<span class="string">&#x27;a&#x27;</span>);    lists.add(<span class="string">&quot;Java&quot;</span>);    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();    lists1.add(<span class="number">10</span>);    lists1.add(<span class="number">20</span>);&#125;</span><br></pre></td></tr></table></figure><p>优点：泛型在编译阶段约束了操作的数据类型，从而不会出现类型转换异常<br>            体现的是 Java 的严谨性和规范性，数据类型，经常需要进行统一</p><hr><h4 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h4><h5 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h5><p>泛型类：使用了泛型定义的类就是泛型类。</p><p>泛型类格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="class"><span class="keyword">class</span> 类名&lt;泛型变量&gt;</span>&#123;&#125;泛型变量建议使用 E , T , K , V</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericDemo</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        MyArrayList&lt;String&gt; list = <span class="keyword">new</span> MyArrayList&lt;String&gt;();        MyArrayList&lt;Integer&gt; list1 = <span class="keyword">new</span> MyArrayList&lt;Integer&gt;();        list.add(<span class="string">&quot;自定义泛型类&quot;</span>);    &#125;&#125;<span class="class"><span class="keyword">class</span> <span class="title">MyArrayList</span>&lt;<span class="title">E</span>&gt;</span>&#123;<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span></span>&#123;&#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(E e)</span></span>&#123;&#125;&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h5><p>泛型方法：定义了泛型的方法就是泛型方法</p><p>泛型方法的定义格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 &lt;泛型变量&gt; 返回值类型 方法名称(形参列表)&#123;&#125;</span><br></pre></td></tr></table></figure><p>方法定义了是什么泛型变量，后面就只能用什么泛型变量。</p><p>泛型类的核心思想：把出现泛型变量的地方全部替换成传输的真实数据类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericDemo</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        Integer[] num = &#123;<span class="number">10</span> , <span class="number">20</span> , <span class="number">30</span> , <span class="number">40</span> , <span class="number">50</span>&#125;;        String s1 = arrToString(nums);             String[] name = &#123;<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;李四&quot;</span>,<span class="string">&quot;王五&quot;</span>&#125;;        String s2 = arrToString(names);    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">String <span class="title">arrToString</span><span class="params">(T[] arr)</span></span>&#123;        --------------    &#125;&#125;</span><br></pre></td></tr></table></figure><p>自定义泛型接口</p><p>泛型接口：使用了泛型定义的接口就是泛型接口。</p><p>泛型接口的格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="class"><span class="keyword">interface</span> 接口名称&lt;泛型变量&gt;</span>&#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericDemo</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        Data d = <span class="keyword">new</span> StudentData();        d.add(<span class="keyword">new</span> Student());        ................    &#125;&#125;<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Data</span>&lt;<span class="title">E</span>&gt;</span>&#123;    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span></span>;    <span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(E e)</span></span>;    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(E e)</span></span>;    <span class="function">E <span class="title">query</span><span class="params">(<span class="keyword">int</span> index)</span></span>;&#125;<span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;&#125;<span class="class"><span class="keyword">class</span> <span class="title">StudentData</span> <span class="keyword">implements</span> <span class="title">Data</span>&lt;<span class="title">Student</span>&gt;</span>&#123;重写所有方法&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h4><p>通配符：？</p><ul><li>? 可以用在使用泛型的时候代表一切类型</li><li>E、T、K、V 是在定义泛型的时候使用代表一切类型</li></ul><p>泛型的上下限：</p><ul><li>? extends Car：那么 ? 必须是 Car 或者其子类（泛型的上限）</li><li>? super  Car：那么 ? 必须是 Car 或者其父类（泛型的下限，不是很常见）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需求：开发一个极品飞车的游戏，所有的汽车都能一起参与比赛。public class GenericDemo &#123;    public static void main(String[] args) &#123;        ArrayList&lt;BMW&gt; bmws = new ArrayList&lt;&gt;();        ArrayList&lt;AD&gt; ads = new ArrayList&lt;&gt;();        ArrayList&lt;Dog&gt; dogs = new ArrayList&lt;&gt;();        run(bmws);        //run(dogs);    &#125;    //public static void run(ArrayList&lt;?&gt; car)&#123;&#125;//这样 dou对象也能进入    public static void run(ArrayList&lt;? extends Car&gt; car)&#123;&#125;&#125;class Car&#123;&#125;class BMW extends Car&#123;&#125;class AD extends Car&#123;&#125;class Dog&#123;&#125;</span></span><br></pre></td></tr></table></figure><hr><h3 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h3><p>在 List、Set、Map 接口中都存在 of 方法，可以创建一个不可变的集合</p><ul><li>这个集合不能添加，不能删除，不能修改</li><li>但是可以结合集合的带参构造，实现集合的批量添加</li></ul><p>在Map接口中，还有一个ofEntries方法可以提高代码的阅读性</p><ul><li>首先会把键值对封装成一个Entry对象，再把这个Entry对象添加到集合当中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyVariableParameter4</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        <span class="comment">// static &lt;E&gt;  List&lt;E&gt;  of(E…elements)  创建一个具有指定元素的List集合对象        //static &lt;E&gt;  Set&lt;E&gt;  of(E…elements)    创建一个具有指定元素的Set集合对象        //static &lt;K , V&gt;   Map&lt;K，V&gt;  of(E…elements) 创建一个具有指定元素的Map集合对象        //method1();        //method2();        //method3();        //method4();    &#125;    private static void method4() &#123;        Map&lt;String, String&gt; map = Map.ofEntries(                Map.entry(&quot;zhangsan&quot;, &quot;江苏&quot;),                Map.entry(&quot;lisi&quot;, &quot;北京&quot;));        System.out.println(map);    &#125;    private static void method3() &#123;        Map&lt;String, String&gt; map = Map.of(&quot;zhangsan&quot;, &quot;江苏&quot;, &quot;lisi&quot;, &quot;北京&quot;);        System.out.println(map);    &#125;    private static void method2() &#123;        //传递的参数当中，不能存在重复的元素。        Set&lt;String&gt; set = Set.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;,&quot;a&quot;);        System.out.println(set);    &#125;    private static void method1() &#123;        List&lt;String&gt; list = List.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;);        System.out.println(list);        //集合的批量添加。        //首先是通过调用List.of方法来创建一个不可变的集合，of方法的形参就是一个可变参数。        //再创建一个ArrayList集合，并把这个不可变的集合中所有的数据，都添加到ArrayList中。        ArrayList&lt;String&gt; list3 = new ArrayList&lt;&gt;(List.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;));        System.out.println(list3);    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="基本介绍-10"><a href="#基本介绍-10" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>异常：程序在”编译”或者”执行”的过程中可能出现的问题，Java 为常见的代码异常都设计一个类来代表。</p><p>错误：Error ，程序员无法处理的错误，只能重启系统，比如内存奔溃，JVM 本身的奔溃</p><p>Java 中异常继承的根类是：Throwable</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">异常的体系:         Throwable(根类，不是异常类)      /              \    Error           Exception（异常，需要研究和处理）                    /            \                   编译时异常     RuntimeException(运行时异常)                   </span><br></pre></td></tr></table></figure><p>Exception 异常的分类:</p><ul><li>编译时异常：继承自 Exception 的异常或者其子类，编译阶段就会报错</li><li>运行时异常: 继承自 RuntimeException 的异常或者其子类，编译阶段是不会出错的，在运行时阶段可能出现，编译阶段是不会出错的，但是运行阶段可能出现，建议提前处理</li></ul><hr><h3 id="处理过程"><a href="#处理过程" class="headerlink" title="处理过程"></a>处理过程</h3><p>异常的产生默认的处理过程解析：（自动处理的过程）</p><ol><li>默认会在出现异常的代码那里自动的创建一个异常对象：ArithmeticException（算术异常）</li><li>异常会从方法中出现的点这里抛出给调用者，调用者最终抛出给JVM虚拟机</li><li>虚拟机接收到异常对象后，先在控制台直接输出<strong>异常栈</strong>信息数据</li><li>直接从当前执行的异常点干掉当前程序</li><li>后续代码没有机会执行了，因为程序已经死亡</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionDemo</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        System.out.println(<span class="string">&quot;程序开始。。。。。。。。。。&quot;</span>);        chu( <span class="number">10</span> ,<span class="number">0</span> );        System.out.println(<span class="string">&quot;程序结束。。。。。。。。。。&quot;</span>);<span class="comment">//不执行    &#125;    public static void chu(int a , int b)&#123;        int c = a / b ;// 出现了运行时异常,自动创建异常对象：ArithmeticException        System.out.println(&quot;结果是：&quot;+c);    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h3 id="编译异常"><a href="#编译异常" class="headerlink" title="编译异常"></a>编译异常</h3><h4 id="基本介绍-11"><a href="#基本介绍-11" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>编译时异常：继承自Exception的异常或者其子类，没有继承 RuntimeException，编译时异常是编译阶段就会报错，必须程序员编译阶段就处理的。否则代码编译就报错</p><p>编译时异常的作用是什么：</p><ul><li>是担心程序员的技术不行，在编译阶段就爆出一个错误, 目的在于提醒</li><li>提醒程序员这里很可能出错，请检查并注意不要出bug</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException </span>&#123;String date = <span class="string">&quot;2015-01-12 10:23:21&quot;</span>;SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);Date d = sdf.parse(date);System.out.println(d);&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="处理机制"><a href="#处理机制" class="headerlink" title="处理机制"></a>处理机制</h4><h5 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h5><p>在出现编译时异常的地方层层把异常抛出去给调用者，调用者最终抛出给JVM虚拟机，JVM 虚拟机输出异常信息，直接干掉程序，这种方式与默认方式是一样的。</p><ul><li>优点：可以解决代码编译时的错误</li><li>运行时出现异常，程序还是会立即死亡！</li></ul><p><strong>Exception是异常最高类型可以抛出一切异常！</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;    System.out.println(<span class="string">&quot;程序开始。。。。&quot;</span>);    String s = <span class="string">&quot;2013-03-23 10:19:23&quot;</span>;    SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);    Date date = sdf.parse(s);    System.out.println(<span class="string">&quot;程序结束。。。。。&quot;</span>);&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="try-catch"><a href="#try-catch" class="headerlink" title="try/catch"></a>try/catch</h5><p>可以处理异常，并且出现异常后代码也不会死亡。</p><ul><li><p>自己捕获异常和处理异常的格式：<strong>捕获处理</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;  <span class="comment">// 监视可能出现异常的代码！&#125;catch(异常类型1 变量)&#123;  // 处理异常&#125;catch(异常类型2 变量)&#123;  // 处理异常&#125;...finall&#123;//资源释放&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>监视捕获处理异常企业级写法：<br>Exception可以捕获处理一切异常类型！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;    <span class="comment">// 可能出现异常的代码！&#125;catch (Exception e)&#123;    e.printStackTrace(); // **直接打印异常栈信息**&#125;</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>Throwable成员方法:</strong><br>    <code>public String getMessage()</code> : 返回此 throwable 的详细消息字符串<br>    <code>public String toString()</code> : 返回此可抛出的简短描述<br>    <code>public void printStackTrace()</code> : 把异常的错误信息输出在控制台</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    System.out.println(<span class="string">&quot;程序开始。。。。&quot;</span>);    <span class="keyword">try</span> &#123;        String s = <span class="string">&quot;2013-03-23 10:19:23&quot;</span>;        SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);        Date date = sdf.parse(s);        InputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:/meinv.png&quot;</span>);    &#125; <span class="keyword">catch</span> (Exception e) &#123;        e.printStackTrace();    &#125;    System.out.println(<span class="string">&quot;程序结束。。。。。&quot;</span>);&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="规范做法"><a href="#规范做法" class="headerlink" title="规范做法"></a>规范做法</h5><p>在出现异常的地方把异常一层一层的抛出给最外层调用者，最外层调用者集中捕获处理！（<strong>规范做法</strong>）<br>这种方案最外层调用者可以知道底层执行的情况，同时程序在出现异常后也不会立即死亡（最好的方案）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionDemo</span></span>&#123;<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;        System.out.println(<span class="string">&quot;程序开始。。。。&quot;</span>);        <span class="keyword">try</span> &#123;            parseDate(<span class="string">&quot;2013-03-23 10:19:23&quot;</span>);        &#125;<span class="keyword">catch</span> (Exception e)&#123;            e.printStackTrace();        &#125;        System.out.println(<span class="string">&quot;程序结束。。。。&quot;</span>);    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parseDate</span><span class="params">(String time)</span> <span class="keyword">throws</span> Exception</span>&#123;...&#125;&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="运行异常"><a href="#运行异常" class="headerlink" title="运行异常"></a>运行异常</h3><h4 id="基本介绍-12"><a href="#基本介绍-12" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>继承自RuntimeException的异常或者其子类，编译阶段是不会出错的，它是在运行时阶段可能出现的错误，运行时异常编译阶段可以处理也可以不处理,代码编译都能通过！！</p><p><strong>常见的运行时异常</strong>：</p><ol><li>数组索引越界异常: ArrayIndexOutOfBoundsException</li><li>空指针异常 : NullPointerException，直接输出没问题，调用空指针的变量的功能就会报错！</li><li>类型转换异常：ClassCastException</li><li>迭代器遍历没有此元素异常：NoSuchElementException</li><li>算术异常（数学操作异常）：ArithmeticException</li><li>数字转换异常： NumberFormatException</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionDemo</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        System.out.println(<span class="string">&quot;程序开始。。。。。。&quot;</span>);        <span class="comment">// 1.数组索引越界异常: ArrayIndexOutOfBoundsException。        int[] arrs = &#123;10 ,20 ,30&#125;;        System.out.println(arrs[3]); //出现了数组索引越界异常。代码在此处直接执行死亡！        // 2.空指针异常 : NullPointerException。        String name = null ;        System.out.println(name); // 直接输出没有问题        System.out.println(name.length());//出现了空指针异常。代码直接执行死亡！        /** 3.类型转换异常：ClassCastException。 */        Object o = &quot;齐天大圣&quot;;        Integer s = (Integer) o;  // 此处出现了类型转换异常。代码在此处直接执行死亡！        /** 5.数学操作异常：ArithmeticException。 */        int c = 10 / 0 ; // 此处出现了数学操作异常。代码在此处直接执行死亡！        /** 6.数字转换异常： NumberFormatException。 */        String num = &quot;23aa&quot;;        Integer it = Integer.valueOf(num); //出现了数字转换异常。代码在此处执行死亡！        System.out.println(&quot;程序结束。。。。。。&quot;);    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="处理机制-1"><a href="#处理机制-1" class="headerlink" title="处理机制"></a>处理机制</h4><p>运行时异常在编译阶段是不会报错，在运行阶段才会出错，运行时出错了程序还是会停止，运行时异常也建议要处理，运行时异常是自动往外抛出的，不需要手工抛出</p><p><strong>运行时异常的处理规范</strong>：直接在最外层捕获处理即可，底层会自动抛出！！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionDemo</span></span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;        System.out.println(<span class="string">&quot;程序开始。。。。&quot;</span>);        <span class="keyword">try</span>&#123;            chu(<span class="number">10</span> / <span class="number">0</span>);<span class="comment">//ArithmeticException: / by zero            System.out.println(&quot;操作成功！&quot;);//没输出        &#125;catch (Exception e)&#123;            e.printStackTrace();            System.out.println(&quot;操作失败！&quot;);//输出了        &#125;        System.out.println(&quot;程序结束。。。。&quot;);//输出了    &#125;        public static void chu(int a , int b)  &#123; System.out.println( a / b );&#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h3 id="Finally"><a href="#Finally" class="headerlink" title="Finally"></a>Finally</h3><p>用在捕获处理的异常格式中的，放在最后面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;    <span class="comment">// 可能出现异常的代码！&#125;catch(Exception e)&#123;    e.printStackTrace();&#125;finally&#123;    // 无论代码是出现异常还是正常执行，最终一定要执行这里的代码！！&#125;try: 1次。catch：0-N次  (如果有finally那么catch可以没有!!)finally: 0-1次</span></span><br></pre></td></tr></table></figure><p><strong>finally的作用</strong>：可以在代码执行完毕以后进行资源的释放操作</p><p>资源：资源都是实现了 Closeable 接口的，都自带 close() 关闭方法！</p><p>注意：如果在 finally 中出现了 return，会吞掉异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinallyDemo</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        System.out.println(chu());<span class="comment">//一定会输出 finally,优先级比return高    &#125;    public static int chu()&#123;        try&#123;            int a = 10 / 2 ;            return a ;        &#125;catch (Exception e)&#123;            e.printStackTrace();            return -1;        &#125;finally &#123;            System.out.println(&quot;=====finally被执行&quot;);            //return 111; // 不建议在finally中写return，会覆盖前面所有的return值!        &#125;    &#125;    public static void test()&#123;        InputStream is = null;        try&#123;            is = new FileInputStream(&quot;D:/cang.png&quot;);        &#125;catch (Exception e)&#123;            e.printStackTrace();        &#125;finally &#123;            System.out.println(&quot;==finally被执行===&quot;);            // 回收资源。用于在代码执行完毕以后进行资源的回收操作！            try &#123;                if(is!=null)is.close();            &#125; catch (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h3 id="自定义-1"><a href="#自定义-1" class="headerlink" title="自定义"></a>自定义</h3><p>自定义异常:</p><ul><li>自定义编译时异常：定义一个异常类继承 Exception，重写构造器，在出现异常的地方用throw new 自定义对象抛出</li><li>自定义运行时异常：定义一个异常类继承 RuntimeException，重写构造器，在出现异常的地方用 throw new  自定义对象抛出!</li></ul><p><strong>throws: 用在方法上，用于抛出方法中的异常</strong></p><p><strong>throw:  用在出现异常的地方，创建异常对象且立即从此处抛出</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需求：认为年龄小于0岁，大于200岁就是一个异常。public class ExceptionDemo &#123;    public static void main(String[] args) &#123;        try &#123;            checkAge(101);        &#125; catch (AgeIllegalException e) &#123;            e.printStackTrace();        &#125;    &#125;    public static void checkAge(int age) throws ItheimaAgeIllegalException &#123;        if(age &lt; 0 || age &gt; 200)&#123;//年龄在0-200之间            throw new AgeIllegalException(&quot;/ age is illegal!&quot;);            //throw new AgeIllegalRuntimeException(&quot;/ age is illegal!&quot;);        &#125;else&#123;            System.out.println(&quot;年龄是：&quot; + age);        &#125;    &#125;&#125;public class AgeIllegalException extends Exception&#123;    Alt + Insert-&gt;Constructor &#125;//编译时异常public class AgeIllegalRuntimeException extends RuntimeException&#123;public AgeIllegalRuntimeException() &#123;    &#125;    public AgeIllegalRuntimeException(String message) &#123;        super(message);    &#125;&#125;//运行时异常</span></span><br></pre></td></tr></table></figure><hr><h3 id="处理规范"><a href="#处理规范" class="headerlink" title="处理规范"></a>处理规范</h3><p>异常的语法注意：</p><ol><li>运行时异常被抛出可以不处理，可以自动抛出；<strong>编译时异常必须处理</strong>；按照规范都应该处理</li><li><strong>重写方法申明抛出的异常，子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型</strong></li><li>方法默认都可以自动抛出运行时异常， throws RuntimeException 可以省略不写</li><li>当多异常处理时，捕获处理，前面的异常类不能是后面异常类的父类。</li><li>在 try/catch 后可以追加 finally 代码块，其中的代码一定会被执行，通常用于资源回收操作</li></ol><p>异常的作用：</p><ol><li><p>可以处理代码问题，防止程序出现异常后的死亡</p></li><li><p>提高了程序的健壮性和安全性</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;        <span class="comment">//请输入一个合法的年龄        while(true)&#123;            try&#123;                Scanner sc = new Scanner(System.in);                System.out.println(&quot;请您输入您的年年龄：&quot;);                int age = sc.nextInt();                System.out.println(&quot;年龄：&quot;+age);                break;            &#125;catch(Exception e)&#123;                System.err.println(&quot;您的年龄是瞎输入的！&quot;);            &#125;        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h2 id="λ"><a href="#λ" class="headerlink" title="λ"></a>λ</h2><h3 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h3><h4 id="基本介绍-13"><a href="#基本介绍-13" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>Lambda表达式是JDK1.8开始之后的新技术，是一种代码的新语法，一种特殊写法</p><p>作用：为了简化匿名内部类的代码写法</p><p>Lambda表达式的格式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(匿名内部类被重写方法的形参列表) -&gt; &#123;<span class="comment">//被重写方法的方法体代码。&#125;</span></span><br></pre></td></tr></table></figure><p>Lambda表达式并不能简化所有匿名内部类的写法，只能简化<strong>函数式接口的匿名内部类</strong></p><p>简化条件：首先必须是接口，接口中只能有一个抽象方法</p><p>@FunctionalInterface函数式接口注解：一旦某个接口加上了这个注解，这个接口只能有且仅有一个抽象方法</p><hr><h4 id="简化方法"><a href="#简化方法" class="headerlink" title="简化方法"></a>简化方法</h4><p>Lambda表达式的省略写法（进一步在Lambda表达式的基础上继续简化）</p><ul><li>如果Lambda表达式的方法体代码只有一行代码，可以省略大括号不写，同时要省略分号；如果这行代码是return语句，必须省略return不写</li><li>参数类型可以省略不写</li><li>如果只有一个参数，参数类型可以省略，同时()也可以省略</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = <span class="keyword">new</span> ArrayList&lt;&gt;();names.add(<span class="string">&quot;胡&quot;</span>);names.add(<span class="string">&quot;甘&quot;</span>);names.add(<span class="string">&quot;洪&quot;</span>);names.forEach(<span class="keyword">new</span> Consumer&lt;String&gt;() &#123;    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String s)</span> </span>&#123;        System.out.println(s);    &#125;&#125;);names.forEach((String s) -&gt; &#123;        System.out.println(s);&#125;);names.forEach((s) -&gt; &#123;    System.out.println(s);&#125;);names.forEach(s -&gt; &#123;    System.out.println(s);&#125;);names.forEach(s -&gt; System.out.println(s) );</span><br></pre></td></tr></table></figure><hr><h4 id="常用简化"><a href="#常用简化" class="headerlink" title="常用简化"></a>常用简化</h4><h5 id="Runnable"><a href="#Runnable" class="headerlink" title="Runnable"></a>Runnable</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.Thread t = new Thread(new Runnable() &#123;    @Override    public void run() &#123;        System.out.println(Thread.currentThread().getName()+&quot;:执行~~~&quot;);    &#125;&#125;);t.start();//2.Thread t1 = new Thread(() -&gt; &#123;    System.out.println(Thread.currentThread().getName()+&quot;:执行~~~&quot;);&#125;);t1.start();//3.new Thread(() -&gt; &#123;    System.out.println(Thread.currentThread().getName()+&quot;:执行~~~&quot;);&#125;).start();//4.一行代码new Thread(() -&gt; System.out.println(Thread.currentThread().getName()+&quot;:执行~~~&quot;)).start();</span></span><br></pre></td></tr></table></figure><h5 id="Comparator"><a href="#Comparator" class="headerlink" title="Comparator"></a>Comparator</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionsDemo</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        List&lt;Student&gt; lists = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//...s1 s2 s3        Collections.addAll(lists , s1 , s2 , s3);        Collections.sort(lists, new Comparator&lt;Student&gt;() &#123;            @Override            public int compare(Student s1, Student s2) &#123;                return s1.getAge() - s2.getAge();            &#125;        &#125;);                // 简化写法        Collections.sort(lists ,(Student t1, Student t2) -&gt; &#123;                return t1.getAge() - t2.getAge();        &#125;);        // 参数类型可以省略,最简单的        Collections.sort(lists ,(t1,t2) -&gt; t1.getAge()-t2.getAge());    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><h4 id="基本介绍-14"><a href="#基本介绍-14" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>方法引用：方法引用是为了进一步简化Lambda表达式的写法</p><p>方法引用的格式：类型或者对象::引用的方法</p><p>关键语法是：<code>::</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lists.forEach( s -&gt; System.out.println(s));<span class="comment">// 方法引用！lists.forEach(System.out::println);</span></span><br></pre></td></tr></table></figure><hr><h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><p>引用格式：<code>类名::静态方法</code></p><p>简化步骤：定义一个静态方法，把需要简化的代码放到一个静态方法中去</p><p>静态方法引用的注意事项：被引用的方法的参数列表要和函数式接口中的抽象方法的参数列表一致,才能引用简化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义集合加入几个Student元素// 使用静态方法进行简化！Collections.sort(lists, (o1, o2) -&gt; Student.compareByAge(o1 , o2));// 如果前后参数是一样的，而且方法是静态方法，既可以使用静态方法引用Collections.sort(lists, Student::compareByAge);public class Student &#123;    private String name ;    private int age ;    public static int compareByAge(Student o1 , Student o2)&#123;        return  o1.getAge() - o2.getAge();    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h4><p>引用格式：<code>对象::实例方法</code></p><p>简化步骤：定义一个实例方法，把需要的代码放到实例方法中去</p><p>实例方法引用的注意事项：被引用的方法的参数列表要和函数式接口中的抽象方法的参数列表一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodDemo</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        List&lt;String&gt; lists = <span class="keyword">new</span> ArrayList&lt;&gt;();        lists.add(<span class="string">&quot;java1&quot;</span>);        lists.add(<span class="string">&quot;java2&quot;</span>);        lists.add(<span class="string">&quot;java3&quot;</span>);        <span class="comment">// 对象是 System.out = new PrintStream();        // 实例方法：println()        // 前后参数正好都是一个        lists.forEach(s -&gt; System.out.println(s));        lists.forEach(System.out::println);    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="特定类型"><a href="#特定类型" class="headerlink" title="特定类型"></a>特定类型</h4><p>特定类型：String，任何类型</p><p>引用格式：<code>特定类型::方法</code></p><p>注意事项：如果第一个参数列表中的形参中的第一个参数作为了后面的方法的调用者，并且其余参数作为后面方法的形参，那么就可以用特定类型方法引用了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodDemo</span></span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        String[] strs = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;James&quot;</span>, <span class="string">&quot;AA&quot;</span>, <span class="string">&quot;John&quot;</span>,                <span class="string">&quot;Patricia&quot;</span>,<span class="string">&quot;Dlei&quot;</span> , <span class="string">&quot;Robert&quot;</span>,<span class="string">&quot;Boom&quot;</span>, <span class="string">&quot;Cao&quot;</span> ,<span class="string">&quot;black&quot;</span> ,                <span class="string">&quot;Michael&quot;</span>, <span class="string">&quot;Linda&quot;</span>,<span class="string">&quot;cao&quot;</span>,<span class="string">&quot;after&quot;</span>,<span class="string">&quot;sBBB&quot;</span>&#125;;        <span class="comment">// public static &lt;T&gt; void sort(T[] a, Comparator&lt;? super T&gt; c)        // 需求：按照元素的首字符(忽略大小写)升序排序！！！        Arrays.sort(strs, new Comparator&lt;String&gt;() &#123;            @Override            public int compare(String s1, String s2) &#123;                return s1.compareToIgnoreCase(s2);//按照元素的首字符(忽略大小写)            &#125;        &#125;);        Arrays.sort(strs, ( s1,  s2 ) -&gt;  s1.compareToIgnoreCase(s2));        // 特定类型的方法引用：        Arrays.sort(strs,  String::compareToIgnoreCase);        System.out.println(Arrays.toString(strs));    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="构造器-1"><a href="#构造器-1" class="headerlink" title="构造器"></a>构造器</h4><p>格式：<code>类名::new</code></p><p>注意事项：前后参数一致的情况下，又在创建对象，就可以使用构造器引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstructorDemo</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        List&lt;String&gt; lists = <span class="keyword">new</span> ArrayList&lt;&gt;();        lists.add(<span class="string">&quot;java1&quot;</span>);        lists.add(<span class="string">&quot;java2&quot;</span>);        lists.add(<span class="string">&quot;java3&quot;</span>);        <span class="comment">// 集合默认只能转成Object类型的数组。        Object[] objs = lists.toArray();        // 我们想指定转换成字符串类型的数组！最新的写法可以结合构造器引用实现         String[] strs = lists.toArray(new IntFunction&lt;String[]&gt;() &#123;            @Override            public String[] apply(int value) &#123;                return new String[value];            &#125;        &#125;);        String[] strs1 = lists.toArray(s -&gt; new String[s]);        String[] strs2 = lists.toArray(String[]::new);        System.out.println(&quot;String类型的数组：&quot;+ Arrays.toString(strs2));    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h2 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h2><h3 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h3><h4 id="概述-8"><a href="#概述-8" class="headerlink" title="概述"></a>概述</h4><p>Stream 流其实就是一根传送带，元素在上面可以被 Stream 流操作</p><p>作用：</p><ul><li>可以解决已有集合类库或者数组 API 的弊端</li><li>Stream 流简化集合和数组的操作</li><li>链式编程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.stream().filter(<span class="keyword">new</span> Predicate&lt;String&gt;() &#123;            <span class="meta">@Override</span>            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(String s)</span> </span>&#123;                <span class="keyword">return</span> s.startsWith(<span class="string">&quot;张&quot;</span>);            &#125;        &#125;);list.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;张&quot;</span>));</span><br></pre></td></tr></table></figure><hr><h4 id="获取流"><a href="#获取流" class="headerlink" title="获取流"></a>获取流</h4><p>集合获取 Stream 流用：<code>default Stream&lt;E&gt; stream()</code></p><p>数组：Arrays.stream(数组)   /  Stream.of(数组);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Collection集合获取Stream流。Collection&lt;String&gt; c = new ArrayList&lt;&gt;();Stream&lt;String&gt; listStream = c.stream();//Map集合获取流// 先获取键的Stream流。Stream&lt;String&gt; keysStream = map.keySet().stream();// 在获取值的Stream流Stream&lt;Integer&gt; valuesStream = map.values().stream();// 获取键值对的Stream流（key=value： Map.Entry&lt;String,Integer&gt;）Stream&lt;Map.Entry&lt;String,Integer&gt;&gt; keyAndValues = map.entrySet().stream();//数组获取流String[] arr = new String[]&#123;&quot;Java&quot;, &quot;JavaEE&quot; ,&quot;Spring Boot&quot;&#125;;Stream&lt;String&gt; arrStream1 = Arrays.stream(arr);Stream&lt;String&gt; arrStream2 = Stream.of(arr);</span></span><br></pre></td></tr></table></figure><hr><h4 id="常用API-1"><a href="#常用API-1" class="headerlink" title="常用API"></a>常用API</h4><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>void forEach(Consumer&lt;? super T&gt; action)</td><td>逐一处理（遍历）</td></tr><tr><td>long count</td><td>返回流中的元素数</td></tr><tr><td>Stream<T> filter(Predicate&lt;? super T&gt; predicate)</T></td><td>用于对流中的数据进行过滤</td></tr><tr><td>Stream<T> limit(long maxSize)</T></td><td>返回此流中的元素组成的流，截取前指定参数个数的数据</td></tr><tr><td>Stream<T> skip(long n)</T></td><td>跳过指定参数个数的数据，返回由该流的剩余元素组成的流</td></tr><tr><td><R> Stream<R> map(Function&lt;? super T,? extends R&gt; mapper)</R></R></td><td>加工方法，将当前流中的 T 类型数据转换为另一种 R 类型的流</td></tr><tr><td>static <T> Stream<T> concat(Stream a, Stream b)</T></T></td><td>合并 a 和 b 两个流为一个，调用 <code>Stream.concat(s1,s2)</code></td></tr><tr><td>Stream<T> distinct()</T></td><td>返回由该流的不同元素组成的流</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamDemo</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();        list.add(<span class="string">&quot;张无忌&quot;</span>); list.add(<span class="string">&quot;周芷若&quot;</span>); list.add(<span class="string">&quot;赵敏&quot;</span>);        list.add(<span class="string">&quot;张强&quot;</span>); list.add(<span class="string">&quot;张三丰&quot;</span>); list.add(<span class="string">&quot;张三丰&quot;</span>);        <span class="comment">//取以张开头并且名字是三位数的        list.stream().filter(s -&gt; s.startsWith(&quot;张&quot;)                .filter(s -&gt; s.length == 3).forEach(System.out::println);        //统计数量long count = list.stream().filter(s -&gt; s.startsWith(&quot;张&quot;)                .filter(s -&gt; s.length == 3).count();//取前两个list.stream().filter(s -&gt; s.length == 3).limit(2).forEach(...);//跳过前两个list.stream().filter(s -&gt; s.length == 3).skip(2).forEach(...);// 需求：把名称都加上“张三的:+xxx”list.stream().map(s -&gt; &quot;张三的&quot;+s).forEach(System.out::println);// 需求：把名称都加工厂学生对象放上去!!// list.stream().map(name -&gt; new Student(name));list.stream.map(Student::new).forEach(System.out::println);                                          //数组流Stream&lt;Integer&gt; s1 = Stream.of(10,20,30,40,50);//集合流Stream&lt;String&gt; s2 = list.stream();//合并流Stream&lt;Object&gt; s3 = Stream.concat(s1,s2);s3.forEach(System.out::println);    &#125;&#125;class Student&#123;    private String name;    //......&#125;                                          </span></span><br></pre></td></tr></table></figure><hr><h4 id="终结方法"><a href="#终结方法" class="headerlink" title="终结方法"></a>终结方法</h4><p>终结方法：Stream 调用了终结方法，流的操作就全部终结，不能继续使用，如 foreach，count 方法等</p><p>非终结方法：每次调用完成以后返回一个新的流对象，可以继续使用，支持<strong>链式编程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foreach终结方法list.stream().filter(s -&gt; s.startsWith(&quot;张&quot;))    .filter(s -&gt; s.length() == 3).forEach(System.out::println);</span></span><br></pre></td></tr></table></figure><hr><h4 id="收集流"><a href="#收集流" class="headerlink" title="收集流"></a>收集流</h4><p>收集 Stream：把 Stream 流的数据转回到集合中去</p><ul><li>Stream流：工具</li><li>集合：目的</li></ul><p>Stream 收集方法：<code>R collect(Collector collector)</code> 把结果收集到集合中</p><p>Collectors 方法：</p><ul><li><code>public static &lt;T&gt; Collector toList()</code>：把元素收集到 List 集合中</li><li><code>public static &lt;T&gt; Collector toSet()</code>：把元素收集到 Set 集合中</li><li><code>public static  Collector toMap(Function keyMapper,Function valueMapper)</code>：把元素收集到 Map 集合中</li><li><code>Object[] toArray()</code>：把元素收集数组中</li><li><code>public static Collector groupingBy(Function&lt;? super T, ? extends K&gt; classifier)</code>：分组</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();Stream&lt;String&gt; stream = list.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;张&quot;</span>));        <span class="comment">//把stream流转换成Set集合。    Set&lt;String&gt; set = stream.collect(Collectors.toSet());        //把stream流转换成List集合。    //重新定义，因为资源已经被关闭了    Stream&lt;String&gt; stream1 = list.stream().filter(s -&gt; s.startsWith(&quot;张&quot;));    List&lt;String&gt; list = stream.collect(Collectors.toList());        //把stream流转换成数组。    Stream&lt;String&gt; stream2 = list.stream().filter(s -&gt; s.startsWith(&quot;张&quot;));    Object[] arr = stream2.toArray();    // 可以借用构造器引用申明转换成的数组类型！！！    String[] arr1 = stream2.toArray(String[]::new);&#125;</span></span><br></pre></td></tr></table></figure><hr><h3 id="File"><a href="#File" class="headerlink" title="File"></a>File</h3><h4 id="文件类"><a href="#文件类" class="headerlink" title="文件类"></a>文件类</h4><p>File 类：代表操作系统的文件对象，是用来操作操作系统的文件对象的，删除文件，获取文件信息，创建文件（文件夹），广义来说操作系统认为文件包含（文件和文件夹）</p><p>File 类构造器：<br>    <code>public File(String pathname)</code>：根据路径获取文件对象<br>    <code>public File(String parent , String child)</code>：根据父路径和文件名称获取文件对象！<br>    <code>public File(File parent , String child)</code></p><p>File 类创建文件对象的格式:</p><ul><li><p><code>File f = new File(&quot;绝对路径/相对路径&quot;);</code></p><ul><li>绝对路径：从磁盘的的盘符一路走到目的位置的路径。<ul><li>绝对路径依赖具体的环境，一旦脱离环境，代码可能出错</li><li>一般是定位某个操作系统中的某个文件对象</li></ul></li><li><strong>相对路径</strong>：不带盘符的（重点）<ul><li>默认是直接相对到工程目录下寻找文件的。</li><li>相对路径只能用于寻找工程下的文件，可以跨平台</li></ul></li></ul></li><li><p><code>File f = new File(&quot;文件对象/文件夹对象&quot;)</code> 广义来说：文件是包含文件和文件夹的</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileDemo</span></span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        <span class="comment">// 1.创建文件对象：使用绝对路径        // 文件路径分隔符：        //      -- a.使用正斜杠： /        //      -- b.使用反斜杠： \\        //      -- c.使用分隔符API:File.separator        //File f1 = new File(&quot;D:&quot;+File.separator+&quot;it&quot;+File.separator//+&quot;图片资源&quot;+File.separator+&quot;beautiful.jpg&quot;);        File f1 = new File(&quot;D:\\seazean\\图片资源\\beautiful.jpg&quot;);        System.out.println(f1.length()); // 获取文件的大小，字节大小        // 2.创建文件对象：使用相对路径        File f2 = new File(&quot;Day09Demo/src/dlei.txt&quot;);        System.out.println(f2.length());        // 3.创建文件对象：代表文件夹。        File f3 = new File(&quot;D:\\it\\图片资源&quot;);        System.out.println(f3.exists());// 判断路径是否存在！！    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="常用API-2"><a href="#常用API-2" class="headerlink" title="常用API"></a>常用API</h4><h5 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h5><p><code>public String getAbsolutePath()</code> : 返回此File的绝对路径名字符串。<br><code>public String getPath()</code> : 获取创建文件对象的时候用的路径<br><code>public String getName()</code> : 返回由此File表示的文件或目录的名称。<br><code>public long length()</code> : 返回由此File表示的文件的长度（大小）。<br><code>public long length(FileFilter filter)</code> : 文件过滤器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileDemo</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        <span class="comment">// 1.绝对路径创建一个文件对象        File f1 = new File(&quot;E:/图片/meinv.jpg&quot;);        // a.获取它的绝对路径。        System.out.println(f1.getAbsolutePath());        // b.获取文件定义的时候使用的路径。        System.out.println(f1.getPath());        // c.获取文件的名称：带后缀。        System.out.println(f1.getName());        // d.获取文件的大小：字节个数。        System.out.println(f1.length());        System.out.println(&quot;------------------------&quot;);        // 2.相对路径        File f2 = new File(&quot;Day09Demo/src/dlei01.txt&quot;);        // a.获取它的绝对路径。        System.out.println(f2.getAbsolutePath());        // b.获取文件定义的时候使用的路径。        System.out.println(f2.getPath());        // c.获取文件的名称：带后缀。        System.out.println(f2.getName());        // d.获取文件的大小：字节个数。        System.out.println(f2.length());    &#125;&#125;</span></span><br></pre></td></tr></table></figure><h5 id="判断方法"><a href="#判断方法" class="headerlink" title="判断方法"></a>判断方法</h5><p><code>public boolean exists()</code> : 此File表示的文件或目录是否实际存在。<br><code>public boolean isDirectory()</code> : 此File表示的是否为目录。<br><code>public boolean isFile()</code> : 此File表示的是否为文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">File f = <span class="keyword">new</span> File(<span class="string">&quot;Day09Demo/src/dlei01.txt&quot;</span>);<span class="comment">// a.判断文件路径是否存在System.out.println(f.exists()); // true// b.判断文件对象是否是文件,是文件返回true ,反之System.out.println(f.isFile()); // true// c.判断文件对象是否是文件夹,是文件夹返回true ,反之System.out.println(f.isDirectory()); // false</span></span><br></pre></td></tr></table></figure><h5 id="创建删除"><a href="#创建删除" class="headerlink" title="创建删除"></a>创建删除</h5><p><code>public boolean createNewFile()</code> : 当且仅当具有该名称的文件尚不存在时， 创建一个新的空文件。<br><code>public boolean delete()</code> : 删除由此File表示的文件或目录。 （只能删除空目录）<br><code>public boolean mkdir()</code> : 创建由此File表示的目录。（只能创建一级目录）<br><code>public boolean mkdirs()</code> : 可以创建多级目录（建议使用的）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileDemo</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;        File f = <span class="keyword">new</span> File(<span class="string">&quot;Day09Demo/src/dlei02.txt&quot;</span>);        <span class="comment">// a.创建新文件，创建成功返回true ,反之        System.out.println(f.createNewFile());        // b.删除文件或者空文件夹        System.out.println(f.delete());        // 不能删除非空文件夹，只能删除空文件夹        File f1 = new File(&quot;E:/it/aaaaa&quot;);        System.out.println(f1.delete());        // c.创建一级目录        File f2 = new File(&quot;E:/bbbb&quot;);        System.out.println(f2.mkdir());        // d.创建多级目录        File f3 = new File(&quot;D:/it/e/a/d/ds/fas/fas/fas/fas/fas/fas&quot;);        System.out.println(f3.mkdirs());    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="遍历目录"><a href="#遍历目录" class="headerlink" title="遍历目录"></a>遍历目录</h4><ul><li><code>public String[] list()</code>：获取当前目录下所有的”一级文件名称”到一个字符串数组中去返回。</li><li><code>public File[] listFiles()(常用)</code>：获取当前目录下所有的”一级文件对象”到一个<strong>文件对象数组</strong>中去返回（<strong>重点</strong>）</li><li><code>public long lastModified</code>：返回此抽象路径名表示的文件上次修改的时间。 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileDemo</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        File dir = <span class="keyword">new</span> File(<span class="string">&quot;D:\\seazean&quot;</span>);        <span class="comment">// a.获取当前目录对象下的全部一级文件名称到一个字符串数组返回。        String[] names = dir.list();        for (String name : names) &#123;            System.out.println(name);        &#125;        // b.获取当前目录对象下的全部一级文件对象到一个File类型的数组返回。        File[] files = dir.listFiles();        for (File file : files) &#123;            System.out.println(file.getAbsolutePath());        &#125;        // c        File f1 = new File(&quot;D:\\it\\图片资源\\beautiful.jpg&quot;);        long time = f1.lastModified(); // 最后修改时间！        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);        System.out.println(sdf.format(time));    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="文件搜索"><a href="#文件搜索" class="headerlink" title="文件搜索"></a>文件搜索</h4><p>递归实现文件搜索（非规律递归）</p><ul><li>定义一个方法用于做搜索</li><li>进入方法中进行业务搜索分析</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** * 去某个目录下搜索某个文件 * <span class="doctag">@param</span> dir 搜索文件的目录。 * <span class="doctag">@param</span> fileName 搜索文件的名称。 */</span><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">searchFiles</span><span class="params">(File dir , String fileName)</span></span>&#123;    <span class="comment">// 1.判断是否存在该路径，是否是文件夹    if(dir.exists() &amp;&amp; dir.isDirectory())&#123;        // 2.提取当前目录下的全部一级文件对象        File files = dir.listFiles();// 可能是null/也可能是空集合[]        // 3.判断是否存在一级文件对象,判断是否不为空目录        if(files != null &amp;&amp; files.length &gt; 0)&#123;            // 4.判断一级文件对象            for(File file : files)&#123;                // 5.判断file是文件还是文件夹                if(file.isFile())&#123;                    // 6.判断该文件是否为我要找的文件对象                    if(f.getName().contains(fileName))&#123;//模糊查找                        sout(f.getAbsolutePath());                        try &#123;                            // 启动它（拓展）                            Runtime r = Runtime.getRuntime();                            r.exec(f.getAbsolutePath());                        &#125; catch (IOException e) &#123;                            e.printStackTrace();                        &#125;                    &#125;                &#125; else &#123;                    // 7.该文件是文件夹，文件夹要递归进入继续寻找                    searchFiles(file,fileName)                &#125;            &#125;        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h3 id="Character"><a href="#Character" class="headerlink" title="Character"></a>Character</h3><p>字符集：为字符编制的一套编号规则</p><p>计算机的底层是不能直接存储字符的，只能存储二进制，010101</p><p>ASCII 编码：8 个开关一组就可以编码字符，1 个字节 2^8 = 256， 一个字节存储一个字符完全够用，英文和数字在底层存储都是采用 1 个字节存储的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a  97b  98A  65B  660  481  49</span><br></pre></td></tr></table></figure><p>中国人：中国人有 9 万左右字符，2 个字节编码一个中文字符，1 个字节编码一个英文字符，这套编码叫：GBK 编码，兼容 ASCII 编码表</p><p>美国人：收集全球所有的字符，统一编号，这套编码叫 Unicode 编码（万国码），一个英文等于两个字节，一个中文（含繁体）等于两个字节，中文标点占两个字节，英文标点占两个字节</p><ul><li>UTF-8 是变种形式，也必须兼容ASCII编码表</li><li>UTF-8 一个中文一般占 3 个字节，中文标点占 3 个，英文字母和数字 1 个字节</li></ul><p>编码前与编码后的编码集必须一致才不会乱码</p><hr><h3 id="IOStream"><a href="#IOStream" class="headerlink" title="IOStream"></a>IOStream</h3><h4 id="概述-9"><a href="#概述-9" class="headerlink" title="概述"></a>概述</h4><p>IO 输入输出流：输入/输出流</p><ul><li>Input：输入</li><li>Output：输出</li></ul><p>引入：File类只能操作文件对象本身，不能读写文件对象的内容，读写数据内容，应该使用IO流</p><p>IO 流是一个水流模型：IO 理解成水管，把数据理解成水流</p><p>IO 流的分类：</p><ul><li>按照流的方向分为：输入流，输出流。<ul><li>输出流：以内存为基准，把内存中的数据写出到磁盘文件或者网络介质中去的流称为输出流<br>输出流的作用：写数据到文件，或者写数据发送给别人</li><li>输入流：以内存为基准，把磁盘文件中的数据或者网络中的数据读入到内存中的流称为输入流<br>输入流的作用：读取数据到内存</li></ul></li><li>按照流的内容分为：字节流，字符流<ul><li>字节流：流中的数据的最小单位是一个一个的字节，这个流就是字节流</li><li>字符流：流中的数据的最小单位是一个一个的字符，这个流就是字符流（<strong>针对于文本内容</strong>）</li></ul></li></ul><p>流大体分为四大类：</p><ul><li>字节输入流：以内存为基准，把磁盘文件中的数据或者网络中的数据以一个一个的字节的形式读入到内存中去的流称为字节输入流</li><li>字节输出流：以内存为基准，把内存中的数据以一个一个的字节写出到磁盘文件或者网络介质中去的流称为字节输出流</li><li>字符输入流：以内存为基准，把磁盘文件中的数据或者网络中的数据以一个一个的字符的形式读入到内存中去的流称为字符输入流</li><li>字符输出流：以内存为基准，把内存中的数据以一个一个的字符写出到磁盘文件或者网络介质中去的流称为字符输出流</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IO流的体系：        字节流                                   字符流  字节输入流              字节输出流            字符输入流         字符输出流<span class="function">InputStream           OutputStream          Reader            <span class="title">Writer</span>   <span class="params">(抽象类)</span>FileInputStream       FileOutputStream      FileReader        <span class="title">FileWriter</span><span class="params">(实现类)</span>BufferedInputStream  BufferedOutputStream  BufferedReader   <span class="title">BufferedWriter</span><span class="params">(实现类缓冲流)</span>                                           InputStreamReader OutputStreamWriterObjectInputStream     ObjectOutputStream</span></span><br></pre></td></tr></table></figure><hr><h4 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h4><h5 id="字节输入"><a href="#字节输入" class="headerlink" title="字节输入"></a>字节输入</h5><p>FileInputStream 文件字节输入流：</p><ul><li><p>作用：以内存为基准，把磁盘文件中的数据按照字节的形式读入到内存中的流</p></li><li><p>构造器：<br><code>public FileInputStream(File path)</code> : 创建一个字节输入流管道与源文件对象接通<br><code>public FileInputStream(String pathName)</code> : 创建一个字节输入流管道与文件路径对接，底层实质上创建了File对象 </p></li><li><p>方法：<br><code>public int read()</code> : 每次读取一个字节返回，读取完毕会返回-1<br><code>public int read(byte[] buffer)</code> : 从字节输入流中读取字节到字节数组中去，返回读取的字节数量，没有字节可读返回-1，<strong>byte中新读取的数据默认是覆盖原数据</strong>，构造String需要设定长度<br><code>public String(byte[] bytes,int offset,int length)</code> : 构造新的String<br><code>public long transferTo(OutputStream out) </code> : 从输入流中读取所有字节，并按读取的顺序，将字节写入给定的输出流<code>is.transferTo(os)</code></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileInputStreamDemo01</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;        <span class="comment">// 1.创建文件对象定位dlei01.txt        File file = new File(&quot;Day09Demo/src/dlei01.txt&quot;);        // 2.创建一个字节输入流管道与源文件接通        InputStream is = new FileInputStream(file);        // 3.读取一个字节的编号返回，读取完毕返回-1//int code1 = is.read(); // 读取一滴水，一个字节//System.out.println((char)code1);        // 4.使用while读取字节数        // 定义一个整数变量存储字节        int ch = 0 ;        while((ch = is.read())!= -1)&#123;            System.out.print((char) ch);        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>一个一个字节读取英文和数字没有问题。但是一旦读取中文输出无法避免乱码，因为会截断中文的字节。一个一个字节的读取数据，性能也较差，所以<strong>禁止使用上面的方案</strong></p><p>采取下面的方案：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;    <span class="comment">//简化写法，底层实质上创建了File对象    InputStream is = new FileInputStream(&quot;Day09Demo/src/dlei01.txt&quot;);    byte[] buffer = new byte[3];//开发中使用byte[1024]    int len;    while((len = is.read(buffer)) !=-1)&#123;        // 读取了多少就倒出多少！        String rs = new String(buffer, 0, len);        System.out.print(rs);    &#125;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个字节数组与文件的大小刚刚一样大，然后一桶水读取全部字节数据再输出！//可以避免中文读取输出乱码，但是如果读取的文件过大，会出现内存溢出！！//字节流并不适合读取文本文件内容输出，读写文件内容建议使用字符流。/*byte[] buffer = new byte[(int) f.length()];int len = is.read(buffer);String rs = new String(buffer);*/File f = new File(&quot;Day09Demo/src/dlei03.txt&quot;);InputStream is = new FileInputStream(f);byte[] buffer = is.readAllBytes();String rs = new String(buffer);System.out.println(rs);</span></span><br></pre></td></tr></table></figure><h5 id="字节输出"><a href="#字节输出" class="headerlink" title="字节输出"></a>字节输出</h5><p>FileOutputStream 文件字节输出流：</p><ul><li><p>作用：以内存为基准，把内存中的数据，按照字节的形式写出到磁盘文件中去</p></li><li><p>构造器：<br><code>public FileOutputStream(File file)</code> : 创建一个字节输出流管道通向目标文件对象<br><code>public FileOutputStream(String file) </code> : 创建一个字节输出流管道通向目标文件路径<br><code>public FileOutputStream(File file , boolean append)</code> : 追加数据的字节输出流管道到目标文件对象<br><code>public FileOutputStream(String file , boolean append)</code> : 创建一个追加数据的字节输出流管道通向目标文件路径</p></li><li><p>API：<br><code>public void write(int a)</code> : 写一个字节出去<br><code>public void write(byte[] buffer)</code> :写一个字节数组出去<br><code>public void write(byte[] buffer , int pos , int len)</code> : 写一个字节数组的一部分出去</p><pre><code>                参数一，字节数组；参数二：起始字节索引位置，参数三：写多少个字节数出去。</code></pre></li><li><p>FileOutputStream字节输出流每次启动写数据的时候都会先清空之前的全部数据，重新写入：<br><code>OutputStream os = new FileOutputStream(&quot;Day09Demo/out05&quot;)</code> : 覆盖数据管道<br><code>OutputStream os = new FileOutputStream(&quot;Day09Demo/out05&quot; , true)</code> : 追加数据的管道 </p></li></ul><p>说明：</p><ul><li>字节输出流只能写字节出去，字节输出流默认是<strong>覆盖</strong>数据管道。</li><li>换行用： <strong>os.write(“\r\n”.getBytes());</strong></li><li>关闭和刷新：刷新流可以继续使用，关闭包含刷新数据但是流就不能使用了！</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OutputStream os = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;Day09Demo/out05&quot;</span>);os.write(<span class="number">97</span>);<span class="comment">//aos.write(&#x27;b&#x27;);os.write(&quot;\r\n&quot;.getBytes());os.write(&quot;我爱Java&quot;.getBytes());os.close();</span></span><br></pre></td></tr></table></figure><h5 id="文件复制"><a href="#文件复制" class="headerlink" title="文件复制"></a>文件复制</h5><p>思想：字节是计算机中一切文件的组成，所以字节流适合做一切文件的复制</p><p>分析步骤：<br>    （1）创建一个字节输入流管道与源文件接通。<br>    （2）创建一个字节输出流与目标文件接通。<br>    （3）创建一个字节数组作为桶<br>    （4）从字节输入流管道中读取数据，写出到字节输出流管道即可。<br>    （5）关闭资源！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyDemo01</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        InputStream is = <span class="keyword">null</span> ;        OutputStream os = <span class="keyword">null</span> ;        <span class="keyword">try</span>&#123;            <span class="comment">//（1）创建一个字节输入流管道与源文件接通。            is = new FileInputStream(&quot;D:\\seazean\\图片资源\\meinv.jpg&quot;);            //（2）创建一个字节输出流与目标文件接通。            os = new FileOutputStream(&quot;D:\\seazean\\meimei.jpg&quot;);            //（3）创建一个字节数组作为桶            byte buffer = new byte[1024];            //（4）从字节输入流管道中读取数据，写出到字节输出流管道即可            int len = 0;            while((len = is.read(buffer)) != -1)&#123;                os.write(buffer,0,len);            &#125;            System.out.println(&quot;复制完成！&quot;);        &#125;catch (Exception e)&#123;            e.printStackTrace();        &#125; finally &#123;            /**（5）关闭资源！ */            try&#123;                if(os!=null)os.close();                if(is!=null)is.close();            &#125;catch (Exception e)&#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h4><h5 id="字符输入"><a href="#字符输入" class="headerlink" title="字符输入"></a>字符输入</h5><p>FileReader：文件字符输入流</p><ul><li>作用：以内存为基准，把磁盘文件的数据以字符的形式读入到内存，读取文本文件内容到内存中去。</li><li>构造器：<br><code>public FileReader(File file)</code> : 创建一个字符输入流与源文件对象接通。<br><code>public FileReader(String filePath)</code> : 创建一个字符输入流与源文件路径接通。</li><li>方法：<br><code>public int read()</code> : 读取一个字符的编号返回！ 读取完毕返回 -1<br><code>public int read(char[] buffer)</code> : 读取一个字符数组，读取多少个就返回多少个，读取完毕返回 -1</li><li>结论：<br>字符流一个一个字符的读取文本内容输出，可以解决中文读取输出乱码的问题，适合操作文本文件。<br>但是：一个一个字符的读取文本内容性能较差！！<br>字符流按照<strong>字符数组循环读取数据</strong>，可以解决中文读取输出乱码的问题，而且性能也较好！！</li><li><strong>字符流不能复制图片，视频等类型的文件</strong>。字符流在读取完了字节数据后并没有直接往目的地写，而是先查编码表，查到对应的数据就将该数据写入目的地。如果查不到，则码表会将一些未知区域中的数据去map这些字节数据，然后写到目的地，这样的话就造成了源数据和目的数据的不一致。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileReaderDemo01</span></span>&#123;<span class="comment">//字符    public static void main(String[] args) throws Exception &#123;        // 1.创建一个文件对象定位源文件        // File f = new File(&quot;Day10Demo/src/dlei01.txt&quot;);        // 2.创建一个字符输入流管道与源文件接通        // Reader fr = new FileReader(f);        // 3.简化写法：创建一个字符输入流管道与源文件路径接通        Reader fr = new FileReader(&quot;Day10Demo/src/dlei01.txt&quot;);        //int code1 = fr.read();//System.out.print((char)code1);        int ch;        while((ch = fr.read()) != -1)&#123;            System.out.print((char)ch);        &#125;    &#125;&#125;public class FileReaderDemo02 &#123;//字符数组    public static void main(String[] args) throws Exception &#123;        Reader fr = new FileReader(&quot;Day10Demo/src/dlei01.txt&quot;);                //char[] buffer = new char[3];//int len = fr.read(buffer);//System.out.println(&quot;字符数：&quot;+len);//String rs = new String(buffer,0,len);//System.out.println(rs);        char[] buffer = new char[1024];        int len;        while((len = fr.read(buffer)) != -1) &#123;            System.out.print(new String(buffer, 0 , len));        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><h5 id="字符输出"><a href="#字符输出" class="headerlink" title="字符输出"></a>字符输出</h5><p>FileWriter：文件字符输出流</p><ul><li>作用：以内存为基准，把内存中的数据按照字符的形式写出到磁盘文件中去</li><li>构造器：<br><code>public FileWriter(File file)</code> : 创建一个字符输出流管道通向目标文件对象<br><code>public FileWriter(String filePath)</code> : 创建一个字符输出流管道通向目标文件路径<br><code>public FileWriter(File file,boolean append)</code> : 创建一个追加数据的字符输出流管道通向文件对象<br><code>public FileWriter(String filePath,boolean append)</code> : 创建一个追加数据的字符输出流管道通向目标文件路径</li><li>方法：<br><code>public void write(int c)</code> : 写一个字符出去<br><code>public void write(String c)</code> : 写一个字符串出去<br><code>public void write(char[] buffer)</code> : 写一个字符数组出去<br><code>public void write(String c ,int pos ,int len)</code> : 写字符串的一部分出去<br><code>public void write(char[] buffer ,int pos ,int len)</code> : 写字符数组的一部分出去</li><li>说明：<br>覆盖数据管道：<code>Writer fw = new FileWriter(&quot;Day10Demo/src/dlei03.txt&quot;)</code><br>追加数据管道：<code>Writer fw = new FileWriter(&quot;Day10Demo/src/dlei03.txt&quot;,true)</code><br>换行：fw.write(“\r\n”); // 换行<br>读写字符文件数据建议使用字符流</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Writer fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;Day10Demo/src/dlei03.txt&quot;</span>);fw.write(<span class="number">97</span>);   <span class="comment">// 字符afw.write(&#x27;b&#x27;);  // 字符bfw.write(&quot;Java是最优美的语言！&quot;);fw.write(&quot;\r\n&quot;);fw.close;</span></span><br></pre></td></tr></table></figure><hr><h4 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h4><h5 id="基本介绍-15"><a href="#基本介绍-15" class="headerlink" title="基本介绍"></a>基本介绍</h5><p>作用：缓冲流可以提高字节流和字符流的读写数据的性能。</p><p>缓冲流分为四类：</p><ul><li>BufferedInputStream：字节缓冲输入流，可以提高字节输入流读数据的性能。</li><li>BufferedOutStream：  字节缓冲输出流，可以提高字节输出流写数据的性能。</li><li>BufferedReader：  字符缓冲输入流，可以提高字符输入流读数据的性能。</li><li>BufferedWriter：  字符缓冲输出流，可以提高字符输出流写数据的性能。</li></ul><hr><h5 id="字节缓冲输入"><a href="#字节缓冲输入" class="headerlink" title="字节缓冲输入"></a>字节缓冲输入</h5><p>字节缓冲输入流：BufferedInputStream</p><p>作用：可以把低级的字节输入流包装成一个高级的缓冲字节输入流管道, 提高字节输入流读数据的性能</p><p>构造器：<code>public BufferedInputStream(InputStream in)</code></p><p>原理：缓冲字节输入流管道自带了一个 8KB 的缓冲池，每次可以直接借用操作系统的功能最多提取 8KB 的数据到缓冲池中去，以后我们直接从缓冲池读取数据，所以性能较好</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedInputStreamDemo01</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;        <span class="comment">// 1.定义一个低级的字节输入流与源文件接通        InputStream is = new FileInputStream(&quot;Day10Demo/src/dlei04.txt&quot;);        // 2.把低级的字节输入流包装成一个高级的缓冲字节输入流。        BufferInputStream bis = new BufferInputStream(is);        // 3.定义一个字节数组按照循环读取。        byte[] buffer = new byte[1024];        int len;        while((len = bis.read(buffer)) != -1)&#123;            String rs = new String(buffer, 0 , len);            System.out.print(rs);        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h5 id="字节缓冲输出"><a href="#字节缓冲输出" class="headerlink" title="字节缓冲输出"></a>字节缓冲输出</h5><p>字节缓冲输出流：BufferedOutputStream</p><p>作用：可以把低级的字节输出流包装成一个高级的缓冲字节输出流，从而提高写数据的性能</p><p>构造器：<code>public BufferedOutputStream(OutputStream os)</code></p><p>原理：缓冲字节输出流自带了8KB缓冲池,数据就直接写入到缓冲池中去，性能极高了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedOutputStreamDemo02</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;        <span class="comment">// 1.写一个原始的字节输出流        OutputStream os = new FileOutputStream(&quot;Day10Demo/src/dlei05.txt&quot;);        // 2.把低级的字节输出流包装成一个高级的缓冲字节输出流        BufferedOutputStream bos =  new BufferedOutputStream(os);        // 3.写数据出去        bos.write(&#x27;a&#x27;);        bos.write(100);        bos.write(&quot;我爱中国&quot;.getBytes());        bos.close();    &#125;&#125;</span></span><br></pre></td></tr></table></figure><h5 id="字节流性能"><a href="#字节流性能" class="headerlink" title="字节流性能"></a>字节流性能</h5><p>利用字节流的复制统计各种写法形式下缓冲流的性能执行情况。</p><p>复制流：</p><ul><li>使用低级的字节流按照一个一个字节的形式复制文件。</li><li>使用低级的字节流按照一个一个字节数组的形式复制文件。</li><li>使用高级的缓冲字节流按照一个一个字节的形式复制文件。</li><li>使用高级的缓冲字节流按照一个一个字节数组的形式复制文件。</li></ul><p>高级的缓冲字节流按照一个一个字节数组的形式复制文件，性能最高，建议使用</p><hr><h5 id="字符缓冲输入"><a href="#字符缓冲输入" class="headerlink" title="字符缓冲输入"></a>字符缓冲输入</h5><p>字符缓冲输入流：BufferedReader</p><p>作用：字符缓冲输入流把字符输入流包装成高级的缓冲字符输入流，可以提高字符输入流读数据的性能。</p><p>构造器：<code>public BufferedReader(Reader reader)</code></p><p>原理：缓冲字符输入流默认会有一个8K的字符缓冲池,可以提高读字符的性能</p><p>按照行读取数据的功能：<code>public String readLine()</code>  读取一行数据返回，读取完毕返回null</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;    <span class="comment">// 1.定义一个原始的字符输入流读取源文件    Reader fr = new FileReader(&quot;Day10Demo/src/dlei06.txt&quot;);    // 2.把低级的字符输入流管道包装成一个高级的缓冲字符输入流管道    BufferedReader br = new BufferedReader(fr);    // 定义一个字符串变量存储每行数据    String line;    while((line = br.readLine()) != null)&#123;        System.out.println(line);    &#125;    br.close();    //淘汰数组循环读取    //char[] buffer = new char[1024];    //int len;    //while((len = br.read(buffer)) != -1)&#123;    //System.out.println(new String(buffer , 0 , len));&#125;</span></span><br></pre></td></tr></table></figure><hr><h5 id="字符缓冲输出"><a href="#字符缓冲输出" class="headerlink" title="字符缓冲输出"></a>字符缓冲输出</h5><p>符缓冲输出流：BufferedWriter</p><p>作用：把低级的字符输出流包装成一个高级的缓冲字符输出流，提高写字符数据的性能。</p><p>构造器：<code>public BufferedWriter(Writer writer)</code></p><p> 原理：高级的字符缓冲输出流多了一个8k的字符缓冲池，写数据性能极大提高了</p><p>字符缓冲输出流多了一个换行的特有功能：<code>public void newLine()</code>  <strong>新建一行</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;    Writer fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;Day10Demo/src/dlei07.txt&quot;</span>,<span class="keyword">true</span>);<span class="comment">//追加    BufferedWriter bw = new BufferedWriter(fw);        bw.write(&quot;我爱学习Java&quot;);    bw.newLine();//换行    bw.close();&#125;</span></span><br></pre></td></tr></table></figure><hr><h5 id="高效原因"><a href="#高效原因" class="headerlink" title="高效原因"></a>高效原因</h5><p>字符型缓冲流高效的原因：（空间换时间）</p><ul><li>BufferedReader：每次调用 read 方法，只有第一次从磁盘中读取了 8192（<strong>8k</strong>）个字符，存储到该类型对象的缓冲区数组中，将其中一个返回给调用者，再次调用 read 方法时，就不需要访问磁盘，直接从缓冲区中拿出一个数据即可，提升了效率</li><li>BufferedWriter：每次调用 write 方法，不会直接将字符刷新到文件中，而是存储到字符数组中，等字符数组写满了，才一次性刷新到文件中，减少了和磁盘交互的次数，提升了效率</li></ul><p>字节型缓冲流高效的原因：</p><ul><li>BufferedInputStream：在该类型中准备了一个数组，存储字节信息，当外界调用 read() 方法想获取一个字节的时候，该对象从文件中一次性读取了 8192 个字节到数组中，只返回了第一个字节给调用者。将来调用者再次调用 read 方法时，当前对象就不需要再次访问磁盘，只需要从数组中取出一个字节返回给调用者即可，由于读取的是数组，所以速度非常快。当 8192 个字节全都读取完成之后，再需要读取一个字节，就得让该对象到文件中读取下一个 8192 个字节</li><li>BufferedOutputStream：在该类型中准备了一个数组，存储字节信息，当外界调用 write 方法想写出一个字节的时候，该对象直接将这个字节存储到了自己的数组中，而不刷新到文件中。一直到该数组所有 8192 个位置全都占满，该对象才把这个数组中的所有数据一次性写出到目标文件中。如果最后一次循环没有将数组写满，最终在关闭流对象的时候，也会将该数组中的数据刷新到文件中。 </li></ul><p>注意：<strong>字节流和字符流，都是装满时自动写出，或者没满时手动 flush 写出，或 close 时刷新写出</strong></p><hr><h4 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h4><h5 id="乱码问题"><a href="#乱码问题" class="headerlink" title="乱码问题"></a>乱码问题</h5><p>字符流读取：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">代码编码            文件编码         中文情况。UTF-8              UTF-8           不乱码!GBK                GBK             不乱码!UTF-8              GBK             乱码!</span><br></pre></td></tr></table></figure><p>如果代码编码和读取的文件编码一致，字符流读取的时候不会乱码。<br>如果代码编码和读取的文件编码不一致，字符流读取的时候会乱码。</p><hr><h5 id="字符输入-1"><a href="#字符输入-1" class="headerlink" title="字符输入"></a>字符输入</h5><p>字符输入转换流：InputStreamReader</p><p>作用：解决字符流读取不同编码的乱码问题，把原始的<strong>字节流</strong>按照默认的编码或指定的编码<strong>转换成字符输入流</strong></p><p>构造器：</p><ul><li><code>public InputStreamReader(InputStream is)</code> : 使用当前代码默认编码 UTF-8 转换成字符流</li><li><code>public InputStreamReader(InputStream is, String charset)</code> : 指定编码把字节流转换成字符流</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InputStreamReaderDemo</span></span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;        <span class="comment">// 1.提取GBK文件的原始字节流        InputStream is = new FileInputStream(&quot;D:\\seazean\\Netty.txt&quot;);        // 2.把原始字节输入流通过转换流，转换成 字符输入转换流InputStreamReader        InputStreamReader isr = new InputStreamReader(is,&quot;GBK&quot;);         // 3.包装成缓冲流        BufferedReader br = new BufferedReader(isr);        //循环读取        String line;        while((line = br.readLine()) != null)&#123;            System.out.println(line);        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h5 id="字符输出-1"><a href="#字符输出-1" class="headerlink" title="字符输出"></a>字符输出</h5><p>字符输出转换流：OutputStreamWriter</p><p>作用：可以指定编码<strong>把字节输出流转换成字符输出流</strong>，可以指定写出去的字符的编码</p><p>构造器：</p><ul><li><code>public OutputStreamWriter(OutputStream os)</code> : 用默认编码 UTF-8 把字节输出流转换成字符输出流</li><li><code>public OutputStreamWriter(OutputStream os, String charset)</code> : 指定编码把字节输出流转换成</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OutputStream os = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;Day10Demo/src/dlei07.txt&quot;</span>);OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(os,<span class="string">&quot;GBK&quot;</span>);osw.write(<span class="string">&quot;我在学习Java&quot;</span>);   osw.close();</span><br></pre></td></tr></table></figure><hr><h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><h5 id="基本介绍-16"><a href="#基本介绍-16" class="headerlink" title="基本介绍"></a>基本介绍</h5><p>对象序列化：把Java对象转换成字节序列的过程，将对象写入到IO流中。     对象 =&gt; 文件中</p><p>对象反序列化：把字节序列恢复为Java对象的过程，从IO流中恢复对象。     文件中 =&gt; 对象</p><p>transient 关键字修饰的成员变量，将不参与序列化！</p><hr><h5 id="序列化-1"><a href="#序列化-1" class="headerlink" title="序列化"></a>序列化</h5><p>对象序列化流（对象字节输出流）：ObjectOutputStream</p><p>作用：把内存中的Java对象数据保存到文件中去</p><p>构造器：<code>public ObjectOutputStream(OutputStream out)</code></p><p>序列化方法：<code>public final void writeObject(Object obj)</code></p><p>注意：对象如果想参与序列化，对象必须实现序列化接口 <strong>implements Serializable</strong> ，否则序列化失败！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializeDemo01</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;        <span class="comment">// 1.创建User用户对象        User user = new User(&quot;seazean&quot;,&quot;980823&quot;,&quot;七十一&quot;);        // 2.创建低级的字节输出流通向目标文件        OutputStream os = new FileOutputStream(&quot;Day10Demo/src/obj.dat&quot;);        // 3.把低级的字节输出流包装成高级的对象字节输出流 ObjectOutputStream        ObjectOutputStream oos = new ObjectOutputStream(os);        // 4.通过对象字节输出流序列化对象：        oos.writeObject(user);        // 5.释放资源        oos.close();        System.out.println(&quot;序列化对象成功~~~~&quot;);    &#125;&#125;class User implements Serializable &#123;    // 加入序列版本号    private static final long serialVersionUID = 1L;    private String loginName;    private transient String passWord;    private String userName;    ///get+set&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 序列化为二进制数据ByteArrayOutputStream bos = new ByteArrayOutputStream();ObjectOutputStream oos = new ObjectOutputStream(bos);oos.writeObject(obj);// 将该对象序列化为二进制数据oos.flush();byte[] bytes = bos.toByteArray();</span></span><br></pre></td></tr></table></figure><hr><h5 id="反序列"><a href="#反序列" class="headerlink" title="反序列"></a>反序列</h5><p>对象反序列化（对象字节输入流）：ObjectInputStream</p><p>作用：读取序列化的对象文件恢复到Java对象中</p><p>构造器：<code>public ObjectInputStream(InputStream is)</code></p><p>方法：<code>public final Object readObject()</code></p><p>序列化版本号：<code>private static final long serialVersionUID = 2L</code><br>说明：序列化使用的版本号和反序列化使用的版本号一致才可以正常反序列化，否则报错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializeDemo02</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;        InputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;Day10Demo/src/obj.dat&quot;</span>);        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(is);        User user = (User)ois.readObject();<span class="comment">//反序列化        System.out.println(user);        System.out.println(&quot;反序列化完成！&quot;);    &#125;&#125;class User implements Serializable &#123;    // 加入序列版本号    private static final long serialVersionUID = 1L;    //........&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h4><p>打印流 PrintStream / PrintWriter</p><p>打印流的作用：</p><ul><li>可以方便，快速的写数据出去，可以实现打印什么类型，就是什么类型</li><li>PrintStream/PrintWriter 不光可以打印数据，还可以写字节数据和字符数据出去</li><li><strong>System.out.print() 底层基于打印流实现的</strong> </li></ul><p>构造器：</p><ul><li><code>public PrintStream(OutputStream os)</code></li><li><code>public PrintStream(String filepath)</code></li></ul><p>System类：</p><ul><li><code>public static void setOut(PrintStream out)</code>：让系统的输出流向打印流</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintStreamDemo01</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;        PrintStream ps = <span class="keyword">new</span>  PrintStream(<span class="string">&quot;Day10Demo/src/dlei.txt&quot;</span>);        <span class="comment">//PrintWriter pw = new  PrintWriter(&quot;Day10Demo/src/dlei08.txt&quot;);        ps.println(任何类型的数据);        ps.print(不换行);        ps.write(&quot;我爱你&quot;.getBytes());        ps.close();    &#125;&#125;public class PrintStreamDemo02 &#123;    public static void main(String[] args) throws Exception &#123;        System.out.println(&quot;==seazean0==&quot;);        PrintStream ps = new PrintStream(&quot;Day10Demo/src/log.txt&quot;);        System.setOut(ps); // 让系统的输出流向打印流//不输出在控制台，输出到文件里        System.out.println(&quot;==seazean1==&quot;);        System.out.println(&quot;==seazean2==&quot;);    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h3 id="Close"><a href="#Close" class="headerlink" title="Close"></a>Close</h3><p>try-with-resources：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(    <span class="comment">// 这里只能放置资源对象，用完会自动调用close()关闭)&#123;&#125;catch(Exception e)&#123; e.printStackTrace();&#125;</span></span><br></pre></td></tr></table></figure><p>资源类一定是实现了 Closeable 接口，实现这个接口的类就是资源</p><p>有 close() 方法，try-with-resources 会自动调用它的 close() 关闭资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(<span class="comment">/** （1）创建一个字节输入流管道与源文件接通。 */</span>InputStream is  = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:\\seazean\\图片资源\\meinv.jpg&quot;</span>);<span class="comment">/** （2）创建一个字节输出流与目标文件接通。*/</span>OutputStream os = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;D:\\seazean\\meimei.jpg&quot;</span>);<span class="comment">/** （5）关闭资源！是自动进行的 */</span>)&#123;<span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];<span class="keyword">int</span> len = <span class="number">0</span>;<span class="keyword">while</span>((len = is.read(buffer)) != -<span class="number">1</span>)&#123;os.write(buffer, <span class="number">0</span> , len);&#125;System.out.println(<span class="string">&quot;复制完成！&quot;</span>);&#125;<span class="keyword">catch</span> (Exception e)&#123;e.printStackTrace();&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h3><p>Properties：属性集对象。就是一个Map集合，一个键值对集合</p><p>核心作用：Properties代表的是一个属性文件，可以把键值对数据存入到一个属性文件</p><p>属性文件：后缀是.properties结尾的文件，里面的内容都是 key=value</p><p>Properties方法：</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public Object setProperty(String key, String value)</td><td>设置集合的键和值，底层调用Hashtable方法 put</td></tr><tr><td>public String getProperty(String key)</td><td>使用此属性列表中指定的键搜索属性</td></tr><tr><td>public Set<String>   stringPropertyNames()</String></td><td>所有键的名称的集合</td></tr><tr><td>public synchronized void load(Reader r)</td><td>从输入字符流读取属性列表（键和元素对）</td></tr><tr><td>public synchronized void load(InputStream inStream)</td><td>加载属性文件的数据到属性集对象中去</td></tr><tr><td>public void store(Writer w, String comments)</td><td>将此属性列表(键和元素对)写入 Properties表</td></tr><tr><td>public void store(OutputStream os, String comments)</td><td>保存数据到属性文件中去</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertiesDemo01</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;        <span class="comment">// a.创建一个属性集对象：Properties的对象。        Properties properties = new Properties();//&#123;&#125;        properties.setProperty(&quot;admin&quot; , &quot;123456&quot;);        // b.把属性集对象的数据存入到属性文件中去（重点）        OutputStream os = new FileOutputStream(&quot;Day10Demo/src/users.properties&quot;);        properties.store(os,&quot;i am very happy!!我保存了用户数据!&quot;);        //参数一：被保存数据的输出管道        //参数二：保存心得。就是对象保存的数据进行解释说明！    &#125;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertiesDemo02</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;        Properties properties = <span class="keyword">new</span> Properties();<span class="comment">//底层基于map集合        properties.load(new FileInputStream(&quot;Day10Demo/src/users.properties&quot;));        System.out.println(properties);        System.out.println(properties.getProperty(&quot;admin&quot;));        Set&lt;String&gt; set = properties.stringPropertyNames();        for (String s : set) &#123;            String value = properties.getProperty(s);            System.out.println(s + value);        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h3 id="RandomIO"><a href="#RandomIO" class="headerlink" title="RandomIO"></a>RandomIO</h3><p>RandomAccessFile 类：该类的实例支持读取和写入随机访问文件</p><p>构造器：<br>RandomAccessFile(File file, String mode)：创建随机访问文件流，从File参数指定的文件读取，可选择写入<br>RandomAccessFile(String name, String mode)：创建随机访问文件流，从指定名称文件读取，可选择写入文件</p><p>常用方法：<br><code>public void seek(long pos)</code> : 设置文件指针偏移，从该文件开头测量，发生下一次读取或写入(插入+覆盖)<br><code>public void write(byte[] b)</code> : 从指定的字节数组写入 b.length个字节到该文件<br><code>public int read(byte[] b)</code> : 从该文件读取最多b.length个字节的数据到字节数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;    RandomAccessFile rf = <span class="keyword">new</span> RandomAccessFile(<span class="keyword">new</span> File(),<span class="string">&quot;rw&quot;</span>);    rf.write(<span class="string">&quot;hello world&quot;</span>.getBytes());    rf.seek(<span class="number">5</span>);<span class="comment">//helloxxxxld    rf.write(&quot;xxxx&quot;.getBytes());    rf.close();&#125;</span></span><br></pre></td></tr></table></figure><hr><h3 id="Commons"><a href="#Commons" class="headerlink" title="Commons"></a>Commons</h3><p>commons-io 是apache开源基金组织提供的一组有关IO操作的类库，可以挺提高IO功能开发的效率。</p><p>commons-io 工具包提供了很多有关 IO 操作的类：</p><table><thead><tr><th>包</th><th align="left">功能描述</th></tr></thead><tbody><tr><td>org.apache.commons.io</td><td align="left">有关Streams、Readers、Writers、Files的工具类</td></tr><tr><td>org.apache.commons.io.input</td><td align="left">输入流相关的实现类，包含Reader和InputStream</td></tr><tr><td>org.apache.commons.io.output</td><td align="left">输出流相关的实现类，包含Writer和OutputStream</td></tr><tr><td>org.apache.commons.io.serialization</td><td align="left">序列化相关的类</td></tr></tbody></table><p>IOUtils 和 FileUtils 可以方便的复制文件和文件夹</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonsIODemo01</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;        <span class="comment">// 1.完成文件复制！        IOUtils.copy(new FileInputStream(&quot;Day13Demo/src/books.xml&quot;),                      new FileOutputStream(&quot;Day13Demo/new.xml&quot;));        // 2.完成文件复制到某个文件夹下！        FileUtils.copyFileToDirectory(new File(&quot;Day13Demo/src/books.xml&quot;),                                      new File(&quot;D:/it&quot;));        // 3.完成文件夹复制到某个文件夹下！        FileUtils.copyDirectoryToDirectory(new File(&quot;D:\\it\\图片服务器&quot;) ,                                           new File(&quot;D:\\&quot;));        //  Java从1.7开始提供了一些nio, 自己也有一行代码完成复制的技术。        Files.copy(Paths.get(&quot;Day13Demo/src/books.xml&quot;)                , new FileOutputStream(&quot;Day13Demo/new11.txt&quot;));    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="测试框架"><a href="#测试框架" class="headerlink" title="测试框架"></a>测试框架</h3><blockquote><p>单元测试是指程序员写的测试代码给自己的类中的方法进行预期正确性的验证。<br>单元测试一旦写好了这些测试代码，就可以一直使用，可以实现一定程度上的自动化测试。</p></blockquote><p>单元测试的经典框架：Junit</p><ul><li>Junit : 是 Java 语言编写的第三方单元测试框架，可以帮助我们方便快速的测试我们代码的正确性。</li><li>单元测试：<ul><li>单元：在 Java 中，一个类就是一个单元</li><li>单元测试：Junit 编写的一小段代码，用来对某个类中的某个方法进行功能测试或业务逻辑测试    </li></ul></li></ul><p>Junit 单元测试框架的作用：</p><ul><li>用来对类中的方法功能进行有目的的测试，以保证程序的正确性和稳定性</li><li>能够<strong>独立的</strong>测试某个方法或者所有方法的预期正确性</li></ul><p>测试方法注意事项：<strong>必须是 public 修饰的，没有返回值，没有参数，使用注解@Test修饰</strong></p><p>Junit常用注解(Junit 4.xxxx版本)，@Test 测试方法：</p><ul><li>@Before：用来修饰实例方法，该方法会在每一个测试方法执行之前执行一次</li><li>@After：用来修饰实例方法，该方法会在每一个测试方法执行之后执行一次</li><li>@BeforeClass：用来静态修饰方法，该方法会在所有测试方法之前<strong>只</strong>执行一次</li><li>@AfterClass：用来静态修饰方法，该方法会在所有测试方法之后<strong>只</strong>执行一次</li></ul><p>Junit常用注解(Junit5.xxxx版本)，@Test 测试方法：</p><ul><li>@BeforeEach：用来修饰实例方法，该方法会在每一个测试方法执行之前执行一次</li><li>@AfterEach：用来修饰实例方法，该方法会在每一个测试方法执行之后执行一次</li><li>@BeforeAll：用来静态修饰方法，该方法会在所有测试方法之前只执行一次</li><li>@AfterAll：用来静态修饰方法，该方法会在所有测试方法之后只执行一次</li></ul><p>作用：</p><ul><li>开始执行的方法：初始化资源</li><li>执行完之后的方法：释放资源</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;    <span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(String loginName , String passWord)</span></span>&#123;        <span class="keyword">if</span>(<span class="string">&quot;admin&quot;</span>.equals(loginName)&amp;&amp;<span class="string">&quot;123456&quot;</span>.equals(passWord))&#123;            <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;        &#125;        <span class="keyword">return</span> <span class="string">&quot;用户名或者密码错误！&quot;</span>;    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">chu</span><span class="params">(<span class="keyword">int</span> a , <span class="keyword">int</span> b)</span></span>&#123;        System.out.println(a / b);    &#125;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试方法的要求：1.必须public修饰 2.没有返回值没有参数 3. 必须使注解@Test修饰public class UserServiceTest &#123;     // @Before：用来修饰实例方法，该方法会在每一个测试方法执行之前执行一次。    @Before    public void before()&#123;        System.out.println(&quot;===before===&quot;);    &#125;    // @After：用来修饰实例方法，该方法会在每一个测试方法执行之后执行一次。    @After    public void after()&#123;        System.out.println(&quot;===after===&quot;);    &#125;    // @BeforeClass：用来静态修饰方法，该方法会在所有测试方法之前只执行一次。    @BeforeClass    public static void beforeClass()&#123;        System.out.println(&quot;===beforeClass===&quot;);    &#125;    // @AfterClass：用来静态修饰方法，该方法会在所有测试方法之后只执行一次。    @AfterClass    public static void afterClass()&#123;        System.out.println(&quot;===afterClass===&quot;);    &#125;    @Test    public void testLogin()&#123;        UserService userService = new UserService();        String rs = userService.login(&quot;admin&quot;,&quot;123456&quot;);        /**断言预期结果的正确性。         * 参数一：测试失败的提示信息。         * 参数二：期望值。         * 参数三：实际值         */        Assert.assertEquals(&quot;登录业务功能方法有错误，请检查！&quot;,&quot;success&quot;,rs);    &#125;    @Test    public void testChu()&#123;        UserService userService = new UserService();        userService.chu(10 , 0);    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h3 id="介绍反射"><a href="#介绍反射" class="headerlink" title="介绍反射"></a>介绍反射</h3><p>反射是指对于任何一个类，在”运行的时候”都可以直接得到这个类全部成分</p><ul><li><p>构造器对象：Constructor</p></li><li><p>成员变量对象：Field</p></li><li><p>成员方法对象：Method</p></li></ul><p>核心思想：在运行时获取类编译后的字节码文件对象，然后解析类中的全部成分</p><p>反射提供了一个Class类型：HelloWorld.java → javac → HelloWorld.class</p><ul><li><code>Class c = HelloWorld.class</code> </li></ul><p>注意：反射是工作在<strong>运行时</strong>的技术，只有运行之后才会有 class 类对象</p><p>作用：可以在运行时得到一个类的全部成分然后操作，破坏封装性，也可以破坏泛型的约束性。</p><p><strong>反射的优点：</strong></p><ul><li>可扩展性：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类</li><li>类浏览器和可视化开发环境：一个类浏览器需要可以枚举类的成员，可视化开发环境（如 IDE）可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码</li><li>调试器和测试工具： 调试器需要能够检查一个类里的私有成员。测试工具可以利用反射来自动地调用类里定义的可被发现的 API 定义，以确保一组测试中有较高的代码覆盖率</li></ul><p><strong>反射的缺点：</strong></p><ul><li>性能开销：反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化，反射操作的效率要比那些非射操作低得多，应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。</li><li>安全限制：使用反射技术要求程序必须在一个没有安全限制的环境中运行，如果一个程序必须在有安全限制的环境中运行，如 Applet，那么这就是个问题了</li><li>内部暴露：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化</li></ul><hr><h3 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h3><h4 id="获取类"><a href="#获取类" class="headerlink" title="获取类"></a>获取类</h4><p>反射技术的第一步是先得到 Class 类对象，有三种方式获取：</p><ul><li>类名.class</li><li>类的对象.getClass()</li><li>Class.forName(“类的全限名”)：<code>public static Class&lt;?&gt; forName(String className) </code></li></ul><p>Class 类下的方法：</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>String getSimpleName()</td><td>获得类名字符串：类名</td></tr><tr><td>String getName()</td><td>获得类全名：包名+类名</td></tr><tr><td>T newInstance()</td><td>创建 Class 对象关联类的对象，底层是调用无参数构造器，已经被淘汰</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo</span></span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;        <span class="comment">// 反射的第一步永远是先得到类的Class文件对象: 字节码文件。        // 1.类名.class        Class c1 = Student.class;        System.out.println(c1);//class _03反射_获取Class类对象.Student        // 2.对象.getClass()        Student swk = new Student();        Class c2 = swk.getClass();        System.out.println(c2);        // 3.Class.forName(&quot;类的全限名&quot;)        // 直接去加载该类的class文件。        Class c3 = Class.forName(&quot;_03反射_获取Class类对象.Student&quot;);        System.out.println(c3);        System.out.println(c1.getSimpleName()); // 获取类名本身（简名）Student        System.out.println(c1.getName()); //获取类的全限名_03反射_获取Class类对象.Student    &#125;&#125;class Student&#123;&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="获取构造"><a href="#获取构造" class="headerlink" title="获取构造"></a>获取构造</h4><p>获取构造器的 API：</p><ul><li>Constructor getConstructor(Class… parameterTypes)：根据参数匹配获取某个构造器，只能拿 public 修饰的构造器</li><li>**Constructor getDeclaredConstructor(Class… parameterTypes)**：根据参数匹配获取某个构造器，只要申明就可以定位，不关心权限修饰符</li><li>Constructor[] getConstructors()：获取所有的构造器，只能拿 public 修饰的构造器</li><li>**Constructor[] getDeclaredConstructors()**：获取所有构造器，只要申明就可以定位，不关心权限修饰符</li></ul><p>Constructor 的常用 API：</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>T newInstance(Object… initargs)</td><td>创建对象，注入构造器需要的数据</td></tr><tr><td>void setAccessible(true)</td><td>修改访问权限，true 攻破权限（暴力反射）</td></tr><tr><td>String getName()</td><td>以字符串形式返回此构造函数的名称</td></tr><tr><td>int getParameterCount()</td><td>返回参数数量</td></tr><tr><td>Class&lt;?&gt;[] getParameterTypes</td><td>返回参数类型数组</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStudent01</span> </span>&#123;    <span class="meta">@Test</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getDeclaredConstructors</span><span class="params">()</span></span>&#123;        <span class="comment">// a.反射第一步先得到Class类对象        Class c = Student.class ;        // b.定位全部构造器，只要申明了就可以拿到        Constructor[] cons = c.getDeclaredConstructors();        // c.遍历这些构造器        for (Constructor con : cons) &#123;            System.out.println(con.getName()+&quot;-&gt;&quot;+con.getParameterCount());        &#125;    &#125;    @Test    public void getDeclaredConstructor() throws Exception &#123;        // a.反射第一步先得到Class类对象        Class c = Student.class ;        // b.定位某个构造器，根据参数匹配，只要申明了就可以获取        //Constructor con = c.getDeclaredConstructor(); // 可以拿到！定位无参数构造器！        Constructor con = c.getDeclaredConstructor(String.class, int.class); //有参数的！!        // c.构造器名称和参数        System.out.println(con.getName()+&quot;-&gt;&quot;+con.getParameterCount());    &#125;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;    <span class="keyword">private</span> String name ;    <span class="keyword">private</span> <span class="keyword">int</span> age ;    <span class="function"><span class="keyword">private</span> <span class="title">Student</span><span class="params">()</span></span>&#123;        System.out.println(<span class="string">&quot;无参数构造器被执行~~~~&quot;</span>);    &#125;    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;        System.out.println(<span class="string">&quot;有参数构造器被执行~~~~&quot;</span>);        <span class="keyword">this</span>.name = name;        <span class="keyword">this</span>.age = age;    &#125;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试方法public class TestStudent02 &#123;    // 1.调用无参数构造器得到一个类的对象返回。    @Test    public void createObj01() throws Exception &#123;        // a.反射第一步是先得到Class类对象        Class c = Student.class ;        // b.定位无参数构造器对象        Constructor constructor = c.getDeclaredConstructor();        // c.暴力打开私有构造器的访问权限        constructor.setAccessible(true);        // d.通过无参数构造器初始化对象返回        Student swk = (Student) constructor.newInstance(); // 最终还是调用无参数构造器的！        System.out.println(swk);//Student&#123;name=&#x27;null&#x27;, age=0&#125;    &#125;    // 2.调用有参数构造器得到一个类的对象返回。    @Test    public void createObj02() throws Exception &#123;        // a.反射第一步是先得到Class类对象        Class c = Student.class ;        // b.定位有参数构造器对象        Constructor constructor = c.getDeclaredConstructor(String.class , int.class);        // c.通过无参数构造器初始化对象返回        Student swk = (Student) constructor.newInstance(&quot;孙悟空&quot;,500); // 最终还是调用有参数构造器的！        System.out.println(swk);//Student&#123;name=&#x27;孙悟空&#x27;, age=500&#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="获取变量"><a href="#获取变量" class="headerlink" title="获取变量"></a>获取变量</h4><p>获取Field成员变量API：</p><ul><li>Field getField(String name) : 根据成员变量名获得对应 Field 对象，只能获得 public 修饰</li><li>Field getDeclaredField(String name) : 根据成员变量名获得对应 Field 对象，所有申明的变量</li><li>Field[] getFields() : 获得所有的成员变量对应的Field对象，只能获得 public 的</li><li>Field[] getDeclaredFields() : 获得所有的成员变量对应的 Field 对象，只要申明了就可以得到 </li></ul><p>Field 的方法：给成员变量赋值和取值</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>void set(Object obj, Object value)</td><td>给对象注入某个成员变量数据，<strong>obj 是对象</strong>，value 是值</td></tr><tr><td>Object get(Object obj)</td><td>获取指定对象的成员变量的值，<strong>obj 是对象</strong>，没有对象为 null</td></tr><tr><td>void setAccessible(true)</td><td>暴力反射，设置为可以直接访问私有类型的属性</td></tr><tr><td>Class getType()</td><td>获取属性的类型，返回 Class 对象</td></tr><tr><td>String getName()</td><td>获取属性的名称</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldDemo</span> </span>&#123;    <span class="comment">//获取全部成员变量    @Test    public void getDeclaredFields()&#123;        // a.先获取class类对象        Class c = Dog.class;        // b.获取全部申明的成员变量对象        Field[] fields = c.getDeclaredFields();        for (Field field : fields) &#123;            System.out.println(field.getName()+&quot;-&gt;&quot;+field.getType());        &#125;    &#125;    //获取某个成员变量    @Test    public void getDeclaredField() throws Exception &#123;        // a.先获取class类对象        Class c = Dog.class;        // b.定位某个成员变量对象 :根据名称定位！！        Field ageF = c.getDeclaredField(&quot;age&quot;);        System.out.println(ageF.getName()+&quot;-&gt;&quot;+ageF.getType());    &#125;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;    <span class="keyword">private</span> String name;    <span class="keyword">private</span> <span class="keyword">int</span> age ;    <span class="keyword">private</span> String color ;    <span class="keyword">public</span> <span class="keyword">static</span> String school;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SCHOOL_1 = <span class="string">&quot;宠物学校&quot;</span>;    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">()</span> </span>&#123;    &#125;    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">(String name, <span class="keyword">int</span> age, String color)</span> </span>&#123;        <span class="keyword">this</span>.name = name;        <span class="keyword">this</span>.age = age;        <span class="keyword">this</span>.color = color;    &#125;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试方法public class FieldDemo02 &#123;    @Test    public void setField() throws Exception &#123;        // a.反射的第一步获取Class类对象        Class c = Dog.class ;        // b.定位name成员变量        Field name = c.getDeclaredField(&quot;name&quot;);        // c.为这个成员变量赋值！        Dog d = new Dog();        name.setAccessible(true);        name.set(d,&quot;泰迪&quot;);        System.out.println(d);//Dog&#123;name=&#x27;泰迪&#x27;, age=0, color=&#x27;null&#x27;&#125;        // d.获取成员变量的值        String value = name.get(d)+&quot;&quot;;        System.out.println(value);//泰迪    &#125;&#125;</span></span><br></pre></td></tr></table></figure><h4 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h4><p>获取 Method 方法 API：</p><ul><li>Method getMethod(String name,Class…args)：根据方法名和参数类型获得方法对象，public 修饰</li><li>Method getDeclaredMethod(String name,Class…args)：根据方法名和参数类型获得方法对象，包括 private</li><li>Method[] getMethods()：获得类中的所有成员方法对象返回数组，只能获得 public 修饰且包含父类的</li><li>Method[] getDeclaredMethods()：获得类中的所有成员方法对象，返回数组，只获得本类申明的方法</li></ul><p>Method 常用 API：</p><ul><li>public Object invoke(Object obj, Object… args)：使用指定的参数调用由此方法对象，obj 对象名</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodDemo</span></span>&#123;    <span class="comment">//获得类中的所有成员方法对象    @Test    public void getDeclaredMethods()&#123;        // a.先获取class类对象        Class c = Dog.class ;        // b.获取全部申明的方法!        Method[] methods = c.getDeclaredMethods();        // c.遍历这些方法        for (Method method : methods) &#123;            System.out.println(method.getName()+&quot;-&gt;&quot;                    + method.getParameterCount()+&quot;-&gt;&quot; + method.getReturnType());        &#125;    &#125;    @Test    public void getDeclardMethod() throws Exception &#123;        Class c = Dog.class;        Method run = c.getDeclaredMethod(&quot;run&quot;);        // c.触发方法执行!        Dog d = new Dog();        Object o = run.invoke(d);        System.out.println(o);// 如果方法没有返回值，结果是null        //参数一：方法名称   参数二：方法的参数个数和类型(可变参数！)        Method eat = c.getDeclaredMethod(&quot;eat&quot;,String.class);        eat.setAccessible(true); // 暴力反射！               //参数一：被触发方法所在的对象  参数二：方法需要的入参值        Object o1 = eat.invoke(d,&quot;肉&quot;);        System.out.println(o1);// 如果方法没有返回值，结果是null    &#125;&#125;public class Dog &#123;    private String name ;    public Dog()&#123;    &#125;    public void run()&#123;System.out.println(&quot;狗跑的贼快~~&quot;);&#125;private void eat()&#123;System.out.println(&quot;狗吃骨头&quot;);&#125;private void eat(String name)&#123;System.out.println(&quot;狗吃&quot;+name);&#125;public static void inAddr()&#123;System.out.println(&quot;在吉山区有一只单身狗！&quot;);&#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h3 id="暴力攻击"><a href="#暴力攻击" class="headerlink" title="暴力攻击"></a>暴力攻击</h3><p>泛型只能工作在编译阶段，运行阶段泛型就消失了，反射工作在运行时阶段</p><ol><li>反射可以破坏面向对象的封装性（暴力反射）</li><li>同时可以破坏泛型的约束性</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;        List&lt;Double&gt; scores = <span class="keyword">new</span> ArrayList&lt;&gt;();        scores.add(<span class="number">99.3</span>);        scores.add(<span class="number">199.3</span>);        scores.add(<span class="number">89.5</span>);        <span class="comment">// 拓展：通过反射暴力的注入一个其他类型的数据进去。        // a.先得到集合对象的Class文件对象        Class c = scores.getClass();        // b.从ArrayList的Class对象中定位add方法        Method add = c.getDeclaredMethod(&quot;add&quot;, Object.class);        // c.触发scores集合对象中的add执行（运行阶段，泛型不能约束了）        add.invoke(scores,&quot;波仔&quot;);        System.out.println(scores);    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>注解：类的组成部分，可以给类携带一些额外的信息，提供一种安全的类似注释标记的机制，用来将任何信息或元数据（metadata）与程序元素（类、方法、成员变量等）进行关联</p><ul><li>注解是 JDK1.5 的新特性</li><li>注解是给编译器或 JVM 看的，编译器或 JVM 可以根据注解来完成对应的功能</li><li>注解类似修饰符，应用于包、类型、构造方法、方法、成员变量、参数及本地变量的声明语句中</li></ul><p>注解作用：</p><ul><li>标记</li><li>框架技术多半都是在使用注解和反射，都是属于框架的底层基础技术</li><li>在编译时进行格式检查，比如方法重写约束 @Override、函数式接口约束 @FunctionalInterface.</li></ul><hr><h3 id="注解格式"><a href="#注解格式" class="headerlink" title="注解格式"></a>注解格式</h3><p>定义格式：自定义注解用 @interface 关键字，注解默认可以标记很多地方</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="meta">@interface</span> 注解名&#123;     <span class="comment">// 注解属性&#125;</span></span><br></pre></td></tr></table></figure><p>使用注解的格式：@注解名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Book</span><span class="meta">@MyTestpublic</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBook</span> </span>&#123;    <span class="comment">//方法变量都可以注解&#125;@interface Book&#123;&#125;@interface MyTest&#123;&#125;</span></span><br></pre></td></tr></table></figure><hr><h3 id="注解属性"><a href="#注解属性" class="headerlink" title="注解属性"></a>注解属性</h3><h4 id="普通属性"><a href="#普通属性" class="headerlink" title="普通属性"></a>普通属性</h4><p>注解可以有属性，**属性名必须带 ()**，在用注解的时候，属性必须赋值，除非属性有默认值</p><p>属性的格式：</p><ul><li>格式 1：数据类型 属性名()</li><li>格式 2：数据类型 属性名() default 默认值</li></ul><p>属性适用的数据类型:</p><ul><li>八种数据数据类型（int，short，long，double，byte，char，boolean，float）和 String、Class</li><li>以上类型的数组形式都支持</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MyBook(name=&quot;《精通Java基础》&quot;,authors = &#123;&quot;播仔&quot;,&quot;Dlei&quot;,&quot;播妞&quot;&#125; , price = 99.9 )</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationDemo01</span> </span>&#123;    <span class="meta">@MyBook(name=&quot;《精通MySQL数据库入门到删库跑路》&quot;,authors = &#123;&quot;小白&quot;,&quot;小黑&quot;&#125; ,     price = 19.9 , address = &quot;北京&quot;)</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    &#125;&#125;<span class="comment">// 自定义一个注解@interface MyBook&#123;    String name();    String[] authors(); // 数组    double price();    String address() default &quot;武汉&quot;;&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="特殊属性"><a href="#特殊属性" class="headerlink" title="特殊属性"></a>特殊属性</h4><p>注解的特殊属性名称：value</p><ul><li>如果只有一个 value 属性的情况下，使用 value 属性的时候可以省略 value 名称不写</li><li>如果有多个属性，且多个属性没有默认值，那么 value 是不能省略的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@Book(&quot;/deleteBook.action&quot;)@Book(value = &quot;/deleteBook.action&quot; , age = 12)public class AnnotationDemo01&#123;&#125;@interface Book&#123;    String value();    int age() default 10;&#125;</span></span><br></pre></td></tr></table></figure><hr><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>元注解是 sun 公司提供的，用来注解自定义注解</p><p>元注解有四个：</p><ul><li><p>@Target：约束自定义注解可以标记的范围，默认值为任何元素，表示该注解用于什么地方</p><p>可使用的值定义在ElementType枚举类中：</p><ul><li><code>ElementType.CONSTRUCTOR</code>：用于描述构造器</li><li><code>ElementType.FIELD</code>：成员变量、对象、属性（包括enum实例）</li><li><code>ElementType.LOCAL_VARIABLE</code>：用于描述局部变量</li><li><code>ElementType.METHOD</code>：用于描述方法</li><li><code>ElementType.PACKAGE</code>：用于描述包</li><li><code>ElementType.PARAMETER</code>：用于描述参数</li><li><code>ElementType.TYPE</code>：用于描述类、接口(包括注解类型) 或enum声明</li></ul></li><li><p>@Retention：定义该注解的生命周期，申明注解的作用范围：编译时，运行时</p><p>可使用的值定义在RetentionPolicy枚举类中：</p><ul><li><code>RetentionPolicy.SOURCE</code>：在编译阶段丢弃，这些注解在编译结束之后就不再有任何意义，只作用在源码阶段，生成的字节码文件中不存在。<code>@Override</code>, <code>@SuppressWarnings</code>都属于这类注解</li><li><code>RetentionPolicy.CLASS</code>：在类加载时丢弃，在字节码文件的处理中有用，运行阶段不存在，默认值</li><li><code>RetentionPolicy.RUNTIME</code> : 始终不会丢弃，运行期也保留该注解，因此可以使用反射机制读取该注解的信息，自定义的注解通常使用这种方式</li></ul></li><li><p>@Inherited：表示修饰的自定义注解可以被子类继承</p></li><li><p>@Documented：表示是否将自定义的注解信息添加在 java 文档中</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationDemo01</span></span>&#123;    <span class="comment">// @MyTest // 只能注解方法    private String name;    @MyTest    public static void main( String[] args) &#123;    &#125;&#125;@Target(ElementType.METHOD) // 申明只能注解方法@Retention(RetentionPolicy.RUNTIME) // 申明注解从写代码一直到运行还在，永远存活！！@interface MyTest&#123;&#125;</span></span><br></pre></td></tr></table></figure><hr><h3 id="注解解析"><a href="#注解解析" class="headerlink" title="注解解析"></a>注解解析</h3><p>开发中经常要知道一个类的成分上面到底有哪些注解，注解有哪些属性数据，这都需要进行注解的解析</p><p>注解解析相关的接口：</p><ul><li>Annotation：注解类型，该类是所有注解的父类，注解都是一个 Annotation 的对象</li><li>AnnotatedElement：该接口定义了与注解解析相关的方法</li><li>Class、Method、Field、Constructor 类成分：实现 AnnotatedElement 接口，拥有解析注解的能力</li></ul><p>Class 类 API ：</p><ul><li><code>Annotation[] getDeclaredAnnotations()</code>：获得当前对象上使用的所有注解，返回注解数组</li><li><code>T getDeclaredAnnotation(Class&lt;T&gt; annotationClass)</code>：根据注解类型获得对应注解对象</li><li><code>T getAnnotation(Class&lt;T&gt; annotationClass)</code>：根据注解类型获得对应注解对象</li><li><code>boolean isAnnotationPresent(Class&lt;Annotation&gt; class)</code>：判断对象是否使用了指定的注解</li><li><code>boolean isAnnotation()</code>：此 Class 对象是否表示注释类型</li></ul><p>注解原理：注解本质是一个继承了 <code>Annotation</code> 的特殊接口，其具体实现类是 Java 运行时生成的<strong>动态代理类</strong>，通过反射获取注解时，返回的是运行时生成的动态代理对象 <code>$Proxy1</code>，通过代理对象调用自定义注解（接口）的方法，回调 <code>AnnotationInvocationHandler</code> 的 <code>invoke</code> 方法，该方法会从 <code>memberValues</code>  这个Map 中找出对应的值，而 <code>memberValues</code> 的来源是 Java 常量池</p><p>解析注解数据的原理：注解在哪个成分上，就先拿哪个成分对象，比如注解作用在类上，则要该类的Class对象，再来拿上面的注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationDemo</span></span>&#123;    <span class="meta">@Test</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseClass</span><span class="params">()</span> </span>&#123;        <span class="comment">// 1.定位Class类对象        Class c = BookStore.class;        // 2.判断这个类上是否使用了某个注解        if(c.isAnnotationPresent(Book.class))&#123;            // 3.获取这个注解对象            Book b = (Book)c.getDeclarAnnotation(Book.class);            System.out.println(book.value());            System.out.println(book.price());            System.out.println(Arrays.toString(book.authors()));        &#125;    &#125;    @Test    public void parseMethod() throws Exception &#123;        Class c = BookStore.class;        Method run = c.getDeclaredMethod(&quot;run&quot;);        if(run.isAnnotationPresent(Book.class))&#123;            Book b = (Book)run.getDeclaredAnnotation(Book.class);           sout(上面的三个);        &#125;    &#125;&#125;@Book(value = &quot;《Java基础到精通》&quot;, price = 99.5, authors = &#123;&quot;波仔&quot;,&quot;波妞&quot;&#125;)class BookStore&#123;    @Book(value = &quot;《Mybatis持久层框架》&quot;, price = 199.5, authors = &#123;&quot;dlei&quot;,&quot;播客&quot;&#125;)    public void run()&#123;    &#125;&#125;@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;) // 类和成员方法上使用@Retention(RetentionPolicy.RUNTIME) // 注解永久存活@interface Book&#123;    String value();    double price() default 100;    String[] authors();&#125;</span></span><br></pre></td></tr></table></figure><hr><h3 id="注解模拟"><a href="#注解模拟" class="headerlink" title="注解模拟"></a>注解模拟</h3><p>注解模拟写一个 Junit 框架的基本使用</p><ol><li>定义一个自定义注解 MyTest，只能注解方法，存活范围一直都在。</li><li>定义若干个方法，只要有 @MyTest 注解的方法就能被触发执行，没有这个注解的方法不能执行！！</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;    <span class="meta">@MyTest</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;System.out.println(<span class="string">&quot;===test01===&quot;</span>);&#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;System.out.println(<span class="string">&quot;===test02===&quot;</span>);&#125;    <span class="meta">@MyTest</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;System.out.println(<span class="string">&quot;===test03===&quot;</span>);&#125;    <span class="meta">@MyTest</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span></span>&#123;System.out.println(<span class="string">&quot;===test04===&quot;</span>);&#125;        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;        TestDemo t = <span class="keyword">new</span> TestDemo();        Class c = TestDemo.class;        Method[] methods = c.getDeclaredMethods();        <span class="keyword">for</span> (Method method : methods) &#123;            <span class="keyword">if</span>(method.isAnnotationPresent(MyTest.class))&#123;                method.invoke(t);            &#125;        &#125;    &#125;&#125;<span class="meta">@Target(ElementType.METHOD)</span> <span class="comment">// 只能注解方法！@Retention(RetentionPolicy.RUNTIME) // 一直都活着@interface MyTest&#123;&#125;</span></span><br></pre></td></tr></table></figure><hr><h2 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h2><h3 id="概述-10"><a href="#概述-10" class="headerlink" title="概述"></a>概述</h3><p>XML介绍：</p><ul><li>XML 指可扩展标记语言（EXtensible Markup Language）</li><li>XML 是一种<strong>标记语言</strong>，很类似 HTML，HTML文件也是XML文档</li><li>XML 的设计宗旨是<strong>传输数据</strong>，而非显示数据</li><li>XML 标签没有被预定义，需要自行定义标签</li><li>XML 被设计为具有自我描述性，易于阅读</li><li>XML 是 W3C 的推荐标准</li></ul><p><strong>XML 与 HTML 的区别</strong>：</p><ul><li>XML 不是 HTML 的替代，XML 和 HTML 为不同的目的而设计</li><li>XML 被设计为传输和存储数据，其焦点是数据的内容；XMl标签可自定义，便于阅读</li><li>HTML 被设计用来显示数据，其焦点是数据的外观；HTML标签被预设好，便于浏览器识别</li><li>HTML 旨在显示信息，而 XML 旨在传输信息</li></ul><hr><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>person.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="tag">&lt;<span class="name">person</span> <span class="attr">id</span>=<span class="string">&quot;110&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">age</span>&gt;</span>18<span class="tag">&lt;/<span class="name">age</span>&gt;</span><span class="comment">&lt;!--年龄--&gt;</span><span class="tag">&lt;<span class="name">name</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  <span class="comment">&lt;!--姓名--&gt;</span><span class="tag">&lt;<span class="name">sex</span>/&gt;</span><span class="comment">&lt;!--性别--&gt;</span><span class="tag">&lt;/<span class="name">person</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>XML 文件中常见的组成元素有:文档声明、元素、属性、注释、转义字符、字符区。文件后缀名为 xml</p><ul><li><p><strong>文档声明</strong><br><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; standalone=&quot;yes&quot; ?&gt;</code>，文档声明必须在第一行，以 <code>&lt;?xml</code> 开头，以 <code>?&gt;</code> 结束，</p><ul><li>version：指定 XML 文档版本。必须属性，这里一般选择 1.0</li><li>enconding：指定当前文档的编码，可选属性，默认值是 utf-8</li><li>standalone：该属性不是必须的，描述 XML 文件是否依赖其他的 xml 文件，取值为 yes/no</li></ul></li><li><p><strong>元素</strong>        </p><ul><li>格式 1：<code>&lt;person&gt;&lt;/person&gt; </code> </li><li>格式 2：<code>&lt;person/&gt;</code></li><li>普通元素的结构由开始标签、元素体、结束标签组成</li><li>标签由一对尖括号和合法标识符组成，标签必须成对出现。特殊的标签可以不成对，必须有结束标记 &lt;/&gt;</li></ul></li><li><p>元素体：可以是元素，也可以是文本，例如：<code>&lt;person&gt;&lt;name&gt;张三&lt;/name&gt;&lt;/person&gt;</code></p><ul><li>空元素：空元素只有标签，而没有结束标签，但<strong>元素必须自己闭合</strong>，例如：<code>&lt;sex/&gt;</code></li><li>元素命名：区分大小写、不能使用空格冒号、不建议用 XML、xml、Xml 等开头</li><li>必须存在一个根标签，有且只能有一个</li></ul></li><li><p><strong>属性</strong>：<code>&lt;name id=&quot;1&quot; desc=&quot;高富帅&quot;&gt;</code></p><ul><li>属性是元素的一部分，它必须出现在元素的开始标签中</li><li>属性的定义格式：<code>属性名=“属性值”</code>，其中属性值必须使用单引或双引号括起来</li><li>一个元素可以有 0~N 个属性，但一个元素中不能出现同名属性</li><li>属性名不能使用空格 , 不要使用冒号等特殊字符，且必须以字母开头</li></ul></li><li><p><strong>注释</strong>：<!--注释内容--><br>XML的注释与HTML相同，既以 <code>&lt;!--</code> 开始，<code>--&gt;</code> 结束。</p></li><li><p><strong>转义字符</strong><br>XML 中的转义字符与 HTML 一样。因为很多符号已经被文档结构所使用，所以在元素体或属性值中想使用这些符号就必须使用转义字符（也叫实体字符），例如：”&gt;”、”&lt;”、”‘“、”””、”&amp;”<br>XML 中仅有字符 &lt; 和 &amp; 是非法的。省略号、引号和大于号是合法的，把它们替换为实体引用</p><table><thead><tr><th align="center">字符</th><th align="center">预定义的转义字符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">&lt;</td><td align="center"><code>&amp;lt;</code></td><td align="center">小于</td></tr><tr><td align="center">&gt;</td><td align="center"><code> &amp;gt;</code></td><td align="center">大于</td></tr><tr><td align="center">“</td><td align="center"><code> &amp;quot;</code></td><td align="center">双引号</td></tr><tr><td align="center">‘</td><td align="center"><code> &amp;apos;</code></td><td align="center">单引号</td></tr><tr><td align="center">&amp;</td><td align="center"><code> &amp;amp;</code></td><td align="center">和号</td></tr></tbody></table></li><li><p><strong>字符区</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;![CDATA[文本数据]]&gt;</span><br></pre></td></tr></table></figure><ul><li>CDATA 指的是不应由 XML 解析器进行解析的文本数据（Unparsed Character Data）</li></ul></li><li><p>CDATA 部分由 “<!--[CDATA[" 开始，由 "]]-->“ 结束；</p><ul><li><p>大量的转义字符在xml文档中时，会使XML文档的可读性大幅度降低。这时使用CDATA段就会好一些</p></li><li><p>规则：</p><ul><li>CDATA 部分不能包含字符串 ]]&gt;，也不允许嵌套的 CDATA 部分</li><li>标记 CDATA 部分结尾的 ]]&gt; 不能包含空格或折行</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><span class="meta">&lt;?xml-stylesheet type=&quot;text/css&quot; href=&quot;../css/xml.css&quot; ?&gt;</span><span class="comment">&lt;!-- 7.处理指令：导入外部的css样式控制xml的界面效果，没有啥用，xml不是为了展示好看的！--&gt;</span><span class="comment">&lt;!-- 1.申明 抬头 必须在第一行--&gt;</span><span class="comment">&lt;!-- 2.注释，本处就是注释，必须用前后尖括号围起来 --&gt;</span><span class="comment">&lt;!-- 3.标签（元素），注意一个XML文件只能有一个根标签--&gt;</span><span class="tag">&lt;<span class="name">student</span>&gt;</span>    <span class="comment">&lt;!-- 4.属性信息：id , desc--&gt;</span>    <span class="tag">&lt;<span class="name">name</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span> <span class="attr">desc</span>=<span class="string">&quot;高富帅&quot;</span>&gt;</span>西门庆<span class="tag">&lt;/<span class="name">name</span>&gt;</span>    <span class="tag">&lt;<span class="name">age</span>&gt;</span>32<span class="tag">&lt;/<span class="name">age</span>&gt;</span>    <span class="comment">&lt;!-- 5.实体字符：在xml文件中，我们不能直接写小于号，等一些特殊字符        会与xml文件本身的内容冲突报错，此时必须用转义的实体字符。    --&gt;</span>    <span class="tag">&lt;<span class="name">sql</span>&gt;</span>       <span class="comment">&lt;!-- select * from student where age &lt; 18 &amp;&amp; age &gt; 10; --&gt;</span>        select * from student where age <span class="symbol">&amp;lt;</span> 18 <span class="symbol">&amp;amp;</span><span class="symbol">&amp;amp;</span> age <span class="symbol">&amp;gt;</span> 10;    <span class="tag">&lt;/<span class="name">sql</span>&gt;</span>    <span class="comment">&lt;!-- 6.字符数据区：在xml文件中，我们不能直接写小于号，等一些特殊字符        会与xml文件本身的内容冲突报错，此时必须用转义的实体字符        或者也可以选择使用字符数据区，里面的内容可以随便了！        --&gt;</span>    <span class="tag">&lt;<span class="name">sql2</span>&gt;</span>        &lt;![CDATA[             select * from student where age &lt; 18 &amp;&amp; age &gt; 10;        ]]&gt;    <span class="tag">&lt;/<span class="name">sql2</span>&gt;</span><span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><h4 id="DTD"><a href="#DTD" class="headerlink" title="DTD"></a>DTD</h4><h5 id="DTD定义"><a href="#DTD定义" class="headerlink" title="DTD定义"></a>DTD定义</h5><p>DTD 是文档类型定义（Document Type Definition）。DTD 可以定义在 XML 文档中出现的元素、这些元素出现的次序、它们如何相互嵌套以及XML文档结构的其它详细信息。</p><h5 id="DTD规则"><a href="#DTD规则" class="headerlink" title="DTD规则"></a>DTD规则</h5><ul><li><p>约束元素的嵌套层级</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ELEMENT 父标签 （子标签1，子标签2，…）&gt;</span><br></pre></td></tr></table></figure></li><li><p>约束元素体里面的数据</p></li><li><p>语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ELEMENT 标签名字 标签类型&gt;</span><br></pre></td></tr></table></figure></li><li><p>判断元素</p><pre><code>简单元素：没有子元素。复杂元素：有子元素的元素；</code></pre><ul><li>标签类型</li></ul><table><thead><tr><th>标签类型</th><th>代码写法</th><th>说明</th></tr></thead><tbody><tr><td>PCDATA</td><td>(#PCDATA)</td><td>被解释的字符串数据</td></tr><tr><td>EMPTY</td><td>EMPTY</td><td>即空元素，例如&lt;hr/&gt;</td></tr><tr><td>ANY</td><td>ANY</td><td>即任意类型</td></tr></tbody></table><ul><li><p>代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ELEMENT persons (person+)&gt;   &lt;!--约束人们至少一个人--&gt;&lt;!ELEMENT person (name,age)&gt;&lt;!--约束元素人的子元素必须为姓名、年龄，并且按顺序--&gt;&lt;!ELEMENT name (#PCDATA)&gt;&lt;!--&quot;姓名&quot;元素体为字符串数据--&gt;&lt;!ELEMENT age ANY&gt;       &lt;!--&quot;年龄&quot;元素体为任意类型--&gt;</span><br></pre></td></tr></table></figure></li><li><p>数量词</p><table><thead><tr><th>数量词符号</th><th>含义</th></tr></thead><tbody><tr><td>空</td><td>表示元素出现一次</td></tr><tr><td>*</td><td>表示元素可以出现0到多个</td></tr><tr><td>+</td><td>表示元素可以出现至少1个</td></tr><tr><td>?</td><td>表示元素可以是0或1个</td></tr><tr><td>,</td><td>表示元素需要按照顺序显示</td></tr><tr><td>|</td><td>表示元素需要选择其中的某一个</td></tr></tbody></table></li></ul></li><li><p>属性声明</p><ul><li><p>语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ATTLIST 标签名称 属性名称1 属性类型1 属性说明1属性名称2 属性类型2 属性说明2…&gt;</span><br></pre></td></tr></table></figure></li><li><p>属性类型</p><table><thead><tr><th>属性类型</th><th>含义</th></tr></thead><tbody><tr><td>CDATA</td><td>代表属性是文本字符串， eg:<!ATTLIST 属性名 CDATA 属性说明></td></tr><tr><td>ID</td><td>代码该属性值唯一，不能以数字开头， eg:<!ATTLIST 属性名 ID 属性说明></td></tr><tr><td>ENUMERATED</td><td>代表属性值在指定范围内进行枚举 Eg:&lt;!ATTLIST属性名 (社科类|工程类|教育类) “社科类”&gt; “社科类”是默认值，属性如果不设置默认值就是”社科类”</td></tr></tbody></table></li><li><p>属性说明</p><table><thead><tr><th>属性说明</th><th>含义</th></tr></thead><tbody><tr><td>#REQUIRED</td><td>代表属性是必须有的</td></tr><tr><td>#IMPLIED</td><td>代表属性可有可无</td></tr><tr><td>#FIXED</td><td>代表属性为固定值，实现方式：book_info CDATA #FIXED “固定值”</td></tr></tbody></table></li><li><p>代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ATTLIST 书&lt;!--设置&quot;书&quot;元素的的属性列表--&gt;id ID #REQUIRED &lt;!--&quot;id&quot;属性值为必须有--&gt;编号 CDATA #IMPLIED    &lt;!--&quot;编号&quot;属性可有可无--&gt;出版社 (清华|北大|传智播客) &quot;传智播客&quot; &lt;!--&quot;出版社&quot;属性值是枚举值，默认为“传智播客”--&gt;type CDATA #FIXED &quot;IT&quot;            &lt;!--&quot;type&quot;属性为文本字符串并且固定值为&quot;IT&quot;--&gt;&gt;&lt;!ATTLIST person id CDATA #REQUIRED&gt;  &lt;!--id是文本字符串必须有--&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h5 id="DTD引入"><a href="#DTD引入" class="headerlink" title="DTD引入"></a>DTD引入</h5><ul><li><p>引入本地 dtd</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE 根元素名称 SYSTEM ‘DTD文件的路径&#x27;&gt;</span><br></pre></td></tr></table></figure></li><li><p>在 xml 文件内部引入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE 根元素名称 [ dtd文件内容 ]&gt;</span><br></pre></td></tr></table></figure></li><li><p>引入网络 dtd</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE 根元素的名称 PUBLIC &quot;DTD文件名称&quot; &quot;DTD文档的URL&quot;&gt;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--这是persondtd.dtd文件中的内容,已经提前写好--&gt;&lt;!ELEMENT persons (person)&gt;&lt;!ELEMENT person (name,age)&gt;&lt;!ELEMENT name (#PCDATA)&gt;&lt;!ELEMENT age (#PCDATA)&gt;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入本地DTD--&gt;</span><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">persons</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&#x27;persondtd.dtd&#x27;</span>&gt;</span><span class="tag">&lt;<span class="name">persons</span>&gt;</span>    <span class="tag">&lt;<span class="name">person</span>&gt;</span>        <span class="tag">&lt;<span class="name">name</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">name</span>&gt;</span>        <span class="tag">&lt;<span class="name">age</span>&gt;</span>23<span class="tag">&lt;/<span class="name">age</span>&gt;</span>    <span class="tag">&lt;/<span class="name">person</span>&gt;</span><span class="tag">&lt;/<span class="name">persons</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--内部引入DTD--&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE persons [        &lt;!ELEMENT persons (person)&gt;        &lt;!ELEMENT person (name,age)&gt;        &lt;!ELEMENT name (#PCDATA)&gt;        &lt;!ELEMENT age (#PCDATA)&gt;        ]&gt;&lt;persons&gt;    &lt;person&gt;        &lt;name&gt;张三&lt;/name&gt;        &lt;age&gt;23&lt;/age&gt;    &lt;/person&gt;&lt;/persons&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--引入网络DTD--&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE persons PUBLIC &quot;dtd文件的名称&quot; &quot;dtd文档的URL&quot;&gt;&lt;persons&gt;    &lt;person&gt;        &lt;name&gt;张三&lt;/name&gt;        &lt;age&gt;23&lt;/age&gt;    &lt;/person&gt;&lt;/persons&gt;</span><br></pre></td></tr></table></figure><hr><h5 id="DTD实现"><a href="#DTD实现" class="headerlink" title="DTD实现"></a>DTD实现</h5><p>persondtd.dtd 文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ELEMENT persons (person+)&gt;   &lt;!--约束人们至少一个人--&gt;&lt;!ELEMENT person (name,age)&gt;&lt;!--约束元素人的子元素必须为姓名、年龄，并且按顺序--&gt;&lt;!ELEMENT name (#PCDATA)&gt;&lt;!--&quot;姓名&quot;元素体为字符串数据--&gt;&lt;!ELEMENT age ANY&gt;       &lt;!--&quot;年龄&quot;元素体为任意类型--&gt;&lt;!ATTLIST person id CDATA #REQUIRED&gt;  &lt;!--id是文本字符串必须有--&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE persons SYSTEM &#x27;persondtd.dtd&#x27;&gt;&lt;persons&gt;    &lt;person id=&quot;001&quot;&gt;        &lt;name&gt;张三&lt;/name&gt;        &lt;age&gt;23&lt;/age&gt;    &lt;/person&gt;    &lt;person id = &quot;002&quot;&gt;        &lt;name&gt;张三&lt;/name&gt;        &lt;age&gt;23&lt;/age&gt;    &lt;/person&gt;&lt;/persons&gt;</span><br></pre></td></tr></table></figure><hr><h4 id="Schema"><a href="#Schema" class="headerlink" title="Schema"></a>Schema</h4><h5 id="XSD定义"><a href="#XSD定义" class="headerlink" title="XSD定义"></a>XSD定义</h5><ol><li>Schema 语言也可作为 XSD（XML Schema Definition）</li><li>Schema 约束文件本身也是一个 xml 文件，符合 xml 的语法，这个文件的后缀名 .xsd</li><li>一个 xml 中可以引用多个 Schema 约束文件，多个 Schema 使用名称空间区分（名称空间类似于 Java 包名）</li><li>dtd 里面元素类型的取值比较单一常见的是 PCDATA 类型，但是在 Schema 里面可以支持很多个数据类型</li><li><strong>Schema 文件约束 xml 文件的同时也被别的文件约束着</strong></li></ol><hr><h5 id="XSD规则"><a href="#XSD规则" class="headerlink" title="XSD规则"></a>XSD规则</h5><ol><li>创建一个文件，这个文件的后缀名为 .xsd</li><li>定义文档声明</li><li>schema 文件的根标签为： <schema></schema></li><li>在 <schema> 中定义属性：<ul><li>xmlns=<a href="http://www.w3.org/2001/XMLSchema">http://www.w3.org/2001/XMLSchema</a></li><li>代表当前文件时约束别人的，同时这个文件也对该 Schema 进行约束</li></ul></schema></li><li>在<schema>中定义属性 ：<ul><li>targetNamespace = 唯一的 url 地址，指定当前这个 schema 文件的名称空间。</li><li><strong>名称空间</strong>：当其他 xml 使用该 schema 文件，需要引入此空间</li></ul></schema></li><li>在<schema>中定义属性 ：<ul><li>elementFormDefault=”qualified“，表示当前 schema 文件是一个质量良好的文件。</li></ul></schema></li><li>通过 element 定义元素</li><li><strong>判断当前元素是简单元素还是复杂元素</strong></li></ol><p>person.xsd</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;&lt;schema    xmlns=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span>     &lt;!--本文件是约束别人的，也被约束--&gt;    targetNamespace=<span class="string">&quot;http://www.seazean.cn/javase&quot;</span>&lt;!--自己的名称空间--&gt;    elementFormDefault=<span class="string">&quot;qualified&quot;</span>  &lt;!--本文件是质量好的--&gt;&gt;    &lt;element name=<span class="string">&quot;persons&quot;</span>&gt;      &lt;!--定义persons复杂元素--&gt;        &lt;complexType&gt;             &lt;!--复杂的元素--&gt;            &lt;sequence&gt;  &lt;!--里面的元素必须按照顺序定义--&gt;                &lt;element name = <span class="string">&quot;person&quot;</span>&gt; &lt;!--定义person复杂元素--&gt;                    &lt;complexType&gt;                        &lt;sequence&gt;                            &lt;!--定义name和age简单元素--&gt;                            &lt;element name = <span class="string">&quot;name&quot;</span> type = <span class="string">&quot;string&quot;</span>&gt;&lt;/element&gt;                            &lt;element name = <span class="string">&quot;age&quot;</span> type = <span class="string">&quot;string&quot;</span>&gt;&lt;/element&gt;                        &lt;/sequence&gt;                    &lt;/complexType&gt;                &lt;/element&gt;            &lt;/sequence&gt;        &lt;/complexType&gt;    &lt;/element&gt;    &lt;/schema&gt;</span><br></pre></td></tr></table></figure><hr><h5 id="XSD引入"><a href="#XSD引入" class="headerlink" title="XSD引入"></a>XSD引入</h5><ol><li>在根标签上定义属性 xmlns=”<a href="http://www.w3.org/2001/XMLSchema-instance&quot;">http://www.w3.org/2001/XMLSchema-instance&quot;</a></li><li><strong>通过 xmlns 引入约束文件的名称空间</strong></li><li>给某一个 xmlns 属性添加一个标识，用于区分不同的名称空间，格式为 <code>xmlns:标识=&quot;名称空间url&quot;</code> ，标识可以是任意的，但是一般取值都是 xsi</li><li>通过 xsi:schemaLocation 指定名称空间所对应的约束文件路径，格式为 <code>xsi:schemaLocation = &quot;名称空间url 文件路径</code></li></ol><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;&lt;personsxmlms:xis=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> &lt;!--被别人约束--&gt;    xmlns=<span class="string">&quot;http://www.seazean.cn/javase&quot;</span>                  &lt;!--约束文件的名称空间--&gt;    xsi:schemaLocation=<span class="string">&quot;http://www.seazean.cn/javase person.xsd&quot;</span>&gt; &lt;person&gt;        &lt;name&gt;张三&lt;/name&gt;        &lt;age&gt;<span class="number">23</span>&lt;/age&gt;    &lt;/person&gt;&lt;/persons&gt;</span><br></pre></td></tr></table></figure><hr><h5 id="XSD属性"><a href="#XSD属性" class="headerlink" title="XSD属性"></a>XSD属性</h5><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;&lt;schema    xmlns=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span>    targetNamespace=<span class="string">&quot;http://www.seazean.cn/javase&quot;</span>    elementFormDefault=<span class="string">&quot;qualified&quot;</span>&gt;    &lt;!--定义persons复杂元素--&gt;    &lt;element name=<span class="string">&quot;persons&quot;</span>&gt;        &lt;complexType&gt;            &lt;sequence&gt;                &lt;!--定义person复杂元素--&gt;                &lt;element name = <span class="string">&quot;person&quot;</span>&gt;                    &lt;complexType&gt;                        &lt;sequence&gt;                            &lt;!--定义name和age简单元素--&gt;                            &lt;element name = <span class="string">&quot;name&quot;</span> type = <span class="string">&quot;string&quot;</span>&gt;&lt;/element&gt;                            &lt;element name = <span class="string">&quot;age&quot;</span> type = <span class="string">&quot;string&quot;</span>&gt;&lt;/element&gt;                        &lt;/sequence&gt;                        &lt;!--定义的位置是sequence的外面，complexType的里面--&gt;                        &lt;!--定义属性，required( 必须的)/optional( 可选的)--&gt;                        &lt;attribute name=<span class="string">&quot;id&quot;</span> type=<span class="string">&quot;string&quot;</span> use=<span class="string">&quot;required&quot;</span>&gt;&lt;/attribute&gt;                    &lt;/complexType&gt;                                    &lt;/element&gt;            &lt;/sequence&gt;        &lt;/complexType&gt;    &lt;/element&gt;    &lt;/schema&gt;&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;&lt;persons    xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>    xmlns=<span class="string">&quot;http://www.seazean.cn/javase&quot;</span>    xsi:schemaLocation=<span class="string">&quot;http://www.seazean.cn/javase person.xsd&quot;</span>&gt;    &lt;person id=<span class="string">&quot;001&quot;</span>&gt;        &lt;name&gt;张三&lt;/name&gt;        &lt;age&gt;<span class="number">23</span>&lt;/age&gt;    &lt;/person&gt;&lt;/persons&gt;</span><br></pre></td></tr></table></figure><hr><h3 id="Dom4J"><a href="#Dom4J" class="headerlink" title="Dom4J"></a>Dom4J</h3><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>XML 解析就是从 XML 中获取到数据，DOM 是解析思想</p><p>DOM（Document Object Model）：文档对象模型，把文档的各个组成部分看做成对应的对象，把 XML 文件全部加载到内存，在内存中形成一个树形结构，再获取对应的值</p><p>Dom4J 实现：</p><ul><li><p>Dom4J 解析器构造方法：<code>SAXReader saxReader = new SAXReader()</code></p></li><li><p>SAXReader 常用API：</p><ul><li><code>public Document read(File file)</code>：Reads a Document from the given File</li><li><code>public Document read(InputStream in)</code>：Reads a Document from the given stream using SAX</li></ul></li><li><p>Java Class 类API：</p><ul><li><code>public InputStream getResourceAsStream(String path)</code>：加载文件成为一个字节输入流返回</li></ul></li></ul><hr><h4 id="根元素"><a href="#根元素" class="headerlink" title="根元素"></a>根元素</h4><p>Document 方法：<code>Element getRootElement()</code> 获取根元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需求：解析books.xml文件成为一个Document文档树对象，得到根元素对象。public class Dom4JDemo &#123;    public static void main(String[] args) throws Exception &#123;        // 1.创建一个dom4j的解析器对象：代表整个dom4j框架。        SAXReader saxReader = new SAXReader();        // 2.第一种方式（简单）：通过解析器对象去加载xml文件数据，成为一个Document文档树对象。        //Document document = saxReader.read(new File(&quot;Day13Demo/src/books.xml&quot;));                // 3.第二种方式（代码多点）先把xml文件读成一个字节输入流        // 这里的“/”是直接去src类路径下寻找文件。        InputStream is = Dom4JDemo01.class.getResourceAsStream(&quot;/books.xml&quot;);        Document document = saxReader.read(is);        System.out.println(document);//org.dom4j.tree.DefaultDocument@27a5f880 [Document: name null]// 4.从document文档树对象中提取根元素对象        Element root = document.getRootElement();        System.out.println(root.getName());//books    &#125;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="tag">&lt;<span class="name">books</span>&gt;</span>    <span class="tag">&lt;<span class="name">book</span> <span class="attr">id</span>=<span class="string">&quot;0001&quot;</span> <span class="attr">desc</span>=<span class="string">&quot;第一本书&quot;</span>&gt;</span>        <span class="tag">&lt;<span class="name">name</span>&gt;</span>  JavaWeb开发教程<span class="tag">&lt;/<span class="name">name</span>&gt;</span>        <span class="tag">&lt;<span class="name">author</span>&gt;</span>    张孝祥<span class="tag">&lt;/<span class="name">author</span>&gt;</span>        <span class="tag">&lt;<span class="name">sale</span>&gt;</span>100.00元   <span class="tag">&lt;/<span class="name">sale</span>&gt;</span>    <span class="tag">&lt;/<span class="name">book</span>&gt;</span>    <span class="tag">&lt;<span class="name">book</span> <span class="attr">id</span>=<span class="string">&quot;0002&quot;</span>&gt;</span>        <span class="tag">&lt;<span class="name">name</span>&gt;</span>三国演义<span class="tag">&lt;/<span class="name">name</span>&gt;</span>        <span class="tag">&lt;<span class="name">author</span>&gt;</span>罗贯中<span class="tag">&lt;/<span class="name">author</span>&gt;</span>        <span class="tag">&lt;<span class="name">sale</span>&gt;</span>100.00元<span class="tag">&lt;/<span class="name">sale</span>&gt;</span>    <span class="tag">&lt;/<span class="name">book</span>&gt;</span>    <span class="tag">&lt;<span class="name">user</span>&gt;</span>    <span class="tag">&lt;/<span class="name">user</span>&gt;</span><span class="tag">&lt;/<span class="name">books</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="子元素"><a href="#子元素" class="headerlink" title="子元素"></a>子元素</h4><p>Element 元素的 API:</p><ul><li>String getName()：取元素的名称。</li><li>List<Element> elements()：获取当前元素下的全部子元素（一级）</Element></li><li>List<Element> elements(String name)：获取当前元素下的指定名称的全部子元素（一级）</Element></li><li>Element element(String name)：获取当前元素下的指定名称的某个子元素，默认取第一个（一级）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dom4JDemo</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;        SAXReader saxReader = <span class="keyword">new</span> SAXReader();        Document document = saxReader.read(<span class="keyword">new</span> File(<span class="string">&quot;Day13Demo/src/books.xml&quot;</span>));        <span class="comment">// 3.获取根元素对象        Element root = document.getRootElement();        System.out.println(root.getName());        // 4.获取根元素下的全部子元素        List&lt;Element&gt; sonElements = root.elements();        for (Element sonElement : sonElements) &#123;            System.out.println(sonElement.getName());        &#125;        // 5.获取根源下的全部book子元素        List&lt;Element&gt; sonElements1 = root.elements(&quot;book&quot;);        for (Element sonElement : sonElements1) &#123;            System.out.println(sonElement.getName());        &#125;                // 6.获取根源下的指定的某个元素        Element son = root.element(&quot;user&quot;);        System.out.println(son.getName());        // 默认会提取第一个名称一样的子元素对象返回！        Element son1 = root.element(&quot;book&quot;);        System.out.println(son1.attributeValue(&quot;id&quot;));    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>Element 元素的 API：</p><ul><li>List<Attribute> attributes()：获取元素的全部属性对象</Attribute></li><li>Attribute attribute(String name)：根据名称获取某个元素的属性对象</li><li>String attributeValue(String var)：直接获取某个元素的某个属性名称的值</li></ul><p>Attribute 对象的 API：</p><ul><li>String getName()：获取属性名称</li><li>String getValue()：获取属性值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dom4JDemo</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;        SAXReader saxReader = <span class="keyword">new</span> SAXReader();        Document document = saxReader.read(<span class="keyword">new</span> File(<span class="string">&quot;Day13Demo/src/books.xml&quot;</span>));        Element root = document.getRootElement();        <span class="comment">// 4.获取book子元素        Element bookEle = root.element(&quot;book&quot;);        // 5.获取book元素的全部属性对象        List&lt;Attribute&gt; attributes = bookEle.attributes();        for (Attribute attribute : attributes) &#123;            System.out.println(attribute.getName()+&quot;-&gt;&quot;+attribute.getValue());        &#125;        // 6.获取Book元素的某个属性对象        Attribute descAttr = bookEle.attribute(&quot;desc&quot;);        System.out.println(descAttr.getName()+&quot;-&gt;&quot;+descAttr.getValue());        // 7.可以直接获取元素的属性值        System.out.println(bookEle.attributeValue(&quot;id&quot;));        System.out.println(bookEle.attributeValue(&quot;desc&quot;));    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h4><p>Element：</p><ul><li>String elementText(String name)：可以直接获取当前元素的子元素的文本内容</li><li>String elementTextTrim(String name)：去前后空格,直接获取当前元素的子元素的文本内容</li><li>String getText()：直接获取当前元素的文本内容</li><li>String getTextTrim()：去前后空格,直接获取当前元素的文本内容</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dom4JDemo</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;        SAXReader saxReader = <span class="keyword">new</span> SAXReader();        Document document = saxReader.read(<span class="keyword">new</span> File(<span class="string">&quot;Day13Demo/src/books.xml&quot;</span>));        Element root = document.getRootElement();        <span class="comment">// 4.得到第一个子元素book        Element bookEle = root.element(&quot;book&quot;);        // 5.直接拿到当前book元素下的子元素文本值        System.out.println(bookEle.elementText(&quot;name&quot;));        System.out.println(bookEle.elementTextTrim(&quot;name&quot;)); // 去前后空格        System.out.println(bookEle.elementText(&quot;author&quot;));        System.out.println(bookEle.elementTextTrim(&quot;author&quot;)); // 去前后空格        System.out.println(bookEle.elementText(&quot;sale&quot;));        System.out.println(bookEle.elementTextTrim(&quot;sale&quot;)); // 去前后空格        // 6.先获取到子元素对象，再获取该文本值        Element bookNameEle = bookEle.element(&quot;name&quot;);        System.out.println(bookNameEle.getText());        System.out.println(bookNameEle.getTextTrim());// 去前后空格    &#125;&#125;</span></span><br></pre></td></tr></table></figure><hr><h3 id="XPath"><a href="#XPath" class="headerlink" title="XPath"></a>XPath</h3><p>Dom4J 可以用于解析整个 XML 的数据，但是如果要检索 XML 中的某些信息，建议使用 XPath</p><p>XPath 常用API：</p><ul><li>List<Node> selectNodes(String var1) : 检索出一批节点集合</Node></li><li>Node selectSingleNode(String var1) : 检索出一个节点返回</li></ul><p>XPath 提供的四种检索数据的写法：</p><ol><li>绝对路径：/根元素/子元素/子元素</li><li>相对路径：./子元素/子元素 (.代表了当前元素)</li><li>全文搜索：<ul><li>//元素：在全文找这个元素</li><li>//元素1/元素2：在全文找元素1下面的一级元素 2</li><li>//元素1//元素2：在全文找元素1下面的全部元素 2</li></ul></li><li>属性查找：<ul><li>//@属性名称：在全文检索属性对象</li><li>//元素[@属性名称]：在全文检索包含该属性的元素对象</li><li>//元素[@属性名称=值]：在全文检索包含该属性的元素且属性值为该值的元素对象</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XPathDemo</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;        SAXReader saxReader = <span class="keyword">new</span> SAXReader();        InputStream is = XPathDemo.class.getResourceAsStream(<span class="string">&quot;/Contact.xml&quot;</span>);        Document document = saxReader.read(is);        <span class="comment">//1.使用绝对路径定位全部的name名称        List&lt;Node&gt; nameNodes1 = document.selectNodes(&quot;/contactList/contact/name&quot;);        for (Node nameNode : nameNodes) &#123;            System.out.println(nameNode.getText());        &#125;                //2.相对路径。从根元素开始检索，.代表很根元素        List&lt;Node&gt; nameNodes2 = root.selectNodes(&quot;./contact/name&quot;);                //3.1 在全文中检索name节点        List&lt;Node&gt; nameNodes3 = root.selectNodes(&quot;//name&quot;);//全部的        //3.2 在全文中检索所有contact下的所有name节点  //包括sql，不外面的        List&lt;Node&gt; nameNodes3 = root.selectNodes(&quot;//contact//name&quot;);        //3.3 在全文中检索所有contact下的直接name节点        List&lt;Node&gt; nameNodes3 = root.selectNodes(&quot;//contact/name&quot;);//不包括sql和外面                //4.1 检索全部属性对象        List&lt;Node&gt; attributes1 = root.selectNodes(&quot;//@id&quot;);//包括sql4        //4.2 在全文检索包含该属性的元素对象        List&lt;Node&gt; attributes1 = root.selectNodes(&quot;//contact[@id]&quot;);        //4.3 在全文检索包含该属性的元素且属性值为该值的元素对象        Node nodeEle = document.selectSingleNode(&quot;//contact[@id=2]&quot;);        Element ele = (Element)nodeEle;        System.out.println(ele.elementTextTrim(&quot;name&quot;));//xi    &#125;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="tag">&lt;<span class="name">contactList</span>&gt;</span><span class="tag">&lt;<span class="name">contact</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">name</span>&gt;</span>小白<span class="tag">&lt;/<span class="name">name</span>&gt;</span>    <span class="tag">&lt;<span class="name">gender</span>&gt;</span>女<span class="tag">&lt;/<span class="name">gender</span>&gt;</span>    <span class="tag">&lt;<span class="name">email</span>&gt;</span>bai@seazean.cn<span class="tag">&lt;/<span class="name">email</span>&gt;</span><span class="tag">&lt;/<span class="name">contact</span>&gt;</span><span class="tag">&lt;<span class="name">contact</span> <span class="attr">id</span>=<span class="string">&quot;2&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">name</span>&gt;</span>小黑<span class="tag">&lt;/<span class="name">name</span>&gt;</span>    <span class="tag">&lt;<span class="name">gender</span>&gt;</span>男<span class="tag">&lt;/<span class="name">gender</span>&gt;</span>    <span class="tag">&lt;<span class="name">email</span>&gt;</span>hei@seazean.cn<span class="tag">&lt;/<span class="name">email</span>&gt;</span>    <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;sql4&quot;</span>&gt;</span>        <span class="tag">&lt;<span class="name">name</span>&gt;</span>sql语句<span class="tag">&lt;/<span class="name">name</span>&gt;</span>    <span class="tag">&lt;/<span class="name">sql</span>&gt;</span><span class="tag">&lt;/<span class="name">contact</span>&gt;</span><span class="tag">&lt;<span class="name">contact</span> <span class="attr">id</span>=<span class="string">&quot;3&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">name</span>&gt;</span>小虎<span class="tag">&lt;/<span class="name">name</span>&gt;</span>    <span class="tag">&lt;<span class="name">gender</span>&gt;</span>男<span class="tag">&lt;/<span class="name">gender</span>&gt;</span>    <span class="tag">&lt;<span class="name">email</span>&gt;</span>hu@seazean.cn<span class="tag">&lt;/<span class="name">email</span>&gt;</span><span class="tag">&lt;/<span class="name">contact</span>&gt;</span><span class="tag">&lt;<span class="name">contact</span>&gt;</span><span class="tag">&lt;/<span class="name">contact</span>&gt;</span><span class="tag">&lt;<span class="name">name</span>&gt;</span>外面的名称<span class="tag">&lt;/<span class="name">name</span>&gt;</span><span class="tag">&lt;/<span class="name">contactList</span>&gt;</span></span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaSE </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
